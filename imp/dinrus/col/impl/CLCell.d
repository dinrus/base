module col.impl.CLCell;

private import col.impl.Cell;

/**
 * ЯчейкиЦС - это ячейки, которые всегда организованы в виде циркулярных списков
 * и служат инструментами для реализации.
**/

public class ЯчейкаЦС(T) : Ячейка!(T)
{
    // Переменные экземпляра

    private ЯчейкаЦС следщ_;
    private ЯчейкаЦС предш_;

    // Конструкторы

    /**
     *Создать ячейку с содержимым знач, предыдущей ячейкой p и следующей ячейкой n.
    **/

    public this (T знач, ЯчейкаЦС p, ЯчейкаЦС n)
    {
        super(знач);
        предш_ = p;
        следщ_ = n;
    }

    /**
     * Создать единичную ячейку.
    **/

    public this (T знач)
    {
        super(знач);
        предш_ = this;
        следщ_ = this;
    }

    /**
     * Создать единичную ячейку с пустым содержимым.
    **/

    public this ()
    {
        super(T.init);
        предш_ = this;
        следщ_ = this;
    }

    /**
     * Вернуть следующую ячейку.
    **/

    public final ЯчейкаЦС следщ()
    {
        return следщ_;
    }

    /**
     * Установить следующую ячейку. Возможно, вызывать this не потребуется.
    **/

    public final проц следщ(ЯчейкаЦС n)
    {
        следщ_ = n;
    }


    /**
     * Вернуть педыдущую ячейку.
    **/
    public final ЯчейкаЦС предш()
    {
        return предш_;
    }

    /**
     * Установить предыдущую ячейку. Вам, видимо, не хотелось вызывать this.
    **/
    public final проц предш(ЯчейкаЦС n)
    {
        предш_ = n;
    }


    /**
     * Возвращает да, если текущая ячейка является единственной в списке.
    **/

    public final бул синглтон_ли()
    {
        return следщ_ is this;
    }

    public final проц вяжиСледщ(ЯчейкаЦС p)
    {
        if (p !is пусто)
        {
            следщ_.предш_ = p;
            p.следщ_ = следщ_;
            p.предш_ = this;
            следщ_ = p;
        }
    }

    /**
     * Создаёт ячейку, содержащую знач и компонует её сразу же после текущей ячейки.
    **/

    public final проц добавьСледщ(T знач)
    {
        ЯчейкаЦС p = new ЯчейкаЦС(знач, this, следщ_);
        следщ_.предш_ = p;
        следщ_ = p;
    }

    /**
     * Создаёт узел, содержащий знач, компонует его перед текущей ячейкой и возвращает её.
    **/

    public final ЯчейкаЦС добавьПредш(T знач)
    {
        ЯчейкаЦС p = предш_;
        ЯчейкаЦС c = new ЯчейкаЦС(знач, p, this);
        p.следщ_ = c;
        предш_ = c;
        return c;
    }

    /**
     * Компонует p перед текущей ячейкой.
    **/

    public final проц вяжиПредш(ЯчейкаЦС p)
    {
        if (p !is пусто)
        {
            предш_.следщ_ = p;
            p.предш_ = предш_;
            p.следщ_ = this;
            предш_ = p;
        }
    }

    /**
     * Возвращает число ячеек в этом списке.
    **/

    public final цел длина()
    {
        цел c = 0;
        ЯчейкаЦС p = this;
        do
        {
            ++c;
            p = p.следщ();
        }
        while (p !is this);
        return c;
    }

    /**
     * Возвращает первую ячейку, хранящую элемент, найденый при циркулярном обходе,
     * начинающийся с текущей ячейки, либо пусто, если такового нет.
    **/

    public final ЯчейкаЦС найди(T элемент)
    {
        ЯчейкаЦС p = this;
        do
        {
            if (p.элемент() == (элемент))
                return p;
            p = p.следщ();
        }
        while (p !is this);
        return пусто;
    }

    /**
     * Возвращает число ячеек, хранящих элемент, найденый при циркулярном
     * обходе.
    **/

    public final цел счёт(T элемент)
    {
        цел c = 0;
        ЯчейкаЦС p = this;
        do
        {
            if (p.элемент() == (элемент))
                ++c;
            p = p.следщ();
        }
        while (p !is this);
        return c;
    }

    /**
     * Возвращает н_ую ячейку, обходимую отсюда. Она может обматываться.
    **/

    public final ЯчейкаЦС н_ый(цел n)
    {
        ЯчейкаЦС p = this;
        for (цел i = 0; i < n; ++i)
            p = p.следщ_;
        return p;
    }


    /**
     * Отлинковать следщ ячейку.
     * Это не влияет на данный список, если он синглтон_ли().
    **/

    public final проц отвяжиСледщ()
    {
        ЯчейкаЦС nn = следщ_.следщ_;
        nn.предш_ = this;
        следщ_ = nn;
    }

    /**
     * Отлинковать предшествующую ячейку.
     * Это не влияет на данный список, если он синглтон_ли().
    **/

    public final проц отвяжиПредш()
    {
        ЯчейкаЦС pp = предш_.предш_;
        pp.следщ_ = this;
        предш_ = pp;
    }


    /**
     * Отлинковать this от списка, в котором он находится.
     * This в итоге становится синглтоном.
    **/

    public final проц отвяжи()
    {
        ЯчейкаЦС p = предш_;
        ЯчейкаЦС n = следщ_;
        p.следщ_ = n;
        n.предш_ = p;
        предш_ = this;
        следщ_ = this;
    }

    /**
     * Создаёт копию этого списка и возвращает новую голову.
    **/

    public final ЯчейкаЦС копируйСписок()
    {
        ЯчейкаЦС hd = this;

        ЯчейкаЦС новый_список = new ЯчейкаЦС(hd.элемент(), пусто, пусто);
        ЯчейкаЦС текущ = новый_список;

        for (ЯчейкаЦС p = следщ_; p !is hd; p = p.следщ_)
        {
            текущ.следщ_ = new ЯчейкаЦС(p.элемент(), текущ, пусто);
            текущ = текущ.следщ_;
        }
        новый_список.предш_ = текущ;
        текущ.следщ_ = новый_список;
        return новый_список;
    }
}

