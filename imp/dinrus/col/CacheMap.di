module col.CacheMap;

private import cidrus;
private import col.HashMapY;
public  import col.Container;

/******************************************************************************

        КэшКарта расширяет базовый тип хэш-карты, добавляя предел  
        числа элементов, содержимых в любое указанное время. В дополнение, 
        КэшКарта сортирует записи кэша, так чтобы эти записи были в голове 
        очереди, если используются часто, а в хвосте были наименее используемые.
        Когда очередь наполняется, старые записи с хвоста сбрасываются и 
        используются снова для помешения новых записей кэша. 

        Другими словами, она оставляет элементы MRU, сбрасывая при этом элементы LRU,
        при заполнении ёмкости.

        Это прекрасно для сохранения часто используемых элементов, причём
		лимитируется используемое количество памяти. Как правило, размер очереди 
        устанавливается в порядке тысяч (посредством конструктора).

******************************************************************************/

class КэшКарта (К, З, alias Хэш = Контейнер.хэш, 
                      alias Извл = Контейнер.извлеки, 
                      alias Куча = Контейнер.Сбор) 
{
        private alias ЗаписьВОчереди       Тип;
        private alias Тип              *Реф;
        private alias ХэшКарта!(К, Реф, Хэш, рипер, куча) Карта;
        private Карта                     хэш;
        private Тип[]                  линки;

        // протяжённость очереди
        private Реф                     голова,
                                        хвост;
        // дименсия очереди
        private бцел                    ёмкость;

       /**********************************************************************

                Конструирует кэш с заданным максимальным числом записей. 
                Добавления в кэш сверх этого числа приводит к повторному
                использованию слота записи в кэш, наименее часто использованного
                до этого момента. 

        **********************************************************************/

        this (бцел ёмкость)
        {
                хэш = new Карта;
                this.ёмкость = ёмкость;
                хэш.корзины (ёмкость, 0.75);
                линки.length = ёмкость;

                // создай пустой список
                голова = хвост = &линки[0];
                foreach (ref link; линки[1..$])
                        {
                        link.предш = хвост;
                        хвост.следщ = &link;
                        хвост = &link;
                        }
        }

        /***********************************************************************

                Извлing обрвызов for the hashmap, acting as a trampoline

        ***********************************************************************/

        static проц рипер(К, R) (К ключ, R r) 
        {
                Извл (ключ, r.значение);
        }

        /***********************************************************************


        ***********************************************************************/

        final бцел размер ()
        {
                return хэш.размер;
        }

        /***********************************************************************

                Iterate из_ MRU в_ LRU записи

        ***********************************************************************/

        final цел opApply (цел delegate(ref К ключ, ref З значение) дг)
        {
                        К   ключ;
                        З   значение;
                        цел результат;

                        auto узел = голова;
                        auto i = хэш.размер;
                        while (i--)
                              {
                              ключ = узел.ключ;
                              значение = узел.значение;
                              if ((результат = дг(ключ, значение)) != 0)
                                   break;
                              узел = узел.следщ;
                              }
                        return результат;
        }

        /**********************************************************************

                Get the кэш Запись опрentified by the given ключ

        **********************************************************************/

        бул получи (К ключ, ref З значение)
        {
                Реф Запись = пусто;

                // if we найди 'ключ' then перемести it в_ the список голова
                if (хэш.получи (ключ, Запись))
                   {
                   значение = Запись.значение;
                   переРеферируй (Запись);
                   return да;
                   }
                return нет;
        }

        /**********************************************************************

                Place an Запись преобр_в the кэш и associate it with the
                предоставленный ключ. Note that there can be only one Запись for
                any particular ключ. If two записи are добавьed with the 
                same ключ, the секунда effectively overwrites the первый.

                Возвращает да, если we добавьed a new Запись; нет if we just
                replaced an existing one

        **********************************************************************/

        final бул добавь (К ключ, З значение)
        {
                Реф Запись = пусто;

                // already в этом списке? -- замени Запись
                if (хэш.получи (ключ, Запись))
                   {
                   // Устанавливает new item for this ключ и перемести в_ список голова
                   переРеферируй (Запись.установи (ключ, значение));
                   return нет;
                   }

                // создай a new Запись at the список голова 
                добавьЗапись (ключ, значение);
                return да;
        }

        /**********************************************************************

                Удали the кэш Запись associated with the предоставленный ключ. 
                Возвращает нет if there is no such Запись.

        **********************************************************************/

        final бул возьми (К ключ)
        {
                З значение;

                return возьми (ключ, значение);
        }

        /**********************************************************************

                Удали (и return) the кэш Запись associated with the 
                предоставленный ключ. Возвращает нет if there is no such Запись.

        **********************************************************************/

        final бул возьми (К ключ, ref З значение)
        {
                Реф Запись = пусто;
                if (хэш.получи (ключ, Запись))
                   {
                   значение = Запись.значение;

                   // don't actually затуши the список Запись -- just place
                   // it at the список 'хвост' ready for subsequent reuse
                   разРеферируй (Запись);

                   // удали the Запись из_ хэш
                   хэш.удалиКлюч (ключ);
                   return да;
                   }
                return нет;
        }

        /**********************************************************************

                Place a кэш Запись at the хвост of the queue. This makes
                it the least-recently referenced.

        **********************************************************************/

        private Реф разРеферируй (Реф Запись)
        {
                if (Запись !is хвост)
                   {
                   // исправь голова
                   if (Запись is голова)
                       голова = Запись.следщ;

                   // перемести в_ хвост
                   Запись.выкинь;
                   хвост = Запись.добавь (хвост);
                   }
                return Запись;
        }

        /**********************************************************************

                Move a кэш Запись в_ the голова of the queue. This makes
                it the most-recently referenced.

        **********************************************************************/

        private Реф переРеферируй (Реф Запись)
        {
                if (Запись !is голова)
                   {
                   // исправь хвост
                   if (Запись is хвост)
                       хвост = Запись.предш;

                   // перемести в_ голова
                   Запись.выкинь;
                   голова = Запись.приставь (голова);
                   }
                return Запись;
        }

        /**********************************************************************

                Добавь an Запись преобр_в the queue. If the queue is full, the
                least-recently-referenced Запись is reused for the new
                добавьition. 

        **********************************************************************/

        private Реф добавьЗапись (К ключ, З значение)
        {
                assert (ёмкость);

                if (хэш.размер < ёмкость)
                    хэш.добавь (ключ, хвост);
                else
                   {
                   // we're re-using a приор ЗаписьВОчереди, so извлеки и
                   // relocate the existing хэш-таблица Запись первый
                   Извл (хвост.ключ, хвост.значение);
                   if (! хэш.replaceKey (хвост.ключ, ключ))
                         throw new Исключение ("ключ отсутствует!");
                   }

                // place at голова of список
                return переРеферируй (хвост.установи (ключ, значение));
        }

        /**********************************************************************
        
                A doubly-linked список Запись, использован as a wrapper for queued 
                кэш записи
        
        **********************************************************************/
        
        private struct ЗаписьВОчереди
        {
                private К               ключ;
                private Реф             предш,
                                        следщ;
                private З               значение;
        
                /**************************************************************
        
                        Набор this linked-список Запись with the given аргументы. 

                **************************************************************/
        
                Реф установи (К ключ, З значение)
                {
                        this.значение = значение;
                        this.ключ = ключ;
                        return this;
                }
        
                /**************************************************************
        
                        Insert this Запись преобр_в the linked-список just in 
                        front of the given Запись.
        
                **************************************************************/
        
                Реф приставь (Реф перед)
                {
                        if (перед)
                           {
                           предш = перед.предш;
        
                           // патч 'предш' в_ точка at me
                           if (предш)
                               предш.следщ = this;
        
                           //патч 'перед' в_ точка at me
                           следщ = перед;
                           перед.предш = this;
                           }
                        return this;
                }
        
                /**************************************************************
                        
                        Добавь this Запись преобр_в the linked-список just после 
                        the given Запись.
        
                **************************************************************/
        
                Реф добавь (Реф после)
                {
                        if (после)
                           {
                           следщ = после.следщ;
        
                           // патч 'следщ' в_ точка at me
                           if (следщ)
                               следщ.предш = this;
        
                           //патч 'после' в_ точка at me
                           предш = после;
                           после.следщ = this;
                           }
                        return this;
                }
        
                /**************************************************************
        
                        Удали this Запись из_ the linked-список. The 
                        previous и следщ записи are patched together 
                        appropriately.
        
                **************************************************************/
        
                Реф выкинь ()
                {
                        // сделай 'предш' и 'следщ' записи see each другой
                        if (предш)
                            предш.следщ = следщ;
        
                        if (следщ)
                            следщ.предш = предш;
        
                        // Murphy's law 
                        следщ = предш = пусто;
                        return this;
                }
        }
}


/*******************************************************************************

*******************************************************************************/

debug (КэшКарта)
{
        import io.Stdout;
        import time.StopWatch;

        проц main()
        {
                цел знач;
                auto карта = new КэшКарта!(ткст, цел)(2);
                карта.добавь ("foo", 1);
                карта.добавь ("bar", 2);
                карта.добавь ("wumpus", 3);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("bar", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("bar", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("foo", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("wumpus", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);


                // установи for benchmark, with a кэш of целыйs
                auto тест = new КэшКарта!(цел, цел, Контейнер.хэш, Контейнер.извлеки, Контейнер.Чанк) (1000);
                const счёт = 1_000_000;
                Секундомер w;

                // benchmark добавим
                w.старт;
                for (цел i=счёт; i--;)
                     тест.добавь (i, i);
                Стдвыв.форматнс ("{} добавьs: {}/s", счёт, счёт/w.stop);

                // benchmark reading
                w.старт;
                for (цел i=счёт; i--;)
                     тест.получи (i, знач);
                Стдвыв.форматнс ("{} lookups: {}/s", счёт, счёт/w.stop);

                // benchmark iteration
                w.старт;
                foreach (ключ, значение; тест) {}
                Стдвыв.форматнс ("{} элемент iteration: {}/s", тест.размер, тест.размер/w.stop);

                тест.хэш.проверь;
        }
}
        
