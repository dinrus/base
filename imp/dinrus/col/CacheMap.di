module col.CacheMap;

private import cidrus;
private import col.HashMapY;
public  import col.Container;

/******************************************************************************

        КэшКарта расширяет базовый тип хэш-карты, добавляя предел  
        числа элементов, содержимых в любое указанное время. В дополнение, 
        КэшКарта сортирует записи кэша, так чтобы эти записи были в голове 
        очереди, если используются часто, а в хвосте были наименее используемые.
        Когда очередь наполняется, старые записи с хвоста сбрасываются и 
        используются снова для помешения новых записей кэша. 

        Другими словами, она оставляет элементы MRU, сбрасывая при этом элементы LRU,
        при заполнении ёмкости.

        Это прекрасно для сохранения часто используемых элементов, причём
		лимитируется используемое количество памяти. Как правило, размер очереди 
        устанавливается в порядке тысяч (посредством конструктора).

******************************************************************************/

class КэшКарта (К, З, alias Хэш = Контейнер.хэш, 
                      alias Извл = Контейнер.извлеки, 
                      alias Куча = Контейнер.Сбор) 
{
        private alias ЗаписьВОчереди       Тип;
        private alias Тип              *Реф;
        private alias ХэшКарта!(К, Реф, Хэш, рипер, куча) Карта;
        private Карта                     хэш;
        private Тип[]                  линки;

        // протяжённость очереди
        private Реф                     голова,
                                        хвост;
        // дименсия очереди
        private бцел                    ёмкость;

       /**********************************************************************

                Конструирует кэш с заданным максимальным числом записей. 
                Добавления в кэш сверх этого числа приводит к повторному
                использованию слота записи в кэш, наименее часто использованного
                до этого момента. 

        **********************************************************************/

        this (бцел ёмкость)
        {
                хэш = new Карта;
                this.ёмкость = ёмкость;
                хэш.корзины (ёмкость, 0.75);
                линки.length = ёмкость;

                // создай пустой список
                голова = хвост = &линки[0];
                foreach (ref link; линки[1..$])
                        {
                        link.предш = хвост;
                        хвост.следщ = &link;
                        хвост = &link;
                        }
        }

        /***********************************************************************

                Извлекает обрвызов для этой хэшкарта, действуя как трамплин.

        ***********************************************************************/

        static проц рипер(К, R) (К ключ, R r) 
        {
                Извл (ключ, r.значение);
        }

        /***********************************************************************


        ***********************************************************************/

        final бцел размер ()
        {
                return хэш.размер;
        }

        /***********************************************************************

                Итерирует от MRU до LRU записи.

        ***********************************************************************/

        final цел opApply (цел delegate(ref К ключ, ref З значение) дг)
        {
                        К   ключ;
                        З   значение;
                        цел результат;

                        auto узел = голова;
                        auto i = хэш.размер;
                        while (i--)
                              {
                              ключ = узел.ключ;
                              значение = узел.значение;
                              if ((результат = дг(ключ, значение)) != 0)
                                   break;
                              узел = узел.следщ;
                              }
                        return результат;
        }

        /**********************************************************************

                Получить кэш Запись, идентифицируемую заданным ключом.

        **********************************************************************/

        бул получи (К ключ, ref З значение)
        {
                Реф Запись = пусто;

                // если находим 'ключ', то перемещаем его в голову списка
                if (хэш.получи (ключ, Запись))
                   {
                   значение = Запись.значение;
                   переРеферируй (Запись);
                   return да;
                   }
                return нет;
        }

        /**********************************************************************

                Поместить Запись, преобразованную в кэш, и ассоциировать её с
                предоставленным ключом. Заметьте, что может быть только одна Запись на
                любой частный ключ. Если добавлено две записи с одинаковым 
                ключом, второй эффективно переписывает первый.

                Возвращает да, если добавлена новая Запись; нет, если просто
                перемещена существующая.

        **********************************************************************/

        final бул добавь (К ключ, З значение)
        {
                Реф Запись = пусто;

                // уже в этом списке? -- заменим Запись
                if (хэш.получи (ключ, Запись))
                   {
                   // Устанавливаем новый элт для этого ключ и перемещаем в голову списка
                   переРеферируй (Запись.установи (ключ, значение));
                   return нет;
                   }

                // создаём новую Запись в голове списка 
                добавьЗапись (ключ, значение);
                return да;
        }

        /**********************************************************************

                Удаляет кэш Запись, ассоциированную с предоставленным ключом. 
                Возвращает нет, если такой Записи нет.

        **********************************************************************/

        final бул возьми (К ключ)
        {
                З значение;

                return возьми (ключ, значение);
        }

        /**********************************************************************

                Удаляет (и возвращает) кэш Запись, ассоциированную с 
                предоставленным ключом. Возвращает нет, если нет такой Записи.

        **********************************************************************/

        final бул возьми (К ключ, ref З значение)
        {
                Реф Запись = пусто;
                if (хэш.получи (ключ, Запись))
                   {
                   значение = Запись.значение;

                   // don't actually затуши the список Запись -- just place
                   // it at the список 'хвост' ready for subsequent reuse
                   разРеферируй (Запись);

                   // удалим Запись из хэша
                   хэш.удалиКлюч (ключ);
                   return да;
                   }
                return нет;
        }

        /**********************************************************************

                Помещает кэш Запись в хвост этой очереди. Она становится
                упоминавшейся давнее всех.

        **********************************************************************/

        private Реф разРеферируй (Реф Запись)
        {
                if (Запись !is хвост)
                   {
                   // исправь голова
                   if (Запись is голова)
                       голова = Запись.следщ;

                   // перемести в_ хвост
                   Запись.выкинь;
                   хвост = Запись.добавь (хвост);
                   }
                return Запись;
        }

        /**********************************************************************

                Перемещает кэш Запись в голову этой очереди. Она становится
                упоминавшейся недавнее всех.

        **********************************************************************/

        private Реф переРеферируй (Реф Запись)
        {
                if (Запись !is голова)
                   {
                   // исправим хвост
                   if (Запись is хвост)
                       хвост = Запись.предш;

                   // переместим в голову
                   Запись.выкинь;
                   голова = Запись.приставь (голова);
                   }
                return Запись;
        }

        /**********************************************************************

                Добавляет Запись в очередь. Если очередь полна,e
                неиболее недавно упоминавшаяся Запись  используется повторно для
                нового добавления. 

        **********************************************************************/

        private Реф добавьЗапись (К ключ, З значение)
        {
                assert (ёмкость);

                if (хэш.размер < ёмкость)
                    хэш.добавь (ключ, хвост);
                else
                   {
                   // we're re-using a приор ЗаписьВОчереди, so извлеки и
                   // relocate the existing хэш-таблица Запись первый
                   Извл (хвост.ключ, хвост.значение);
                   if (! хэш.replaceKey (хвост.ключ, ключ))
                         throw new Исключение ("ключ отсутствует!");
                   }

                // поместим в голову списка
                return переРеферируй (хвост.установи (ключ, значение));
        }

        /**********************************************************************
        
                Запись дважды линкованного списка, используемая как обёртка для 
                записи кэша в очереди.
        
        **********************************************************************/
        
        private struct ЗаписьВОчереди
        {
                private К               ключ;
                private Реф             предш,
                                        следщ;
                private З               значение;
        
                /**************************************************************
        
                Устанавливает эту Запись линкованного списка с заданными аргументами. 

                **************************************************************/
        
                Реф установи (К ключ, З значение)
                {
                        this.значение = значение;
                        this.ключ = ключ;
                        return this;
                }
        
                /**************************************************************
        
                 Вставляет эту Запись, преобразуя её в линкованный список, прямо 
                 перед заданной Записью.
        
                **************************************************************/
        
                Реф приставь (Реф перед)
                {
                        if (перед)
                           {
                           предш = перед.предш;
        
                           // патч 'предш' в_ точка at me
                           if (предш)
                               предш.следщ = this;
        
                           //патч 'перед' в_ точка at me
                           следщ = перед;
                           перед.предш = this;
                           }
                        return this;
                }
        
                /**************************************************************
                        
                Добавляет эту Запись, преобразуя её в линкованный список, прямо после 
                указанной Записи.
        
                **************************************************************/
        
                Реф добавь (Реф после)
                {
                        if (после)
                           {
                           следщ = после.следщ;
        
                           // патч 'следщ' в_ точка at me
                           if (следщ)
                               следщ.предш = this;
        
                           //патч 'после' в_ точка at me
                           предш = после;
                           после.следщ = this;
                           }
                        return this;
                }
        
                /**************************************************************
        
                Удаляет эту Запись из линкованного списка.Предыдущая 
                и следующая записи соответствующим образом пропатчиваются.
        
                **************************************************************/
        
                Реф выкинь ()
                {
                        // сделай 'предш' и 'следщ' записи see each другой
                        if (предш)
                            предш.следщ = следщ;
        
                        if (следщ)
                            следщ.предш = предш;
        
                        // Murphy's law 
                        следщ = предш = пусто;
                        return this;
                }
        }
}


/*******************************************************************************

*******************************************************************************/

debug (КэшКарта)
{
        import io.Stdout;
        import time.StopWatch;

        проц main()
        {
                цел знач;
                auto карта = new КэшКарта!(ткст, цел)(2);
                карта.добавь ("foo", 1);
                карта.добавь ("bar", 2);
                карта.добавь ("wumpus", 3);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("bar", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("bar", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("foo", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);

                Стдвыв.нс;
                карта.получи ("wumpus", знач);
                foreach (ключ, знач; карта)
                         Стдвыв.форматнс ("{} {}", ключ, знач);


                // установи for benchmark, with a кэш of целыйs
                auto тест = new КэшКарта!(цел, цел, Контейнер.хэш, Контейнер.извлеки, Контейнер.Чанк) (1000);
                const счёт = 1_000_000;
                Секундомер w;

                // benchmark добавим
                w.старт;
                for (цел i=счёт; i--;)
                     тест.добавь (i, i);
                Стдвыв.форматнс ("{} добавки: {}/s", счёт, счёт/w.stop);

                // benchmark reading
                w.старт;
                for (цел i=счёт; i--;)
                     тест.получи (i, знач);
                Стдвыв.форматнс ("{} поиски: {}/s", счёт, счёт/w.stop);

                // benchmark iteration
                w.старт;
                foreach (ключ, значение; тест) {}
                Стдвыв.форматнс ("{} обходов элементов: {}/s", тест.размер, тест.размер/w.stop);

                тест.хэш.проверь;
        }
}
        
