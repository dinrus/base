module col.Hash;

private import col.Link;
private import col.model.Iterator;
private import col.DefaultAllocator;

/+  ИНТЕРФЕЙС:

struct ДефолтыХэш
{
    const плав факторЗагрузки = .75;
    const бцел размерТаблицы = 31;
}


struct Хэш(З, alias хэшФункц, alias обновлФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель, бул допускатьДубликаты=нет, бул обновить_ли=да)
{
 Связка!(З).Узел узел;
 alias Разместитель!(Связка!(З)) разместитель;
 разместитель разм;
 узел[] таблица;
 бцел счёт;
    struct Позиция
    {
        Хэш *владелец;
        узел укз; alias укз ptr;
        цел инд;
        Позиция следщ();
        Позиция предш();
    бул добавь(З з);
    проц перемерьПод(бцел ёмкость);
    проц проверьФакторЗагрузки();
    Позиция начало();
    Позиция конец();
    Позиция найди(З з);
    Позиция удали(Позиция поз);
    проц зачисть();
    бцел накладка(Обходчик!(З) поднабор);;
        бцел считайВсе(З з);
        бцел удалиВсе(З з);
        Позиция найди(З з, Позиция начатьС);
    проц копируйВ(ref Хэш цель);
    узел размести();
    узел размести(З з);
    проц установка();
}


template ХэшБезОбновлений(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель);

template ХэшДуб(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель);

+/
//==================================================================
struct ДефолтыХэш
{
    const плав факторЗагрузки = .75;
    const бцел размерТаблицы = 31;
}

/**
 * Дефолтная реализация Хэша. Используется в контейнерах Хэш* по
 * умолчанию.
 *
 * Реализация содержит таблицу из линкованных списков. Тааблица индексирует
 * входящие элементы, основываясь на хэн-коде.
 */
struct Хэш(З, alias хэшФункц, alias обновлФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель, бул допускатьДубликаты=нет, бул обновить_ли=да)
{
    /**
     * Псевдоним для Узел
     */
    alias Связка!(З).Узел узел;

    /**
     * Псевдоним для Разместитель
     */
    alias Разместитель!(Связка!(З)) разместитель;

    /**
     * Разместитель для хэша
     */
    разместитель разм;

    /**
     * Таблица бакетов (buckets)
     */
    узел[] таблица;

    /**
     * Число элементов в этой таблице
     */
    бцел счёт;

    /**
     * Подобно указателю, используется для указания на заданный элемент в хэше.
     */
    struct Позиция
    {
        Хэш *владелец;
        узел укз; alias укз ptr;
        цел инд;

        /**
         * Возвращает Позицию вслед за p.
         */
        Позиция следщ()
        {
            Позиция p = *this;
            auto таблица = владелец.таблица;

            if(p.ptr !is пусто)
            {
                if(p.ptr.следщ is таблица[p.инд])
                    //
                    // Особый случай в конце бакета, переход к следщ
                    // бакету.
                    //
                    p.ptr = пусто;
                else
                {
                    //
                    // Всё ещё в бакете
                    //
                    p.ptr = p.ptr.следщ;
                    return p;
                }
            }

            //
            // Перейти за бакет, к следующему валидному бакету
            //
            while(p.инд < cast(цел)таблица.length && p.ptr is пусто)
            {
                if(++p.инд < таблица.length)
                    p.ptr = таблица[p.инд];
                else
                    p.ptr = пусто;
            }
            return p;
        }

        /**
         * Возвращает Позицию перед p.
         */
        Позиция предш()
        {
            Позиция p = *this;
            auto таблица = владелец.таблица;
            if(p.ptr !is пусто)
            {
                if(p.ptr is таблица[p.инд])
                    p.ptr = пусто;
                else
                {
                    p.ptr = p.ptr.предш;
                    return p;
                }
            }

            while(p.инд > 0 && p.ptr is пусто)
                p.ptr = таблица[--p.инд];
            if(p.ptr)
                //
                // Перейти в конец нового бакета
                //
                p.ptr = p.ptr.предш;
            return p;
        }
    }

    /**
     * Добавить значение в этот хэш. Возвращает да, если значение отсутствует,
     * или нет, если обх обновлён.
     */
    бул добавь(З з)
    {
        if(таблица is пусто)
            перемерьПод(исходнРазмерТаблицы);

        auto h = хэшФункц(з) % таблица.length;
        узел хвост = таблица[h];
        if(хвост is пусто)
        {
            //
            // Узла пока ещё нет, добавим здесь новый узел.
            //
            хвост = таблица[h] = размести(з);
            узел.крепи(хвост, хвост);
            счёт++; 
            return да;
        }
        else
        {
            static if(!допускатьДубликаты)
            {
                узел элт = найдиВБакете(хвост, з, хвост);
                if(элт is пусто)
                {
                    счёт++;
                    хвост.надставь(размести(з));
                    // Не единичный элемент, нужно проверить фактор загрузки.
                    проверьФакторЗагрузки();
                    return да;
                }
                else
                {
                    //
                    // Найден узел, установить значение.
                    //
                    static if(обновить_ли)
                        обновлФункц(элт.значение, з);
                    return нет;
                }
            }
            else
            {
                //
                // Всегда добавь, даже если узел уже существует.
                //
                счёт++;
                хвост.надставь(размести(з));
                // Не единичный элемент, нужно проверить фактор загрузки.
                проверьФакторЗагрузки();
                return да;
            }
        }
    }

    /**
     * Изменить размер хэш-таблицы на заданную ёмкость. Как правило, вызывается
     * только приватно.
     */
    проц перемерьПод(бцел ёмкость)
    {
        if(ёмкость > таблица.length)
        {
            auto новТабл = new узел[ёмкость];

            foreach(голова; таблица)
            {
                if(голова)
                {
                    //
                    // make the последн узел point to пусто, to mark the конец of
                    // the бакет
                    //
                    узел.крепи(голова.предш, пусто);
                    for(узел тек = голова, следщ = голова.следщ; тек !is пусто;
                            тек = следщ)
                    {
                        следщ = тек.следщ;
                        auto h = хэшФункц(тек.значение) % новТабл.length;
                        узел новГолова = новТабл[h];
                        if(новГолова is пусто)
                        {
                            новТабл[h] = тек;
                            узел.крепи(тек, тек);
                        }
                        else
                            новГолова.надставь(тек);
                    }
                }
            }
            delete таблица;
            таблица = новТабл;
        }
    }

    /**
     * Проверить, whether the load фактор dictates a перемерьПод is in order.
     */
    проц проверьФакторЗагрузки()
    {
        if(таблица !is пусто)
        {
            плав fc = cast(плав) счёт;
            плав ft = таблица.length;

            if(fc / ft > факторЗагрузки)
                перемерьПод(2 * cast(бцел)(fc / факторЗагрузки) + 1);
        }
    }

    /**
     * Возвращает Позицию, которая указывает на первый элемент в этом хэше.
     */
    Позиция начало()
    {
        if(счёт == 0)
            return конец;
        Позиция рез;
        рез.ptr = пусто;
        рез.владелец = this;
        рез.инд = -1;
        //
        // this finds the первый valid узел
        //
        return рез.следщ;
    }

    /**
     * Возвращает Позицию, указывающую за последний элемент этого хэша.
     */
    Позиция конец()
    {
        Позиция рез;
        рез.инд = таблица.length;
        рез.владелец = this;
        return рез;
    }

    // приватная функция используется для реализации общих фрагментов
    private узел найдиВБакете(узел бакет, З з, узел начатьС)
    in
    {
        assert(бакет !is пусто);
    }
    body
    {
        if(начатьС.значение == з)
            return начатьС;
        узел n;
        for(n = начатьС.следщ; n !is бакет && n.значение != з; n = n.следщ)
        {
        }
        return (n is бакет ? пусто : n);
    }

    /**
     * Найти первый экземпляр значения.
     */
    Позиция найди(З з)
    {
        if(счёт == 0)
            return конец;
        auto h = хэшФункц(з) % таблица.length;
        // если бакет пустой или не содержит з, вернуть конец
        узел укз;
        if(таблица[h] is пусто || (укз = найдиВБакете(таблица[h], з, таблица[h])) is пусто)
            return конец;
        Позиция p;
        p.владелец = this;
        p.инд = h;
        p.ptr = укз;
        return p;
    }

    /**
     * Удалить данную Позиция из этого хэша.
     */
    Позиция удали(Позиция поз)
    {
        Позиция возврзнач = поз.следщ;
        if(поз.ptr is таблица[поз.инд])
        {
            if(поз.ptr.следщ is поз.ptr)
                таблица[поз.инд] = пусто;
            else
                таблица[поз.инд] = поз.ptr.следщ;
        }
        поз.ptr.открепи;
        static if(разместитель.нужноСвоб)
            разм.освободи(поз.ptr);
        счёт--;
        return возврзнач;
    }

    /**
     * Удалить все значения из хэша.
     */
    проц зачисть()
    {
        static if(разместитель.нужноСвоб)
            разм.освободиВсе();
        delete таблица;
        таблица = пусто;
        счёт = 0;
    }

    /**
     * Оставить только элементы из поднабор.
     *
     * Возвращает число удалённых элементов.
     */
    бцел накладка(Обходчик!(З) поднабор)
    {
        if(счёт == 0)
            return 0;
        //
        // начать удаление всех узлов, затем отфильтровать те, которые в
        // этом наборе.
        //
        бцел рез = счёт;
        auto врм = new узел[таблица.length];

        foreach(ref з; поднабор)
        {
            Позиция p = найди(з);
            if(p.инд != таблица.length)
            {
                //
                // найти этот узел в текущей таблице, добавить обходчик в
                // новую таблицу.
                //
                узел голова = врм[p.инд];

                //
                // нужно обновить указатель на таблицу, если это головной узел в ячейке.
                //
                if(p.ptr is таблица[p.инд])
                {
                    if(p.ptr.следщ is p.ptr)
                        таблица[p.инд] = пусто;
                    else
                        таблица[p.инд] = p.ptr.следщ;
                }

                if(голова is пусто)
                {
                    врм[p.инд] = p.ptr.открепи;
                    узел.крепи(p.ptr, p.ptr);
                }
                else
                    голова.надставь(p.ptr.открепи);
                рез--;
            }
        }

        static if(разместитель.нужноСвоб)
        {
            //
            // теперь нужно освободить все неиспользуемые узлы.
            //
            foreach(голова; таблица)
            {
                if(голова !is пусто)
                {
                    //
                    // так как будем освобождать голову, пометим конец списка
                    // указателем пусто.
                    //
                    узел.крепи(голова.предш, пусто);
                    while(голова !is пусто)
                    {
                        auto newhead = голова.следщ;
                        разм.освободи(голова);
                        голова = newhead;
                    }
                }
            }
        }
        таблица = врм;
        счёт -= рез;
        return рез;
    }

    static if(допускатьДубликаты)
    {
        // private function to do the dirty work of считайВсе and удалиВсе
        private бцел _applyAll(З з, бул удали)
        {
            Позиция p = найди(з);
            бцел рез = 0;
            if(p.инд != таблица.length)
            {
                auto бакет = таблица[p.инд];
                do
                {
                    if(p.ptr.значение == з)
                    {
                        рез++;
                        if(удали)
                        {
                            auto исх = p.ptr;
                            p.ptr = p.ptr.следщ;
                            исх.открепи();
                            static if(разместитель.нужноСвоб)
                            {
                                разм.освободи(исх);
                            }
                            continue;
                        }
                    }

                    p.ptr = p.ptr.следщ;
                }
                while(p.ptr !is бакет)
            }
            return рез;
        }

        /**
         * Подсчитывает число раз, которое данное значение появляется в хэше.
         */
        бцел считайВсе(З з)
        {
            return _applyAll(з, нет);
        }

        /**
         * Удаляет все экземпляры з, имеющиеся в хэше.
         */
        бцел удалиВсе(З з)
        {
            return _applyAll(з, да);
        }

        /**
         * Находит данное значение в хэше, начиная с заданной Позиции.
         * Если Позиция за последн экземпляром з (что может быть определено,
         * если бакет этой Позиции за бакетом, в который должно попасть з).
         */
        Позиция найди(З з, Позиция начатьС)
        {
            if(счёт == 0)
                return конец;
            auto h = хэшФункц(з) % таблица.length;
            if(начатьС.инд < h)
            {
                // если бакет пуст, вернуть конец.
                if(таблица[h] is пусто)
                    return конец;

                // начать с бакета, в котором должно находиться значение.
                начатьС.инд = h;
                начатьС.ptr = таблица[h];
            }
            else if(начатьС.инд > h)
                // за бакетом, вернуть конец.
                return конец;

            if((начатьС.ptr = найдиВБакете(таблица[h], з, начатьС.ptr)) !is
                    пусто)
                return начатьС;
            return конец;
        }
    }

    /**
     * Копирует все элементы этого хэша в цель.
     */
    проц копируйВ(ref Хэш цель)
    {
        //
        // копируем все локальные значения.
        //
        цель = *this;

        //
        // сбросить разместитель.
        //
        цель.разм = цель.разм.init;

        //
        // реалоцировать все узлы в таблице.
        //
        цель.таблица = new узел[таблица.length];
        foreach(i, n; таблица)
        {
            if(n !is пусто)
                цель.таблица[i] = n.dup(&цель.размести);
        }
    }

    узел размести()
    {
        return разм.размести();
    }

    узел размести(З з)
    {
        auto рез = размести();
        рез.значение = з;
        return рез;
    }

    /**
     * Выполнить любую необходимую настройку (для этой реализации хэша она отсутствует).
     */
    проц установка()
    {
    }
}

/**
 * Используется для определения Хэша, который не выполняет обновлений.
 */
template ХэшБезОбновлений(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель)
{
    // Примечание: второй хэшФункц не используется, так как обновлять_ли равно нет
    alias Хэш!(З, хэшФункц, хэшФункц, факторЗагрузки, исходнРазмерТаблицы, Разместитель, нет, нет) ХэшБезОбновлений;
}

/**
 * Используется для определения Хэша, который принимает дубликаты.
 */
template ХэшДуб(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель)
{
    // Примечание: второй хэшФункц не используется, так как обновлять_ли равно нет
    alias Хэш!(З, хэшФункц, хэшФункц, факторЗагрузки, исходнРазмерТаблицы, Разместитель, да, нет) ХэшДуб;
}
