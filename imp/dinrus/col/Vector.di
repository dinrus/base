module col.Vector;

private import exception: ArrayBoundsException;
private import cidrus :memmove;

/******************************************************************************

        A вектор of the given значение-тип З, with maximum глубина Размер. Note
        that this does no память allocation of its own when Размер != 0, и
        does куча allocation when Размер == 0. Thus you can have a fixed-размер
        low-overhead экземпляр, or a куча oriented экземпляр.

******************************************************************************/

struct Вектор (З, цел Размер = 0)
{
    alias добавь       сунь;
    alias срез     opSlice;
    alias сунь      opCatAssign;

    static if (Размер == 0)
    {
        private бцел глубина;
        private З[]  вектор;
    }
    else
    {
        private бцел     глубина;
        private З[Размер]  вектор;
    }

    /***********************************************************************

            Clear the вектор

    ***********************************************************************/

    Вектор* очисть ()
    {
        глубина = 0;
        return this;
    }

    /***********************************************************************

            Return глубина of the вектор

    ***********************************************************************/

    бцел размер ()
    {
        return глубина;
    }

    /***********************************************************************

            Return остаток неиспользовано slots

    ***********************************************************************/

    бцел неиспользовано ()
    {
        return вектор.length - глубина;
    }

    /***********************************************************************

            Возвращает (shallow) клонируй of this вектор

    ***********************************************************************/

    Вектор клонируй ()
    {
        Вектор знач;
        static if (Размер == 0)
            знач.вектор.length = вектор.length;

        знач.вектор[0..глубина] = вектор[0..глубина];
        знач.глубина = глубина;
        return знач;
    }

    /**********************************************************************

            Добавь a значение в_ the вектор.

            Throws an исключение when the вектор is full

    **********************************************************************/

    З* добавь (З значение)
    {
        static if (Размер == 0)
        {
            if (глубина >= вектор.length)
                вектор.length = вектор.length + 64;
            вектор[глубина++] = значение;
        }
        else
        {
            if (глубина < вектор.length)
                вектор[глубина++] = значение;
            else
                ошибка (__LINE__);
        }
        return &вектор[глубина-1];
    }

    /**********************************************************************

            Добавь a значение в_ the вектор.

            Throws an исключение when the вектор is full

    **********************************************************************/

    З* добавь ()
    {
        static if (Размер == 0)
        {
            if (глубина >= вектор.length)
                вектор.length = вектор.length + 64;
        }
        else if (глубина >= вектор.length)
            ошибка (__LINE__);

        auto p = &вектор[глубина++];
        *p = З.init;
        return p;
    }

    /**********************************************************************

            Добавь a series of значения в_ the вектор.

            Throws an исключение when the вектор is full

    **********************************************************************/

    Вектор* добавь (З[] значение...)
    {
        foreach (знач; значение)
        добавь (знач);
        return this;
    }

    /**********************************************************************

            Удали и return the most recent добавьition в_ the вектор.

            Throws an исключение when the вектор is пустой

    **********************************************************************/

    З удали ()
    {
        if (глубина)
            return вектор[--глубина];

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Index вектор записи, where a zero индекс represents the
            oldest вектор Запись.

            Throws an исключение when the given индекс is out of range

    **********************************************************************/

    З удали (бцел i)
    {
        if (i < глубина)
        {
            if (i is глубина-1)
                return удали;
            --глубина;
            auto знач = вектор [i];
            memmove (вектор.ptr+i, вектор.ptr+i+1, З.sizeof * глубина-i);
            return знач;
        }

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Index вектор записи, as though it were an Массив

            Throws an исключение when the given индекс is out of range

    **********************************************************************/

    З opIndex (бцел i)
    {
        if (i < глубина)
            return вектор [i];

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Assign вектор записи as though it were an Массив.

            Throws an исключение when the given индекс is out of range

    **********************************************************************/

    З opIndexAssign (З значение, бцел i)
    {
        if (i < глубина)
        {
            вектор[i] = значение;
            return значение;
        }

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Return the вектор as an Массив of значения, where the первый
            Массив Запись represents the oldest значение.

            Doing a foreach() on the returned Массив will traverse in
            the opposite direction of foreach() upon a вектор

    **********************************************************************/

    З[] срез ()
    {
        return вектор [0 .. глубина];
    }

    /**********************************************************************

            Throw an исключение

    **********************************************************************/

    private З ошибка (т_мера строка)
    {
        throw new ArrayBoundsException (__FILE__, строка);
    }

    /***********************************************************************

            Iterate из_ the most recent в_ the oldest вектор записи

    ***********************************************************************/

    цел opApply (цел delegate(ref З значение) дг)
    {
        цел результат;

        for (цел i=глубина; i-- && результат is 0;)
            результат = дг (вектор [i]);
        return результат;
    }

    /***********************************************************************

            Iterate из_ the most recent в_ the oldest вектор записи

    ***********************************************************************/

    цел opApply (цел delegate(ref З значение, ref бул затуши) дг)
    {
        цел результат;

        for (цел i=глубина; i-- && результат is 0;)
        {
            auto затуши = нет;
            результат = дг (вектор[i], затуши);
            if (затуши)
                удали (i);
        }
        return результат;
    }
}


/*******************************************************************************

*******************************************************************************/

debug (Вектор)
{
    import io.Stdout;

    проц main()
    {
        Вектор!(цел, 0) знач;
        знач.добавь (1);

        Вектор!(цел, 10) s;

        Стдвыв.форматнс ("добавь four");
        s.добавь (1);
        s.добавь (2);
        s.добавь (3);
        s.добавь (4);
        foreach (знач; s)
        Стдвыв.форматнс ("{}", знач);

        s = s.клонируй;
        Стдвыв.форматнс ("pop one: {}", s.удали);
        foreach (знач; s)
        Стдвыв.форматнс ("{}", знач);

        Стдвыв.форматнс ("удали[1]: {}", s.удали(1));
        foreach (знач; s)
        Стдвыв.форматнс ("{}", знач);

        Стдвыв.форматнс ("удали two");
        s.удали;
        s.удали;
        foreach (знач; s)
        Стдвыв.форматнс ("> {}", знач);

        s.добавь (1);
        s.добавь (2);
        s.добавь (3);
        s.добавь (4);
        foreach (знач, ref ключ; s)
        ключ = да;
        Стдвыв.форматнс ("размер {}", s.размер);
    }
}

