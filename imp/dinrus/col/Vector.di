module col.Vector;

private import exception: ArrayBoundsException;
private import cidrus :memmove;

/******************************************************************************

        Вектор значений указанного типа З с максимальной глубиной Размер. 
		Следует помнить, что собственных размещений в памяти, когда Размер != 0,
		не выполняется и выполняется размещение в кучу, когда Размер == 0.
		Следовательно, можно получить экземпляр фиксированного размера,
		либо экземпляр, нацеленный на кучу.

******************************************************************************/

struct Вектор (З, цел Размер = 0)
{
    alias добавь       сунь;
    alias срез     opSlice;
    alias сунь      opCatAssign;

    static if (Размер == 0)
    {
        private бцел глубина;
        private З[]  вектор;
    }
    else
    {
        private бцел     глубина;
        private З[Размер]  вектор;
    }

    /***********************************************************************

            Очистить вектор.

    ***********************************************************************/

    Вектор* очисть ()
    {
        глубина = 0;
        return this;
    }

    /***********************************************************************

            Возвращает глубину вектора.

    ***********************************************************************/

    бцел размер ()
    {
        return глубина;
    }

    /***********************************************************************

            Возвращает остаток неиспользованных слотов.

    ***********************************************************************/

    бцел неиспользовано ()
    {
        return вектор.length - глубина;
    }

    /***********************************************************************

            Возвращает (неглубокий) клон этого вектора.

    ***********************************************************************/

    Вектор клонируй ()
    {
        Вектор знач;
        static if (Размер == 0)
            знач.вектор.length = вектор.length;

        знач.вектор[0..глубина] = вектор[0..глубина];
        знач.глубина = глубина;
        return знач;
    }

    /**********************************************************************

            Добавляет значение в вектор.

            Выводит исключение, когда вектор заполнен.
			
    **********************************************************************/

    З* добавь (З значение)
    {
        static if (Размер == 0)
        {
            if (глубина >= вектор.length)
                вектор.length = вектор.length + 64;
            вектор[глубина++] = значение;
        }
        else
        {
            if (глубина < вектор.length)
                вектор[глубина++] = значение;
            else
                ошибка (__LINE__);
        }
        return &вектор[глубина-1];
    }

    /**********************************************************************

            Добавляет значение в вектор.

            Выводит исключение, когда вектор заполнен.

    **********************************************************************/

    З* добавь ()
    {
        static if (Размер == 0)
        {
            if (глубина >= вектор.length)
                вектор.length = вектор.length + 64;
        }
        else if (глубина >= вектор.length)
            ошибка (__LINE__);

        auto p = &вектор[глубина++];
        *p = З.init;
        return p;
    }

    /**********************************************************************

            Добавляет ряд значений в вектор.

            Выводит исключение, когда вектор заполнен.

    **********************************************************************/

    Вектор* добавь (З[] значение...)
    {
        foreach (знач; значение)
        добавь (знач);
        return this;
    }

    /**********************************************************************

            Удаляет и возвращает последнюю добавку в вектор.

            Выводит исключение, когда вектор пустой.

    **********************************************************************/

    З удали ()
    {
        if (глубина)
            return вектор[--глубина];

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Индексирует записи в векторе, где нулевой индекс представляет
            самую старую запись в векторе.

            Выводит исключение, когда заданный индекс вне диапазона.

    **********************************************************************/

    З удали (бцел i)
    {
        if (i < глубина)
        {
            if (i is глубина-1)
                return удали;
            --глубина;
            auto знач = вектор [i];
            memmove (вектор.ptr+i, вектор.ptr+i+1, З.sizeof * глубина-i);
            return знач;
        }

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Индексирует записи в векторе, как если бы это был массив.

            Выводит исключение, когда заданный индекс вне диапазона.

    **********************************************************************/

    З opIndex (бцел i)
    {
        if (i < глубина)
            return вектор [i];

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Присваивает вектору записи, как если бы это был массив.

            Выводит исключение, когда заданный индекс вне диапазона.

    **********************************************************************/

    З opIndexAssign (З значение, бцел i)
    {
        if (i < глубина)
        {
            вектор[i] = значение;
            return значение;
        }

        return ошибка (__LINE__);
    }

    /**********************************************************************

            Возвращает вектор как массив значений, в котором первая запись
            массива представляет наиболее старое значение.

            При выполнении foreach() над возвращённым массивом выполняется обход
            вектора в обратном порядке.

    **********************************************************************/

    З[] срез ()
    {
        return вектор [0 .. глубина];
    }

    /**********************************************************************

            Выводит исключение.

    **********************************************************************/

    private З ошибка (т_мера строка)
    {
        throw new ArrayBoundsException (__FILE__, строка);
    }

    /***********************************************************************

            Итерирует от последней к самой давней записи в векторе.

    ***********************************************************************/

    цел opApply (цел delegate(ref З значение) дг)
    {
        цел результат;

        for (цел i=глубина; i-- && результат is 0;)
            результат = дг (вектор [i]);
        return результат;
    }

    /***********************************************************************

            Итерирует от последней к самой давней записи в векторе.

    ***********************************************************************/

    цел opApply (цел delegate(ref З значение, ref бул затуши) дг)
    {
        цел результат;

        for (цел i=глубина; i-- && результат is 0;)
        {
            auto затуши = нет;
            результат = дг (вектор[i], затуши);
            if (затуши)
                удали (i);
        }
        return результат;
    }
}


/*******************************************************************************

*******************************************************************************/

debug (Вектор)
{
    import io.Stdout;

    проц main()
    {
        Вектор!(цел, 0) знач;
        знач.добавь (1);

        Вектор!(цел, 10) s;

        Стдвыв.форматнс ("добавь four");
        s.добавь (1);
        s.добавь (2);
        s.добавь (3);
        s.добавь (4);
        foreach (знач; s)
        Стдвыв.форматнс ("{}", знач);

        s = s.клонируй;
        Стдвыв.форматнс ("pop one: {}", s.удали);
        foreach (знач; s)
        Стдвыв.форматнс ("{}", знач);

        Стдвыв.форматнс ("удали[1]: {}", s.удали(1));
        foreach (знач; s)
        Стдвыв.форматнс ("{}", знач);

        Стдвыв.форматнс ("удали two");
        s.удали;
        s.удали;
        foreach (знач; s)
        Стдвыв.форматнс ("> {}", знач);

        s.добавь (1);
        s.добавь (2);
        s.добавь (3);
        s.добавь (4);
        foreach (знач, ref ключ; s)
        ключ = да;
        Стдвыв.форматнс ("размер {}", s.размер);
    }
}

