module col.Container;

private import cidrus;


/*******************************************************************************

        Вспомогательные функции и константы

*******************************************************************************/

struct Контейнер
{
    /***********************************************************************

           Дефолтное начальное число корзин непустой хэш-карты.

    ***********************************************************************/

    static т_мера дефНачКорзины = 31;

    /***********************************************************************

            Дефолтный фактор загрузки для непустой хэш-карты. Эта хэш-
            таблица изменяется в размере, когда соотношение элементов на
            корзины превысит данный предел.

    ***********************************************************************/

    static плав дефФакторЗагрузки = 0.75f;

    /***********************************************************************

            Генерный рипер значения, который ничего не делает.

    ***********************************************************************/

    static проц извлеки(З) (З знач) {}

    /***********************************************************************

            Генерный рипер ключ/значение, который ничего не делает.

    ***********************************************************************/

    static проц извлеки(К, З) (К ключ, З знач) {}

    /***********************************************************************

            Генерная хэш-функция, использующая дефолтное хэширование.

    ***********************************************************************/

    static т_мера хэш(К) (К ключ, т_мера длина)
    {
        static if (is(К : цел)   || is(К : бцел)   ||
                   is(К : дол)  || is(К : бдол)  ||
                   is(К : крат) || is(К : бкрат) ||
                   is(К : байт)  || is(К : ббайт)  ||
                   is(К : сим)  || is(К : шим)  || is (К : дим))
            return cast(т_мера) (ключ % длина);
        else
            return (typeid(К).дайХэш(&ключ) & 0x7FFFFFFF) % длина;
    }


    /***********************************************************************

            Разместитель чанков СМ

            Может сохранять около 30% памяти для мелких элементов (проверялось
    		с целочисленными элементами и чанком размером 1000), и как минимум
            дважды быстрее при добавке элементов в сравнении с генерным
            аллокатором (примерно в 50x быстрее со СвязныйСписок).

            Безопасно оперирует с управляемыми сущностями СМ.

    ***********************************************************************/

    struct ЧанкСМ(T)
    {
        static assert (T.sizeof >= (T*).sizeof, "ЧанкСМ аллокатор может использоваться только для данных размером не менее " ~ ((T*).sizeof).stringof[0..$-1] ~ " байт!");

        private struct Кэш
        {
            Кэш* следщ;
        }

        private Кэш*  кэш;
        private T[][]   списки;
        private т_мера  чанки = 256;

        /***************************************************************

                Размещает чанк памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            if (кэш is пусто)
                новый_список;
            auto p = кэш;
            кэш = p.следщ;
            return cast(T*) p;
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером Т*.

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            auto p = (cast(T**) кразмести(счёт, (T*).sizeof)) [0 .. счёт];
            смДобавьПространство (cast(ук) p, счёт * (T*).sizeof);
            return p;
        }

        /***************************************************************

                Вызывается, когда заданный T*[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t.ptr)
            {
                смУдалиПространство (t.ptr);
                освободи (t.ptr);
            }
        }

        /***************************************************************

                Вызывается, когда заданный T сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            assert (p);
            auto d = cast(Кэш*) p;
            //*p = T.init;
            d.следщ = кэш;
            кэш = d;
        }

        /***************************************************************

                Вызывается, когда вызван очисть/сбрось на этом хосте.
                Быстрая очистка всего размещённого в памяти.
				
                Должен вернуть да, если поддерживается, либо нет иначе.
                Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            if (все)
            {
                foreach (ref список; списки)
                {
                    смУдалиПространство (список.ptr);
                    освободи (список.ptr);
                    список = пусто;
                }
                кэш = пусто;
                списки = пусто;
                return да;
            }
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и предварительно заполняет узлами.

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
            this.чанки = чанки;
            if (размести)
                for (цел i=размести/чанки+1; i--;)
                    новый_список;
        }

        /***************************************************************

                Менеджер списка

        ***************************************************************/

        private проц новый_список ()
        {
            списки.length = списки.length + 1;
            auto p = (cast(T*) кразмести (чанки, T.sizeof)) [0 .. чанки];
            списки[$-1] = p;
            смДобавьПространство (p.ptr, T.sizeof * чанки);
            auto голова = кэш;
            foreach (ref узел; p)
            {
                auto d = cast(Кэш*) &узел;
                d.следщ = голова;
                голова = d;
            }
            кэш = голова;
        }
    }


    /***********************************************************************

            Разместитель чанков (не СМ)

            Может сберечь примерно 30% памяти для небольших элементов (протестировано
            с целочисленными элементами и размером чанка 1000), и, как минимум,
            в два раза быстрее при добавке элементов, по сравнению с
            дефолтным разместителем (примерно в 50x быстрее со СвязныйСписок).

            Заметьте, что из-за поведения СМ, не следует конфигурировать
            кастомный разместитель для контейнеров, в которых есть что-либо,
            чем управляет СМ. Например, нельзя использовать MallocAllocator
            для менеджмента контейнера классов или строк, которые были
            размещены СМ. Если чем-либо владеет СМ, то его срок жизни
            должен управляться сущностями под менеджментом СМ
            (иначе СМ может посчитать, что живых ссылок не осталось,
            и досрочно выполнить сборку содержимого контейнера).

            Можно явно управлять коллекцией ключей и значений самому,
            предоставляя делегат-рипер. Например, если используется
            MallocAllocator для управления парой ключ/значение, которые сами
            размещены через malloc,  то следует также
            предоставить и делегат-рипер для их сбора.

            Превичная пользо от этого разместителя в избежании сканирования СМ
            вовлечённых структур данных. Используйте ЧанкСМ, когда эта
            опция не даёт гарантии, либо если у вас управляемые СМ данные.

    ***********************************************************************/

    struct Чанк(T)
    {
        static assert (T.sizeof >= (T*).sizeof, "Чанк аллокатор может использоваться только для данных размером не менее " ~ ((T*).sizeof).stringof[0..$-1] ~ " байт!");

        private struct Кэш
        {
            Кэш* следщ;
        }

        private Кэш*  кэш;
        private T[][]   списки;
        private т_мера  чанки = 256;

        /***************************************************************

                Размещает чанк памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            if (кэш is пусто)
                новый_список;
            auto p = кэш;
            кэш = p.следщ;
            return cast(T*) p;
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером T* .				

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            return (cast(T**) кразмести(счёт, (T*).sizeof)) [0 .. счёт];
        }

        /***************************************************************

                Вызывается, когда заданный T*[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t.ptr)
                освободи (t.ptr);
        }

        /***************************************************************

                Вызывается, когда заданный T сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            assert (p);
            auto d = cast(Кэш*) p;
            d.следщ = кэш;
            кэш = d;
        }

        /***************************************************************

                Вызывается, когда очисть/сбрось вызван на этом хосте.
                Быстрая очистка всего размещённого в памяти.

                Должен вернуть да, если это поддерживается, либо нет иначе.
				Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            if (все)
            {
                foreach (ref список; списки)
                {
                    освободи (список.ptr);
                    список = пусто;
                }
                кэш = пусто;
                списки = пусто;
                return да;
            }
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и prepopulate with узлы

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
            this.чанки = чанки;
            if (размести)
                for (цел i=размести/чанки+1; i--;)
                    новый_список;
        }

        /***************************************************************

                Менеджер списка

        ***************************************************************/

        private проц новый_список ()
        {
            списки.length = списки.length + 1;
            auto p = (cast(T*) кразмести (чанки, T.sizeof)) [0 .. чанки];
            списки[$-1] = p;
            auto голова = кэш;
            foreach (ref узел; p)
            {
                auto d = cast(Кэш*) &узел;
                d.следщ = голова;
                голова = d;
            }
            кэш = голова;
        }
    }


    /***********************************************************************

            Генерный менеджер аллокации памяти СМ

            Медлителен и ресурсоёмок относительно памяти.

    ***********************************************************************/

    struct Сбор(T)
    {
        /***************************************************************

                Размещает чанк памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            return cast(T*) смКразмести (T.sizeof);
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером Т.

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            return new T*[счёт];
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            if (p)
                delete p;
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t)
                delete t;
        }

        /***************************************************************

                Вызывается, когда очисть/сбрось вызван на этом хосте.
                Быстрая очистка всего размещённого в памяти.

                Должен вернуть да, если это поддерживается, либо нет иначе.
                Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и prepopulate with узлы

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
        }
    }


    /***********************************************************************
			Менеджер размещения памяти.

            Заметьте, что из-за поведения СМ, не следует конфигурировать
            кастомный разместитель для контейнеров, в которых есть что-либо,
            чем управляет СМ. Например, нельзя использовать MallocAllocator
            для менеджмента контейнера классов или строк, которые были
            размещены СМ. Если чем-либо владеет СМ, то его срок жизни
            должен управляться сущностями под менеджментом СМ
            (иначе СМ может посчитать, что живых ссылок не осталось,
            и досрочно выполнить сборку содержимого контейнера).

            Можно явно управлять коллекцией ключей и значений самому,
            предоставляя делегат-рипер. Например, если используется
            MallocAllocator для управления парой ключ/значение, которые сами
            размещены через malloc,  то следует также
            предоставить и делегат-рипер для их сбора.

    ***********************************************************************/

    struct Празмест(T)
    {
        /***************************************************************

                Размещает Массив из чанков памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            return cast(T*) кразмести (1, T.sizeof);
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером Т.

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            return (cast(T**) кразмести(счёт, (T*).sizeof)) [0 .. счёт];
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t.length)
                освободи (t.ptr);
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            if (p)
                освободи (p);
        }

        /***************************************************************

                Вызывается, когда очисть/сбрось вызван на этом хосте.
                Быстрая очистка всего размещённого в памяти.

                Должен вернуть да, если это поддерживается, либо нет иначе.
                Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и преднаполняет узлами.

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
        }
    }


    version (prior_allocator)
    {
        /***********************************************************************

                Разместитель СМЧанка.

                Подобно разместителю Чанка, размещает элементы в чанки,
                но допускается размещение элементов, у которых есть СМ-указатели.

                Тесты показали 60% ускорения при использовании СМ чанк
                разместителя для ХэшКарта!(цел, цел).

        ***********************************************************************/

        struct СМЧанк(T, бцел размЧанка)
        {
            static if(T.sizeof < (ук).sizeof)
            {
                static assert(нет, "Ошибка, аллокатор для " ~ T.stringof ~ " не удалось инстанциировать");
            }

            /**
             * Эта форма используется для линковки друг с другом рециклируемых элементов.
             */
            struct элемент
            {
                элемент *следщ;
            }

            /**
             * Чанк элементов.
             */
            struct чанк
            {
                /**
                 * Следующий чанк в цепи.
                 */
                чанк *следщ;

                /**
                 * Предыдущий чанк в этой цепи. Требуется для O(1) удаления
                 * из этой цепи.
                 */
                чанк *предш;

                /**
                 * Линкованный список освобождаемых элементов в этом чанке. Этот список
                 * меняется при каждом освобождении элемента.
                 */
                элемент *списокОсвобождений;

                /**
                 * Число освобождаемых элементов в списокОсвобождений. Используется для
                 * определения, можно ли этот чанк вернуть в СМ.
                 */
                бцел члоОсвобождений;

                /**
                 * Элементы в этом чанке.
                 */
                T[размЧанка] элемы;

                /**
                 * Размесщает T* из списка освобождений.
                 */
                T *разместиИзОсвобСписка()
                {
                    элемент *x = списокОсвобождений;
                    списокОсвобождений = x.следщ;
                    //
                    // очистим указатель, этим элемент очищается, как если бы
                    // его только-что разместили.
                    //
                    x.следщ = пусто;
                    члоОсвобождений--;
                    return cast(T*)x;
                }

                /**
                 * Вымещает T*, посылая его в список освобождений.
                 *
                 * Возвращает да, если этот чанк больше не имеет никаких используемых элементов.
                 */
                бул вымести(T *t)
                {
                    //
                    // Очищает элемент, так что СМ не интерпретирует этот элемент
                    // как на что-либо указывающий.
                    //
                    устбуф(t, 0, (T).sizeof);
                    элемент *x = cast(элемент *)t;
                    x.следщ = списокОсвобождений;
                    списокОсвобождений = x;
                    return (++члоОсвобождений == размЧанка);
                }
            }

            /**
             * Цепочка используемых чанков. Используемые чанки имели хотя бы раз
             * размещение своих элементов.
             */
            чанк *использован;

            /**
             * Свежий чанк. Он только использован, если нет в наличии элементов
             * в использованной цепочке.
             */
            чанк *свежий;

            /**
             * Следующий элемент в свежем чанке. Так как нас не волнует список
             * освобождений в свежем чанке, нужно отслеживать следующий
             * используемый свежий элемент.
             */
            бцел свежийСледщ;

            /**
             * Размещает T*.
             */
            T* размести()
            {
                if(использован !is пусто && использован.члоОсвобождений > 0)
                {
                    //
                    // разместим один элемент из использован список
                    //
                    T* результат = использован.разместиИзОсвобСписка();
                    if(использован.члоОсвобождений == 0)
                        //
                        // переместим использован в конец этого списка
                        //
                        использован = использован.следщ;
                    return результат;
                }

                //
                // Нет использован элементов в наличии, вымещаем свежие
                // элементы
                //
                if(свежий is пусто)
                {
                    свежий = new чанк;
                    свежийСледщ = 0;
                }

                T* результат = &свежий.элемы[свежийСледщ];
                if(++свежийСледщ == размЧанка)
                {
                    if(использован is пусто)
                    {
                        использован = свежий;
                        свежий.следщ = свежий;
                        свежий.предш = свежий;
                    }
                    else
                    {
                        //
                        // вставим свежий преобр в использован цепочку
                        //
                        свежий.предш = использован.предш;
                        свежий.следщ = использован;
                        свежий.предш.следщ = свежий;
                        свежий.следщ.предш = свежий;
                        if(свежий.члоОсвобождений != 0)
                        {
                            //
                            // can recycle элементы из_ свежий
                            //
                            использован = свежий;
                        }
                    }
                    свежий = пусто;
                }
                return результат;
            }

            T*[] размести(бцел счёт)
            {
                return new T*[счёт];
            }


            /**
             * Освобождает из памяти T*
             */
            проц собери(T* t)
            {
                //
                // need в_ figure out which чанк t is in
                //
                чанк *тек = cast(чанк *)смАдрес(t);

                if(тек !is свежий && тек.члоОсвобождений == 0)
                {
                    //
                    // переместим тек во фронт использован списка, it имеется освободи узлы
                    // в_ be использован.
                    //
                    if(тек !is использован)
                    {
                        if(использован.члоОсвобождений != 0)
                        {
                            //
                            // первый, отвяжи тек из_ its текущ location
                            //
                            тек.предш.следщ = тек.следщ;
                            тек.следщ.предш = тек.предш;

                            //
                            // сейчас, вставь тек перед использован.
                            //
                            тек.предш = использован.предш;
                            тек.следщ = использован;
                            использован.предш = тек;
                            тек.предш.следщ = тек;
                        }
                        использован = тек;
                    }
                }

                if(тек.вымести(t))
                {
                    //
                    // тек no longer имеется any элементы in use, it can be deleted.
                    //
                    if(тек.следщ is тек)
                    {
                        //
                        // only one элемент, don't освободи it.
                        //
                    }
                    else
                    {
                        //
                        // удали тек из_ список
                        //
                        if(использован is тек)
                        {
                            //
                            // обнови использован pointer
                            //
                            использован = использован.следщ;
                        }
                        тек.следщ.предш = тек.предш;
                        тек.предш.следщ = тек.следщ;
                        delete тек;
                    }
                }
            }

            проц собери(T*[] t)
            {
                if(t)
                    delete t;
            }

            /**
             * Освобождает из памяти все чанки использованные этим разместителем.
			 * Зависит от СМ создание действительной коллекции.
             */
            бул собери(бул все = да)
            {
                использован = пусто;

                //
                // keep свежий around
                //
                if(свежий !is пусто)
                {
                    свежийСледщ = 0;
                    свежий.списокОсвобождений = пусто;
                }

                return да;
            }

            проц конфиг (т_мера чанки, цел размести=0)
            {
            }
        }

        /***********************************************************************

                Алиасы корректного дефолтного разместителя, зависящие от
                величины типа. Бессмысленно использовать СМЧанк разместитель,
                если тип получится больше страницы.
				Если на страницу помещается не более одного блока,
				тогда используется дефолтный СМ разместитель.

        ***********************************************************************/
        template ДефСбор(T)
        {
            static if((T).sizeof + ((ук).sizeof * 3) + бцел.sizeof >= (РАЗМЕР_СТРАНИЦЫ - 1) / 2)
            {
                alias Сбор!(T) ДефСбор;
            }
            else
            {
                alias СМЧанк!(T, ((РАЗМЕР_СТРАНИЦЫ-1) - ((ук).sizeof * 3) - бцел.sizeof) / (T).sizeof) ДефСбор;
            }
            // TODO: нужно знать, можно ли автоматически вывести, есть ли у типа
            // какой-либо указатель на него, это бы позволило автоматически использовать
            // этот разместитель чанков с дополнительной скоростью.
        }
    }
    else
        template ДефСбор(T)
    {
        alias ЧанкСМ!(T) ДефСбор;
    }

}


