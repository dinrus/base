/*******************************************************************************
        Based upon Doug Lea's Java collection package
*******************************************************************************/

module col.Slink;

private import col.model.IContainer;

/*******************************************************************************

        ССвязка экземпляры provопрe стандарт linked список следщ-fields, и
        support стандарт operations upon them. ССвязка structures are 
        implementation tools, и выполни no аргумент проверьing, no результат
        screening, и no synchronization. They rely on пользователь-уровень classes
        (see ХэшНабор, for example) в_ do such things.

        Still, ССвязка is made `public' so that you can use it в_ build другой
        kinds of containers
        
        Note that when К is specified, support for ключи are включен. When
        Идентичность is снИПulated as 'да', those ключи are compared using an
        опрentity-сравнение instead of equality (using 'is'). Similarly, if
        ХэшКэш is установи да, an добавьitional атрибут is создай in order в_
        retain the хэш of К

*******************************************************************************/

private typedef цел КлючНаобум;

struct ССвязка (З, К=КлючНаобум, бул Идентичность = нет, бул ХэшКэш = нет)
{
        alias ССвязка!(З, К, Идентичность, ХэшКэш) Тип;
        alias Тип                              *Реф;
        alias Сравни!(З)                       Сравнитель;

        Реф             следщ;           // pointer в_ следщ
        З               значение;          // элемент значение

        static if (ХэшКэш == да)
        {
        т_хэш       кэш;             // retain хэш значение?
        }
                
        /***********************************************************************

                добавь support for ключи also?
                
        ***********************************************************************/

        static if (!is(typeof(К) == КлючНаобум))
        {
                К ключ;

                final Реф установи (К ключ, З знач, Реф n)
                {
                        ключ = ключ;
                        return установи (знач, n);
                }

                final цел хэш()
                {
                        return typeid(К).дайХэш(&ключ);
                }

                final Реф найдиКлюч (К ключ)
                {
                        static if (Идентичность == да)
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ is p.ключ)
                                    return p;
                        }
                        else
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ == p.ключ)
                                    return p;
                        }
                        return пусто;
                }

                final Реф найдиПару (К ключ, З значение)
                {
                        static if (Идентичность == да)
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ is p.ключ && значение == p.значение)
                                    return p;
                        }
                        else
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ == p.ключ && значение == p.значение)
                                    return p;
                        }
                        return пусто;
                }

                final цел индексируйКлюч (К ключ)
                {
                        цел i = 0;
                        static if (Идентичность == да)
                        {
                           for (auto p=this; p; p = p.следщ, ++i)
                                if (ключ is p.ключ)
                                    return i;
                        }
                        else
                        {
                           for (auto p=this; p; p = p.следщ, ++i)
                                if (ключ == p.ключ)
                                    return i;
                        }
                        return -1;
                }

                final цел индексируйПару (К ключ, З значение)
                {
                        цел i = 0;
                        static if (Идентичность == да)
                        {
                           for (auto p=this; p; p = p.следщ, ++i)
                                if (ключ is p.ключ && значение == p.значение)
                                    return i;
                        }
                        else
                        {
                           for (auto p=this; p; p = p.следщ, ++i)
                                if (ключ == p.ключ && значение == p.значение)
                                    return i;
                        }
                        return -1;
                }

                final цел учтиКлюч (К ключ)
                {
                        цел c = 0;
                        static if (Идентичность == да)
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ is p.ключ)
                                    ++c;
                        }
                        else
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ == p.ключ)
                                    ++c;
                        }
                        return c;
                }

                final цел учтиПару (К ключ, З значение)
                {
                        цел c = 0;
                        static if (Идентичность == да)
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ is p.ключ && значение == p.значение)
                                    ++c;
                        }
                        else
                        {
                           for (auto p=this; p; p = p.следщ)
                                if (ключ == p.ключ && значение == p.значение)
                                    ++c;
                        }
                        return c;
                }
        }
        
        /***********************************************************************

                 Набор в_ точка в_ n as следщ ячейка

                 param: n, the new следщ ячейка
                        
        ***********************************************************************/

        final Реф установи (З знач, Реф n)
        {
                следщ = n;
                значение = знач;
                return this;
        }

        /***********************************************************************

                 Splice in p between текущ ячейка и whatever it was
                 previously pointing в_

                 param: p, the ячейка в_ splice
                        
        ***********************************************************************/

        final проц прикрепи (Реф p)
        {
                if (p)
                    p.следщ = следщ;
                следщ = p;
        }

        /***********************************************************************

                Cause текущ ячейка в_ пропусти over the текущ следщ() one, 
                effectively removing the следщ элемент из_ the список
                        
        ***********************************************************************/

        final проц отторочьСледщ()
        {
                if (следщ)
                    следщ = следщ.следщ;
        }

        /***********************************************************************

                 Linear ищи down the список looking for элемент
                 
                 param: элемент в_ look for
                 Возвращает: the ячейка containing элемент, or пусто if no such
                 
        ***********************************************************************/

        final Реф найди (З элемент)
        {
                for (auto p = this; p; p = p.следщ)
                     if (элемент == p.значение)
                         return p;
                return пусто;
        }

        /***********************************************************************

                Return the число of cells traversed в_ найди первый occurrence
                of a ячейка with элемент() элемент, or -1 if not present
                        
        ***********************************************************************/

        final цел индекс (З элемент)
        {
                цел i;
                for (auto p = this; p; p = p.следщ, ++i)
                     if (элемент == p.значение)
                         return i;

                return -1;
        }

        /***********************************************************************

                Счёт the число of occurrences of элемент in список
                        
        ***********************************************************************/

        final цел счёт (З элемент)
        {
                цел c;
                for (auto p = this; p; p = p.следщ)
                     if (элемент == p.значение)
                         ++c;
                return c;
        }

        /***********************************************************************

                 Return the число of cells in the список
                        
        ***********************************************************************/

        final цел счёт ()
        {
                цел c;
                for (auto p = this; p; p = p.следщ)
                     ++c;
                return c;
        }

        /***********************************************************************

                Return the ячейка representing the последний элемент of the список
                (i.e., the one whose следщ() is пусто
                        
        ***********************************************************************/

        final Реф хвост ()
        {
                auto p = this;
                while (p.следщ)
                       p = p.следщ;
                return p;
        }

        /***********************************************************************

                Return the н_ый ячейка of the список, or пусто if no such
                        
        ***********************************************************************/

        final Реф н_ый (цел n)
        {
                auto p = this;
                for (цел i; i < n; ++i)
                     p = p.следщ;
                return p;
        }

        /***********************************************************************

                Make a копируй of the список; i.e., a new список containing new cells
                but включая the same элементы in the same order
                        
        ***********************************************************************/

        final Реф копируй (Реф delegate() размести)
        {
                auto новый_список = dup (размести);
                auto текущ = новый_список;

                for (auto p = следщ; p; p = p.следщ)
                    {
                    текущ.следщ = p.dup (размести);
                    текущ = текущ.следщ;
                    }
                текущ.следщ = пусто;
                return новый_список;
        }

        /***********************************************************************

                dup is shallow; i.e., just makes a копируй of the текущ ячейка
                        
        ***********************************************************************/

        private Реф dup (Реф delegate() размести)
        {
                auto возвр = размести();
                static if (is(typeof(К) == КлючНаобум))
                           возвр.установи (значение, следщ);
                       else
                          возвр.установи (ключ, значение, следщ);
                return возвр;
        }

        /***********************************************************************

                Basic linkedlist совмести algorithm.
                Merges the списки голова by перв и втор with respect в_ cmp
         
                param: перв голова of the первый список
                param: втор голова of the секунда список
                param: cmp a Сравнитель использован в_ сравни элементы
                Возвращает: the merged ordered список
                        
        ***********************************************************************/

        static Реф совмести (Реф перв, Реф втор, Сравнитель cmp) //merge
        {
                auto a = перв;
                auto b = втор;
                Реф hd = пусто;
                Реф текущ = пусто;

                for (;;)
                    {
                    if (a is пусто)
                       {
                       if (hd is пусто)
                           hd = b;
                       else
                          текущ.следщ = b;
                       return hd;
                       }
                    else
                       if (b is пусто)
                          {
                          if (hd is пусто)
                              hd = a;
                          else
                             текущ.следщ = a;
                          return hd;
                          }

                    цел рознь = cmp (a.значение, b.значение);
                    if (рознь <= 0)
                       {
                       if (hd is пусто)
                           hd = a;
                       else
                          текущ.следщ = a;
                       текущ = a;
                       a = a.следщ;
                       }
                    else
                       {
                       if (hd is пусто)
                           hd = b;
                       else
                          текущ.следщ = b;
                       текущ = b;
                       b = b.следщ;
                       }
                    }
        }

        /***********************************************************************

                Standard список splitter, использован by сортируй.
                Splits the список in half. Возвращает the голова of the секунда half

                param: s the голова of the список
                Возвращает: the голова of the секунда half

        ***********************************************************************/

        static Реф разбей (Реф s)
        {
                auto быстро = s;
                auto медленно = s;

                if (быстро is пусто || быстро.следщ is пусто)
                    return пусто;

                while (быстро)
                      {
                      быстро = быстро.следщ;
                      if (быстро && быстро.следщ)
                         {
                         быстро = быстро.следщ;
                         медленно = медленно.следщ;
                         }
                      }

                auto r = медленно.следщ;
                медленно.следщ = пусто;
                return r;

        }

        /***********************************************************************

                 Standard совмести сортируй algorithm
                 
                 param: s the список в_ сортируй
                 param: cmp, the сравнитель в_ use for ordering
                 Возвращает: the голова of the sorted список
                        
        ***********************************************************************/

        static Реф сортируй (Реф s, Сравнитель cmp)
        {
                if (s is пусто || s.следщ is пусто)
                    return s;
                else
                   {
                   auto право = разбей (s);
                   auto лево = s;
                   лево = сортируй (лево, cmp);
                   право = сортируй (право, cmp);
                   return совмести (лево, право, cmp);
                   }
        }

}

