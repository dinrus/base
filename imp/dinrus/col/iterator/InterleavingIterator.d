module col.iterator.InterleavingIterator;

private import  exception;
private import  col.model.IteratorX;

/**
 *
 * Перемежающиеся итераторы позволяют комбинировать элементы
 * двух разных перечислений, как если бы они были в одном перечне,
 * перед тем как попадут к своим `потребителям'.
 * Иногда это позволяет избегать использования объекта Коллекция,
 * чтобы временно скомбинировать два набора элементы() коллекции,
 * которые нужно собрать вместе для общей обработки.
 * <P>
 * Эти элементы обнаруживаются (с помощью получи()) чисто
 * перемежающимся образом, чередуясь между первой и второй эннумерацией,
 * пока одна из них не истощится, в случае чего все остальные
 * элементы другой коллекции ипользуются, пока она тоже не закончится.
 * <P>
 * Перемежающиеся обходчики - это обёртки вокруг других обходчиков.
 * Чтобы построить такой, нужно два уже существующих итератора.
 * Например, если нужно обработать вместе все элементы двух
 * коллекций a и b, можно написать что-то в форме:
 * <PRE>
 * Обходчик элты = ПеремежающийОбходчик(a.элементы(), b.элементы());
 * while (элты.ещё())
 *  делаем_чтото_с(элты.получи());
 * </PRE>
 *
 */


public class ПеремежающийОбходчик(T) : Обходчик!(T)
{

    /**
     * Первый исток; обнуляется когда исчерпан.
    **/

    private Обходчик!(T) перв_;

    /**
     * Второй исток; обнуляется когда исчерпан.
    **/

    private Обходчик!(T) втор_;

    /**
     * Исток, используемый сейчас.
    **/

    private Обходчик!(T) текущ_;



    /**
     * Создаёт перечисление из смеси элементов первой и второй.
    **/

    public this (Обходчик!(T) перв, Обходчик!(T) втор)
    {
        перв_ = перв;
        втор_ = втор;
        текущ_ = втор_; // флип will сбрось в_ перв (if it can)
        флип();
    }

    /**
     * Реализует col.model.IteratorX.ещё
    **/
    public final бул ещё()
    {
        return текущ_ !is пусто;
    }

    /**
     * Реализует col.model.IteratorX.получи.
    **/
    public final T получи()
    {
        if (текущ_ is пусто)
            throw new НетЭлементаИскл("обходчик завершён");
        else
        {
            // following строка may also throw ex, but there's nothing
            // reasonable в_ do except распространить
            auto результат = текущ_.получи();
            флип();
            return результат;
        }
    }


    цел opApply (цел delegate (inout T значение) дг)
    {
        цел результат;

        while (текущ_)
        {
            auto значение = получи();
            if ((результат = дг(значение)) != 0)
                break;
        }
        return результат;
    }

    /**
     * Поменять источники.
    **/

    private final проц флип()
    {
        if (текущ_ is перв_)
        {
            if (втор_ !is пусто && !втор_.ещё())
                втор_ = пусто;
            if (втор_ !is пусто)
                текущ_ = втор_;
            else
            {
                if (перв_ !is пусто && !перв_.ещё())
                    перв_ = пусто;
                текущ_ = перв_;
            }
        }
        else
        {
            if (перв_ !is пусто && !перв_.ещё())
                перв_ = пусто;
            if (перв_ !is пусто)
                текущ_ = перв_;
            else
            {
                if (втор_ !is пусто && !втор_.ещё())
                    втор_ = пусто;
                текущ_ = втор_;
            }
        }
    }


}

