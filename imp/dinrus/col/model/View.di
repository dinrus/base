module col.model.View;

private import col.model.Dispenser;
private import col.model.GuardIterator;


/**
 * Это базовый интерфейс к большинству классов из этого пакета.
**/
public interface Обзор(T) 
{
        /**
         * Все Обзоры реализуют дубликат.
        **/

        public Обзор!(T) дубликат ();
        public alias дубликат dup;

        /**
         * Репортирует о том, содержит ли этот обзор элемент.
         * По поведению равнозначно <CODE>экземпляры(элемент) &gt;= 0</CODE>.
         * @param элемент искомый элемент
         * Возвращает: да, если содержится как минимум один чден, равный элементу.
        **/
        public бул содержит (T элемент);
        public alias содержит opIn;

        /**
         * Репортирует число элементов в этом Обзоре.
         * Никаких иных эффектов.
         * Возвращает: число элементов
        **/
        public бцел размер ();
        public alias размер length;

        /**
         * Репортирует о том, что в этом Обзоре нет элементов.
         * По поведению равнозначно <CODE>размер() == 0</CODE>.
         * Возвращает: да, если размер() == 0
        **/

        public бул опустошён ();


        /**
         * Все коллекции поддерживают `номер версии'. Схема нумерации
         * произвольная, но гарантированно меняется при каждой модификации,
         * которая может с вероятностью повлиять на обход элементы() перечисления.
         * (Она верна, как минимум,в пределах точности представления `цел';
         * выполнение более 2^32 операций ведёт к повторному использованию номеров
		 * версии).
         * Версификация
         * <EM>может</EM> быть консервативной, благодаря операциям `замена'.
         * Ради версификации замены (перемещения) могут пониматься как
         * удаления, за которыми следует добавление. Так, номера версии могут меняться, 
         * даже если старые и новые элементы идентичны.
         * <P>
         * Перечисления всех элемент()  для мутабельных коллекций отслеживает номера
         * версии, и вызывают исключения неконсистентности перечисления, когда
         * использована (через получи()) иная версия, чем та, что сгенерирована
         * методом элементы().
         * <P>
         * Версии можно использовать для проверки того, повлияли ли операции
		 * обновления на самом деле на состояние наблюдаемого.
         * Например, очисть() вызывает изменение версии только тогда,
         * если коллекция заранее не пустая.
         * Возвращает: номер версии
        **/

        public бцел изменение ();
        
        /**
         * Репортирует, мог бы  этот Обзор  содержать элемент,
         * т.е., что он действителен, благодаря наличию
         * скринера элементов Обзора.
         * Всегда возвращает нет, если элемент == пусто.
         * Константная функция: если позволяет(знач) всегда да, и у него всегда да.
         * (Данное свойство ни коим образом не принудительное.)
         * Отсутствуют иные спуриозные эффекты.
         * Возвращает: да, если не-пусто
        **/
        public бул позволяет (T элемент);


        /**
         * Репортирует число случаев элемента в Обзоре.
         * Всегда возвращает 0, если элемент == пусто.
         * В ином случае используется T.равно для тестирования на равенство.
         * @param элемент искомый элемент
         * Возвращает: число случаев (всегда неотрицательное)
        **/
        public бцел экземпляры (T элемент);

        /**
         * Возвращает перечисление, которое может быть использовано для обхода
         * по элементам в этом Обзоре. Сьандартное применение, для некоторого
         * ОбзорТ c, и некой операции `используй(T об)':
         * <PRE>
         * for (Обходчик e = c.элементы(); e.ещё(); )
         *   используй(e.значение());
         * </PRE>
         * (Получаемое значения зачастую приходится
         * согласовывать с известными типами.)
         * <P>
         * Все Обзоры возвращают экземпляры
         * ViewIterator, способные репортировать число оставшихся
         * элементов, а также выполнять проверку консистентности,
         * так, что для MutableViews, перечисления элементов могут становиться 
         * инвалидированными, если этот Обзор изменён при таком обходе
         * (что в свою очередь может вызывать случайные эффекты у этого ОбзорТ.
         * Для предотвращения этого,  ViewIterators 
         * вызывают ИсклПовреждённыйОбходчик при попытках доступа и
         * получения из изменённых Обзоров.)
         * Примечание: Поскольку все реализации Обзор синхронизуемые,
         * можно обеспечить гарантию того, что элементы обхода не будут
         * повреждены, путём применения конструкта D <CODE>synchronized</CODE>
         * вокпуг блоков кода, выполняющих обходы. (Используйте с предосторожностью,
         * так как такие конструкты могут вызывать мёртвые блокировки.)
         * <P>
         * Гарантии о природе элементов, возвращаемых методом  получи этого
         * Обходчика, могут быть разными по подинтерфейсам.
         * Во всех случаях, перечисления, предоставляемые методом элементы(), гарантированно
         * делают шаг (посредством метода "получи") через все элементы в этом Обзоре.
         * Если не гарантируется иное (например, в Секе), то перечисления элементы()
         * не нуждаются в наличии отдельного получи() для упорядочивания,так как
         * у них допускается обход всех элементов. Так, например, два последовательных
         * вызова элемент() может производить перечисления с одинаковыми
         * элементами,но разным упорядочиванием получи().
         * Опять же, подинтерфесы могут предоставлять более страныые гарантии. В
         * частности, Секи производят перечисления с получениями в
         * индексном порядке, перечисления ElementSortedViews - в возрастающем 
         * отсортированном порядке, а KeySortedViews - в возрастающем порядке ключей.
         * Возвращает: перечисление e, так чтобы
         * <PRE>
         *   e.остаток() == размер() &&
         *   foreach (знач in e) имеется(e) 
         * </PRE>
        **/

        public СтражОбходчик!(T) элементы ();

        /**
         Обходит контент коллекции. Это эффективней, чем применение
         обходчика, так как нет создания нового класса.
        **/

        public цел opApply (цел delegate (inout T значение) дг);

        /**
         Выставляет контент коллекции в виде массива.
        **/

        public T[] вМассив ();

        /**
         * Репортирует о том, такие же ли (одинаковы ли) элементы
         * в другой коллекции, как в этой.
         * То есть, другой является ли такого же размера, и имеет ли такие же 
         * свойства элементы()?
         * Это полезная функция тестирования на равенство. Но она не названа
         * `равно', так как не всегда работает с одинаковой версией.
         * <P>
         * Простейший способ описать эту операцию - просто объяснить, 
         * как она интерпретируется в стандартных подинтерфейсах:
         * <UL>
         *  <LI> Сек и ElementSortedView: другой.элементы() имеет такой 
         *        же порядок, как this.элементы().
         *  <LI> Рюкзак: другой.элементы имеет такие же экземпляры каждого элемента, как this.
         *  <LI> Набор: другой.элементы имеет все элементы этого.
         *  <LI> Карта: другой имеет все (ключ, элемент) пары этого.
         *  <LI> KeySortedView: другой имеет все (ключ, элемент)
         *       пары, как этот, и ключи перечисляются в том же порядке,как
         *       this.ключи().
         *</UL>
         * @param другой  Обзор
         * Возвращает: да, если полагается, что размер и элементы одинаковы.
        **/

        public бул совпадает (Обзор другой);
        public alias совпадает opEquals;


        /**
         * Проверяет консистентность внутреннего состояния и вызывает исключение,
         * если что-то не в порядке.
         * Это должны быть наиболее эффективные проверки. Невозможно всегда локально
         * определить полную консистентность, но всегда можно к этому стремиться,
         * и оценивать наиболее важные инварианты представления.
         * Наиболее общие виды проверок - это проверки кэша. Например,
         * линкованный список, который также поддерживает отдельную запись
         * числа элементов в списке, должен проверяться на совпадение
         * записанного счёта и числа элементов в этом списке.
         * <P>
         * Этот метод должен либо давать нормальный возврат, либо:
         * Выводит исключение: ImplementationError, нсли проверка не удалась.
        **/

        public проц проверьРеализацию();
}

