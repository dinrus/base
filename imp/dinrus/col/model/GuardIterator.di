module col.model.GuardIterator;

private import col.model.IteratorX;

/**
 *
 * CollectionIterator расширяет стандартный интерфейс
 * col.model.IteratorX даумя дополнительными методами.
 * 
**/

public interface СтражОбходчик(З) : Обходчик!(З)
{
        /**
         * Возвращает да, если построившая это перечисление коллекция
         * была заметно изменена со вреени его построения.
         * Способность и точность детекции этого условия может
         * различаться между реализациями класса этой коллекции.
         * ещё() is нет, а, если повреждён, is да.
         *
         * Возвращает: да, если заметно повреждён.
        **/

        public бул повреждён();

        /**
         * Возвращает число элементов в перечислении, которые пока не
         * обходились. Когда повреждён() is да, это число может 
         * (или не может) быть больше нуля, даже если ещё() 
         * is нет. Механизмы восстановления после исключений могут
         * использовать это как указание на то, что некоторого сорта
         * восстановление гарантировано.
         * <P>
         * Может также использоваться для упаковки перечислений в массивы.
		 * Например:
         * <PRE>
         * Объект масс[] = new Объект[e.члоОставшихсяЭлтов()]
         * цел i = 0;
         * while (e.ещё()) масс[i++] = e.значение();
         * </PRE>
         * <P>
         * Для противного случая 
         * См_Также: col.iterator.ArrayIterator.ОбходчикМассива
         * Возвращает: число непройденных элементов
        **/

        public бцел остаток();
}


public interface ОбходчикПар(К, З) : СтражОбходчик!(З)
{
        alias СтражОбходчик!(З).получи     получи;
        alias СтражОбходчик!(З).opApply opApply;
        
        public З получи (inout К ключ);

        цел opApply (цел delegate (inout К ключ, inout З значение) дг);        
}

