module col.TreeMultiset;

public import col.model.Multiset;
public import col.Functions;

private import col.RBTree;

/+ ИНТЕРФЕЙС:

class ДеревоМультинабор(З, alias ШаблРеализац = КЧДеревоДуб, alias функцСравнения=ДефСравнить) : Мультинабор!(З)
{

    alias ШаблРеализац!(З, функцСравнения) Реализ;

    struct курсор
    {
        З значение();
        курсор opPostInc();
        курсор opPostDec();
        курсор opAddAssign(цел прир);
        курсор opSubAssign(цел прир);
        бул opEquals(курсор обх);
    }

    final цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг);
    цел opApply(цел delegate(ref З з) дг);
    this();
    private this(ref Реализ дубИз);
    ДеревоМультинабор зачисть();
    бцел длина();
	alias длина length;

    курсор начало();
    курсор конец();
    курсор удали(курсор обх);
    курсор найди(З з);
    бул содержит(З з);
    ДеревоМультинабор удали(З з);
    ДеревоМультинабор удали(З з, ref бул былУдалён);
    ДеревоМультинабор добавь(З з);
    ДеревоМультинабор добавь(З з, ref бул былДобавлен);
    ДеревоМультинабор добавь(Обходчик!(З) обх);
    ДеревоМультинабор добавь(Обходчик!(З) обх, ref бцел члоДобавленных);
    ДеревоМультинабор добавь(З[] массив);
    ДеревоМультинабор добавь(З[] массив, ref бцел члоДобавленных);
    бцел счёт(З з);
    ДеревоМультинабор удалиВсе(З з);
    ДеревоМультинабор удалиВсе(З з, ref бцел члоУдалённых);
    ДеревоМультинабор dup();
    З дай();
    З изыми();
}

+/

/**
 * Реализация интерфейса Мультинабор с использованием Красно-Чёрных деревьев. 
 * Позволяет делать за время O(lg(n)) вставки, удаления и поиск. Также создаёт
 * отсортированный набор элементов.  З должно быть совместимо.
 *
 * Добавление элемента не повреждает никаких курсоров.
 *
 * Удаление элемента повреждает только те курсоры, которые указывали на
 * этот элемент.
 *
 * Можно заменить реализацию Дерево любой кастомной реализацией, эта
 * реализация должна быть шаблоном структуры, экземпляр которого создаётся
 * единственный шаблонным аргументом З, и должен реализовывать следующие члены
 * (члены-нефункции могут быть свойствами, если не указано иное):
 *
 * параметры -> должно быть структурой, как минимум со следующими членами:
 *   функцСравнения -> используемая функция сравнения (должна быть
 *                      ФункцСравнения!(З))
 * 
 * проц установка(параметры p) -> инициализует это дерево с заданными параметрами.
 *
 * бцел счёт -> счёт элементов в этом дереве
 *
 * Узел -> должно быть struct/class со следующими членами:
 *   З значение -> значение, на которое указывает эта позиция (не может быть
 *                свойством)
 *   Узел следщ -> следующий Узел в этом дереве, как определено функцией сравнения,
 *                либо конец, если нет иных узлов.
 *   Узел предш -> предыдущий Узел в этом дереве, как определено функцией сравнения.
 *
 * бул добавь(З з) -> добавляет заданное значение в это дерево, согласно порядку,
 * определённому функцией сравнения. Если элемент уже существует в дереве,
 * эта функция должна добавлять обх после всех эквивалентных элементов.
 *
 * Узел начало -> должно быть Узлом, который указывает на самый первый валидный
 * элемент в этом дереве, либо концом, если элементов больше нет.
 *
 * Узел конец -> должно быть Узлом, указывающим сразу после самого последнего
 * валидного элемента.
 *
 * Узел найди(З з) -> возвращает Узел, указывающий на первый элемент в этом
 * дереве, который содержит з, либо конец, если этого элемента нет.
 *
 * Узел удали(Узел p) -> удаляет данный элемент из этого дерева,
 * возвращает следующий валидный элемент или конец, если p был последним в этом дереве.
 *
 * проц зачисть() -> удаляет все элементы из этого дерева, устанавливает счёт в 0.
 *
 * бцел считайВсе(З з) -> возвращает число элементов с заданным значением.
 *
 * Узел удалиВсе(З з) -> удаляет все заданные значения из этого дерева.
 */
class ДеревоМультинабор(З, alias ШаблРеализац = КЧДеревоДуб, alias функцСравнения=ДефСравнить) : Мультинабор!(З)
{
    /**
     * Удобный алиас
     */
    alias ШаблРеализац!(З, функцСравнения) Реализ;

    private Реализ _дерево;

    /**
     * Курсор для дерева-мультинабора.
     */
    struct курсор
    {
        private Реализ.Узел укз; alias укз ptr;

        /**
         * Даёт значение этого элемента.
         */
        З значение()
        {
            return укз.значение;
        }

        /**
         * Инкрементирует этот курсор, возвращает курсок, который был перед
         * инкрементацией.
         */
        курсор opPostInc()
        {
            курсор врм = *this;
            укз = укз.следщ;
            return врм;
        }

        /**
         * Декрементирует этот курсор, возвращает курсор, который был перед
         * декрементацией.
         */
        курсор opPostDec()
        {
            курсор врм = *this;
            укз = укз.предш;
            return врм;
        }

        /**
		 * Инкрементирует курсор на заданное количество.
         *
         * Это операция O(прир)! Этот оператор используется только
         * в форме:
         *
         *
         * ++i;
         */
        курсор opAddAssign(цел прир)
        {
            if(прир < 0)
                return opSubAssign(-прир);
            while(прир--)
                укз = укз.следщ;
            return *this;
        }

        /**
         * Декрементирует курсор на заданное количество.
         *
         * Это операция O(прир)! Этот оператор используется только
         * в форме:
         *
         * --i;
         */
        курсор opSubAssign(цел прир)
        {
            if(прир < 0)
                return opAddAssign(-прир);
            while(прир--)
                укз = укз.предш;
            return *this;
        }

        /**
         * Сравнивает два курсора на равенство.
         */
        бул opEquals(курсор обх)
        {
            return обх.ptr is укз;
        }
    }

    /**
     * Итерирует по элементам этой коллекции, определяет, какие из них
     * следует удалить.
     *
     * Пример использования:
     * -------------
     * // Удаляет все нечётные элементы.
     * foreach(ref чистить_ли, з; &treeMultiset.очистить)
     * {
     *   чистить_ли = ((з % 1) == 1);
     * }
     * -------------
     */
    final цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг)
    {
        return _примени(дг);
    }

    private цел _примени(цел delegate(ref бул чистить_ли, ref З з) дг)
    {
        курсор обх = начало;
        бул чистить_ли;
        цел возврдг = 0;
        курсор _конец = конец; // cache конец so обх isn'т всегда being generated
        while(!возврдг && обх != _конец)
        {
            //
            // don'т allow user to change значение
            //
            З врмзначение = обх.значение;
            чистить_ли = false;
            if((возврдг = дг(чистить_ли, врмзначение)) != 0)
                break;
            if(чистить_ли)
                обх = удали(обх);
            else
                обх++;
        }
        return возврдг;
    }

    /**
     * Итерирует по значениям этой коллекции.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел _дг(ref бул чистить_ли, ref З з)
        {
            return дг(з);
        }
        return _примени(&_дг);
    }

    /**
     * Создаёт экземпляр этого дерева-мультинабора.
     */
    this()
    {
        _дерево.установка();
    }

    //
    // для dup
    //
    private this(ref Реализ дубИз)
    {
        дубИз.копируйВ(_дерево);
    }

    /**
     * Очищает коллекцию от всех элементов.
     */
    ДеревоМультинабор зачисть()
    {
        _дерево.зачисть();
        return this;
    }

    /**
     * Возвращает число элементов в этой коллекции.
     */
    бцел длина()
    {
        return _дерево.счёт;
    }
	alias длина length;

    /**
     * Возвращает курсор на первый элемент в этой коллекции.
     */
    курсор начало()
    {
        курсор обх;
        обх.ptr = _дерево.начало;
        return обх;
    }

    /**
     * Возвращает курсор, указывающий сразу после последнего элементв в
     * этой коллекции.
     */
    курсор конец()
    {
        курсор обх;
        обх.ptr = _дерево.конец;
        return обх;
    }

    /**
     * Удаляет элемент, на который указывает данный курсор, возвращая
     * курсор, указывающий на следующий элемент в этой коллекции.
     *
     * Выполняется за время O(lg(n)).
     */
    курсор удали(курсор обх)
    {
        обх.ptr = _дерево.удали(обх.ptr);
        return обх;
    }

    /**
     * Находит первый экземпляр данного значения в этой коллекции. Возвращает
     * конец, если это значение отсутствует.
     *
     * Выполняется за время O(lg(n)).
     */
    курсор найди(З з)
    {
        курсор обх;
        обх.ptr = _дерево.найди(з);
        return обх;
    }

    /**
     * Возвращает да, если данное значение существует в коллекции.
     *
     * Выполняется за время O(lg(n)).
     */
    бул содержит(З з)
    {
        return найди(з) != конец;
    }

    /**
     * Удаляет первый элемент со значением з. Врзвращает да, если
     * это значение имелось и было удалено.
     *
     * Выполняется за время O(lg(n)).
     */
    ДеревоМультинабор удали(З з)
    {
        курсор обх = найди(з);
        if(обх != конец)
            удали(обх);
        return this;
    }

    /**
     * Удаляет первый элемент со значением з. Возвращает да, если
     * это значение имелось и было удалено.
     *
     * Выполняется за время O(lg(n)).
     */
    ДеревоМультинабор удали(З з, ref бул былУдалён)
    {
        курсор обх = найди(з);
        if(обх == конец)
        {
            былУдалён = false;
        }
        else
        {
            удали(обх);
            былУдалён = true;
        }
        return this;
    }

    /**
     * Добавляет значение в эту коллекцию.
     * Возвращает this.
     *
     * Выполняется за время O(lg(n)).
     */
    ДеревоМультинабор добавь(З з)
    {
        _дерево.добавь(з);
        return this;
    }

    /**
     * Добавляет значение в эту коллекцию. Устанавливает былДобавлен в да, если значение
     * добавленно.
     *
     * Возвращаетs this.
     *
     * Выполняется за время O(lg(n)).
     */
    ДеревоМультинабор добавь(З з, ref бул былДобавлен)
    {
        былДобавлен = _дерево.добавь(з);
        return this;
    }

    /**
     * Adds all the values from the iterator to the collection.
     *
     * Runs in O(m lg(n)) time, where m is the number of elements in
     * the iterator.
     */
    ДеревоМультинабор добавь(Обходчик!(З) обх)
    {
        foreach(з; обх)
            _дерево.добавь(з);
        return this;
    }

    /**
     * Adds all the values from the iterator to the collection. Sets члоДобавленных
     * to the number of values добавленный from the iterator.
     *
     * Runs in O(m lg(n)) time, where m is the number of elements in
     * the iterator.
     */
    ДеревоМультинабор добавь(Обходчик!(З) обх, ref бцел члоДобавленных)
    {
        бцел исхдлина = длина;
        добавь(обх);
        члоДобавленных = длина - исхдлина;
        return this;
    }

    /**
     * Добавляет все значения из массива в коллекцию.
     *
     * Выполняется за время O(m lg(n)), где m - число элементов в
     * массиве.
     */
    ДеревоМультинабор добавь(З[] массив)
    {
        foreach(з; массив)
            _дерево.добавь(з);
        return this;
    }

    /**
     * Добавляет все значения из массива в коллекцию. Устанавливает члоДобавленных в
     * число добавленных из массива элементов.
     *
     * Выполняется за время O(m lg(n)), где m - число элементов в
     * массиве.
     */
    ДеревоМультинабор добавь(З[] массив, ref бцел члоДобавленных)
    {
        бцел исхдлина = длина;
        добавь(массив);
        члоДобавленных = длина - исхдлина;
        return this;
    }

    /**
     * Возвращает число элеметнов в этой коллекции, равное з.
     *
     * Выполняется за время O(m lg(n)), где m - число элементов, равное з.
     */
    бцел счёт(З з)
    {
        return _дерево.считайВсе(з);
    }

    /**
     * Удаляет все элементы, равные з.
     *
     * Выполняется за время O(m lg(n)), где m i- число элементов в з.
     */
    ДеревоМультинабор удалиВсе(З з)
    {
        _дерево.удалиВсе(з);
        return this;
    }
    
    /**
     * Удаляет все элементы, равные з.  Устанавливает члоУдалённых в
     * число элементов, удалённых из этого мультинабора.
     *
     * Выполняется за время O(m lg(n)), где m - число элементов в з.
     */
    ДеревоМультинабор удалиВсе(З з, ref бцел члоУдалённых)
    {
        члоУдалённых = _дерево.удалиВсе(з);
        return this;
    }

    /**
     * Делает дубликат этого дерева-мультинабора.
     */
    ДеревоМультинабор dup()
    {
        return new ДеревоМультинабор(_дерево);
    }

    /**
     * Выдаёт наиболее удобный элемент в этом наборе. Это элемент, который
     * итерировался бы первым. Следовательно, вызов удали(дай())
     * гарантировано меньше операции O(n).
     */
    З дай()
    {
        return начало.значение;
    }

    /**
     * Удаляет наиболее подходящий  элемент из набора, и возвращает его значение.
     * Это равноценно удали(дай()), за исключением того, что выполняется
     * только один поиск.
     */
    З изыми()
    {
        auto c = начало;
        auto возврзнач = c.значение;
        удали(c);
        return возврзнач;
    }
}

version(UnitTest)
{
    unittest
    {
        auto tms = new ДеревоМультинабор!(бцел);
        Мультинабор!(бцел) ms = tms;
        ms.добавь([0U, 1, 2, 3, 4, 5, 5]);
        assert(ms.length == 7);
        assert(ms.счёт(5U) == 2);
        foreach(ref чистить_ли, i; &ms.очистить)
            чистить_ли = (i % 2 == 1);
        assert(ms.счёт(5U) == 0);
        assert(ms.length == 3);
    }
}
