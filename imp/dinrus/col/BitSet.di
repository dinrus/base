module col.BitSet;

private import std.intrinsic;

/******************************************************************************

        Фиксированный или динамический набор битов. Он не делает собственной
        аллокации памяти, когда Размер != 0, и делает аллокацию в куче, когда
        Размер равен нулю. Таким образом, можно получить фиксированного размера
        low-overhead экземпляр, или куча-оиентированнный экземпляр. Последний
        поддерживает изменение размера, а первый нет.

        Note that leveraging intrinsics is slower when using dmd ...

******************************************************************************/

struct НаборБит (цел Счёт=0)
{
    public alias и        opAnd;
    public alias или         opOrAssign;
    public alias иили        opXorAssign;
    private const           ширина = т_мера.sizeof * 8;

    static if (Счёт == 0)
        private т_мера[] биты;
    else
        private т_мера [(Счёт+ширина-1)/ширина] биты;

    /**********************************************************************

            Установить индексированный бит, меняя при необходимости размер
	        для основанных на куче экземпляров
             (IndexOutOfBounds для статически-размеренных экземпляров)

    **********************************************************************/

    проц добавь (т_мера i)
    {
        static if (Счёт == 0)
            размер (i);
        или (i);
    }

    /**********************************************************************

            Проверить, активирован ли индексированный бит.

    **********************************************************************/

    бул имеется (т_мера i)
    {
        auto индкс = i / ширина;
        return индкс < биты.length && (биты[индкс] & (1 << (i % ширина))) != 0;
        //return индкс < биты.length && bt(&биты[индкс], i % ширина) != 0;
    }

    /**********************************************************************

            Подобно получи(), но немного быстрее, когда известно, что
	        диапазон действителен.

    **********************************************************************/

    бул и (т_мера i)
    {
        return (биты[i / ширина] & (1 << (i % ширина))) != 0;
        //return bt(&биты[i / ширина], i % ширина) != 0;
    }

    /**********************************************************************

            Включить индексированный бит.

    **********************************************************************/

    проц или (т_мера i)
    {
        биты[i / ширина] |= (1 << (i % ширина));
        //bts (&биты[i / ширина], i % ширина);
    }

    /**********************************************************************

            Инвертировать индексированный бит.

    **********************************************************************/

    проц иили (т_мера i)
    {
        биты[i / ширина] ^= (1 << (i % ширина));
        //btc (&биты[i / ширина], i % ширина);
    }

    /**********************************************************************

            Очистить индексированный бит.

    **********************************************************************/

    проц сотри (т_мера i)
    {
        биты[i / ширина] &= ~(1 << (i % ширина));
        //btr (&биты[i / ширина], i % ширина);
    }

    /**********************************************************************

            Очистить все биты

    **********************************************************************/

    НаборБит* сотри ()
    {
        биты[] = 0;
        return this;
    }

    /**********************************************************************

            Клонировать данный НаборБит и вернуть его.

    **********************************************************************/

    НаборБит dup ()
    {
        НаборБит x;
        static if (Счёт == 0)
            x.биты.length = this.биты.length;
        x.биты[] = биты[];
        return x;
    }

    /**********************************************************************

            Вернуть число битов, для которых есть место.

    **********************************************************************/

    т_мера размер ()
    {
        return ширина * биты.length;
    }

    /**********************************************************************

            Расширить, чтобы включить индексированный бит (только динамически).

    **********************************************************************/

    static if (Счёт == 0) НаборБит* размер (т_мера i)
    {
        i = i / ширина;
        if (i >= биты.length)
            биты.length = i + 1;
        return this;
    }
}
