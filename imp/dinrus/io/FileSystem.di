module io.FileSystem;

private import sys.Common, sys.WinConsts, sys.WinFuncs, sys.WinStructs;

private import io.FilePath;

private import exception, stdrus, stringz;

private import io.Path: стандарт, исконный;

/*******************************************************************************

*******************************************************************************/

version (Win32)
{
    private import Текст = text.Util;
    private import stringz : изТкст16н, изТкст0;

    enum
    {
        FILE_DEVICE_DISK = 7,
        IOCTL_DISK_BASE = FILE_DEVICE_DISK,
        METHOD_BUFFERED = 0,
        FILE_READ_ACCESS = 1
    }
    бцел CTL_CODE(бцел t, бцел f, бцел m, бцел a)
    {
        return (t << 16) | (a << 14) | (f << 2) | m;
    }

    const IOCTL_DISK_GET_LENGTH_INFO = CTL_CODE(IOCTL_DISK_BASE,0x17,METHOD_BUFFERED,FILE_READ_ACCESS);
}

version (Posix)
{
    private import cidrus;
    private import rt.core.stdc.posix.unistd,
            rt.core.stdc.posix.sys.statvfs;

    private import io.device.File;
    private import Целое = text.convert.Integer;
}

/*******************************************************************************

        Моделирует ОС-специфичную файловую систему. Сюда входят методы для
		манипулирования текущей рабочей папкой и преобразования пути
        в его абсолютную форму.

*******************************************************************************/


struct ФСистема
{


    /***********************************************************************

            Преобразует предоставленный путь в абсолютный путь, используя
            текущую рабочую папку, где префикс не указан.
            Если заданный путь уже абсолютный, возвращается без изменений.

            Возвращает предоставленный путь, подкорректированный надлежащим
			образом.

            deprecated: see ФПуть.абсолютный

    ***********************************************************************/

    static ФПуть вАбсолют (ФПуть мишень, ткст префикс=пусто)
    {
        if (! мишень.абс_ли)
        {
            if (префикс is пусто)
                префикс = дайПапку;

            мишень.приставь (мишень.псеп_в_конце(префикс));
        }
        return мишень;
    }

    /***********************************************************************

            Преобразует предоставленный путь в абсолютный путь, используя
            текущую рабочую папку, где префикс не задан.
            Если данный путь уже абсолютный, возвращается без изменений.

            Возвращает предоставленный путь, настроенный при необходимости.

            deprecated: see ФПуть.абсолютный

    ***********************************************************************/

    static ткст вАбсолют (ткст путь, ткст префикс=пусто)
    {
        scope мишень = new ФПуть (путь);
        return вАбсолют (мишень, префикс).вТкст;
    }

    /***********************************************************************

            Сравнить пути на абсолютное равенство. Заданный префикс
            приставляется к путям, если они ещё не находятся в
            абсолютном формате(начинается с '/'). Если префикс не
            указан, будет использоваться текущая рабочая папка.

            Возвращает да, если пути эквивалентны, нет - в противном случае.

            deprecated: see ФПуть.равно

    ***********************************************************************/

    static бул равно (ткст path1, ткст path2, ткст префикс=пусто)
    {
        scope p1 = new ФПуть (path1);
        scope p2 = new ФПуть (path2);
        return (вАбсолют(p1, префикс) == вАбсолют(p2, префикс)) is 0;
    }

    /***********************************************************************

    ***********************************************************************/

    private static проц исключение (ткст сооб)
    {
        throw new ВВИскл (сооб);
    }

    /***********************************************************************

            Специфика Windows 

    ***********************************************************************/

    version (Windows)
    {
        /***************************************************************

                Приватные хелперы.

        ***************************************************************/

        version (Win32SansUnicode)
        {
            private static проц путьВиндовс(ткст путь, ref ткст результат)
            {
                результат[0..путь.length] = путь;
                результат[путь.length] = 0;
            }
        }
        else
        {
            private static проц путьВиндовс(ткст путь, ref шим[] результат)
            {
                assert (путь.length < результат.length);
                auto i = sys.WinFuncs.МультиБайтВШирСим (ПКодСтр.УТФ8, 0,
                                              cast(PCHAR)путь.ptr,
                                              путь.length,
                                              результат.ptr, результат.length);
                результат[i] = 0;
            }
        }

        /***************************************************************

                Установить текущую рабочую папку.

                deprecated: see Среда.текрабпап()

        ***************************************************************/

        static проц установиПапку (ткст путь)
        {
            version (Win32SansUnicode)
            {
                if (! УстановиТекущуюПапкуА (путь))
                    исключение ("Не удалось установить текущую папку");
            }
            else
            {

                if (! УстановиТекущуюПапку (путь))
                    исключение ("Не удалось установить текущую папку");
            }
        }

        /***************************************************************

                Вернуть текущую рабочую папку.

                deprecated: see Среда.текрабпап()

        ***************************************************************/

        static ткст дайПапку()
        {
            ткст путь;

            version (Win32SansUnicode)
            {
                путь = ДайТекущуюПапкуА();
            }
            else
            {
                путь = ДайТекущуюПапку();
            }

            return путь;
        }

        /***************************************************************

                Список набора корневых устройств (C:, D: и т.п.)

        ***************************************************************/

        static ткст[] корни ()
        {
            ткст          ткт;
            ткст[]        корни;

			ткт = ДайТкстЛогДисковА();

                // разбить корни, чтобы преобразовать в отдельные строки
                корни = Текст.разграничь (ткт [0 .. $-1], "\0");
            
            return корни;
        }

        private enum
        {
            volumePathBufferLen = МАКС_ПУТЬ + 6
        }

        private static ткст дайПутьТома(ткст папка, шим[] томПуть_,
                бул бэкслэшхвост)
        in
        {
            assert (томПуть_.length > 5);
        } body
        {
            version (Win32SansUnicode)
            {
                alias sys.WinFuncs.ДайИмяПутиТомаА ДайИмяПутиТома;
                alias изТкст0 fromStringzT;
            }
            else {
                alias sys.WinFuncs.ДайИмяПутиТома ДайИмяПутиТома;
                alias изТкст16н fromStringzT;
            }

            // преобразовать в (w)stringz
            шим[МАКС_ПУТЬ+2] tmp_ =void;
            шим[] врем = tmp_;
            путьВиндовс( папка, врем);

            // нужно открыть том
            томПуть_[0..4] = `\\.\`;
            шткст0 тп = (томПуть_.ptr)+4;
            auto дл = (томПуть_.length)-4;
            шткст0 вф = врем.ptr;

            if(!ДайИмяПутиТома(вф, тп, дл))
                исключение ("Краш функции ДайИмяПутиТома");

            шткст томПуть;

            // путь может уже иметь префикс тома/сети
            if (томПуть_[4..6] != `\\`)
            {
                томПуть = fromStringzT(томПуть_.ptr);
            }
            else {
                томПуть = fromStringzT(томПуть_[4..$].ptr);
            }

            // ДайИмяПутиТома возвращает путь с завершающим его обратным слэшем.
            // Некоторым функциям из sys.Common этот обратный слэш нужен, другим нет.
            if ('\\' == томПуть[$-1] && !бэкслэшхвост)
            {
                томПуть[$-1] = '\0';
            }

            return stdrus.вЮ8(томПуть);
        }

        /***************************************************************

                Запрос остатка свободного места в байтах на диске/точке монтажа
                где находится папка.

                Если есть лимит квоты для данной зоны, он будет учтён для аккаунта,
                если суперпользователь установил да.

                Если какой-то пользователь превысил квоту, может возвращаться
                отрицательное число.

                Заметьте, что разница между общим доступным пространством
                и свободным пространством не равна суммарному размеру
                содержимого файловой системы, так как эти числа для функций
                вычисляются по использованным блокам, включая те,
                которые израсходованы на метаданные и файловые ноды (узлы).

                Если требуется действительное использованное пространство,
                 можно воспользоватся статистическим функционалом из io.vfs.

                Смотрите также: всегоМеста()

                Since: 0.99.9

        ***************************************************************/

        static дол свободноеМесто(ткст папка, бул superuser = нет)
        {
            scope fp = new ФПуть(папка);

            const бул нуженЗавершОбрСлэш = да;
            WCHAR[volumePathBufferLen] буфПутиТома;
            auto томПуть = дайПутьТома(fp.исконный.вТкст, буфПутиТома, нуженЗавершОбрСлэш);

            version (Win32SansUnicode)
            {
                alias ДайСвобДискПространствоДопА ДайСвобДискПространствоДоп;
            }
            else
            {
                alias sys.WinFuncs.ДайСвобДискПространствоДоп ДайСвобДискПространствоДоп;
            }

            ББОЛЬШЕЦЕЛ free, totalFree;
            ДайСвобДискПространствоДоп(stringz.вТкст16н(cast(шткст)томПуть), &free, cast(ББОЛЬШЕЦЕЛ*)пусто, &totalFree);
            return cast(дол) (superuser ? totalFree : free).квадрЧасть;
        }

        static бдол всегоМеста(ткст папка, бул superuser = нет)
        {
            version (Win32SansUnicode)
            {
                alias ДайСвобДискПространствоДопА ДайСвобДискПространствоДоп;
                alias sys.WinFuncs.СоздайФайлА СоздайФайл;
            }
            else
            {
                alias sys.WinFuncs.ДайСвобДискПространствоДоп ДайСвобДискПространствоДоп;
                alias sys.WinFuncs.СоздайФайл СоздайФайл;
            }

            scope fp = new ФПуть(папка);

            бул нуженЗавершОбрСлэш = (нет == superuser);
            шим[volumePathBufferLen] буфПутиТома;
            auto томПуть = дайПутьТома(fp.исконный.вТкст, буфПутиТома, нуженЗавершОбрСлэш);

            if (superuser)
            {
                struct ИНФОДЛИНЕ
                {
                    БОЛЬШЕЦЕЛ Длина;
                }
                ИНФОДЛИНЕ инфОДлин;
                бцел члоБайт;
                АСИНХРОН оверлап;

                ук h = СоздайФайл(томПуть, ППраваДоступа.ГенернаяЗапись, ПСовмИспФайла.Чтение | ПСовмИспФайла.Запись,
                               пусто, ПРежСоздФайла.ОткрытьСущ, cast(ПФайл) 0, пусто
                           );

                if (h == НЕВЕРНХЭНДЛ)
                {
                    исключение ("Не удалось открыть том для чтения");
                }

                if (0 == УправляйВВУстройства(
                            h, IOCTL_DISK_GET_LENGTH_INFO, пусто, 0,
                            cast(ук)&инфОДлин, инфОДлин.sizeof, &члоБайт, &оверлап
                        ))
                {
                    исключение ("IOCTL_DISK_GET_LENGTH_INFO неудачно:" ~ СисОш.последнСооб);
                }

                return cast(бдол)инфОДлин.Длина.квадрЧасть;
            }
            else
            {
                ББОЛЬШЕЦЕЛ total;
                ДайСвобДискПространствоДоп(stringz.вТкст16н(cast(шткст)томПуть), cast(ББОЛЬШЕЦЕЛ*)пусто, &total, cast(ББОЛЬШЕЦЕЛ*) пусто);
                return cast(бдол)total.квадрЧасть;
            }
        }
    }

    /***********************************************************************

    ***********************************************************************/

    version (Posix)
    {

        static проц установиПапку (ткст путь)
        {
            сим[512] врем =void;
            врем [путь.length] = 0;
            врем[0..путь.length] = путь;

            if (rt.core.stdc.posix.unistd.chdir (врем.ptr))
                исключение ("Не удалось установить текущую папку");
        }

        static ткст дайПапку ()
        {
            сим[512] врем =void;

            сим *s = rt.core.stdc.posix.unistd.getcwd (врем.ptr, врем.length);
            if (s is пусто)
                исключение ("Не удалось получить текущую папку");

            auto путь = s[0 .. strlen(s)+1].dup;
            путь[$-1] = '/';
            return путь;
        }


        static ткст[] корни ()
        {
            version(darwin)
            {
                assert(0);
            }
            else
            {
                ткст путь = "";
                ткст[] список;
                цел пробелы;

                auto fc = new Файл("/etc/mtab");
                scope (exit)
                fc.закрой;

                auto контент = new сим[cast(цел) fc.length];
                fc.ввод.читай (контент);

                for(цел i = 0; i < контент.length; i++)
                {
                    if(контент[i] == ' ') пробелы++;
                    else if(контент[i] == '\n')
                    {
                        пробелы = 0;
                        список ~= путь;
                        путь = "";
                    }
                    else if(пробелы == 1)
                    {
                        if(контент[i] == '\\')
                        {
                            путь ~= Целое.разбор(контент[++i..i+3], 8u);
                            i += 2;
                        }
                        else путь ~= контент[i];
                    }
                }

                return список;
            }
        }

        static дол свободноеМесто(ткст папка, бул superuser = нет)
        {
            scope fp = new ФПуть(папка);
            statvfs_t инфо;
            цел рез = statvfs(fp.исконный.сиТкст.ptr, &инфо);
            if (рез == -1)
                исключение ("свободноеМесто->statvfs неудачно:"
                                      ~ СисОш.последнСооб);

            if (superuser)
                return cast(дол)инфо.f_bfree *  cast(дол)инфо.f_bsize;
            else
                return cast(дол)инфо.f_bavail * cast(дол)инфо.f_bsize;
        }


        static дол всегоМеста(ткст папка, бул superuser = нет)
        {
            scope fp = new ФПуть(папка);
            statvfs_t инфо;
            цел рез = statvfs(fp.исконный.сиТкст.ptr, &инфо);
            if (рез == -1)
                исключение ("всегоМеста->statvfs неудачно:"
                                      ~ СисОш.последнСооб);

            return cast(дол)инфо.f_blocks *  cast(дол)инфо.f_frsize;
        }
    }
}
/+
unittest
{
    import io.Stdout;

    static проц foo (ФПуть путь)
    {
        Стдвыв("все: ") (путь).нс;
        Стдвыв("путь: ") (путь.путь).нс;
        Стдвыв("файл: ") (путь.файл).нс;
        Стдвыв("папка: ") (путь.папка).нс;
        Стдвыв("имя: ") (путь.имя).нс;
        Стдвыв("расш: ") (путь.расш).нс;
        Стдвыв("суффикс: ") (путь.суффикс).нс.нс;
    }

    проц main()
    {
        Стдвыв.форматнс ("Пап: {}", ФСистема.дайПапку);

        auto путь = new ФПуть (".");
        foo (путь);

        путь.установи ("..");
        foo (путь);

        путь.установи ("...");
        foo (путь);

        путь.установи (r"/x/y/.файл");
        foo (путь);

        путь.суффикс = ".foo";
        foo (путь);

        путь.установи ("файл.bar");
        путь.абсолютный("c:/префикс");
        foo(путь);

        путь.установи (r"arf/тест");
        foo(путь);
        путь.абсолютный("c:/префикс");
        foo(путь);

        путь.имя = "foo";
        foo(путь);

        путь.суффикс = ".d";
        путь.имя = путь.суффикс;
        foo(путь);

    }
}
+/
