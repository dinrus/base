module io.stream.Buffered;

public import io.model;
import io.device.Conduit;

public alias БуфВвод  Бввод;        /// краткий алиас
public alias БуфВывод Бвыв;       /// описано ранее


extern(D):

class БуфВвод : ФильтрВвода, ИБуферВвода
{

        alias слей             очисть;          /// очисть/слей одно и то же
        alias ФильтрВвода.ввод ввод;          /// доступ к истоку	
		
        this (ИПотокВвода поток);
        this (ИПотокВвода поток, т_мера ёмкость);
        static ИБуферВвода создай (ИПотокВвода поток);
        final т_мера наполни ();
        final проц[] opSlice (т_мера старт, т_мера конец);
        final проц[] срез ();
        final проц[] срез (т_мера размер, бул съешь = да);
        final т_мера читатель (т_мера delegate (проц[]) дг);
        т_мера писатель (т_мера delegate (проц[]) дг);
        final override т_мера читай (проц[] приёмн);
        final т_мера заполни (проц[] приёмн, бул exact = нет);
        final бул пропусти (цел размер);
        final override дол сместись (дол смещение, Якорь старт = Якорь.Нач);
        final бул следщ (т_мера delegate (проц[]) скан);
        final т_мера резервируй (т_мера пространство);
        final ИБуферВвода сожми ();
        final т_мера дренируй (ИПотокВывода приёмн);
        final т_мера предел ();
        final т_мера ёмкость ();
        final т_мера позиция ();
        final т_мера читаемо ();
        static T[] преобразуй(T)(проц[] x)
        {
                return (cast(T*) x.ptr) [0 .. (x.length / T.sizeof)];
        }

        final БуфВвод слей ();
        final проц ввод (ИПотокВвода исток);
        final override проц[] загрузи (т_мера max = т_мера.max);                

}


class БуфВывод : ФильтрВывода, ИБуферВывода
{
        alias ФильтрВывода.вывод вывод;       /// доступ к стоку

		
        this (ИПотокВывода поток);
        this (ИПотокВывода поток, т_мера ёмкость);
        static БуфВывод создай (ИПотокВывода поток);
        final проц[] срез ();
        final override т_мера пиши (проц[] ист);
        final БуфВывод добавь (проц[] ист);
        final БуфВывод добавь (ук ист, т_мера длина);
        final т_мера записываемо ();
        final т_мера предел ();
        final т_мера ёмкость ();
        final бул упрости (т_мера длина);
        static T[] преобразуй(T)(проц[] x)
        {
                return (cast(T*) x.ptr) [0 .. (x.length / T.sizeof)];
        }

        final override БуфВывод слей ();
        final override БуфВывод копируй (ИПотокВвода ист, т_мера max = -1);
        final т_мера дренируй (ИПотокВывода приёмн);
        final БуфВывод очисть ();
        final проц вывод (ИПотокВывода сток);
        final override дол сместись (дол смещение, Якорь старт = Якорь.Нач);
        final т_мера писатель (т_мера delegate (проц[]) дг);

}



debug (Буферированный)
{
        проц main()
        {
                auto ввод = new БуфВвод (пусто);
                auto вывод = new БуфВывод (пусто);
        }
}
