/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. Все права защищены

        license:        BSD стиль: $(LICENSE)

        version:        Mar 2004: Initial release
                        Dec 2006: Outback release
                        Nov 2008: relocated and simplified

        author:         Kris,
                        John Reimer,
                        Anders F Bjorklund (Darwin patches),
                        Chris Sauls (Win95 файл support)

*******************************************************************************/

module io.device.File;

private import sys.Common;
private import io.device.Device, io.device.Conduit, io.Stdout;
private import stringz, thread, exception;

/*******************************************************************************

        Платформоспецифичные функции

*******************************************************************************/

version (Win32)
private import Utf = text.convert.Utf;
else
    private import rt.core.stringz.posix.unistd;


/*******************************************************************************

        Реализует средство чтения и записи в генерный файл. Conduits -
        это первичное средство доступа к внешним данным; Файл
        расширяет базовый образец, предоставляя файл-специфичные методы для
        установки размера файла, смещения на заданную файловую позицию и т.п.

        Серийный ввод и вывод непосредственен. В этом примере мы
        копируем файл прямо на консоль:
        ---
        // открыть файл для чтения
        auto из_ = new Файл ("тест.txt");

        // залить прямо в консоль
        Стдвыв.копируй (из_);
        ---

        А здесь копируем один файл в другой:
        ---
        // открыть файл для чтения
        auto из_ = new Файл ("тест.txt");

        // открыть другой для записи
        auto в_ = new Файл ("копия.txt", Файл.ЗапСозд);

        // скопировать файл и закрыть
        в_.копируй.закрой;
        из_.закрой;
        ---

        Можно использовать ИПотокВвода.загрузи() для загрузки файла прямо в память:
        ---
        auto файл = new Файл ("тест.txt");
        auto контент = файл.загрузи;
        файл.закрой;
        ---

        Или использовать удобную статическую функцию из Файл:
        ---
        auto контент = Файл.получи ("тест.txt");
        ---

        Другой способ для получения такого же результата:
        ---
        // открыть файл для чтения
        auto файл = new Файл ("тест.txt");

        // создать Массив, вмещающий весь файл
        auto контент = new сим [файл.length];

        // считать содержимое файла. Возвращаемое значение представляет собой число считанных байтов.
        auto байты = файл.читай (контент);
        файл.закрой;
        ---

        Можно прямо записывать в Файл таким методом:
        ---
        // откроем файл для записи
        auto в_ = new Файл ("текст.txt", Файл.ЗапСозд);

        // запишим Массив контента в него
        auto байты = в_.пиши (контент);
        ---

        Имеются эквивалентные статические функции, Файл.установи() и
        Файл.добавь(), которые устанавливают или добавляют файловый контент, соответственно.

        Файл отлично обрабатывает случайный I/O. Используем сместись() для
        перемещения файлового указателя:
        ---
        // откроем файл для чтения и записи
        auto файл = new Файл ("random.bin", Файл.ЧитЗапСозд);

        // запишим какие-либо данные
        файл.пиши ("testing");

        // перейдём на начало файла
        файл.сместись (0);

        // считаем данные ещё раз
        сим[10] врем;
        auto байты = файл.читай (врем);

        файл.закрой;
        ---

        Заметьте, что по умолчанию Файл не буферирован - обмотка экземпляра внутри
        io.stream.Buffered для буферированного I/O.

        Компилируется с -version=Win32SansUnicode, чтобы активировать Win95 & Win32s файл
        суппорт.

*******************************************************************************/

export class Файл : Устройство
{


    public alias Устройство.читай  читай;
    public alias Устройство.пиши пиши;

    /***********************************************************************

            32 бит ...

    ***********************************************************************/

    align(1) struct Стиль
    {
        Доступ          доступ;                 /// права доступа
        Откр            откр;                   /// как открыть
        Общ           совместно;                  /// в совместном режиме
        Кэш           кэш;                  ///  в кэш
    }

    /***********************************************************************

    ***********************************************************************/

    enum Доступ : ббайт
    {
        Чит      = 0x01,       /// читаемый ли
        Зап     = 0x02,       /// записываемый ли
        ЧитЗап = 0x03,       /// все
    }

    /***********************************************************************

    ***********************************************************************/

    enum Откр : ббайт
    {
        Сущ=0,               /// должен существовать
        Созд,                 /// создать или упростить
        Sedate,                 /// создать при необходимости
        Доб,                 /// создать при необходимости
        Нов,                    /// не может существовать
    };

    /***********************************************************************

    ***********************************************************************/

    enum Общ : ббайт
    {
        Нет=0,                 /// без совместного использования
        Чит,                   ///  совместное чтение
        ЧитЗап,              /// открыть для любых действий
    };

    /***********************************************************************

    ***********************************************************************/

    enum Кэш : ббайт
    {
        Нет      = 0x00,       /// не оптимизировать
        Случай    = 0x01,       /// оптимизировать для случайного
        Поток    = 0x02,       /// оптимизировать для потока
        WriteThru = 0x04,       /// поддерживающего-кэша флаг
    };

    /***********************************************************************

        Читать существующий файл.

    ***********************************************************************/

    const Стиль ЧитСущ = {Доступ.Чит, Откр.Сущ};

    /***********************************************************************

        Читать существующий файл.

    ***********************************************************************/

    const Стиль ЧитОбщ = {Доступ.Чит, Откр.Сущ, Общ.Чит};

    /***********************************************************************

            Записать существующий файл. Не создавать.

    ***********************************************************************/

    const Стиль ЗапСущ = {Доступ.Зап, Откр.Сущ};

    /***********************************************************************

            Записать в чистый файл. Создать при необходимости.

    ***********************************************************************/

    const Стиль ЗапСозд = {Доступ.Зап, Откр.Созд};

    /***********************************************************************

            Записать в конец файла.

    ***********************************************************************/

    const Стиль ЧитДоб = {Доступ.Зап, Откр.Доб};

    /***********************************************************************

            Чтение и запись в существующий файл.

    ***********************************************************************/

    const Стиль ЧитЗапСущ = {Доступ.ЧитЗап, Откр.Сущ};

    /***********************************************************************

            Чтение и запись в чистый файл. Создать при необходимости.

    ***********************************************************************/

    const Стиль ЧитЗапСозд = {Доступ.ЧитЗап, Откр.Созд};

    /***********************************************************************

            Чит и Зап. Используется - при его наличии - существующий файл.

    ***********************************************************************/

    const Стиль ЧитЗапОткр = {Доступ.ЧитЗап, Откр.Sedate};


    // файл, с которым работаем
    private ткст  путь_;

    // стиль, в котором открываем
    private Стиль   стиль_;

export:
    /***********************************************************************

            Создать Файл для использования с открой().

            Заметьте, что Файл не буферирован по умолчанию - обмотка экземпляра
            внутри io.stream.Buffered для буферированного I/O.

    ***********************************************************************/

    this ()
    {
    }

    /***********************************************************************

            Создаёт Файл с заданными путь и стиль.

            Заметьте, что Файл не буферирован по умолчанию - обмотка экземпляра
            внутри io.stream.Buffered для буферированного I/O.

    ***********************************************************************/

    this (ткст путь, Стиль стиль = ЧитСущ)
    {
        открой (путь, стиль);
    }

    /***********************************************************************

            Возвращает Стиль, используемый для этого файла.

    ***********************************************************************/

    Стиль стиль ()
    {
        return стиль_;
    }

    /***********************************************************************

            Возвращает путь, используемый для этого файла.

    ***********************************************************************/

    override ткст вТкст ()
    {
        return путь_;
    }

    /***********************************************************************

            Вспомогательная функция для возврата контента файла.
            Возвращает срез предоставленного буфера вывода, где
            есть достаточная ёмкость, и размещает из кучи,
            в которой файловый контент больше.

            Размер контента определяется через файловую систему, по
            Файл.length, хотя может быть неверным для некоторых систем
            *nix. Альтернатива - использовать Файл.загрузи, который
            грузит контент, пока не натолкнётся на Кф.

    ***********************************************************************/

    static проц[] получи (ткст путь, проц[] приёмн = пусто)
    {
        scope файл = new Файл (путь);

        // разместим достаточное пространство для всего файла
        auto длин = cast(т_мера) файл.длина;
        if (приёмн.length < длин)
        {
            if (приёмн is пусто)  // избежим настройки атрибута несканируемый
            {
                приёмн=new ббайт[](длин);
            }
            else
            {
                приёмн.length = длин;
            }
        }

        //читаем контент
        длин = файл.читай (приёмн);
        if (длин is файл.Кф)
            throw new ВВИскл("io.device.File.Файл.читай :: неожиданный кф");

        return приёмн [0 .. длин];
    }

    /***********************************************************************

            Вспомогательная функция для установки файлового контента и длины,
            отражающей данный Массив.

    ***********************************************************************/

    static проц установи (ткст путь, проц[] контент)
    {
        scope файл = new Файл (путь, ЧитЗапСозд);
        файл.пиши (контент);
    }

    /***********************************************************************

            Вспомогательная функция для добавки контента в файл.

    ***********************************************************************/

    static проц добавь (ткст путь, проц[] контент)
    {
        scope файл = new Файл (путь, ЧитДоб);
        файл.пиши (контент);
    }

    /***********************************************************************

            Windows-специфичный код

    ***********************************************************************/

    version(Win32)
    {
        /***************************************************************

            Low уровень открой for подст-classes that need в_ apply specific
            атрибуты.

            Return: нет in case of failure

        ***************************************************************/

        protected бул открой (ткст путь, Стиль стиль, бцел добатр)
        {
            бцел   атр,
                    совместно,
                    доступ,
                    созд;

            alias бцел[] Флаги;

            static const Флаги Доступ =
                [
                    0,                      // не_годится
                    ГЕНЕРНОЕ_ЧТЕНИЕ,
                    ГЕНЕРНАЯ_ЗАПИСЬ,
                    ГЕНЕРНОЕ_ЧТЕНИЕ | ГЕНЕРНАЯ_ЗАПИСЬ,
                ];

            static const Флаги Созд =
                [
                    ПРежСоздФайла.ОткрытьСущ,          // должен существовать
                    ПРежСоздФайла.СоздатьВсегда,          // упрости always
                    ПРежСоздФайла.ОткрытьВсегда,            // создай if needed
                    ПРежСоздФайла.ОткрытьВсегда,            // (for appending)
                    ПРежСоздФайла.СоздатьНовый              // не может существовать
                ];

            static const Флаги Общ =
                [
                    0,
                    ПСовмИспФайла.Чтение,
                    ПСовмИспФайла.Чтение | ПСовмИспФайла.Запись,
                ];

            static const Флаги Атр =
                [
                    0,
                    ПФайл.СлучДоступ,
                    ПФайл.ПоследоватСкан,
                    0,
                    ПФайл.ПереписатьЧерез,
                ];

            // remember our настройки
            assert(путь);
            путь_ = путь;
            стиль_ = стиль;

            атр   = Атр[стиль.кэш] | добатр;
            совместно  = Общ[стиль.совместно];
            созд = Созд[стиль.откр];
            доступ = Доступ[стиль.доступ];

            if (планировщик)
                атр |= ПФайл.Асинхронно;// + FILE_FLAG_NO_BUFFERING;

                // открой the файл
                вв.указатель = cast(Дескр) СоздайФайл (путь, cast(ППраваДоступа) доступ, cast(ПСовмИспФайла) совместно,cast(АТРИБУТЫ_БЕЗОПАСНОСТИ*)
                                          пусто, cast(ПРежСоздФайла) созд,
                                          cast(ПФайл) (атр | ПФайл.Нормальный),
                                          cast(ук) пусто);
            

            if (вв.указатель is НЕВЕРНХЭНДЛ)
            {
                //Стдвыв("Неверный ук").нс;
                return нет;
            }

            // сбрось extended ошибка
            УстановиПоследнОшибку(ПОшибка.Успех);

            // перемести в_ конец of файл?
            if (стиль.откр is Откр.Доб)
                *(cast(дол*) &вв.асинх.смещение) = -1;
            else
                вв.след = да;

            // monitor this укз for async I/O?
            if (планировщик) планировщик.открой(cast(thread.Фибра.Планировщик.Дескр) вв.указатель, вТкст());
            {
                //Стдвыв("Планировщику - ук").нс;
                return да;
            }
        }

        /***************************************************************

                Откр a файл with the предоставленный стиль.

        ***************************************************************/

        проц открой (ткст путь, Стиль стиль = ЧитСущ)
        {
            if (! открой (путь, стиль, 0))
                ошибка;
        }

        /***************************************************************

                Набор the файл размер в_ be that of the текущ сместись
                позиция. The файл must be записываемый for this в_
                succeed.

        ***************************************************************/

        проц упрости ()
        {
            упрости (позиция);
        }

        /***************************************************************

                Набор the файл размер в_ be the specified length. The
                файл must be записываемый for this в_ succeed.

        ***************************************************************/

        проц упрости (дол размер)
        {
            auto s = сместись (размер);
            assert (s is размер);

            // must have Generic_Write доступ
            if (! УстановиКонецФайла (вв.указатель))
                ошибка;
        }

        /***************************************************************

                Набор the файл сместись позиция в_ the specified смещение
                из_ the given якорь.

        ***************************************************************/

        override дол сместись (дол смещение, Якорь якорь = Якорь.Нач)
        {
            дол новСмещение;

            // хак в_ ensure overlapped.Offset and файл location
            // are correctly in synch ...
            if (якорь is Якорь.Тек)
                УстановиФайлУкДоп (вв.указатель,
                                  *cast(БОЛЬШЕЦЕЛ*) &вв.асинх.смещение,
                                  cast(БОЛЬШЕЦЕЛ*) &новСмещение, 0);

            if (! УстановиФайлУкДоп (вв.указатель, *cast(БОЛЬШЕЦЕЛ*)
                                    &смещение, cast(БОЛЬШЕЦЕЛ*)
                                    &новСмещение, якорь))
                ошибка;

            return (*cast(дол*) &вв.асинх.смещение) = новСмещение;
        }

        /***************************************************************

                Return the текущ файл позиция.

        ***************************************************************/

        дол позиция ()
        {
            return *cast(дол*) &вв.асинх.смещение;
        }

        /***************************************************************

                Return the total length of this файл.

        ***************************************************************/

        дол длина ()
        {
            дол длин;

            if (! ДайРазмерФайлаДоп ( вв.указатель, cast(БОЛЬШЕЦЕЛ*) &длин))
                ошибка;
            return длин;
        }

        /***************************************************************

            Instructs the OS в_ слей it's internal buffers в_
                    the disk устройство.

                    NOTE: due в_ OS and hardware design, данные flushed
                    cannot be guaranteed в_ be actually on disk-platters.
                    Actual durability of данные depends on пиши-caches,
                    barriers, presence of battery-backup, filesystem and
                    OS-support.

            ***************************************************************/

        проц синх ()
        {
            if (! СлейБуферыФайла (вв.указатель))
                ошибка;
        }
    }


    /***********************************************************************

             Unix-specific код. Note that some methods are 32bit only

    ***********************************************************************/

    version (Posix)
    {
        /***************************************************************

            Low уровень открой for подст-classes that need в_ apply specific
            атрибуты.

            Return:
                нет in case of failure

        ***************************************************************/

        protected бул открой (ткст путь, Стиль стиль,
                                       цел добфлаги, цел доступ = 0666)
        {
            alias цел[] Флаги;

            const O_LARGEFILE = 0x8000;

            static const Флаги Доступ =
                [
                    0,                      // не_годится
                    O_RDONLY,
                    O_WRONLY,
                    O_RDWR,
                ];

            static const Флаги Созд =
                [
                    0,                      // открой existing
                    O_CREAT | O_TRUNC,      // упрости always
                    O_CREAT,                // создай if needed
                    O_APPEND | O_CREAT,     // добавь
                    O_CREAT | O_EXCL,       // не может существовать
                ];

            static const крат[] Locks =
                [
                    F_WRLCK,                // без совместнго использования
                    F_RDLCK,                // /*shared*/ читай
                ];

            // remember our настройки
            assert(путь);
            путь_ = путь;
            стиль_ = стиль;

            // zero терминируй and преобразуй в_ utf16
            сим[512] zero =void;
            auto имя = stringz.вТкст0 (путь, zero);
            auto режим = Доступ[стиль.доступ] | Созд[стиль.открой];

            // always открой as a large файл
            укз = posix.открой (имя, режим | O_LARGEFILE | добфлаги,
                                         доступ);
            if (укз is -1)
                return нет;

            return да;
        }

        /***************************************************************

                Откр a файл with the предоставленный стиль.

                Note that файлы default в_ no-sharing. That is,
                they are locked exclusively в_ the хост process
                unless иначе снИПulated. We do this in order
                в_ expose the same default behaviour as Win32

                NO FILE LOCKING FOR BORKED POSIX

        ***************************************************************/

        проц открой (ткст путь, Стиль стиль = ЧитСущ)
        {
            if (! открой (путь, стиль, 0))
                ошибка;
        }

        /***************************************************************

                Набор the файл размер в_ be that of the текущ сместись
                позиция. The файл must be записываемый for this в_
                succeed.

        ***************************************************************/

        проц упрости ()
        {
            упрости (позиция);
        }

        /***************************************************************

                Набор the файл размер в_ be the specified length. The
                файл must be записываемый for this в_ succeed.

        ***************************************************************/

        override проц упрости (дол размер)
        {
            // установи filesize в_ be текущ сместись-позиция
            if (posix.ftruncate (укз, cast(off_t) размер) is -1)
                ошибка;
        }

        /***************************************************************

                Набор the файл сместись позиция в_ the specified смещение
                из_ the given якорь.

        ***************************************************************/

        override дол сместись (дол смещение, Якорь якорь = Якорь.Нач)
        {
            дол результат = posix.lseek (укз, cast(off_t) смещение, якорь);
            if (результат is -1)
                ошибка;
            return результат;
        }

        /***************************************************************

                Return the текущ файл позиция.

        ***************************************************************/

        дол позиция ()
        {
            return сместись (0, Якорь.Тек);
        }

        /***************************************************************

                Return the total length of this файл.

        ***************************************************************/

        дол длина ()
        {
            stat_t статс =void;
            if (posix.fstat (укз, &статс))
                ошибка;
            return cast(дол) статс.st_size;
        }

        /***************************************************************

            Instructs the OS в_ слей it's internal buffers в_
                    the disk устройство.

                    NOTE: due в_ OS and hardware design, данные flushed
                    cannot be guaranteed в_ be actually on disk-platters.
                    Actual durability of данные depends on пиши-caches,
                    barriers, presence of battery-backup, filesystem and
                    OS-support.

            ***************************************************************/

        проц синх ()
        {
            if (fsync (укз))
                ошибка;
        }
    }
}
alias Файл ФВвод, ФВывод;

debug (File)
{
    import io.Stdout;

    проц main()
    {
        сим[10] ff;

        auto файл = new Файл("File.d");
        auto контент = cast(ткст) файл.загрузи (файл);
        Стдвыв(контент).нс;
        assert (контент.length is файл.length);
        assert (файл.читай(ff) is файл.Кф);
        assert (файл.позиция is контент.length);
        файл.сместись (0);
        assert (файл.позиция is 0);
        Стдвыв("Позиция при чтении фф = ", файл.читай(ff)).нс;
        assert (файл.читай(ff) is 10);
        assert (файл.позиция is 20);
        assert (файл.сместись(0, файл.Якорь.Тек) is 20);
        assert (файл.сместись(5, файл.Якорь.Тек) is 25);
    }
}
