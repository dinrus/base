module io.device.ThreadPipe;

private import io.device.Conduit;

extern(D)
 class ПайпНить : Провод
{
    /**
     * Создаёт новый ПайпНить с заданным размером буфера.
     *
     * Парамы:
     * размерБуфера = размер выделяемой под буфер памяти.
     */
    this(т_мера размерБуфера=(1024*16));

    /**
     * Реализует IConduit.размерБуфера.
     *
     * Возвращает соответствующего размера буфер, который следует
     * использовать для буферирования ПайпНити. 
     * Заметьте, что это просто передаваемый размер буфера, и
     * поскольку все данные ПайпНить находятся в памяти,
     * буферирование не имеет никакого смысла.
     */
    т_мера размерБуфера();

    /**
     * Реализует IConduit.вТкст
     *
     * Возвращает "&lt;io.device.ThreadPipe.ПайпНить&gt;"
     */
    ткст вТкст();

    /**
     * Возвращает да, если ещё есть данные для чтения,
     * и конец записи не закрыт.
     */
    override бул жив_ли();

    /**
     * Возвращает число остаточных байтов для чтения в циркулярном буфере.
     */
    т_мера остаток();

    /**
     * Возвращает число байтов, которые могут быть записаны в циркулярный буфер.
     */
    т_мера записываемо();

    /**
     * Закрыть пишущий конец провода. Запись в провод после этого
     * вернёт Кф.
     *
     * Читающий край не закрывается до тех пор, пока буфер не оказывается пуст.
     */
    проц стоп();

    /**
     * Процедура ничего не делает, так как нам не известно, был ли собран сборшиком
	 * мусора тот или иной член, открепи выполняется в деструкторе. Стовы прервать
	 * коммуникации, используется стоп().
     *
     * TODO: Переместить функциональность стоп() в открепи(), как только станет возможно,
     * чтобы полностью владеть членами.
	 */
    проц открепи();

    /**
     * Реализует ИПотокВвода.читай.
     *
     * Читает из провода в целевой массив. Предоставленный приёмник 
     * наполяется контентом из Потока.
     *
     * Возвращает число считанных байтов, которое может быть менбше, чем требуется
     * в приёмнике. Кф возвращается, когда выполняется условие конца потока.
     */
    т_мера читай(проц[] приёмник);

    /**
     * Реализует ИПотокВвода.очисть().
     *
     * Очистить любой буферированный контент.
     */
    ПайпНить очисть();

    /**
     * Реализует OutputПоток.пиши.
     *
     * Записывает в поток из массива-источника. Предоставленный ист контент будет
     * записан в этот Поток.
     *
     * Возвращает число байтов, записанных из ист, которое может быть меньшим
     * чем предоставленное количество. Кф возвращается, когда выполняется условие конца потока.
     */
    т_мера пиши(проц[] ист);
}