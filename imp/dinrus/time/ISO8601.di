/*******************************************************************************

        Copyright:      Copyright (c) 2007-2008 Matti Niemenmaa.
                        Все права защищены
        License:        BSD стиль: $(LICENSE)
        Версия:        Aug 2007: Initial release
                        Feb 2008: Retooled
        Author:         Matti Niemenmaa

        Модуль основан на стандарте ISO 8601:2004 и располагает функциями для
        парсинга (практически) любого формата дата/время, указанного в нём.
		(Единственно не поддерживаются интервалы, продолжительности и рекуррирующие интервалы.)

        Смотрите этот стандарт, где полностью описываются поддерживаемые форматы.

        Функции (разборВремени, разборДаты и разборДатыИВремени) перегружены,
		каждая имеет по две версии: одна обновляет указанное Время, а другая -
		указанную структуру РасширеннаяДата. Эта структура предназначена для
		поддержки более детальной информации, которую не поддерживает тип данных Время.

        Если указан часовой пояс, то время просто преобразуется в UTC: из_ может
		вызывать изменение даты, если парсировано одно лишь время, например, "01:00+03"
        то же самое что и "22:00", но когда парсируется последнее, от дня отнимается единица.

*******************************************************************************/

module time.ISO8601;

public import time.Time;
public import time.chrono.Gregorian;

import exception : ИсклНелегальногоАргумента;
import math.Math : мин;

private alias Время ДВ;
private alias РасширеннаяДата ПолнаяДата;

/** Расширенный тип данных, охватывающий Время с некоторой дополнительной
 * информацией. */
 struct РасширеннаяДата
{
    /** Значение Время, содержащее допустимую информацию. */
    ДВ знач;

    private цел год_;

    /** Возвращает годовую часть даты: значение в диапазоне
     * [-1_000_000_000,-1] ∪ [1,999_999_999], где -1 = год 1 BCE.
     *
     * Не используйте напрямую знач.год, пока не убедитесь окончательно, что
     * оно в диапазоне Времени (-10000 в 9999).
     */
    цел год()
    out(знач)
    {
        assert (  (знач >= -1_000_000_000 && знач <=          -1)
                  || (знач >=              1 && знач <= 999_999_999));
    } body
    {
        if (год_)
            return год_;

        auto эра = Грегориан.генерный.дайЭру(знач);
        if (эра == Грегориан.НАША_ЭРА)
            return Грегориан.генерный.дайГод(знач);
        else
            return -Грегориан.генерный.дайГод(знач);
    }

    // y может быть равно нулю: в этом случае оно ссылается на год 1 BCE
    private проц год(цел y)
    {
        if (годДВ(y))
        {
            год_ = 0;
            // дайГод возвращает бцел
            цел добавить = y - Грегориан.генерный.дайГод(знач);
            знач = Грегориан.генерный.добавьГоды(знач, добавить);
        }
        else
            год_ = y < 0 ? y-1 : y;
    }

    private байт маска; // leap секунда и конецДня

    /** Возвращает секундную часть даты: может равняться 60, если leap секунда
     * имеет место быть. В таком случае, секундная часть знач'я равна 59.
     */
    бцел сек()
    {
        return знач.время.сек + ((маска >>> 0) & 1);
    }
    alias сек секунды, секунда, сек;

    /** Является ли представление ISO 8601 this час равным 24 или же 00:
     * this мгновение полуночи считается концом предыдущего дня, либо
     * началом следщ.
     *
     * Если время у знач не есть точно 00:00:00.000, то это значение не определено.
     */
    бул конецДня()
    {
        return 1 ==              ((маска >>> 1) & 1);
    }

    private проц установиВисокосный()
    {
        маска |= 1 << 0;
    }
    private проц установиКонецДня()
    {
        маска |= 1 << 1;
    }
/*
    debug (Tango_ISO8601) private ткст toStr()
    {
        return Стдвыв.выкладка.преобразуй(
                   "{:d} и {:d}-{:d2}-{:d2} :: {:d2}:{:d2}:{:d2}.{:d3} и {:d2}, {}",
                   год_, годы(*this), месяцы(*this), дни(*this),
                   часы(*this), минуты(*this), .секунды(*this), мс(*this),
                   this.сек, this.конецДня);
    }
	*/
}

/** Разбирает дату, представленную в формате, описанном в ISO 8601:2004.
 *
 * Возвращает число символов, используемых для компоновки валидной даты: 0, если дата
 * не может быть скомпонованной.
 *
 * Поля в дв будут либо корректными (напр., месяцы будут >= 1 и <= 12), либо
 * по умолчанию, равному 1 для год, месяц и день, и 0 - для всех прочих
 * полей. Если нет полной уверенности, что 0001-01-01 никогда не встретится,
 * то следует проверять возвратное значение, чтобы убедиться, что разбор
 * прошёл удачно.
 *
 * Для этой версии РасширеннаяДата доступен третий параметр: он позволяет выполнять
 * разбор развёрнутых представлений года. Параметр этот есть число цифр года
 * свыше четырёх, а по умолчанию равен нулю. Он должен попадать в диапазон
 * [0,5]: этим становится возможен максимальный год 999 999 999, которого на данный
 * момент должно быть достаточно.
 *
 * При использовании развёрнутого представления лет используется
 * РасширеннаяДата.год вместо значения года Времени.
 *
 * Примеры:
 * ---
 * Время t;
 * РасширеннаяДата ed;
 *
 * разборДаты("19",             t);    // Январь 1-ое, 1900
 * разборДаты("1970",           t);    // Январь 1-ое, 1970
 * разборДаты("1970-02",        t);    // Февраль 1-ое, 1970
 * разборДаты("19700203",       t);    // Февраль 3-е, 1970
 * разборДаты("+19700203",     ed, 2); // Март 1-ое, 197002
 * разборДаты("-197002-04-01", ed, 2); // Апрель 1-ое, -197003 (197003 BCE)
 * разборДаты("00000101",       t);    // Январь 1-ое, -1 (1 BCE)
 * разборДаты("1700-W14-2",     t);    // Апрель 6-ое, 1700
 * разборДаты("2008W01",        t);    // Декабрь 31-ое, 2007
 * разборДаты("1987-221",       t);    // Август 9-ое, 1987
 * разборДаты("1234abcd",       t);    // Январь 1-ое, 1234; возвратное значение равно 4
 * разборДаты("12abcdef",       t);    // Январь 1-ое, 1200; возвратное значение равно 2
 * разборДаты("abcdefgh",       t);    // Январь 1-ое, 0001; возвратное значение равно 0
 * ---
 */
public т_мера разборДаты(T)(T[] ист, ref ДВ дв)
{
    auto пд = ПолнаяДата(дв);

    auto возвр = разборДаты(ист, пд);
    дв = пд.знач;
    return возвр;
}
/** описано ранее */
public т_мера разборДаты(T)(T[] ист, ref ПолнаяДата пд, ббайт развёрнуто = 0)
{
    ббайт приблуда = void;
    T* p = ист.ptr;
    return сделайИсо8601Дату(p, ист, пд, развёрнуто, приблуда);
}

private т_мера сделайИсо8601Дату(T)(

    ref T* p, T[] ист,
    ref ПолнаяДата пд,
    ббайт развёрнуто,
    out ббайт разделители

)
{
    if (развёрнуто > 5)
        throw new ИсклНелегальногоАргумента(
            "ISO8601 :: год, развёрнутый в более чем 5 цифр, не помещается в тип цел");

    т_мера съедено()
    {
        return p - ист.ptr;
    }
    т_мера осталось()
    {
        return ист.length - съедено();
    }
    бул готово(T[] s)
    {
        return .готово(съедено(), ист.length, p, s);
    }

    if (!парсируйГод(p, ист.length, развёрнуто, пд))
        return 0;

    auto толькоГод = съедено();

    // /([+-]Y{развёрнуто})?(YYYY|YY)/
    if (готово("-0123W"))
        return толькоГод;

    if (прими(p, '-'))
    {
        разделители = ДА;

        if (осталось() == 0)
            return съедено() - 1;
    }

    if (прими(p, 'W'))
    {
        T* p2 = p;

        цел i = парсируйЦел(p, мин(cast(т_мера)3, осталось()));

        if (i) if (p - p2 == 2)
            {

                // (год)-Www
                if (готово("-"))
                {
                    if (дайМесяцИДеньИзНедели(пд, i))
                        return съедено();

                    // (год)-Www-D
                }
                else if (требуй(p, '-'))
                {
                    if (осталось() == 0)
                        return съедено() - 1;

                    if (разделители == НЕТ)
                    {
                        // (год)Www после все
                        if (дайМесяцИДеньИзНедели(пд, i))
                            return съедено() - 1;

                    }
                    else if (дайМесяцИДеньИзНедели(пд, i, *p++ - '0'))
                        return съедено();
                }

            }
            else if (p - p2 == 3)
            {
                // (год)WwwD, i == wwD

                if (разделители == ДА)
                {
                    // (год)-Www после все
                    if (дайМесяцИДеньИзНедели(пд, i / 10))
                        return съедено() - 1;

                }
                else if (дайМесяцИДеньИзНедели(пд, i / 10, i % 10))
                    return съедено();
            }
        return толькоГод;
    }

    // следщ up, MM or MM[-]DD or DDD

    T* p2 = p;

    цел i = парсируйЦел(p, осталось());
    if (!i)
        return толькоГод;

    switch (p - p2)
    {
    case 2:
        // MM or MM-DD

        if (i >= 1 && i <= 12)
            добавьМесяцы(пд, i);
        else
            return толькоГод;

        auto толькоМесяц = съедено();

        // (год)-MM
        if (готово("-") || !требуй(p, '-') || разделители == НЕТ)
            return толькоМесяц;

        цел день = парсируйЦел(p, мин(cast(т_мера)2, осталось()));

        // (год)-MM-DD
        if (день && день <= днейВМесяце(месяцы(пд), пд.год))
            добавьДни(пд, день);
        else
            return толькоМесяц;

        break;

    case 4:
        // e.g. 20010203, i = 203 сейчас

        цел месяц = i / 100;
        цел день   = i % 100;

        if (разделители == ДА)
        {
            // Don't прими the день: behave as though we only got the месяц
            p -= 2;
            i = месяц;
        goto case 2;
        }

        // (год)MMDD
        if (
            месяц >= 1 && месяц <= 12 &&
            день   >= 1 && день   <= днейВМесяце(месяц, пд.год)
        )
        {
            добавьМесяцы(пд, месяц);
            добавьДни  (пд, день);
        }
        else
            return толькоГод;

        break;

    case 3:
        // (год)-DDD
        // i is the порядковый of the день внутри the год

        if (i > 365 + високосен_ли(пд.год))
            return толькоГод;

        добавьДни(пд, i);

    default:
        break;
    }
    return съедено();
}

/** Разбирает время дня в формате, определённом в ISO 8601:2004.
 *
 * Возвращает число символов, используемое для составления валидного времени: 0,
 * если время не может быть компонировано вообще.
 *
 * Поля в дв либо будут корректными, либо по умолчанию, что равно 0 для всех
 * связанных с временем полей. Unless one is absolutely sure that mопрnight
 * can never be encountered, one should check the return значение в_ be sure that
 * the parsing succeeded as ожидалось.
 *
 * Экстра fields in РасширеннаяДата:
 *
 * Seconds may be 60 if the часы and минуты are 23 and 59, as leap сек
 * are occasionally добавьed в_ UTC время. A Время's сек will be 59 in this
 * case.
 *
 * Hours may be 0 or 24: the latter marks the конец of a день and the former the
 * beginning, although they Всё refer в_ the same instant во времени. A Время
 * will be precisely 00:00 in either case.
 *
 * Примеры:
 * ---
 * Время t;
 * РасширеннаяДата ed;
 *
 * // ",000" omitted for clarity
 * разборВремени("20",             t); // 20:00:00
 * разборВремени("2004",           t); // 20:04:00
 * разборВремени("20:04:06",       t); // 20:04:06
 * разборВремени("16:49:30,001",   t); // 16:49:30,001
 * разборВремени("16:49:30,1",     t); // 16:49:30,100
 * разборВремени("16:49,4",        t); // 16:49:24
 * разборВремени("23:59:60",      ed); // 23:59:60
 * разборВремени("24:00:01",       t); // 00:00:00; возвратное значение равно 5
 * разборВремени("24:00:01",      ed); // 00:00:00; возвратное значение равно 5; конецДня
 * разборВремени("30",             t); // 00:00:00; возвратное значение равно 0
 * разборВремени("21:32:43-12:34", t); // 10:06:43; день increased by one
 * ---
 */
public т_мера разборВремени(T)(T[] ист, ref ДВ дв)
{
    auto пд = ПолнаяДата(дв);

    auto возвр = разборВремени(ист, пд);
    дв = пд.знач;
    return возвр;
}
/** описано ранее */
public т_мера разборВремени(T)(T[] ист, ref ПолнаяДата пд)
{
    бул приблуда =void;
    T* p = ист.ptr;
    return сделайИсо8601Время(p, ист, пд, ЧТО_ЛИБО, приблуда);
}

// разделители
private enum : ббайт { НЕТ = 0, ДА = 1, ЧТО_ЛИБО }

// всёВалидно is used only в_ получи разборДатыИВремени() в_ catch ошибки correctly
private т_мера сделайИсо8601Время(T)(

    ref T* p, T[] ист,
    ref ПолнаяДата пд,
    ббайт разделители,
    out бул всёВалидно

)
{
    т_мера съедено()
    {
        return p - ист.ptr;
    }
    т_мера осталось()
    {
        return ист.length - съедено();
    }
    бул готово(T[] s)
    {
        return .готово(съедено(), ист.length, p, s);
    }
    бул проверьДвоеточие()
    {
        return .проверьДвоеточие(p, разделители);
    }

    байт дайВременнуюЗону()
    {
        return .дайВременнуюЗону(p, осталось(), пд, разделители, &готово);
    }

    if (разделители == ЧТО_ЛИБО)
        прими(p, 'T');

    цел час =void;
    if (парсируйЦел(p, мин(cast(т_мера)2, осталось()), час) != 2 || час > 24)
        return 0;

    if (час == 24)
        пд.установиКонецДня();

    // Добавь the часы even if конецДня: the день should be the следщ день, not the
    // previous
    добавьЧасы(пд, час);

    auto толькоЧас = съедено();

    // hh
    if (готово("+,-.012345:"))
        return толькоЧас;

    switch (дайДесяток(p, осталось(), пд, час))
    {
    case НЕ_НАЙДЕНО:
        break;
    case    НАЙДЕНО:
        auto толькоДесяток = съедено();
        if (дайВременнуюЗону() == ПЛОХ)
            return толькоДесяток;

        // /hh,h+/
        return съедено();

    case ПЛОХ:
        return толькоЧас;
    default:
        assert (нет);
    }

    switch (дайВременнуюЗону())
    {
    case НЕ_НАЙДЕНО:
        break;
    case    НАЙДЕНО:
        return съедено();
    case ПЛОХ:
        return толькоЧас;
    default:
        assert (нет);
    }

    if (!проверьДвоеточие())
        return толькоЧас;

    цел минуты =void;
    if (
        парсируйЦел(p, мин(cast(т_мера)2, осталось()), минуты) != 2 ||
        минуты > 59 ||
        // конец of день is only for 24:00:00
        (пд.конецДня && минуты != 0)
    )
        return толькоЧас;

    добавьМинуты(пд, минуты);

    auto толькоМинута = съедено();

    // hh:mm
    if (готово("+,-.0123456:"))
    {
        всёВалидно = да;
        return толькоМинута;
    }

    switch (дайДесяток(p, осталось(), пд, минута))
    {
    case НЕ_НАЙДЕНО:
        break;
    case    НАЙДЕНО:
        auto толькоДесяток = съедено();
        if (дайВременнуюЗону() == ПЛОХ)
            return толькоДесяток;

        // /hh:mm,m+/
        всёВалидно = да;
        return съедено();

    case ПЛОХ:
        return толькоМинута;
    default:
        assert (нет);
    }

    switch (дайВременнуюЗону())
    {
    case НЕ_НАЙДЕНО:
        break;
    case    НАЙДЕНО:
        всёВалидно = да;
        return съедено();
    case ПЛОХ:
        return толькоМинута;
    default:
        assert (нет);
    }

    if (!проверьДвоеточие())
        return толькоМинута;

    цел сек =void;
    if (
        парсируйЦел(p, мин(cast(т_мера)2, осталось()), сек) != 2 ||
        сек > 60 ||
        (пд.конецДня && сек != 0)
    )
        return толькоМинута;

    if (сек == 60)
    {
        if (часы(пд) != 23 && .минуты(пд) != 59)
            return толькоМинута;

        пд.установиВисокосный();
        --сек;
    }
    добавьСекунды(пд, сек);

    auto толькоСекунда = съедено();

    // hh:mm:ss
    if (готово("+,-.Z"))
    {
        всёВалидно = да;
        return толькоСекунда;
    }

    switch (дайДесяток(p, осталось(), пд, секунда))
    {
    case НЕ_НАЙДЕНО:
        break;
    case    НАЙДЕНО:
        auto толькоДесяток = съедено();
        if (дайВременнуюЗону() == ПЛОХ)
            return толькоДесяток;

        // /hh:mm:ss,s+/
        всёВалидно = да;
        return съедено();

    case ПЛОХ:
        return толькоСекунда;
    default:
        assert (нет);
    }

    if (дайВременнуюЗону() == ПЛОХ)
        return толькоСекунда;
    else
    {
        всёВалидно = да;
        return съедено(); // hh:mm:ss with timezone
    }
}

/** Parses a combined дата and время in a форматируй specified in ISO 8601:2004.
 *
 * Возвращает the число of characters used в_ compose a valid дата and время.
 * Zero is returned if a complete дата and время cannot be extracted. In that
 * case, the значение of the результатing Время or РасширеннаяДата is undefined.
 *
 * This function is stricter than just calling разборДаты followed by
 * разборВремени: there are no allowances for развёрнуто годы or reduced dates
 * (two-цифра годы), and разделитель usage must be consistent.
 *
 * Although the стандарт допускается for omitting the T between the дата and the
 * время, this function требует it.
 *
 * Примеры:
 * ---
 * Время t;
 *
 * // Январь 1-ое, 2008 00:01:00
 * разборДатыИВремени("2007-12-31T23:01-01", t);
 *
 * // Апрель 12th, 1985 23:50:30,042
 * разборДатыИВремени("1985W155T235030,042", t);
 *
 * // Неверный время: returns zero
 * разборДатыИВремени("1902-03-04T10:1a", t);
 *
 * // Separating T omitted: returns zero
 * разборДатыИВремени("1985-04-1210:15:30+04:00", t);
 *
 * // Inconsistent разделители: все return zero
 * разборДатыИВремени("200512-01T10:02",          t);
 * разборДатыИВремени("1985-04-12T10:15:30+0400", t);
 * разборДатыИВремени("1902-03-04T050607",        t);
 * ---
 */
public т_мера разборДатыИВремени(T)(T[] ист, ref ДВ дв)
{
    ПолнаяДата пд;
    auto возвр = разборДатыИВремени(ист, пд);
    дв = пд.знач;
    return возвр;
}
/** описано ранее */
public т_мера разборДатыИВремени(T)(T[] ист, ref ПолнаяДата пд)
{
    T* p = ист.ptr;
    ббайт sep;
    бул всёВалидно = нет;

    if (
        сделайИсо8601Дату(p, ист, пд, cast(ббайт)0, sep) &&

        // by mutual agreement this T may be omitted
        // but this is just a convenience метод for дата+время anyway
        ист.length - (p - ист.ptr) >= 1 &&
        требуй(p, 'T') &&

        сделайИсо8601Время(p, ист, пд, sep, всёВалидно) &&
        всёВалидно
    )
        return p - ист.ptr;
    else
        return 0;
}

/+ +++++++++++++++++++++++++++++++++++++++ +\

Privates used by дата

\+ +++++++++++++++++++++++++++++++++++++++ +/

private:

// /([+-]Y{развёрнуто})?(YYYY|YY)/
бул парсируйГод(T)(ref T* p, т_мера длин, ббайт развёрнуто, ref ПолнаяДата пд)
{

    цел год =void;

    бул doParse()
    {
        T* p2 = p;

        if (!парсируйЦел(p, мин(cast(т_мера)(развёрнуто + 4), длин), год))
            return нет;

        // it's Y{развёрнуто}YY, Y{развёрнуто}YYYY, or unacceptable

        if (p - p2 - развёрнуто == 2)
            год *= 100;
        else if (p - p2 - развёрнуто != 4)
            return нет;

        return да;
    }

    if (прими(p, '-'))
    {
        if (!doParse() || год < 0)
            return нет;
        год = -год;
    }
    else
    {
        прими(p, '+');
        if (!doParse() || год < 0)
            return нет;
    }

    пд.год = год;

    return да;
}

// найди the месяц and день given a calendar week and день недели
// uses пд.год for leap год calculations
// returns нет if week and пд.год are incompatible
бул дайМесяцИДеньИзНедели(ref ПолнаяДата пд, цел week, цел день = 1)
{
    if (week < 1 || week > 53 || день < 1 || день > 7)
        return нет;

    цел год = пд.год;

    // only годы starting with Четверг and leap годы starting with Среда
    // have 53 weeks
    if (week == 53)
    {
        цел startingDay = деньНедели(год, 1, 1);

        if (!(startingDay == 4 || (високосен_ли(год) && startingDay == 3)))
            return нет;
    }

    // XXX
    // дни since год-01-04, plus 4 (?)...
    /* This is a bit scary, actually: I have ***no опрea why this works***. I
     * came up with this completely by accопрent. It seems в_ work though -
     * unless it fails in some (very) obscure case which isn't represented in
     * the unit tests.
    */
    добавьДни(пд, 7*(week - 1) + день - деньНедели(год, 1, 4) + 4);

    return да;
}

бул високосен_ли(цел год)
{
    return год % 4 == 0 && (год % 100 != 0 || год % 400 == 0);
}

цел деньНедели(цел год, цел месяц, цел день)
in
{
    assert (месяц  >= 1 && месяц  <= 12);
    assert (день    >= 1 && день    <= 31);
} out(результат)
{
    assert (результат >= 1 && результат <= 7);
}
body
{
    бцел эра = эрируй(год);

    цел результат =
    Грегориан.генерный.дайДеньНедели(
        Грегориан.генерный.воВремя(год, месяц, день, 0, 0, 0, 0, эра));

    if (результат == Грегориан.ДеньНедели.Воскресенье)
        return 7;
    else
        return результат;
}

/+ +++++++++++++++++++++++++++++++++++++++ +\

Privates used by время

\+ +++++++++++++++++++++++++++++++++++++++ +/

enum : ббайт { час, минута, секунда }
enum :  байт { ПЛОХ, НАЙДЕНО, НЕ_НАЙДЕНО }

бул проверьДвоеточие(T)(ref T* p, ref ббайт разделители)
{
    ббайт найденныйСеп = прими(p, ':') ? ДА : НЕТ;
    if (найденныйСеп != разделители)
    {
        if (разделители == ЧТО_ЛИБО)
            разделители = найденныйСеп;
        else
            return нет;
    }
    return да;
}

байт дайДесяток(T)(ref T* p, т_мера длин, ref ПолнаяДата пд, ббайт which)
{
    if (!(прими(p, ',') || прими(p, '.')))
        return НЕ_НАЙДЕНО;

    T* p2 = p;

    цел i =void;
    auto iLen = парсируйЦел(p, длин-1, i);

    if (
        iLen == 0 ||

        // if i is 0, must have at least 3 цифры
        // ... or at least that's что I think the стандарт means
        // when it says "[i]f the magnitude of the число is less
        // than unity, the десяток знак shall be preceded by two
        // zeros"...
        // surely that should читай "followed" and not "preceded"

        (i == 0 && iLen < 3)
    )
        return ПЛОХ;

    // 10 в_ the power of (iLen - 1)
    цел степень = 1;
    while (--iLen)
        степень *= 10;

    switch (which)
    {
    case час:
        добавьМинуты(пд, 6 * i / степень);
        добавьСекунды(пд, 6 * i % степень);
        break;
    case минута:
        добавьСекунды(пд, 6    * i / степень);
        добавьМс  (пд, 6000 * i / степень % 1000);
        break;
    case секунда:
        добавьМс(пд, 100 * i / степень);
        break;

    default:
        assert (нет);
    }

    return НАЙДЕНО;
}

// the ДВ is always UTC, so this just добавьs the смещение в_ the дата fields
// другой опция would be в_ добавь время зона fields в_ ДВ and have this заполни them

байт дайВременнуюЗону(T)(ref T* p, т_мера длин, ref ПолнаяДата пд, ббайт разделители, бул delegate(T[]) готово)
{
    бул проверьДвоеточие()
    {
        return .проверьДвоеточие(p, разделители);
    }

    if (длин == 0)
        return НЕ_НАЙДЕНО;

    auto p0 = p;

    if (прими(p, 'Z'))
        return НАЙДЕНО;

    цел фактор = -1;

    if (прими(p, '-'))
        фактор = 1;
    else if (!прими(p, '+'))
        return НЕ_НАЙДЕНО;

    цел час =void;
    if (парсируйЦел(p, мин(cast(т_мера)2, длин-1), час) != 2 || час > 12 || (час == 0 && фактор == 1))
        return ПЛОХ;

    добавьЧасы(пд, фактор * час);

    // if we go вперёд во времени в_ mопрnight, it's 24:00
    if (
        фактор > 0 &&
        часы(пд) == 0 && минуты(пд) == 0 && секунды(пд) == 0 && мс(пд) == 0
    )
        пд.установиКонецДня();

    if (готово("012345:"))
        return НАЙДЕНО;

    auto afterHours = p;

    if (!проверьДвоеточие())
        return ПЛОХ;

    цел минута =void;
    if (парсируйЦел(p, мин(cast(т_мера)2, длин - (p-p0)), минута) != 2)
    {
        // The часы were valid even if the минуты weren't
        p = afterHours;
        return НАЙДЕНО;
    }

    добавьМинуты(пд, фактор * минута);

    // as above
    if (
        фактор > 0 &&
        часы(пд) == 0 && минуты(пд) == 0 && секунды(пд) == 0 && мс(пд) == 0
    )
        пд.установиКонецДня();

    return НАЙДЕНО;
}

/+ +++++++++++++++++++++++++++++++++++++++ +\

Privates used by Всё дата and время

\+ +++++++++++++++++++++++++++++++++++++++ +/

бул прими(T)(ref T* p, сим c)
{
    if (*p == c)
    {
        ++p;
        return да;
    }
    return нет;
}

бул требуй(T)(ref T* p, сим c)
{
    return (*p++ == c);
}

бул готово(T)(т_мера съедено, т_мера srcLen, T* p, T[] s)
{
    if (съедено == srcLen)
        return да;

    // s is the Массив of characters which may come следщ
    // (i.e. which *p may be)
    // sorted in ascending order
    T t = *p;
    foreach (c; s)
    {
        if (t < c)
            return да;
        else if (t == c)
            break;
    }
    return нет;
}

цел днейВМесяце(цел месяц, цел год)
{
    бцел эра = эрируй(год);
    return Грегориан.генерный.дайДниМесяца(год, месяц, эра);
}

бцел эрируй(ref цел год)
{
    if (год < 0)
    {
        год *= -1;
        return Грегориан.ДО_НАШЕЙ_ЭРЫ;
    }
    else
        return Грегориан.НАША_ЭРА;
}

/+ +++++++++++++++++++++++++++++++++++++++ +\

Extract an целое из_ the ввод, прими no ещё than max цифры

\+ +++++++++++++++++++++++++++++++++++++++ +/

// note: код relies on these always being positive, failing if *p == '-'

цел парсируйЦел(T)(ref T* p, т_мера max)
{
    т_мера i = 0;
    цел значение = 0;
    while (i < max && p[i] >= '0' && p[i] <= '9')
        значение = значение * 10 + p[i++] - '0';
    p += i;
    return значение;
}

// ... and return the amount of цифры processed

т_мера парсируйЦел(T)(ref T* p, т_мера max, out цел i)
{
    T* p2 = p;
    i = парсируйЦел(p, max);
    return p - p2;
}


/+ +++++++++++++++++++++++++++++++++++++++ +\

Помощники для манипуляции с ДВ/ПолнаяДата

\+ +++++++++++++++++++++++++++++++++++++++ +/

// as documented in time.Time
бул годДВ(цел год)
{
    return год >= -10000 && год <= 9999;
}

проц добавьМесяцы(ref ПолнаяДата d, цел n)
{
    d.знач = Грегориан.генерный.добавьМесяцы(d.знач, n-1);    // -1 due в_ начальное being 1
}
проц добавьДни  (ref ПолнаяДата d, цел n)
{
    d.знач += ИнтервалВремени.изДней   (n-1);    // описано ранее
}
проц добавьЧасы (ref ПолнаяДата d, цел n)
{
    d.знач += ИнтервалВремени.изЧасов  (n);
}
проц добавьМинуты  (ref ПолнаяДата d, цел n)
{
    d.знач += ИнтервалВремени.изМин(n);
}
проц добавьСекунды  (ref ПолнаяДата d, цел n)
{
    d.знач += ИнтервалВремени.изСек(n);
}
проц добавьМс    (ref ПолнаяДата d, цел n)
{
    d.знач += ИнтервалВремени.изМиллисек (n);
}

// годы and секунды always just получи the ДВ значение
цел годы (ПолнаяДата d)
{
    return Грегориан.генерный.дайГод      (d.знач);
}
цел месяцы(ПолнаяДата d)
{
    return Грегориан.генерный.дайМесяц     (d.знач);
}
цел дни  (ПолнаяДата d)
{
    return Грегориан.генерный.дайДеньМесяца(d.знач);
}
цел часы (ПолнаяДата d)
{
    return d.знач.время.часы;
}
цел минуты  (ПолнаяДата d)
{
    return d.знач.время.минуты;
}
цел секунды  (ПолнаяДата d)
{
    return d.знач.время.сек;
}
цел мс    (ПолнаяДата d)
{
    return d.знач.время.миллисек;
}

////////////////////

// Unit tests

debug (UnitTest)
{
    // проц main() {}

debug (Tango_ISO8601_Valgrind) import cidrus :
    malloc, free;

    unittest
    {
        ПолнаяДата пд;

        // дата

        т_мера d(ткст s, ббайт e = 0)
        {
            пд = пд.init;
            return разборДаты(s, пд, e);
        }

        auto
        INIT_YEAR  = годы (ПолнаяДата.init),
        INIT_MONTH = месяцы(ПолнаяДата.init),
        INIT_DAY   = дни  (ПолнаяДата.init);

        assert (d("20abc") == 2);
        assert (годы(пд) == 2000);

        assert (d("2004") == 4);
        assert (годы(пд) == 2004);

        assert (d("+0019", 2) == 5);
        assert (годы(пд) == 1900);

        assert (d("+111985", 2) == 7);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год   == 111985);

        assert (d("+111985", 1) == 6);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год   == 11198);

        assert (d("+111985", 3) == 0);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год   == INIT_YEAR);

        assert (d("+111985", 4) == 7);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год   == 11198500);

        assert (d("-111985", 5) == 0);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год   == INIT_YEAR);

        assert (d("+999999999", 5) == 10);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год == 999_999_999);

        try {
            d("+10000000000", 6);
            assert (нет);
        }
        catch (ИсклНелегальногоАргумента)
        {
            assert (годы(пд) == INIT_YEAR);
            assert (пд.год   == INIT_YEAR);
        }

        assert (d("-999999999", 5) == 10);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год == -1_000_000_000);

        assert (d("0001") == 4);
        assert (годы(пд) == 1);
        assert (пд.год   == 1);

        assert (d("0000") == 4);
        assert (пд.год   == -1);

        assert (d("-0001") == 5);
        assert (пд.год   == -2);

        assert (d("abc") == 0);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год   == INIT_YEAR);

        assert (d("abc123") == 0);
        assert (годы(пд) == INIT_YEAR);
        assert (пд.год   == INIT_YEAR);

        assert (d("2007-08") == 7);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    8);

        assert (d("+001985-04", 2) == 10);
        assert (годы(пд)  == 1985);
        assert (месяцы(пд) ==    4);

        assert (d("2007-08-07") == 10);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    8);
        assert (дни(пд)   ==    7);

        assert (d("2008-20-30") == 4);
        assert (годы(пд)  == 2008);
        assert (месяцы(пд) == INIT_MONTH);

        assert (d("2007-02-30") == 7);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    2);

        assert (d("20060708") == 8);
        assert (годы(пд)  == 2006);
        assert (месяцы(пд) ==    7);
        assert (дни(пд)   ==    8);

        assert (d("19953080") == 4);
        assert (годы(пд)  == 1995);
        assert (месяцы(пд) == INIT_MONTH);

        assert (d("2007-0201") == 7);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    2);

        assert (d("200702-01") == 6);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    2);

        assert (d("+001985-04-12", 2) == 13);
        assert (годы(пд)  == 1985);
        assert (пд.год    == 1985);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==   12);

        assert (d("-0123450607", 2) == 11);
        assert (годы(пд)  == INIT_YEAR);
        assert (пд.год    == -12346);
        assert (месяцы(пд) ==      6);
        assert (дни(пд)   ==      7);

        assert (d("1985W15") == 7);
        assert (годы(пд)  == 1985);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==    8);

        assert (d("2008-W01") == 8);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   31);

        assert (d("2008-W012") == 8);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   31);

        assert (d("2008W01-2") == 7);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   31);

        assert (d("2008-W01-2") == 10);
        assert (годы(пд)  == 2008);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    1);

        assert (d("2009-W53-4") == 10);
        assert (годы(пд)  == 2009);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   31);

        assert (d("2009-W01-1") == 10);
        assert (годы(пд)  == 2008);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   29);

        assert (d("2009W537") == 8);
        assert (годы(пд)  == 2010);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    3);

        assert (d("2010W537") == 4);
        assert (годы(пд)  == 2010);
        assert (месяцы(пд) == INIT_MONTH);

        assert (d("2009-W01-3") == 10);
        assert (годы(пд)  == 2008);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   31);

        assert (d("2009-W01-4") == 10);
        assert (годы(пд)  == 2009);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    1);

        assert (d("2004-W53-6") == 10);
        assert (годы(пд)  == 2005);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    1);

        assert (d("2004-W53-7") == 10);
        assert (годы(пд)  == 2005);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    2);

        assert (d("2005-W52-6") == 10);
        assert (годы(пд)  == 2005);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   31);

        assert (d("2007-W01-1") == 10);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    1);

        assert (d("1000-W07-7") == 10);
        assert (годы(пд)  == 1000);
        assert (месяцы(пд) ==    2);
        assert (дни(пд)   ==   16);

        assert (d("1500-W11-1") == 10);
        assert (годы(пд)  == 1500);
        assert (месяцы(пд) ==    3);
        assert (дни(пд)   ==   12);

        assert (d("1700-W14-2") == 10);
        assert (годы(пд)  == 1700);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==    6);

        assert (d("1800-W19-3") == 10);
        assert (годы(пд)  == 1800);
        assert (месяцы(пд) ==    5);
        assert (дни(пд)   ==    7);

        assert (d("1900-W25-4") == 10);
        assert (годы(пд)  == 1900);
        assert (месяцы(пд) ==    6);
        assert (дни(пд)   ==   21);

        assert (d("0900-W27-5") == 10);
        assert (годы(пд)  ==  900);
        assert (месяцы(пд) ==    7);
        assert (дни(пд)   ==    9);

        assert (d("0800-W33-6") == 10);
        assert (годы(пд)  ==  800);
        assert (месяцы(пд) ==    8);
        assert (дни(пд)   ==   19);

        assert (d("0700-W37-7") == 10);
        assert (годы(пд)  ==  700);
        assert (месяцы(пд) ==    9);
        assert (дни(пд)   ==   16);

        assert (d("0600-W41-4") == 10);
        assert (годы(пд)  ==  600);
        assert (месяцы(пд) ==   10);
        assert (дни(пд)   ==    9);

        assert (d("0500-W45-7") == 10);
        assert (годы(пд)  ==  500);
        assert (месяцы(пд) ==   11);
        assert (дни(пд)   ==   14);

        assert (d("2000-W55") == 4);
        assert (годы(пд) == 2000);

        assert (d("1980-002") == 8);
        assert (годы(пд)  == 1980);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    2);

        assert (d("1981-034") == 8);
        assert (годы(пд)  == 1981);
        assert (месяцы(пд) ==    2);
        assert (дни(пд)   ==    3);

        assert (d("1982-063") == 8);
        assert (годы(пд)  == 1982);
        assert (месяцы(пд) ==    3);
        assert (дни(пд)   ==    4);

        assert (d("1983-095") == 8);
        assert (годы(пд)  == 1983);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==    5);

        assert (d("1984-127") == 8);
        assert (годы(пд)  == 1984);
        assert (месяцы(пд) ==    5);
        assert (дни(пд)   ==    6);

        assert (d("1985-158") == 8);
        assert (годы(пд)  == 1985);
        assert (месяцы(пд) ==    6);
        assert (дни(пд)   ==    7);

        assert (d("1986-189") == 8);
        assert (годы(пд)  == 1986);
        assert (месяцы(пд) ==    7);
        assert (дни(пд)   ==    8);

        assert (d("1987-221") == 8);
        assert (годы(пд)  == 1987);
        assert (месяцы(пд) ==    8);
        assert (дни(пд)   ==    9);

        assert (d("1988-254") == 8);
        assert (годы(пд)  == 1988);
        assert (месяцы(пд) ==    9);
        assert (дни(пд)   ==   10);

        assert (d("1989-284") == 8);
        assert (годы(пд)  == 1989);
        assert (месяцы(пд) ==   10);
        assert (дни(пд)   ==   11);

        assert (d("1990316") == 7);
        assert (годы(пд)  == 1990);
        assert (месяцы(пд) ==   11);
        assert (дни(пд)   ==   12);

        assert (d("1991-347") == 8);
        assert (годы(пд)  == 1991);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   13);

        assert (d("1992-000") == 4);
        assert (годы(пд) == 1992);

        assert (d("1993-370") == 4);
        assert (годы(пд) == 1993);

        // время

        т_мера t(ткст s)
        {
            пд = пд.init;
            return разборВремени(s, пд);
        }

        assert (t("20") == 2);
        assert (часы(пд) == 20);
        assert (минуты(пд)  ==  0);
        assert (секунды(пд)  ==  0);

        assert (t("30") == 0);

        assert (t("T15") == 3);
        assert (часы(пд) == 15);
        assert (минуты(пд)  ==  0);
        assert (секунды(пд)  ==  0);

        assert (t("T1") == 0);
        assert (t("T") == 0);

        assert (t("2004") == 4);
        assert (часы(пд) == 20);
        assert (минуты(пд)  ==  4);
        assert (секунды(пд)  ==  0);

        assert (t("200406") == 6);
        assert (часы(пд) == 20);
        assert (минуты(пд)  ==  4);
        assert (секунды(пд)  ==  6);

        assert (t("24:00") == 5);
        assert (пд.конецДня);
        assert (дни(пд)  == INIT_DAY + 1);
        assert (часы(пд) == 0);
        assert (минуты(пд)  == 0);
        assert (секунды(пд)  == 0);

        assert (t("00:00") == 5);
        assert (часы(пд) == 0);
        assert (минуты(пд)  == 0);
        assert (секунды(пд)  == 0);

        assert (t("23:59:60") == 8);
        assert (часы(пд)  == 23);
        assert (минуты(пд)   == 59);
        assert (секунды(пд)   == 59);
        assert (пд.сек == 60);

        assert (t("12:3456") == 5);
        assert (часы(пд) == 12);
        assert (минуты(пд)  == 34);

        assert (t("1234:56") == 4);
        assert (часы(пд) == 12);
        assert (минуты(пд)  == 34);

        assert (t("16:49:30,001") == 12);
        assert (часы(пд) == 16);
        assert (минуты(пд)  == 49);
        assert (секунды(пд)  == 30);
        assert (мс(пд)    ==  1);

        assert (t("15:48:29,1") == 10);
        assert (часы(пд) ==  15);
        assert (минуты(пд)  ==  48);
        assert (секунды(пд)  ==  29);
        assert (мс(пд)    == 100);

        assert (t("02:10:34,a") ==  8);
        assert (часы(пд) ==  2);
        assert (минуты(пд)  == 10);
        assert (секунды(пд)  == 34);

        assert (t("14:50,5") == 7);
        assert (часы(пд) == 14);
        assert (минуты(пд)  == 50);
        assert (секунды(пд)  == 30);

        assert (t("1540,4") == 6);
        assert (часы(пд) == 15);
        assert (минуты(пд)  == 40);
        assert (секунды(пд)  == 24);

        assert (t("1250,") == 4);
        assert (часы(пд) == 12);
        assert (минуты(пд)  == 50);

        assert (t("14,5") == 4);
        assert (часы(пд) == 14);
        assert (минуты(пд)  == 30);

        assert (t("12,") == 2);
        assert (часы(пд) == 12);
        assert (минуты(пд)  ==  0);

        assert (t("24:00:01") == 5);
        assert (пд.конецДня);
        assert (часы(пд) == 0);
        assert (минуты(пд)  == 0);
        assert (секунды(пд)  == 0);

        assert (t("12:34+:56") == 5);
        assert (часы(пд) == 12);
        assert (минуты(пд)  == 34);
        assert (секунды(пд)  ==  0);

        // время zones

        assert (t("14:45:15Z") == 9);
        assert (часы(пд) == 14);
        assert (минуты(пд)  == 45);
        assert (секунды(пд)  == 15);

        assert (t("23Z") == 3);
        assert (часы(пд) == 23);
        assert (минуты(пд)  ==  0);
        assert (секунды(пд)  ==  0);

        assert (t("21:32:43-12:34") == 14);
        assert (дни(пд)  == INIT_DAY + 1);
        assert (часы(пд) == 10);
        assert (минуты(пд)  ==  6);
        assert (секунды(пд)  == 43);

        assert (t("12:34,5+00:00") == 13);
        assert (часы(пд) == 12);
        assert (минуты(пд)  == 34);
        assert (секунды(пд)  == 30);

        assert (t("03:04+07") == 8);
        assert (часы(пд) == 20);
        assert (минуты(пд)  ==  4);
        assert (секунды(пд)  ==  0);

        assert (t("11,5+") == 4);
        assert (часы(пд) == 11);
        assert (минуты(пд)  == 30);

        assert (t("07-") == 2);
        assert (часы(пд) == 7);

        assert (t("06:12,7-") == 7);
        assert (часы(пд) ==  6);
        assert (минуты(пд)  == 12);
        assert (секунды(пд)  == 42);

        assert (t("050403,2+") == 8);
        assert (часы(пд) ==   5);
        assert (минуты(пд)  ==   4);
        assert (секунды(пд)  ==   3);
        assert (мс(пд)    == 200);

        assert (t("061656-") == 6);
        assert (часы(пд) ==  6);
        assert (минуты(пд)  == 16);
        assert (секунды(пд)  == 56);

        // дата and время together

        т_мера b(ткст s)
        {
            пд = пд.init;
            return разборДатыИВремени(s, пд);
        }

        assert (b("2007-08-09T12:34:56") == 19);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    8);
        assert (дни(пд)   ==    9);
        assert (часы(пд)  ==   12);
        assert (минуты(пд)   ==   34);
        assert (секунды(пд)   ==   56);

        assert (b("1985W155T235030,768") == 19);
        assert (годы(пд)  == 1985);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==   12);
        assert (часы(пд)  ==   23);
        assert (минуты(пд)   ==   50);
        assert (секунды(пд)   ==   30);
        assert (мс(пд)     ==  768);

        // время zones

        assert (b("2009-08-07T01:02:03Z") == 20);
        assert (годы(пд)  == 2009);
        assert (месяцы(пд) ==    8);
        assert (дни(пд)   ==    7);
        assert (часы(пд)  ==    1);
        assert (минуты(пд)   ==    2);
        assert (секунды(пд)   ==    3);

        assert (b("2007-08-09T03:02,5+04:56") == 24);
        assert (годы(пд)  == 2007);
        assert (месяцы(пд) ==    8);
        assert (дни(пд)   ==    8);
        assert (часы(пд)  ==   22);
        assert (минуты(пд)   ==    6);
        assert (секунды(пд)   ==   30);

        assert (b("20000228T2330-01") == 16);
        assert (годы(пд)  == 2000);
        assert (месяцы(пд) ==    2);
        assert (дни(пд)   ==   29);
        assert (часы(пд)  ==    0);
        assert (минуты(пд)   ==   30);
        assert (секунды(пд)   ==    0);

        assert (b("2007-01-01T00:00+01") == 19);
        assert (годы(пд)  == 2006);
        assert (месяцы(пд) ==   12);
        assert (дни(пд)   ==   31);
        assert (часы(пд)  ==   23);
        assert (минуты(пд)   ==    0);
        assert (секунды(пд)   ==    0);

        assert (b("2007-12-31T23:00-01") == 19);
        assert (пд.конецДня);
        assert (годы(пд)  == 2008);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    1);
        assert (часы(пд)  ==    0);
        assert (минуты(пд)   ==    0);
        assert (секунды(пд)   ==    0);

        assert (b("2007-12-31T23:01-01") == 19);
        assert (!пд.конецДня);
        assert (годы(пд)  == 2008);
        assert (месяцы(пд) ==    1);
        assert (дни(пд)   ==    1);
        assert (часы(пд)  ==    0);
        assert (минуты(пд)   ==    1);
        assert (секунды(пд)   ==    0);

        assert (b("1902-03-04T1a") == 0);
        assert (b("1902-03-04T10:aa") == 0);
        assert (b("1902-03-04T10:1aa") == 0);
        assert (b("200512-01T10:02") == 0);
        assert (b("1985-04-1210:15:30+04:00") == 0);
        assert (b("1985-04-12T10:15:30+0400") == 0);
        assert (b("19020304T05:06:07") == 0);
        assert (b("1902-03-04T050607") == 0);
        assert (b("19020304T05:06:07abcd") == 0);
        assert (b("1902-03-04T050607abcd") == 0);

        assert (b("1985-04-12T10:15:30-05:4") == 22);
        assert (годы(пд)  == 1985);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==   12);
        assert (часы(пд)  ==   15);
        assert (минуты(пд)   ==   15);
        assert (секунды(пд)   ==   30);
        assert (b("2009-04-13T23:00-01") == 19);
        assert (пд.конецДня);
        assert (годы(пд)  == 2009);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==   14);
        assert (часы(пд)  ==    0);
        assert (минуты(пд)   ==    0);
        assert (секунды(пд)   ==    0);
        assert (b("2009-04-13T24:00Z") == 17);
        assert (пд.конецДня);
        assert (годы(пд)  == 2009);
        assert (месяцы(пд) ==    4);
        assert (дни(пд)   ==   14);
        assert (часы(пд)  ==    0);
        assert (минуты(пд)   ==    0);
        assert (секунды(пд)   ==    0);

        // unimplemented: intervals, durations, recurring intervals

        debug (Tango_ISO8601_Valgrind)
        {
            т_мера valgrind(т_мера delegate(ткст) f, ткст s)
            {
                auto p = cast(сим*)malloc(s.length);
                auto ps = p[0..s.length];
                ps[] = s[];
                auto результат = f(ps);
                free(p);
                return результат;
            }
            т_мера vd(ткст s)
            {
                т_мера дата(ткст ss)
                {
                    return d(ss);
                }
                return valgrind(&дата, s);
            }
            т_мера vt(ткст s)
            {
                return valgrind(&t, s);
            }
            т_мера vb(ткст s)
            {
                return valgrind(&b, s);
            }

            assert (vd("1") == 0);
            assert (vd("19") == 2);
            assert (vd("199") == 0);
            assert (vd("1999") == 4);
            assert (vd("1999-") == 4);
            assert (vd("1999-W") == 4);
            assert (vd("1999-W0") == 4);
            assert (vd("1999-W01") == 8);
            assert (vd("1999-W01-") == 8);
            assert (vd("1999-W01-3") == 10);
            assert (vd("1999W") == 4);
            assert (vd("1999W0") == 4);
            assert (vd("1999W01") == 7);
            assert (vd("1999W01-") == 7);
            assert (vd("1999W01-3") == 7);
            assert (vd("1999W013") == 8);
            assert (vd("1999-0") == 4);
            assert (vd("1999-01") == 7);
            assert (vd("1999-01-") == 7);
            assert (vd("1999-01-0") == 7);
            assert (vd("1999-01-01") == 10);
            assert (vd("1999-0101") == 7);
            assert (vd("1999-365") == 8);
            assert (vd("1999365") == 7);

            assert (vt("1") == 0);
            assert (vt("15") == 2);
            assert (vt("15:") == 2);
            assert (vt("15:3") == 2);
            assert (vt("15:30") == 5);
            assert (vt("153") == 2);
            assert (vt("1530") == 4);
            assert (vt("1530:") == 4);
            assert (vt("15304") == 4);
            assert (vt("153045") == 6);
            assert (vt("15:30:") == 5);
            assert (vt("15:30:4") == 5);
            assert (vt("15:30:45") == 8);
            assert (vt("T15") == 3);
            assert (vt("T1") == 0);
            assert (vt("T") == 0);
            assert (vt("15,") == 2);
            assert (vt("15,2") == 4);
            assert (vt("1530,") == 4);
            assert (vt("1530,2") == 6);
            assert (vt("15:30:45,") == 8);
            assert (vt("15:30:45,2") == 10);
            assert (vt("153045,") == 6);
            assert (vt("153045,2") == 8);
            assert (vt("153045,22") == 9);
            assert (vt("153045,222") == 10);
            assert (vt("15Z") == 3);
            assert (vt("15+") == 2);
            assert (vt("15-") == 2);
            assert (vt("15+0") == 2);
            assert (vt("15+00") == 5);
            assert (vt("15+00:") == 5);
            assert (vt("15+00:0") == 5);
            assert (vt("15+00:00") == 8);
            assert (vb("1999-01-01") == 0);
            assert (vb("1999-01-01T") == 0);
            assert (vb("1999-01-01T15:30:45") == 19);
        }
    }
}
