
// Написано на языке программирования Динрус.

/**
 * Шаблоны для извлечения информации о типах во время
 * компиляции.
 *
 * Модуль tpl.traits определяет средства для получения детальной информации
 * времени компиляции о типе. Смешанная схема именований здесь используется
 * намеренно. Шаблоны, оцениваемые в какой-либо тип, следуют конвенции
 * именования, используемой для типов, а шаблоны, оцениваемые в какое-л.
 * значение, - конвенции именований, используемой для функций.
 *
 * СОДЕРЖИТ:
 * ВозврТип, КортежТипаПараметр, КортежТипаПоле, КортежТипаОснова, статМас_ли, кортежВыражений_ли, ТипВозврата2,
 * КортежТипаПараметров, КортежТиповПолей, КортежТиповПредставления, естьСырАлиасинг, имеетОбъекты,
 * имеетАлиасинг, КортежБазовыхКлассов, КортежИнтерфейсов, ТранзитивныйКортежБазовыхТипов, ОбщийТип,
 * ЦелиНеявногоПреобразования, интегральный_ли, дробный_ли, числовой_ли, типТкст_ли, типАссоцМас_ли, статМас_ли,
 * динМас_ли, массив_ли, беззначный, самоеОтрицательное, типТкст_ли,  типСим_ли, типЦел_ли, типБЦел_ли, 
 * типЦелЧис_ли, типРеал_ли, типКомплекс_ли, типМнимое_ли, типДробь_ли, типАтом_ли, КомплексныйТипИз, 
 * РеальныйТипИз, МнимыйТипИз, МаксПрецТипИз,  типУк_ли, типСсылка_ли, типДинМас_ли, типСтатМас_ли, 
 * типМассив_ли, ВызываемыйТип_ли, ВозвратныйТипИз, ТипВыражениеИз, КортежПараметровИз,  КортежТиповОсновУ, 
 * БазТипМассива, ТипЭлтовМассива, рангМассива, ТипКлючаАМ, ТипЗначенияАМ, размерСтатМассива, ТипДинМас, 
 *
 */
module tpl.traits;

/***
 * Получить тип возвратного значения функции,
 * указатель на функуцию или делегат.
 * Пример:
 * ---
 * import tpl.traits;
 * цел foo();
 * ВозврТип!(foo) x;   // x объявлен как цел
 * ---
 */
template ВозврТип(alias дг)
{
    alias ВозврТип!(typeof(дг)) ВозврТип;
}

/** описано ранее */
template ВозврТип(дг)
{
    static if (is(дг R == return))
	alias R ВозврТип;
    else
	static assert(0, cast(ткст) "у аргумента отсутствует тип возврата");
}

/***
 * Получить типы заданных функции  параметров,
 * указатель на функцию или на делегат в виде кортежа.
 * Пример:
 * ---
 * import tpl.traits;
 * цел foo(цел, дол);
 * проц bar(КортежТипаПараметр!(foo));      // объявляет проц bar(цел, дол);
 * проц abc(КортежТипаПараметр!(foo)[1]);   // объявляет проц abc(дол);
 * ---
 */
template КортежТипаПараметр(alias дг)
{
    alias КортежТипаПараметр!(typeof(дг)) КортежТипаПараметр;
}

/** описано ранее */
template КортежТипаПараметр(дг)
{
    static if (is(дг P == function))
	alias P КортежТипаПараметр;
    else static if (is(дг P == delegate))
	alias КортежТипаПараметр!(P) КортежТипаПараметр;
    else static if (is(дг P == P*))
	alias КортежТипаПараметр!(P) КортежТипаПараметр;
    else
	static assert(0, cast(ткст) "у аргумента отсутствуют параметры");
}


/***
 * Получить типы полей структуры или класса.
 * Состоят из полей, занимающих пространство памяти,
 * за исключением скрытых полей типа указателя на
 * таблицу виртуальных функций.
 */

template КортежТипаПоле(S)
{
    static if (is(S == struct) || is(S == class))
	alias typeof(S.tupleof) КортежТипаПоле;
    else
	static assert(0, cast(ткст)"аргумент не является структурой или классом");
}

/***
 * Получить $(D_PARAM КортежТипов) базового класса и базовые интерфейсы
 * этого класса или интерфейса. $(D_PARAM КортежТипаОснова!(Объект)) возвращает
 * пустой кортеж типов.
 * 
 * Пример:
 * ---
 * import tpl.traits, tpl.typetuple, stdrus;
 * interface I { }
 * class A { }
 * class B : A, I { }
 *
 * проц main()
 * {
 *     alias КортежТипаОснова!(B) TL;
 *     пишинс(typeid(TL));  // выводит: (A,I)
 * }
 * ---
 */

template КортежТипаОснова(A)
{
    static if (is(A P == super))
    alias P КортежТипаОснова;
    else
    static assert(0, "аргумент не является классом или интерфейсом");
}

unittest
{
    interface I1 { }
    interface I2 { }
    class A { }
    class C : A, I1, I2 { }

    alias КортежТипаОснова!(C) TL;
    assert(TL.length == 3);
    assert(is (TL[0] == A));
    assert(is (TL[1] == I1));
    assert(is (TL[2] == I2));

    assert(КортежТипаОснова!(Объект).length == 0);
}

/**
 * Сообщает, является ли кортеж Т кортежем выражений.
 */
template кортежВыражений_ли(Т ...)
{
    static if (is(проц function(Т)))
	const бул кортежВыражений_ли = нет;
    else
	const бул кортежВыражений_ли = да;
}

//std2.traits

/***
 * Получить тип возврата функции,
 * указатель на функцию, структуру с opCall
 * или класс с opCall.
 * Пример:
 * ---
 * import tpl.traits;
 * цел foo();
 * ТипВозврата2!(foo) x;   // x объявлен как цел
 * ---
 */
template ТипВозврата2(alias дг)
{
    alias ТипВозврата2!(typeof(дг), проц) ТипВозврата2;
}

template ТипВозврата2(дг, dummy = void)
{
    static if (is(дг R == return))
	alias R ТипВозврата2;
    else static if (is(дг Т : Т*))
	alias ТипВозврата2!(Т, проц) ТипВозврата2;
    else static if (is(дг S == struct))
	alias ТипВозврата2!(typeof(&дг.opCall), проц) ТипВозврата2;
    else static if (is(дг C == class))
	alias ТипВозврата2!(typeof(&дг.opCall), проц) ТипВозврата2;
    else
	static assert(0, "у аргумента нет возвратного типа");
}

unittest
{
    struct G
    {
	цел opCall (цел i) { return 1;}
    }

    //alias ТипВозврата2!(G) ShouldBeInt;
   // static assert(is(ShouldBeInt == цел));

    G g;
    static assert(is(ТипВозврата2!(g) == цел));

    G* p;
    alias ТипВозврата2!(p) pg;
    static assert(is(pg == цел));

    class C
    {
	цел opCall (цел i) { return 1;}
    }

   // static assert(is(ТипВозврата2!(C) == цел));

    C c;
    static assert(is(ТипВозврата2!(c) == цел));
}

/***
 * Получить  типы параметров функции,
 * указатель на функцию или делегата в качестве кортежа.
 * Пример:
 * ---
 * import std.traits;
 * цел foo(цел, дол);
 * проц bar(КортежТипаПараметров!(foo));      // декларирует проц bar(цел, дол);
 * проц abc(КортежТипаПараметров!(foo)[1]);   // декларирует проц abc(дол);
 * ---
 */
template КортежТипаПараметров(alias дг)
{
    alias КортежТипаПараметров!(typeof(дг)) КортежТипаПараметров;
}

/** описано ранее */
template КортежТипаПараметров(дг)
{
    static if (is(дг P == function))
	alias P КортежТипаПараметров;
    else static if (is(дг P == delegate))
	alias КортежТипаПараметров!(P) КортежТипаПараметров;
    else static if (is(дг P == P*))
	alias КортежТипаПараметров!(P) КортежТипаПараметров;
    else
	static assert(0, "у аргумента параметры отсутствуют");
}


/***
 * Получить типы полей структуры или класса.
 * Состоит из полей, которые захватывают пространство памяти,
 * исключая скрытые поля, как указатель на таблицу виртуальных
 * функций.
 */

template КортежТиповПолей(S)
{
    static if (is(S == struct) || is(S == class) || is(S == union))
	alias typeof(S.tupleof) КортежТиповПолей;
    else
        alias S КортежТиповПолей;
	//static assert(0, "аргумент не является структурой или классом");
}

// // КортежСмещенийПолей
// protected template КортежСмещенийПолей_реализ(т_мера n, Т...)
// {
//     static if (Т.length == 0)
//     {
//         alias КортежТипов!() Результат;
//     }
//     else
//     {
//         //protected alias КортежТиповПолей!(Т[0]) Типы;
//         protected const т_мера мСмещение =
//             ((n + Т[0].alignof - 1) / Т[0].alignof) * Т[0].alignof;
//         static if (is(Т[0] == struct))
//         {
//             alias КортежТиповПолей!(Т[0]) MyRep;
//             alias КортежСмещенийПолей_реализ!(мСмещение, MyRep, Т[1 .. $]).Результат
//                 Результат;
//         }
//         else
//         {
//             protected enum т_мера mySize = Т[0].sizeof;
//             alias КортежТипов!(мСмещение) Голова;
//             static if (is(Т == union))
//             {
//                 alias КортежСмещенийПолей_реализ!(мСмещение, Т[1 .. $]).Результат
//                     Tail;
//             }
//             else
//             {
//                 alias КортежСмещенийПолей_реализ!(мСмещение + mySize,
//                                              Т[1 .. $]).Результат
//                     Tail;
//             }
//             alias КортежТипов!(Голова, Tail) Результат;
//         }
//     }
// }

// template КортежСмещенийПолей(Т...)
// {
//     alias КортежСмещенийПолей_реализ!(0, Т).Результат КортежСмещенийПолей;
// }

// unittest
// {
//     alias КортежСмещенийПолей!(цел) T1;
//     assert(T1.length == 1 && T1[0] == 0);
//     //
//     struct S2 { сим a; цел b; сим c; дво d; сим e, f; }
//     alias КортежСмещенийПолей!(S2) T2;
//     //pragma(msg, T2);
//     static assert(T2.length == 6
//            && T2[0] == 0 && T2[1] == 4 && T2[2] == 8 && T2[3] == 16
//                   && T2[4] == 24&& T2[5] == 25);
//     //
//     class C { цел a, b, c, d; }
//     struct S3 { сим a; C b; сим c; }
//     alias КортежСмещенийПолей!(S3) T3;
//     //pragma(msg, T2);
//     static assert(T3.length == 3
//            && T3[0] == 0 && T3[1] == 4 && T3[2] == 8);
//     //
//     struct S4 { сим a; union { цел b; сим c; } цел d; }
//     alias КортежСмещенийПолей!(S4) T4;
//     //pragma(msg, КортежТиповПолей!(S4));
//     static assert(T4.length == 4
//            && T4[0] == 0 && T4[1] == 4 && T4[2] == 8);
// }

// /***
// Поучить смещение полея структуры или класса.
// */

// template КортежСмещенийПолей(S)
// {
//     static if (is(S == struct) || is(S == class))
// 	alias typeof(S.tupleof) КортежТиповПолей;
//     else
// 	static assert(0, "аргумент не является структурой или классом");
// }

/***
Получить примитивные типы полей структуры или класса, в
топологическом порядке.

Пример:
----
struct S1 { цел a; плав b; }
struct S2 { ткст a; union { S1 b; S1 * c; } }
alias КортежТиповПредставления!(S2) R;
assert(R.length == 4
    && is(R[0] == сим[]) && is(R[1] == цел)
    && is(R[2] == плав) && is(R[3] == S1*));
----
*/

template КортежТиповПредставления(Т...)
{
    static if (Т.length == 0)
    {
        alias КортежТипов!() КортежТиповПредставления;
    }
    else
    {
        static if (is(Т[0] == struct) || is(Т[0] == union))
// @@@BUG@@@ this should work
//             alias .ТипыПредставления!(Т[0].tupleof)
//                 ТипыПредставления;
            alias .КортежТиповПредставления!(КортежТиповПолей!(Т[0]),
                                            Т[1 .. $])
                КортежТиповПредставления;
        else static if (is(Т[0] U == typedef))
        {
            alias .КортежТиповПредставления!(КортежТиповПолей!(U),
                                            Т[1 .. $])
                КортежТиповПредставления;
        }
        else
        {
            alias КортежТипов!(Т[0], КортежТиповПредставления!(Т[1 .. $]))
                КортежТиповПредставления;
        }
    }
}

unittest
{
    alias КортежТиповПредставления!(цел) S1;
    static assert(is(S1 == КортежТипов!(цел)));
    struct S2 { цел a; }
    static assert(is(КортежТиповПредставления!(S2) == КортежТипов!(цел)));
    struct S3 { цел a; сим b; }
    static assert(is(КортежТиповПредставления!(S3) == КортежТипов!(цел, сим)));
    struct S4 { S1 a; цел b; S3 c; }
    static assert(is(КортежТиповПредставления!(S4) ==
                     КортежТипов!(цел, цел, цел, сим)));

    struct S11 { цел a; плав b; }
    struct S21 { ткст a; union { S11 b; S11 * c; } }
    alias КортежТиповПредставления!(S21) R;
    assert(R.length == 4
           && is(R[0] == сим[]) && is(R[1] == цел)
           && is(R[2] == плав) && is(R[3] == S11*));
}

/*
СмещенияПредставления
*/

// protected template Повторить(т_мера n, Т...)
// {
//     static if (n == 0) alias КортежТипов!() Повторить;
//     else alias КортежТипов!(Т, Повторить!(n - 1, Т)) Повторить;
// }

// template СмещенияПредставления_реализ(т_мера n, Т...)
// {
//     static if (Т.length == 0)
//     {
//         alias КортежТипов!() Результат;
//     }
//     else
//     {
//         protected enum т_мера мСмещение =
//             ((n + Т[0].alignof - 1) / Т[0].alignof) * Т[0].alignof;
//         static if (!is(Т[0] == union))
//         {
//             alias Повторить!(n, КортежТиповПолей!(Т[0])).Результат
//                 Голова;
//         }
//         static if (is(Т[0] == struct))
//         {
//             alias .СмещенияПредставления_реализ!(n, КортежТиповПолей!(Т[0])).Результат
//                 Голова;
//         }
//         else
//         {
//             alias КортежТипов!(мСмещение) Голова;
//         }
//         alias КортежТипов!(Голова,
//                          СмещенияПредставления_реализ!(
//                              мСмещение + Т[0].sizeof, Т[1 .. $]).Результат)
//             Результат;
//     }
// }

// template СмещенияПредставления(Т)
// {
//     alias СмещенияПредставления_реализ!(0, Т).Результат
//         СмещенияПредставления;
// }

// unittest
// {
//     struct S1 { сим c; цел i; }
//     alias СмещенияПредставления!(S1) Смещения;
//     static assert(Смещения[0] == 0);
//     //pragma(msg, Смещения[1]);
//     static assert(Смещения[1] == 4);
// }

// естьСырАлиасинг

protected template ЕстьЛиСыройУк_реализ(Т...)
{
    static if (Т.length == 0)
    {
        const результат = нет;
    }
    else
    {
        static if (is(Т[0] U : U*))
            const естьСырАлиасинг = да;
        else static if (is(Т[0] U : U[]))
            const естьСырАлиасинг = да;
        else
            const естьСырАлиасинг = нет;
        const результат = естьСырАлиасинг || ЕстьЛиСыройУк_реализ!(Т[1 .. $]).результат;
    }
}

/*
Статически оценивается в $(D да), тогда и только тогда, когда представление $(D Т)
содержит как минимум одно поле типа указатель или массив.
Члены типов класс не считаются сырыми указателями. Указатели на инвариантные объекты
не рассматриваются в сыром алиасинге.

Пример:
---
// простые типы
static assert(!естьСырАлиасинг!(цел));
static assert(естьСырАлиасинг!(сим*));
// ссылки не являются сырыми указателями
static assert(!естьСырАлиасинг!(Объект));
// встроенные массивы содержат сырые указатели
static assert(естьСырАлиасинг!(цел[]));
// агрегат простых типов
struct S1 { цел a; дво b; }
static assert(!естьСырАлиасинг!(S1));
// indirect aggregation
struct S2 { S1 a; дво b; }
static assert(!естьСырАлиасинг!(S2));
// struct with a pointer member
struct S3 { цел a; дво * b; }
static assert(естьСырАлиасинг!(S3));
// struct with an indirect pointer member
struct S4 { S3 a; дво b; }
static assert(естьСырАлиасинг!(S4));
----
*/
protected template естьСырАлиасинг(Т...)
{
    const естьСырАлиасинг = ЕстьЛиСыройУк_реализ!(КортежТиповПредставления!(Т)).результат;
}

unittest
{
// простые типы
    static assert(!естьСырАлиасинг!(цел));
    static assert(естьСырАлиасинг!(сим*));
// ссылки не являются сырыми указателями
    static assert(!естьСырАлиасинг!(Объект));
    static assert(!естьСырАлиасинг!(цел));
    struct S1 { цел z; }
    static assert(!естьСырАлиасинг!(S1));
    struct S2 { цел* z; }
    static assert(естьСырАлиасинг!(S2));
    struct S3 { цел a; цел* z; цел c; }
    static assert(естьСырАлиасинг!(S3));
    struct S4 { цел a; цел z; цел c; }
    static assert(!естьСырАлиасинг!(S4));
    struct S5 { цел a; Объект z; цел c; }
    static assert(!естьСырАлиасинг!(S5));
    union S6 { цел a; цел b; }
    static assert(!естьСырАлиасинг!(S6));
    union S7 { цел a; цел * b; }
    static assert(естьСырАлиасинг!(S7));
    typedef цел* S8;
    static assert(естьСырАлиасинг!(S8));
    enum S9 { a };
    static assert(!естьСырАлиасинг!(S9));
    // indirect members
    struct S10 { S7 a; цел b; }
    static assert(естьСырАлиасинг!(S10));
    struct S11 { S6 a; цел b; }
    static assert(!естьСырАлиасинг!(S11));
}

/*
Статически оценивается в $(D да), тогда и только тогда, когда в 
представление $(D Т) входит хотя бы одна инвариантная ссылка на объект.
*/

protected template имеетОбъекты(Т...)
{
    static if (Т.length == 0)
    {
        const имеетОбъекты = нет;
    }
    else static if (is(Т[0] U == typedef))
    {
        const имеетОбъекты = имеетОбъекты!(U, Т[1 .. $]);
    }
    else static if (is(Т[0] == struct))
    {
        const имеетОбъекты = имеетОбъекты!(
            КортежТиповПредставления!(Т[0]), Т[1 .. $]);
    }
    else
    {
        const имеетОбъекты = is(Т[0] == class) || имеетОбъекты!(Т[1 .. $]);
    }
}

/**
* Возвращает $(D да), тогда и только тогда, если представление $(D Т)
* включает в себя хотя бы одно из следующего:
*  $(OL $(LI сырой указатель $(D U*) и $(D U)не инвариант;)
*  $(LI  массив $(D U[]) и $(D U) iне инвариант;) 
* $(LI ссылка на тип класса $(D C) и $(D C) не инвариант.))
*/

template имеетАлиасинг(Т...)
{
    const имеетАлиасинг = естьСырАлиасинг!(Т) || имеетОбъекты!(Т);
}

unittest
{
    struct S1 { цел a; Объект b; }
    static assert(имеетАлиасинг!(S1));
    struct S2 { ткст a; }
    static assert(!имеетАлиасинг!(S2));
}

/**
 * Получить $(D_PARAM КортежТипов) базовых классов $(I all) данного класса,
 * в уменьшающемся порядке. Не включая интерфесы. $(D_PARAM
 * КортежБазовыхКлассов!(Объект)) получает пустой кортеж типов.
 *
 * Пример:
 * ---
 * import tpl.traits, tpl.typetuple, stdrus;
 * interface I { }
 * class A { }
 * class B : A, I { }
 * class C : B { }
 *
 * проц main()
 * {
 *     alias КортежБазовыхКлассов!(C) TL;
 *     пишинс(typeid(TL));	// выводит: (B,A,Объект)
 * }
 * ---
 */

template КортежБазовыхКлассов(Т)
{
    static if (is(Т == Объект))
    {
        alias КортежТипов!() КортежБазовыхКлассов;
    }
    static if (is(КортежТипаОснова!(Т)[0] == Объект))
    {
        alias КортежТипов!(Объект) КортежБазовыхКлассов;
    }
    else
    {
        alias КортежТипов!(КортежТипаОснова!(Т)[0],
                         КортежБазовыхКлассов!(КортежТипаОснова!(Т)[0]))
            КортежБазовыхКлассов;
    }
}

/**
 * Получить $(D_PARAM КортежТипов) из $(I всех) интерфейсов, прямо или
 * косвенно унаследованных данным классом или интерфейсом. Если реализовано умножение,
 * интерфейсы не повторяются. $(D_PARAM КортежИнтерфейсов!(Объект))
 * получает пустой кортеж типов.
 *
 * Пример:
 * ---
 * import tpl.traits, tpl.typetuple, stdrus;
 * interface I1 { }
 * interface I2 { }
 * class A : I1, I2 { }
 * class B : A, I1 { }
 * class C : B { }
 *
 * проц main()
 * {
 *     alias КортежИнтерфейсов!(C) TL;
 *     пишинс(typeid(TL));	// выводит: (I1, I2)
 * }
 * ---
 */

template КортежИнтерфейсов(Т)
{
    static if (is(Т == Объект))
    {
        alias КортежТипов!() КортежИнтерфейсов;
    }
    static if (is(КортежТипаОснова!(Т)[0] == Объект))
    {
        alias КортежТипов!(КортежТипаОснова!(Т)[1 .. $]) КортежИнтерфейсов;
    }
    else
    {
        alias БезДубликатов!(
            КортежТипов!(КортежТипаОснова!(Т)[1 .. $], // прямые интерфейсы
                       КортежИнтерфейсов!(КортежТипаОснова!(Т)[0])))
            КортежИнтерфейсов;
    }
}

unittest
{
    interface I1 {}
    interface I2 {}
    {
        // doc example
        class A : I1, I2 { }
        class B : A, I1 { }
        class C : B { }
        alias КортежИнтерфейсов!(C) TL;
        assert(is(TL[0] == I1) && is(TL[1] == I2));
    }
    class B1 : I1, I2 {}
    class B2 : B1, I1 {}
    class B3 : B2, I2 {}
    alias КортежИнтерфейсов!(B3) TL;
    //
    assert(TL.length == 2);
    assert(is (TL[0] == I2));
    assert(is (TL[1] == I1));
}

/**
 * Получить $(D_PARAM КортежТипов) из  $(I всех) базовых классов для $(D_PARAM
 * Т), в нисходящем порядке, за которым следуют интерфесы $(D_PARAM Т).
 * $(D_PARAM ТранзитивныйКортежБазовыхТипов!(Объект)) получает
 * пустой кортеж типов.
 *
 * Пример:
 * ---
 * import tpl.traits, tpl.typetuple, stdrus;
 * interface I { }
 * class A { }
 * class B : A, I { }
 * class C : B { }
 *
 * проц main()
 * {
 *     alias ТранзитивныйКортежБазовыхТипов!(C) TL;
 *     пишинс(typeid(TL));	// выводит: (B,A,Объект,I)
 * }
 * ---
 */

template ТранзитивныйКортежБазовыхТипов(Т)
{
    static if (is(Т == Объект))
        alias КортежТипов!() ТранзитивныйКортежБазовыхТипов;
    else
        alias КортежТипов!(КортежБазовыхКлассов!(Т),
            КортежИнтерфейсов!(Т))
            ТранзитивныйКортежБазовыхТипов;
}

unittest
{
    interface I1 {}
    interface I2 {}
    class B1 {}
    class B2 : B1, I1, I2 {}
    class B3 : B2, I1 {}
    alias ТранзитивныйКортежБазовыхТипов!(B3) TL;
    assert(TL.length == 5);
    assert(is (TL[0] == B2));
    assert(is (TL[1] == B1));
    assert(is (TL[2] == Объект));
    assert(is (TL[3] == I1));
    assert(is (TL[4] == I2));
    
    assert(ТранзитивныйКортежБазовыхТипов!(Объект).length == 0);
}

/**
* Получить тип, в который неявно преобразуются все типы. Полезно,
* напр., для выявления типа массива из связки инициализованных
* значений. Возвращаает $(D_PARAM проц), если передан пустой список
* или эти типы не имеют общего типа.
*
* Пример:
*
*----
* alias ОбщийТип!(цел, дол, крат) X;
* assert(is(X == дол));
* alias ОбщийТип!(цел, сим[], крат) Y;
* assert(is(Y == void));
* ----
*/
template ОбщийТип(Т...)
{
    static if (!Т.length)
        alias проц ОбщийТип;
    else static if (Т.length == 1)
        alias Т[0] ОбщийТип;
    else static if (is(typeof(да ? Т[0] : Т[1]) U))
        alias ОбщийТип!(U, Т[2 .. $]) ОбщийТип;
    else
        alias проц ОбщийТип;
}

unittest
{
    alias ОбщийТип!(цел, дол, крат) X;
    assert(is(X == дол));
    alias ОбщийТип!(сим[], цел, дол, крат) Y;
    assert(is(Y == void), Y.stringof);
}

/**
 * Возвращает кортеж со всеми возможными целевыми типами неявного
 * преобразования значения типа $(D_PARAM Т).
 *
 * Важное примечание:
 *
 * The possible targets are computed more conservatively than the D
 * 2.005 compiler does, eliminating all dangerous conversions. For
 * example, $(D_PARAM ЦелиНеявногоПреобразования!(дво)) does not
 * include $(D_PARAM плав).
 */

template ЦелиНеявногоПреобразования(Т)
{
    static if (is(Т == бул))
        alias КортежТипов!(байт, ббайт, крат, бкрат, цел, бцел, дол, бдол,
            плав, дво, реал, сим, шим, дим)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == байт))
        alias КортежТипов!(крат, бкрат, цел, бцел, дол, бдол,
            плав, дво, реал, сим, шим, дим)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == ббайт))
        alias КортежТипов!(крат, бкрат, цел, бцел, дол, бдол,
            плав, дво, реал, сим, шим, дим)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == крат))
        alias КортежТипов!(бкрат, цел, бцел, дол, бдол,
            плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == бкрат))
        alias КортежТипов!(цел, бцел, дол, бдол, плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == цел))
        alias КортежТипов!(дол, бдол, плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == бцел))
        alias КортежТипов!(дол, бдол, плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == дол))
        alias КортежТипов!(плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == бдол))
        alias КортежТипов!(плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == плав))
        alias КортежТипов!(дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == дво))
        alias КортежТипов!(реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == сим))
        alias КортежТипов!(шим, дим, байт, ббайт, крат, бкрат,
            цел, бцел, дол, бдол, плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == шим))
        alias КортежТипов!(шим, дим, крат, бкрат, цел, бцел, дол, бдол,
            плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if (is(Т == дим))
        alias КортежТипов!(шим, дим, цел, бцел, дол, бдол,
            плав, дво, реал)
            ЦелиНеявногоПреобразования;
    else static if(is(Т : Объект))
        alias ТранзитивныйКортежБазовыхТипов!(Т) ЦелиНеявногоПреобразования;
    else static if (is(Т : ук))
        alias КортежТипов!(ук) ЦелиНеявногоПреобразования;
    else
        alias КортежТипов!() ЦелиНеявногоПреобразования;
}

unittest
{
    assert(is(ЦелиНеявногоПреобразования!(дво)[0] == реал));
}

/**
 * Определить, является ли Т встроенным целочисленным типом.
 */

template интегральный_ли(Т)
{
    static const интегральный_ли = is(Т == байт) || is(Т == ббайт) || is(Т == крат)
        || is(Т == бкрат) || is(Т == цел) || is(Т == бцел)
        || is(Т == дол) || is(Т == бдол);
}

/**
 * Определить, является ли Т встроенным типом с плавающей точкой.
 */

template дробный_ли(Т)
{
    static const дробный_ли = is(Т == плав)
        || is(Т == дво) || is(Т == реал);
}

/**
 * Определить, является ли Т встроенным числовым типом.
 */

template числовой_ли(Т)
{
    static const числовой_ли = интегральный_ли!(Т) || дробный_ли!(Т);
}

/**
 * Оценивается в да, если T является ткст, шим[] или дим[].
 */

template типТкст_ли(Т)
{
    static const типТкст_ли = is(Т : сим[])
        || is(Т : шим[]) || is(Т : дим[]);
}

static assert(!типТкст_ли!(цел));
static assert(!типТкст_ли!(цел[]));
static assert(!типТкст_ли!(байт[]));
static assert(типТкст_ли!(сим[]));
static assert(типТкст_ли!(дим[]));
static assert(типТкст_ли!(string));
static assert(типТкст_ли!(wstring));
static assert(типТкст_ли!(dstring));
static assert(типТкст_ли!(сим[4]));

/**
 * Оценивается в да, если T является сим, шим или дим.
 */
template типСим_ли( T )
{
    const бул типСим_ли = is( T == сим )  ||
    is( T == шим ) ||
    is( T == дим );
}

/**
 * Оценивается в да, если T является типом ассоциативный Массив.
 */
template типАссоцМас_ли( T )
{
    const бул типАссоцМас_ли = is( typeof(T.init.values[0])[typeof(T.init.keys[0])] == T );
}

static assert(!типАссоцМас_ли!(цел));
static assert(!типАссоцМас_ли!(цел[]));
static assert(типАссоцМас_ли!(цел[цел]));
static assert(типАссоцМас_ли!(цел[string]));
static assert(типАссоцМас_ли!(сим[5][цел]));

/* *******************************************
 */
private template статМас_ли_реализ(Т)
{
    const Т inst = void;
    
    static if (is(typeof(Т.length)))
    {
	static if (!is(Т == typeof(Т.init)))
	{			// Не принимает тот факт, что цел[5].init == цел
	    static if (is(Т == typeof(Т[0])[inst.length]))
	    {	// Санитарная проверка. Самой этой проверки недостаточно, так как dmd жалуется на динамические массивы
		const бул рез =да;
	    }
	    else
		const бул рез = нет;
	}
	else
	    const бул рез = нет;
    }
    else
    {
	    const бул рез = нет;
    }
}
/**
 * Определяет, является ли тип Т статическим массивом.
 */
template статМас_ли(Т)
{
    const бул статМас_ли = статМас_ли_реализ!(Т).рез;
}

template статМас_ли(Т : U[N], U, т_мера N)
{
    const бул статМас_ли = да;
}

static assert (статМас_ли!(цел[51]));
static assert (статМас_ли!(цел[][2]));
static assert (статМас_ли!(сим[][цел][11]));
static assert (!статМас_ли!(цел[]));
static assert (!статМас_ли!(цел[сим]));
static assert (!статМас_ли!(цел[1][]));
static assert(статМас_ли!(сим[13u]));
static assert (статМас_ли!(typeof("string literal")));
static assert (статМас_ли!(проц[0]));
static assert (!статМас_ли!(цел[цел]));
static assert (!статМас_ли!(цел));

/**
 * Определить, является ли тип Т динамическим массивом.
 */
template динМас_ли(Т, U = void)
{
    static const динМас_ли = нет;
}

template динМас_ли(Т : U[], U)
{
  static const динМас_ли = !статМас_ли!(Т);
}

static assert(динМас_ли!(цел[]));
static assert(!динМас_ли!(цел[5]));

/**
 * Определить, является ли тип Т массивом.
 */
template массив_ли(Т)
{
    static const массив_ли = статМас_ли!(Т) || динМас_ли!(Т);
}

static assert(массив_ли!(цел[]));
static assert(массив_ли!(цел[5]));
static assert(!массив_ли!(бцел));
static assert(!массив_ли!(бцел[бцел]));
static assert(массив_ли!(проц[]));

/**
 * Возвращает соответствующий беззначный тип для Т. Т должен быть
 * числовым интегральным типом, иначе имеет место быть ошибка времени компиляции.
 */

template беззначный(Т) {
    static if (is(Т == байт)) alias ббайт беззначный;
    else static if (is(Т == крат)) alias бкрат беззначный;
    else static if (is(Т == цел)) alias бцел беззначный;
    else static if (is(Т == дол)) alias бдол беззначный;
    else static if (is(Т == ббайт)) alias ббайт беззначный;
    else static if (is(Т == бкрат)) alias бкрат беззначный;
    else static if (is(Т == бцел)) alias бцел беззначный;
    else static if (is(Т == бдол)) alias бдол беззначный;
    else static if (is(Т == сим)) alias сим беззначный;
    else static if (is(Т == шим)) alias шим беззначный;
    else static if (is(Т == дим)) alias дим беззначный;
    else static if(is(Т == enum)) {
        static if (Т.sizeof == 1) alias ббайт беззначный;
        else static if (Т.sizeof == 2) alias бкрат беззначный;
        else static if (Т.sizeof == 4) alias бцел беззначный;
        else static if (Т.sizeof == 8) alias бдол беззначный;
        else static assert(нет, "Тип " ~ Т.stringof
                           ~ " не имеет беззначную контрчасть");
    }
    else static assert(нет, "Тип " ~ Т.stringof
                       ~ " не имеет беззначную контрчасть");
}

unittest
{
    alias беззначный!(цел) U;
    assert(is(U == бцел));
}
/+
/******
 * Returns the mutable version of the type Т.
 */

template Mutable(Т)
{

    static if (is(Т U == (const U)))
	alias U Mutable;
    else static if (is(Т U == invariant(U)))
	alias U Mutable;
    else

	alias Т Mutable;
}
+/
/**
* Возвращает самое отрицательное значение числового типа Т.
*/

template самоеОтрицательное(Т)
{
    static if (Т.min == 0) const байт самоеОтрицательное = 0;
    else static if (Т.min > 0) const самоеОтрицательное = -Т.max;
    else const самоеОтрицательное = Т.min;
}

unittest
{
    static assert(самоеОтрицательное!(плав) == -плав.max);
    static assert(самоеОтрицательное!(бцел) == 0);
    static assert(самоеОтрицательное!(дол) == дол.min);
}

/**
 * Оценивается в да, если T является целым со знаком.
 */
template типЦел_ли( T )
{
    const бул типЦел_ли = is( T == байт )  ||
    is( T == крат ) ||
    is( T == цел )   ||
    is( T == дол )/+||
    is( T == cent  )+/;
}

/**
 * Оценивается в да, если T является целым без знака.
 */
template типБЦел_ли( T )
{
    const бул типБЦел_ли = is( T == ббайт )  ||
    is( T == бкрат ) ||
    is( T == бцел )   ||
    is( T == бдол )/+||
    is( T == ucent  )+/;
}

/**
 * Оценивается в да, если T является целым со знаком или без знака.
 */
template типЦелЧис_ли( T )
{
    const бул типЦелЧис_ли = типЦел_ли!(T) ||
    типБЦел_ли!(T);
}

/**
 * Оценивается в да, если T является реальной дробью.
 */
template типРеал_ли( T )
{
    const бул типРеал_ли = is( T == плав )  ||
    is( T == дво ) ||
    is( T == реал );
}

/**
 * Оценивается в да, если T является комплексной дробью.
 */
template типКомплекс_ли( T )
{
    const бул типКомплекс_ли = is( T == кплав )  ||
    is( T == кдво ) ||
    is( T == креал );
}

/**
 * Оценивается в да, если T является мнимой дробью.
 */
template типМнимое_ли( T )
{
    const бул типМнимое_ли = is( T == вплав )  ||
    is( T == вдво ) ||
    is( T == вреал );
}

/**
 * Оценивается в да, если T любого дробного типа: реал, комплексное или
 * мнимое.
 */
template типДробь_ли( T )
{
    const бул типДробь_ли = типРеал_ли!(T)    ||
    типКомплекс_ли!(T) ||
    типМнимое_ли!(T);
}

/// да, если Т - атомного типа
template типАтом_ли(T)
{
    static if( is( T == бул )
               || is( T == сим )
               || is( T == шим )
               || is( T == дим )
               || is( T == байт )
               || is( T == крат )
               || is( T == цел )
               || is( T == дол )
               || is( T == ббайт )
               || is( T == бкрат )
               || is( T == бцел )
               || is( T == бдол )
               || is( T == плав )
               || is( T == дво )
               || is( T == реал )
               || is( T == вплав )
               || is( T == вдво )
               || is( T == вреал ) )
        const типАтом_ли = да;
    else
        const типАтом_ли = нет;
}

/**
 * Комплексный тип для данного типа
 */
template КомплексныйТипИз(T)
{
    static if(is(T==плав)||is(T==вплав)||is(T==кплав))
    {
        alias кплав КомплексныйТипИз;
    }
    else static if(is(T==дво)|| is(T==вдво)|| is(T==кдво))
    {
        alias кдво КомплексныйТипИз;
    }
    else static if(is(T==реал)|| is(T==вреал)|| is(T==креал))
    {
        alias креал КомплексныйТипИз;
    }
    else static assert(0,"неподдерживаемый тип в КомплексныйТипИз "~T.stringof);
}

/**
 * Реальный тип для данного типа
 */
template РеальныйТипИз(T)
{
    static if(is(T==плав)|| is(T==вплав)|| is(T==кплав))
    {
        alias плав РеальныйТипИз;
    }
    else static if(is(T==дво)|| is(T==вдво)|| is(T==кдво))
    {
        alias дво РеальныйТипИз;
    }
    else static if(is(T==реал)|| is(T==вреал)|| is(T==креал))
    {
        alias реал РеальныйТипИз;
    }
    else static assert(0,"неподдерживаемый тип в РеальныйТипИз "~T.stringof);
}

/**
 * Мнимый тип для данного типа
 */
template МнимыйТипИз(T)
{
    static if(is(T==плав)|| is(T==вплав)|| is(T==кплав))
    {
        alias вплав МнимыйТипИз;
    }
    else static if(is(T==дво)|| is(T==вдво)|| is(T==кдво))
    {
        alias вдво МнимыйТипИз;
    }
    else static if(is(T==реал)|| is(T==вреал)|| is(T==креал))
    {
        alias вреал МнимыйТипИз;
    }
    else static assert(0,"неподдерживаемый тип в МнимыйТипИз "~T.stringof);
}

/// Тип с максимальной точностью
template МаксПрецТипИз(T)
{
    static if (типКомплекс_ли!(T))
    {
        alias креал МаксПрецТипИз;
    }
    else static if (типМнимое_ли!(T))
    {
        alias вреал МаксПрецТипИз;
    }
    else
    {
        alias реал МаксПрецТипИз;
    }
}

/**
 * Оценивается в да, если T является указательным типом.
 */
template типУк_ли(T)
{
    const типУк_ли = нет;
}

template типУк_ли(T : T*)
{
    const типУк_ли = да;
}

debug( UnitTest )
{
    unittest
    {
        static assert( типУк_ли!(проц*) );
        static assert( !типУк_ли!(ткст) );
        static assert( типУк_ли!(ткст*) );
        static assert( !типУк_ли!(сим*[]) );
        static assert( типУк_ли!(реал*) );
        static assert( !типУк_ли!(бцел) );
        static assert( is(МаксПрецТипИз!(плав)==реал));
        static assert( is(МаксПрецТипИз!(кплав)==креал));
        static assert( is(МаксПрецТипИз!(вплав)==вреал));

        class Ham
        {
            ук  a;
        }

        static assert( !типУк_ли!(Ham) );

        union Eggs
        {
            ук  a;
            бцел  b;
        };

        static assert( !типУк_ли!(Eggs) );
        static assert( типУк_ли!(Eggs*) );

        struct Bacon {};

        static assert( !типУк_ли!(Bacon) );

    }
}

/**
 * Оценивается в да, если T является указателем, классом, интерфейсом или делегатом.
 */
template типСсылка_ли( T )
{

    const бул типСсылка_ли = типУк_ли!(T)  ||
    is( T == class )     ||
    is( T == interface ) ||
    is( T == delegate );
}

/**
 * Оценивается в да, если T типа динамический Массив.
 */
template типДинМас_ли( T )
{
    const бул типДинМас_ли = is( typeof(T.init[0])[] == T );
}

/**
 * Оценивается в да, если T является типом статического массива.
 */
version( GNU )
{
    // GDC should also be able в_ use the другой version, but it probably
    // relies on a frontend fix in one of the latest DMD versions - will
    // удали this when GDC is ready. For сейчас, this код пароль the unittests.
    private template экзТипаСтатМас( T )
    {
        const T экзТипаСтатМас = void;
    }

    template типСтатМас_ли( T )
    {
        static if( is( typeof(T.length) ) && !is( typeof(T) == typeof(T.init) ) )
        {
            const бул типСтатМас_ли = is( T == typeof(T[0])[экзТипаСтатМас!(T).length] );
        }
        else
        {
            const бул типСтатМас_ли = нет;
        }
    }
}
else
{
    template типСтатМас_ли( T : T[U], т_мера U )
    {
        const бул типСтатМас_ли = да;
    }

    template типСтатМас_ли( T )
    {
        const бул типСтатМас_ли = нет;
    }
}

/// Да для массивных типов
template типМассив_ли(T)
{
    static if (is( T U : U[] ))
        const бул типМассив_ли = да;
    else
        const бул типМассив_ли = нет;
}

debug( UnitTest )
{
    unittest
    {
        static assert( типСтатМас_ли!(сим[5][2]) );
        static assert( !типДинМас_ли!(сим[5][2]) );
        static assert( типМассив_ли!(сим[5][2]) );

        static assert( типСтатМас_ли!(сим[15]) );
        static assert( !типСтатМас_ли!(сим[]) );

        static assert( типДинМас_ли!(сим[]) );
        static assert( !типДинМас_ли!(сим[15]) );

        static assert( типМассив_ли!(сим[15]) );
        static assert( типМассив_ли!(сим[]) );
        static assert( !типМассив_ли!(сим) );
    }
}

/**
 * Оценивается в да, если T является функцией, указателем на функцию, делегатом или
 * иным вызываемым объектом.
 */
template ВызываемыйТип_ли( T )
{
    const бул ВызываемыйТип_ли = is( T == function )             ||
    is( typeof(*T) == function )    ||
    is( T == delegate )             ||
    is( typeof(T.opCall) == function );
}

/**
 * Оценивается в возвратный тип Фн.  Фн должно быть вызываемым типом (callable).
 */
template ВозвратныйТипИз( Фн )
{
    static if( is( Фн Возвр == return ) )
        alias Возвр ВозвратныйТипИз;
    else
        static assert( нет, "Аргумент не имеет возвратного типа." );
}

/**
 * Возвращает тип, в который будет оцениваться T в выражении.
 * Выраж не обязательно должно быть вызываемого типа.
 */
template ТипВыражениеИз( Выраж )
{
    static if(ВызываемыйТип_ли!( Выраж ))
        alias ВозвратныйТипИз!( Выраж ) ТипВыражениеИз;
    else
        alias Выраж ТипВыражениеИз;
}

/**
 * Оценивается в возвратный тип фн.  фн должно быть вызываемым типом (callable).
 */
template ВозвратныйТипИз( alias фн )
{
    static if( is( typeof(фн) База == typedef ) )
        alias ВозвратныйТипИз!(База) ВозвратныйТипИз;
    else
        alias ВозвратныйТипИз!(typeof(фн)) ВозвратныйТипИз;
}

/**
 * Оценивается в кортеж, представляющий параметры Фн.  Фн должна иметь вызываемый тип.
 */
template КортежПараметровИз( Фн )
{
    static if( is( Фн Парамы == function ) )
        alias Парамы КортежПараметровИз;
    else static if( is( Фн Парамы == delegate ) )
        alias КортежПараметровИз!(Парамы) КортежПараметровИз;
    else static if( is( Фн Парамы == Парамы* ) )
        alias КортежПараметровИз!(Парамы) КортежПараметровИз;
    else
        static assert( нет, "Аргумент не имеет параметров." );
}


/**
 * Оценивается в кортеж, представляющий параметры fn.  n должно быть
 * вызываемым.
 */
template КортежПараметровИз( alias фн )
{
    static if( is( typeof(фн) База == typedef ) )
        alias КортежПараметровИз!(База) КортежПараметровИз;
    else
        alias КортежПараметровИз!(typeof(фн)) КортежПараметровИз;
}


/**
 * Оценивается в кортеж, представляющий потомков Т.  Т должен быть
 * типом класс или интерфейс.
 */
template КортежТиповОсновУ( Т )
{
    static if( is( Т Основа == super ) )
        alias Основа КортежТиповОсновУ;
    else
        static assert( нет, "Аргумент не является ни классом, ни интерфейсом." );
}

/**
 * Удаляет []'ки с типа.
 */
template БазТипМассива(Т)
{
    static if( is( Т S : S[]) ) {
        alias БазТипМассива!(S)  БазТипМассива;
    }
    else {
        alias Т БазТипМассива;
    }
}

/**
 * Удаляет одну [] с типа
 */
template ТипЭлтовМассива(Т:Т[])
{
    alias Т ТипЭлтовМассива;
}

/**
 * Считает []'ки на типе массив
 */
template рангМассива(T)
{
    static if(is(T S : S[]))
    {
        const бцел рангМассива = 1 + рангМассива!(S);
    }
    else
    {
        const бцел рангМассива = 0;
    }
}

/// Тип ключей ассоциативного массива.
template ТипКлючаАМ(Т){
    alias typeof(Т.init.keys[0]) ТипКлючаАМ;
}

/// Тип значений ассоциативного массива.
template ТипЗначенияАМ(Т){
    alias typeof(Т.init.values[0]) ТипЗначенияАМ;
}

/// Возвращает размер статического Массива.
template размерСтатМассива(Т)
{
    static assert(типСтатМас_ли!(Т),"размерСтатМассива требует указать статический массив в качестве типа");
    static assert(рангМассива!(Т)==1,"реализовано только для массивов 1d...");
    const size_t размерСтатМассива=(Т).sizeof / typeof(Т.init).sizeof;
}

/// Если Т статический массив, возвращает динамический массив, иначе возвращает Т.
template ТипДинМас(Т)
{
    static if( типСтатМас_ли!(Т) )
        alias typeof(Т.dup) ТипДинМас;
    else
        alias Т ТипДинМас;
}

debug( UnitTest )
{
    static assert( is(БазТипМассива!(реал[][])==реал) );
    static assert( is(БазТипМассива!(реал[2][3])==реал) );
    static assert( is(ТипЭлтовМассива!(реал[])==реал) );
    static assert( is(ТипЭлтовМассива!(реал[][])==реал[]) );
    static assert( is(ТипЭлтовМассива!(реал[2][])==реал[2]) );
    static assert( is(ТипЭлтовМассива!(реал[2][2])==реал[2]) );
    static assert( рангМассива!(реал[][])==2 );
    static assert( рангМассива!(реал[2][])==2 );
    static assert( is(ТипЗначенияАМ!(сим[int])==сим));
    static assert( is(ТипКлючаАМ!(сим[int])==int));
    static assert( is(ТипЗначенияАМ!(сим[][int])==сим[]));
    static assert( is(ТипКлючаАМ!(сим[][int[]])==int[]));
    static assert( типАссоцМас_ли!(сим[][int[]]));
    static assert( !типАссоцМас_ли!(сим[]));
    static assert( is(ТипДинМас!(сим[2])==ТипДинМас!(сим[])));
    static assert( is(ТипДинМас!(сим[2])==сим[]));
    static assert( размерСтатМассива!(сим[2])==2);
}


// ------- CTFE -------

/// компилируй время целое в_ ткст
сим[] ctfe_i2a(цел i)
{
    ткст цифра="0123456789";
    ткст рез="";
    if (i==0)
    {
        return "0";
    }
    бул отриц = нет;
    if (i<0)
    {
        отриц = да;
        i=-i;
    }
    while (i>0)
    {
        рез = цифра[i%10]~рез;
        i/=10;
    }
    if (отриц)
        return '-'~рез;
    else
        return рез;
}
/// описано
сим[] ctfe_i2a(дол i)
{
    ткст цифра="0123456789";
    ткст рез="";
    if (i==0)
    {
        return "0";
    }
    бул отриц = нет;
    if (i<0)
    {
        отриц = да;
        i=-i;
    }
    while (i>0)
    {
        рез=цифра[cast(т_мера)(i%10)]~рез;
        i/=10;
    }
    if (отриц)
        return '-'~рез;
    else
        return рез;
}
/// описано
сим[] ctfe_i2a(бцел i)
{
    ткст цифра="0123456789";
    ткст рез="";
    if (i==0)
    {
        return "0";
    }
    бул отриц = нет;
    while (i>0)
    {
        рез=цифра[i%10]~рез;
        i/=10;
    }
    return рез;
}
/// описано
сим[] ctfe_i2a(бдол i)
{
    ткст цифра="0123456789";
    ткст рез="";
    if (i==0)
    {
        return "0";
    }
    бул отриц = нет;
    while (i>0)
    {
        рез = цифра[cast(т_мера)(i%10)]~рез;
        i/=10;
    }
    return рез;
}

debug( UnitTest )
{
    unittest
    {
        static assert( ctfe_i2a(31)=="31" );
        static assert( ctfe_i2a(-31)=="-31" );
        static assert( ctfe_i2a(14u)=="14" );
        static assert( ctfe_i2a(14L)=="14" );
        static assert( ctfe_i2a(14UL)=="14" );
    }
}