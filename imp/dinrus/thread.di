/**
* Модуль для работы с потоками и фибрами языка Динрус.
* Разработчик Виталий Кулич.
*/
module thread;
pragma(lib,"DinrusX86.lib");


 /// точка входа для нитей на Windows
extern (Windows) бцел нить_точкаВхода( ук арг );
extern (Windows)	ук ДайДескрТекущейНити();

/**
     * В этом классе собрана вся функциональность Динрус, связанная с потоками.
     * Так как управление нитями - важное средство для сборки мусора,
     * все нити пользователя должны происходить от данного класса,
     * а экземпляры данного класса не могут удаляться непосредственно.
     * Новая нить может быть создана либо с использованием деривации, либо композиции,
     * как показано в следующем примере.
     *
     * Пример:
     * -----------------------------------------------------------------------------
     *
     * class ПроизводнаяНить : Нить
     * {
     *     this()
     *     {
     *         super( &пуск );
     *     }
     *
     * private :
     *     проц пуск()
     *     {
     *         скажинс( "Запущена производная нить.\n" );
     *     }
     * }
     *
     * проц функцНити()
     * {
     *     скажинс( "Компонированная нить выполняется.\n" );
     * }
     *
     * // создание экземпляров каждого типа
     * Нить производная = new ПроизводнаяНить();
     * Нить компонированная = new Нить( &функцНити );
     *
     * // старт обеих нитей
     * производная.старт();
     * компонированная.старт();
     *
     * -----------------------------------------------------------------------------
     */
extern (D)	class Нить
{

    this( проц function() fn, т_мера разм = 0 );
        /**
         * Инициализует объект нити, связанный с динамической функцией
         * Динрус.
         *
         * Параметры:
         *  дг = Функция нити.
         *  разм = Размер стека для этой нити.
         *
         * In:
         *  дг не должно быть null.
         */
    this( проц delegate() дг, т_мера разм = 0 );
        /**
         * Очищает остатки ресурсов, использованных объектом.
         */
    ~this();
        /**
         * Запускает нить и вызывает функцию или делегат,
         * переданный при конструкции.
         *
         * In:
         *  Процедура может вызываться лишь единожды на экземпляр.
         *
         * Выбрасывает:
         *  ОшибкаНити, если старт не удаётся.
         */
    final проц старт()	;
        /**
        * Ждёт завершения данной нити.  Если нить завершилась как
         * результат необработанного исключения, это исключение повторно выводится.
         *
         * Параметры:
         *  повторноБросить = Повторно бросить необраб. искл., которое могло быть
         *            причиной преркащения работы этой нити.
         *
         * Выводит:
         *  ОшибкаНити,
		 * если операция не удалась.
         *  Любое исключение, необработанное нитью присоединения.
         *
         * Возвращает:
         *  Любое необработанное этой нитью исключение, если повторноБросить = нет,
         * null - в ином случае.
         */
    final Объект присоедини( бул rethrow = да );
        /**
         * Получить удобочитаемый лейбл для этой нити.
         *
         * Возвращает:
         *  Имя этой нити.
         */
    final ткст имя();
        /**
         * Установить удобочитаемый лейбл для этой нити.
         *
         * Параметры:
         *  знач = Новое имя этой нити.
         */
    final проц имя( ткст знач );
        /**
         * Получает статус демона для этой нити. В то время как рантайм ждёт
         * завершения работы всех нормальных потоков прежде чем  завершить процесс,
         * потоки-демоны эффективно игнорируются и это не защищает процесс
         * от завершения. На деле потоки-демоны автоматически прекращаются
         * операционной системой при выходе из процесса.
         *
         * Возвращает:
         *  да, если это поток-демон.
         */
    final бул демон();
        /**
         * Устанавливает этой нити статус демона.  В то время как рантайм ждёт
         * завершения работы всех нормальных потоков прежде чем  завершить процесс,
         * потоки-демоны эффективно игнорируются и это не защищает процесс
         * от завершения. На деле потоки-демоны автоматически прекращаются
         * операционной системой при выходе из процесса.
         *
         * Параметры:
         *  знач = Новый статус демона для этой нити.
         */
    final проц демон( бул знач );
        /**
         * Проверяет, выполняется ли эта нить.
         *
         * Возвращает:
         *  да, если нить выполняется, нет, если иначе.
         */
    final бул пущена();
        /**
         * Минимальный планировочный приоритет, который может быть установлен для нити.
         * На системах с определением нескольких планировочных политик, это значение
         * представляет минимальный валидный приоритет для планировочной политики
         * этого процесса.
         */
    static const цел МИНПРИОР;
        /**
         * Максимальный планировочный приоритет, который может быть установлен для нити.
         * На системах с определением нескольких планировочных политик, это значение
         * представляет максимальный валидный приоритет для планировочной политики
         * этого процесса.
         */
    static const цел МАКСПРИОР;
        /**
         *  Выводит планируемый приоритет для связанной с ней нити.
         *
         * Возвращает:
         *  планируемый приоритет для данной нити.
         */
    final цел приоритет();
        /**
         * Устанавливает планируемый приоритет для связанной с ней нити.
         *
         * Параметры:
         *  знач = новый планируемый приоритет для данной нити.
         */
    final проц приоритет( цел знач );
        /**
         * Замораживает вызывающую нить на указанное время, вплоть до
         * максимума (бцел.max - 1) миллисекунд.
         *
         * Параметры:
         *  период = Минимальная продолжительность для заморозки вызывающей нити,
         *           в сек.  Промежутки времени менее секунды задаются как
         *           дробные значения
         * Вход:
         *  период должен быть менее (бцел.max - 1) миллисек.
         *
         * Пример:
         * -------------------------------------------------------------------------
         *
         * Нить.спи( 0.05 ); // "спать" 50 миллисек
         * Нить.спи( 5 );    // спать 5 сек
         *
         * -------------------------------------------------------------------------
         */
    static проц спи( дво период );
        /**
         * Заставляет переключатель контекста оказываться подалее от вызывающей нити.
         */
    static проц жни();
        /**
         * Предаставляет ссылку на вызывающую нить.
         *
         * Возвращает:
         *  Поточный объект, представляющий взывающую нить.
		 * Результат удаления этого объекта непредсказуем.
         */
    static Нить дайЭту();
        /**
         * Представляет список всех нитей, в данный момент отслеживаемых системой.
         *
         * Возвращает:
         *  Массив, содержащий ссылки на все нити, в данный момент отслеживаемые
         *  системой. Результат удаления любого из этих объектов
         *  неизвестен.
         */
    static Нить[] дайВсе();
    static цел opApply( цел delegate( ref  Нить ) дг );

    static const бцел МАКСЛОК = 64;

    static бцел создайЛок();
    static проц удалиЛок( бцел ключ );
    static ук дайЛок( бцел ключ );
    static ук устЛок( бцел ключ, ук знач );

    static this()
    {
        МИНПРИОР = -15;
        МАКСПРИОР =  15;

    }
private:
        //
        // Инициализует объек Нить, не связанный ни с какой исполнимой функцией.
        // Используется для главной нити, инициализированной в нить_иниц().
        //
    this();
        //
        // Точка входа в Нить. Вызывает функцию или делегата, переданного при
        // конструкции (если он передан!).
        //
    final проц пуск();

    //
    // Тип процедуры, передаваемой при конструкции нити.
    //
    enum Вызов
    {
        НЕТ,
        ФН,
        ДГ
    }

    //
    // Стандартные типы
    //

    alias бцел КлючНЛХ;
    alias бцел АдрНити;

    //
    // Локальное хранилище
    //
    static бул[МАКСЛОК]  см_локал;
    static КлючНЛХ           см_эта;

    ук[МАКСЛОК]        м_локал;


    //
    // Стандартные данные нити
    //
    version( Win32 )
    {
        ук          м_дескр;
    }
    public АдрНити          м_адр;
    Вызов                м_вызов;
    ткст              м_имя;
    union
    {
        проц function() м_фн;
        проц delegate() м_дг;
    }
    т_мера              м_рр;
    version( Posix )
    {
        бул            м_пущена;
    }
    бул                м_демон;
    public Объект              м_необработ;
        //
        // Устанавливает нителокальную ссылку на текущий объект нити.
        //
    static проц установиЭту( Нить t );
    final проц суньКонтекст( Контекст* c );
    final проц выньКонтекст();
    public final Контекст* топКонтекст();

    public static struct Контекст
    {
        ук           нстэк,
        встэк;
        Контекст*        внутри;
        Контекст*        следщ,
        предщ;
    }


    Контекст             м_глав;
    Контекст*            м_тек;
    бул                м_блок;

    version( Win32 )
    {
        бцел[8]         м_рег; // edi,esi,ebp,esp,ebx,edx,ecx,eax
    }

    static Объект slock();

    static Контекст*     см_кнач;
    static т_мера       см_кдлин;

    static Нить       см_ннач;
    static т_мера       см_ндлин;

    //
    // Используется для упорядочивания нитей в глобальном списке.
    //
    Нить              предщ;
    Нить              следщ;
////////////////////////////////////////////////////////////////////////////
        // Операции с Глобальным Списком Контекстов
        ////////////////////////////////////////////////////////////////////////////


        //
        // Добавить контекст в глобальный список контекстов.
        //
    static проц добавь( Контекст* c );
        //
        // Удалить контекст из глобального списка контекстов.
        //
    static проц удали( Контекст* c );
////////////////////////////////////////////////////////////////////////////
        // Операции с Глобальным Списком Нитей
        ////////////////////////////////////////////////////////////////////////////


        //
        // Добавить нить в глобальный список нитей.
        //
    static проц добавь( Нить t );
        //
        // Удалить нить из списка.
        //
    static проц удали( Нить t );

}


class НитьЛок( T )
{
    this( T def = T.init )
    {
        м_деф = def;
        м_ключ = Нить.создайЛок();
    }

    ~this()
    {
        Нить.удалиЛок( м_ключ );
    }

    T знач()
    {
        Обёртка* wrap = cast(Обёртка*) Нить.дайЛок( м_ключ );

        return wrap ? wrap.знач : м_деф;
    }

    T знач( T newval )
    {
        Обёртка* wrap = cast(Обёртка*) Нить.дайЛок( м_ключ );

        if( wrap is null )
        {
            wrap = new Обёртка;
            Нить.устЛок( м_ключ, wrap );
        }
        wrap.знач = newval;
        return newval;
    }

private:

    struct Обёртка
    {
        T   знач;
    }

    T       м_деф;
    бцел    м_ключ;
}

extern (D)	class ГруппаНитей
{

    final Нить создай( проц function() фн );
    final Нить создай( проц delegate() дг );
    final проц добавь( Нить t );
    final проц удали( Нить t );
    final цел opApply( цел delegate( ref  Нить ) дг );
    final проц объединиВсе( бул rethrow = да );
}

extern (D) class Фибра
{
    static class Планировщик
    {
        alias ук Дескр;

        enum Тип {Чтение =1, Запись=2, Приём=3, Подключение=4, Трансфер=5}

        проц пауза (бцел ms);
        проц готов (Фибра fiber);
        проц открой (Дескр fd, ткст имя);
        проц закрой (Дескр fd, ткст имя);
        проц ожидай (Дескр fd, Тип t, бцел timeout);
        проц ответви (ткст имя, проц delegate() дг, т_мера stack=8192);
    }

    final static Планировщик планировщик ();

    this(т_мера разм);
    this( проц function() fn, т_мера разм = РАЗМЕР_СТРАНИЦЫ);
    this( проц delegate() дг, т_мера разм = РАЗМЕР_СТРАНИЦЫ, Планировщик s = пусто );
    ~this();
    final Object вызови( бул rethrow = да );
    final проц сбрось();
    final проц сбрось( проц function() фн );
    final проц сбрось( проц delegate() дг );
    final проц сотри();
    final проц глуши ();
    static проц жни();
    static проц жниИБросай( Объект объ );
    static Фибра дайЭту();
    final проц пуск();

    enum Состояние
    {
        ЗАДЕРЖ,   ///
        ВЫП,   ///
        ТЕРМ    ///
    }

    struct Событие
    {
        бцел             инд;           // поддержка удаления таймера
        Фибра            следщ;          // линкованный список просроченных фибр
        ук            данные;          // данные для обмена
        бдол            время;         // требуемая продолжительность таймаута
        Планировщик.Дескр хэндл;        // хэндл запроса на ввод-вывод
        Планировщик        планировщик;     // ассоциированный планировщик (м. б. пусто)
    }

    final Состояние состояние();

    т_мера размерСтэка();


    enum Вызов
    {
        НЕТ,
        ФН,
        ДГ
    }


    //
    // Стандартные данные фибры
    //
    Вызов                м_вызов;
    union
    {
        проц function() м_фн;
        проц delegate() м_дг;
    }
    бул                м_пущена;
    Объект              м_необработ;
    Состояние               м_состояние;
    ткст              м_имя;
public:
    Событие               событие;

    final проц разместиСтэк( т_мера разм );
    final проц освободиСтэк();
    final проц инициализуйСтэк();

    public Нить.Контекст* м_кткст;
    public т_мера          м_разм;
    ук           м_пам;

    static проц установиЭту( Фибра f );
    final проц подключись();
    final проц отключись();

}

extern (C)
{
    проц фибра_точкаВхода();
    проц фибра_переклКонтекст( ук* старук, ук новук );

    проц нить_жни();
    проц нить_спи(дво период);

    проц нить_иниц();
    проц нить_прикрепиЭту();
    проц нить_открепиЭту();
    проц нить_объединиВсе();
    бул нить_нужнаБлокировка();
    проц нить_заморозьВсе();
    проц нить_разморозьВсе();
    проц нить_сканируйВсе( фнСканВсеНити скан, ук текВерхСтека = null );

}
