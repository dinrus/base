/*******************************************************************************
        Поддержка форматирования значений дата/время, локале-специфичным
        образом. Смотрите МестнДатаВремя.форматируй() с описанием процесса
        выполнения форматирования (ниже).

        Справочные ссылки:
        ---
        http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html
        http://msdn.microsoft.com/en-us/library/system.globalization.datetimeformatinfo(VS.71).aspx
        ---

******************************************************************************/

module text.convert.DateTime;

private import  exception;
private import  time.WallClock;
private import  time.chrono.Calendar,
        time.chrono.Gregorian;

private import  Utf = text.convert.Utf;
private import  Целое = text.convert.Integer;

/******************************************************************************

        O/S specifics

******************************************************************************/

version (Windows)
private import sys.common;
/******************************************************************************

        Дефолтный экземпляр МестнДатаВремя

******************************************************************************/

public МестнДатаВремя ДефДатаВремя;

static this()
{
    ДефДатаВремя = МестнДатаВремя.создай;
}

/******************************************************************************

       Как форматировать локале-специфичный вывод дата/время

******************************************************************************/

 struct МестнДатаВремя
{
    static ткст   образецРФС1123 = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'";
    static ткст   сортируемыйОбразецДатыВремени = "yyyy'-'MM'-'dd'T'HH':'mm':'ss";
    static ткст   универсальныйСортируемыйОбразецДатыВремени = "yyyy'-'MM'-'dd' 'HH':'mm':'ss'Z'";

    Календарь        назначенныйКалендарь;

    ткст          краткийОбразецДаты,
    краткийОбразецВремени,
    длинныйОбразецДаты,
    длинныйОбразецВремени,
    полныйОбразецДатыВремени,
    общКраткийОбразецВремени,
    общДлинныйОбразецВремени,
    образецДняМесяца,
    образецМесяцаГода;

    ткст          определительДоПолудня,
    определительПослеПолудня;

    ткст          разделительВремени,
    разделительДаты;

    ткст[]        именаДней,
    именаМесяцев,
    сокращённыеИменаДней,
    сокращённыеИменаМесяцев;

    /**********************************************************************

            Форматирует данное значение Время под предоставленный вывод,
            используя заданную выкладку. Выкладка может быть генерным
            вариантом или кастомным, где дженерики указываются одним
            символом:

            <pre>
            "t" = 7:04
            "T" = 7:04:02 PM
            "d" = 3/30/2009
            "D" = Понедельник, March 30, 2009
            "f" = Понедельник, March 30, 2009 7:04 PM
            "F" = Понедельник, March 30, 2009 7:04:02 PM
            "g" = 3/30/2009 7:04 PM
            "G" = 3/30/2009 7:04:02 PM
            "y"
            "Y" = March, 2009
            "r"
            "R" = Mon, 30 Mar 2009 19:04:02 GMT
            "s" = 2009-03-30T19:04:02
            "u" = 2009-03-30 19:04:02Z
            </pre>

            Для локали US, эти генерные выкладки разворачиваются 
            следующим образом:

            <pre>
            "t" = "h:mm"
            "T" = "h:mm:ss tt"
            "d" = "M/d/yyyy"
            "D" = "dddd, MMMM d, yyyy"
            "f" = "dddd, MMMM d, yyyy h:mm tt"
            "F" = "dddd, MMMM d, yyyy h:mm:ss tt"
            "g" = "M/d/yyyy h:mm tt"
            "G" = "M/d/yyyy h:mm:ss tt"
            "y"
            "Y" = "MMMM, yyyy"
            "r"
            "R" = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"
            "s" = "yyyy'-'MM'-'dd'T'HH':'mm':'ss"
            "u" = "yyyy'-'MM'-'dd' 'HH':'mm':'ss'Z'"
            </pre>

            Кастомные выкладки конструируются с использованием комбинации
            символьных кодов, указанных справа, вверху. Например,
            выкладка  "dddd, dd MMM yyyy HH':'mm':'ss zzzz" выльется в
            нечто подобное:
            ---
            Понедельник, 30 Мар 2009 19:04:02 -08:00
            ---

            Использование этих индикаторов формата с Выкладкой (Стдвыв и т.д.)
            прямолинейно.Форматирование целочисленных, например, делается
            так:
            ---
            Стдвыв.форматнс ("{:u}", 5);
            Стдвыв.форматнс ("{:b}", 5);
            Стдвыв.форматнс ("{:x}", 5);
            ---

            Форматирование значения дата/время похоже, где индикаторы
            формата предоставлены после двоеточия:
            ---
            Стдвыв.форматнс ("{:t}", Часы.сейчас);
            Стдвыв.форматнс ("{:D}", Часы.сейчас);
            Стдвыв.форматнс ("{:dddd, dd MMMM yyyy HH:mm}", Часы.сейчас);
            ---

    **********************************************************************/

    ткст форматируй (ткст вывод, Время датаВремя, ткст выкладка)
    {
        // по умолчанию общий формат
        if (выкладка.length is 0)
            выкладка = "G";

        // может быть одним из наших сокращений
        if (выкладка.length is 1)
            выкладка = разверниИзвестныйФормат (выкладка);

        auto рез=Результат(вывод);
        return форматируйОсобо (рез, датаВремя, выкладка);
    }

    /**********************************************************************

    **********************************************************************/

    T[] шФормат(T) (T[] вывод, Время датаВремя, T[] фмт)
    {
        static if (is (T == сим))
            return форматируй (вывод, датаВремя, фмт);
        else
        {
            сим[128] tmp0 =void;
            сим[128] tmp1 =void;
            return Utf.изТкст8(форматируй(tmp0, датаВремя, Utf.вТкст(фмт, tmp1)), вывод);
        }
    }

    /**********************************************************************

            Вернуть генерный экземпляр Russian/RU.

    **********************************************************************/

     static МестнДатаВремя* генерный ()
    {
        return &RuRU;
    }

    /**********************************************************************

            Вернуть назначенный экземпляр Календаря, используя Грегорианский
            по умолчанию.

    **********************************************************************/

     Календарь календарь ()
    {
        if (назначенныйКалендарь is пусто)
            назначенныйКалендарь = Грегориан.генерный;
        return назначенныйКалендарь;
    }

    /**********************************************************************

            Вернуть краткое имя дня.

    **********************************************************************/

     ткст сокращённоеИмяДня (Календарь.ДеньНедели деньНедели)
    {
        return сокращённыеИменаДней [cast(цел) деньНедели];
    }

    /**********************************************************************

           Вернуть длинное имя дня.

    **********************************************************************/

     ткст имяДня (Календарь.ДеньНедели деньНедели)
    {
        return именаДней [cast(цел) деньНедели];
    }

    /**********************************************************************

            Вернуть краткое имя месяца.

    **********************************************************************/

     ткст сокращённоеИмяМесяца (цел месяц)
    {
        assert (месяц > 0 && месяц < 13);
        return сокращённыеИменаМесяцев [месяц - 1];
    }

    /**********************************************************************

            Вернуть длинное имя месяца.

    **********************************************************************/

     ткст имяМесяца (цел месяц)
    {
        assert (месяц > 0 && месяц < 13);
        return именаМесяцев [месяц - 1];
    }

    version (Windows)
    {
        /**********************************************************************

                Cоздать и наполнить экземпляр посредством ОС конфигурации
                для текущего пользователя.

        **********************************************************************/

        static МестнДатаВремя создай ()
        {
            static ткст вТкст (ткст приёмн, ЛКИД ид, т_локаль тип)
            {
                шим[256] шир =void;

                auto длин = ДайИнфОЛокале (ид, тип, пусто, 0);
                if (длин && длин < шир.length)
                {
                    ДайИнфОЛокале (ид, тип, шир.ptr, шир.length);
                    длин = ШирСимВМультиБайт(ПКодСтр.УТФ8, ПШирСим.ОтдельнСимв, шир.ptr, длин-1,
                                                    cast(PCHAR)приёмн.ptr, приёмн.length,
                                                    пусто, 0);
                    return приёмн [0..длин].dup;
                }
                throw new Исключение ("ДатаВремя :: GetLocaleInfo неудачно");
            }

            МестнДатаВремя дв;
            сим[256] врем =void;
            auto лкид = ПИдЛокали.ПользовательскийДефолт;

            for (auto i=ПЛокаль.SDAYNAME1; i <= ПЛокаль.SDAYNAME7; ++i)
                дв.именаДней ~= вТкст (врем, лкид, i);

            for (auto i=ПЛокаль.SABBREVDAYNAME1; i <= ПЛокаль.SABBREVDAYNAME7; ++i)
                дв.сокращённыеИменаДней ~= вТкст (врем, лкид, i);

            for (auto i=ПЛокаль.SMONTHNAME1; i <= ПЛокаль.SMONTHNAME12; ++i)
                дв.именаМесяцев ~= вТкст (врем, лкид, i);

            for (auto i=ПЛокаль.SABBREVMONTHNAME1; i <= ПЛокаль.SABBREVMONTHNAME12; ++i)
                дв.сокращённыеИменаМесяцев ~= вТкст (врем, лкид, i);

            дв.разделительДаты    = вТкст (врем, лкид, ПЛокаль.SDATE);
            дв.разделительВремени    = вТкст (врем, лкид, ПЛокаль.STIME);
            дв.определительДоПолудня     = вТкст (врем, лкид, ПЛокаль.S1159);
            дв.определительПослеПолудня     = вТкст (врем, лкид, ПЛокаль.S2359);
            дв.длинныйОбразецДаты  = вТкст (врем, лкид, ПЛокаль.SLONGDATE);
            дв.краткийОбразецДаты = вТкст (врем, лкид, ПЛокаль.SSHORTDATE);
            дв.образецМесяцаГода = вТкст (врем, лкид, ПЛокаль.SYEARMONTH);
            дв.длинныйОбразецВремени  = вТкст (врем, лкид, ПЛокаль.STIMEFORMAT);

            // синтезируем краткое время
            auto s = дв.краткийОбразецВремени = дв.длинныйОбразецВремени;
            for (auto i=s.length; i--;)
                if (s[i] is дв.разделительВремени[0])
                {
                    дв.краткийОбразецВремени = s[0..i];
                    break;
                }

            дв.полныйОбразецДатыВремени = дв.длинныйОбразецДаты ~ " " ~
                    дв.длинныйОбразецВремени;
            дв.общДлинныйОбразецВремени = дв.краткийОбразецДаты ~ " " ~
                    дв.длинныйОбразецВремени;
            дв.общКраткийОбразецВремени = дв.краткийОбразецДаты ~ " " ~
                    дв.краткийОбразецВремени;
            return дв;
        }
    }
    else
    {
        /**********************************************************************

                Создаёт и заполняет экземпляр с помощью конфигурации ОС
                для текущего пользователя.

        **********************************************************************/

         static МестнДатаВремя создай ()
        {
            //выкинуть разделитель
            static ткст откиньРазделитель(ткст стр, ткст def)
            {
                for (auto i = 0; i < стр.length; ++i)
                {
                    сим c = стр[i];
                    if ((c == '%') || (c == ' ') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
                        continue;
                    return стр[i..i+1].dup;
                }
                return def;
            }

            static ткст дайТкст(nl_item ид, ткст def = пусто)
            {
                сим* p = nl_langinfo(ид);
                return p ? изТкст0(p).dup : def;
            }

            static ткст дайТкстФормата(nl_item ид, ткст def = пусто)
            {
                ткст posix_str = дайТкст(ид, def);
                return преобразуй(posix_str);
            }

            МестнДатаВремя дв;

            for (auto i = DAY_1; i <= DAY_7; ++i)
                дв.именаДней ~= дайТкст (i);

            for (auto i = ABDAY_1; i <= ABDAY_7; ++i)
                дв.сокращённыеИменаДней ~= дайТкст (i);

            for (auto i = MON_1; i <= MON_12; ++i)
                дв.именаМесяцев ~= дайТкст (i);

            for (auto i = ABMON_1; i <= ABMON_12; ++i)
                дв.сокращённыеИменаМесяцев ~= дайТкст (i);

            дв.определительДоПолудня = дайТкст (AM_STR, "AM");
            дв.определительПослеПолудня = дайТкст (PM_STR, "PM");

            дв.длинныйОбразецДаты = "dddd, MMMM d, yyyy"; //default
            дв.краткийОбразецДаты = дайТкстФормата(D_FMT, "M/d/yyyy");

            дв.длинныйОбразецВремени = дайТкстФормата(T_FMT, "h:mm:ss tt");
            дв.краткийОбразецВремени = "h:mm"; //default

            дв.образецМесяцаГода = "MMMM, yyyy"; //no posix equivalent?
            дв.полныйОбразецДатыВремени = дайТкстФормата(D_T_FMT, "dddd, MMMM d, yyyy h:mm:ss tt");

            дв.разделительДаты = откиньРазделитель(дв.краткийОбразецДаты, "/");
            дв.разделительВремени = откиньРазделитель(дв.длинныйОбразецВремени, ":");

            //выкинуть краткийОбразецВремени из длинныйОбразецВремени
            for (auto i = дв.длинныйОбразецВремени.length; i--;)
            {
                if (дв.длинныйОбразецВремени[i] == дв.разделительВремени[$-1])
                {
                    дв.краткийОбразецВремени = дв.длинныйОбразецВремени[0..i];
                    break;
                }
            }

            //выкинуть длинныйОбразецДаты из полныйОбразецДатыВремени
            auto поз = дв.полныйОбразецДатыВремени.length - дв.длинныйОбразецВремени.length - 2;
            if (поз < дв.полныйОбразецДатыВремени.length)
                дв.длинныйОбразецДаты = дв.полныйОбразецДатыВремени[0..поз];

            дв.полныйОбразецДатыВремени = дв.длинныйОбразецДаты ~ " " ~ дв.длинныйОбразецВремени;
            дв.общДлинныйОбразецВремени = дв.краткийОбразецДаты ~ " " ~  дв.длинныйОбразецВремени;
            дв.общКраткийОбразецВремени = дв.краткийОбразецДаты ~ " " ~  дв.краткийОбразецВремени;

            return дв;
        }

        /**********************************************************************

                Преобразует формат даты-времени POSIX в синтаксис .NET.

        **********************************************************************/

        private static ткст преобразуй(ткст фмт)
        {
            сим[32] возвр;
            т_мера длин;

            проц помести(ткст стр)
            {
                assert((длин+стр.length) <= возвр.length);
                возвр[длин..длин+стр.length] = стр;
                длин += стр.length;
            }

            for (auto i = 0; i < фмт.length; ++i)
            {
                сим c = фмт[i];

                if (c != '%')
                {
                    assert((длин+1) <= возвр.length);
                    возвр[длин] = c;
                    длин += 1;
                    continue;
                }

                i++;
                if (i >= фмт.length)
                    break;

                c = фмт[i];
                switch (c)
                {
                case 'a': //сокращ1нное имя дня недели локали.
                    помести("ddd"); //Сокращённое имя дня недели.
                    break;

                case 'A': //полное имя дня недели локали.
                    помести("dddd");
                    break;

                case 'b': //сокращённое имя месяца локали.
                    помести("MMM");
                    break;

                case 'B': //полное имя месяца локали.
                    помести("MMMM");
                    break;

                case 'd': //день месяца как десятичное число [01,31]
                    помести("dd"); // Этот день месяца. Дни с
                    //одной цифрой в начале получают ноль.
                    break;

                case 'D': //то же что и %m/%d/%y.
                    помести("MM/dd/yy");
                    break;

                case 'e': //день месяца как десяток число [1,31];
                    //a single цифра is preceded by a пространство
                    помести("d"); //The день месяца. Single-цифра дни
                    //will not have a leading zero.
                    break;

                case 'h': //same as %b.
                    помести("MMM");
                    break;

                case 'H':
                    //час (24-час clock) как десяток число [00,23]
                    помести("HH"); //The час in a 24-час clock. Single-цифра
                    //часы will have a leading zero.
                    break;

                case 'I': //the час (12-час clock) как десяток число [01,12]
                    помести("hh"); //The час in a 12-час clock.
                    //Single-цифра часы will have a leading zero.
                    break;

                case 'm': //месяц как десяток число [01,12]
                    помести("MM"); //The numeric месяц. Single-цифра
                    //месяцы will have a leading zero.
                    break;

                case 'M': //минута как десяток число [00,59]
                    помести("mm"); //The минута. Single-цифра минуты
                    //will have a leading zero.
                    break;

                case 'n': //нс character
                    помести("\n");
                    break;

                case 'p': //локаль's equivalent of either a.m. or p.m
                    помести("tt");
                    break;

                case 'r': //время in a.m. и p.m. notation;
                    //equivalent в_ %I:%M:%S %p.
                    помести("hh:mm:ss tt");
                    break;

                case 'R': //время in 24 час notation (%H:%M)
                    помести("HH:mm");
                    break;

                case 'S': //секунда как десяток число [00,61]
                    помести("ss"); //The секунда. Single-цифра сек
                    //will have a leading zero.
                    break;

                case 't': //tab character.
                    помести("\t");
                    break;

                case 'T': //equivalent в_ (%H:%M:%S)
                    помести("HH:mm:ss");
                    break;

                case 'u': //weekday как десяток число [1,7],
                //with 1 representing Понедельник
                case 'U': //week число of the год
                //(Воскресенье as первый день недели) как десяток число [00,53]
                case 'З': //week число of the год
                //(Понедельник as первый день недели) как десяток число [01,53].
                //If the week containing 1 January имеется four or ещё дни
                //in the new год, then it is consопрered week 1.
                //Otherwise, it is the последний week of the previous год, и the следщ week is week 1.
                case 'w': //weekday как десяток число [0,6], with 0 representing Воскресенье
                case 'W': //week число of the год (Понедельник as первый день недели)
                //как десяток число [00,53].
                //все дни in a new год preceding the первый Понедельник
                //are consопрered в_ be in week 0.
                case 'x': //локаль's appropriate дата представление
                case 'X': //локаль's appropriate время представление
                case 'c': //локаль's appropriate дата и время представление
                case 'C': //century число (the год divопрed by 100 и
                //truncated в_ an целое) как десяток число [00-99]
                case 'j': //день годв как десяток число [001,366]
                    assert(0);
                    break;

                case 'y': //год without century как десяток число [00,99]
                    помести("yy"); // The год without the century. If the год without
                    //the century is less than 10, the год is displayed with a leading zero.
                    break;

                case 'Y': //год with century как десяток число
                    помести("yyyy"); //The год in four цифры, включая the century.
                    break;

                case 'Z': //timezone имя or abbreviation,
                    //or by no байты if no timezone information есть_ли
                    //assert(0);
                    break;

                case '%':
                    помести("%");
                    break;

                default:
                    assert(0);
                }
            }
            return возвр[0..длин].dup;
        }
    }

    /**********************************************************************

    **********************************************************************/

    private ткст разверниИзвестныйФормат (ткст формат)
    {
        ткст f;

        switch (формат[0])
        {
        case 'd':
            f = краткийОбразецДаты;
            break;
        case 'D':
            f = длинныйОбразецДаты;
            break;
        case 'f':
            f = длинныйОбразецДаты ~ " " ~ краткийОбразецВремени;
            break;
        case 'F':
            f = полныйОбразецДатыВремени;
            break;
        case 'g':
            f = общКраткийОбразецВремени;
            break;
        case 'G':
            f = общДлинныйОбразецВремени;
            break;
        case 'r':
        case 'R':
            f = образецРФС1123;
            break;
        case 's':
            f = сортируемыйОбразецДатыВремени;
            break;
        case 'u':
            f = универсальныйСортируемыйОбразецДатыВремени;
            break;
        case 't':
            f = краткийОбразецВремени;
            break;
        case 'T':
            f = длинныйОбразецВремени;
            break;
        case 'y':
        case 'Y':
            f = образецМесяцаГода;
            break;
        default:
            return ("'{время в формате непригодно}'");
        }
        return f;
    }

    /**********************************************************************

    **********************************************************************/

    private ткст форматируйОсобо (ref Результат результат, Время датаВремя, ткст форматируй)
    {
        бцел            длин,
        деньгода,
        деньнед,
        эра;
        бцел            день,
        год,
        месяц;
        цел             индекс;
        сим[10]        врем =void;
        auto            время = датаВремя.время;

        // выкинь дата components
        календарь.разбей (датаВремя, год, месяц, день, деньгода, деньнед, эра);

        // смети форматируй specifiers ...
        while (индекс < форматируй.length)
        {
            сим c = форматируй[индекс];

            switch (c)
            {
            // день
            case 'd':
                длин = повториРазбор (форматируй, индекс, c);
                if (длин <= 2)
                    результат ~= форматируйЦел (врем, день, длин);
                else
                    результат ~= форматируйДеньНедели (cast(Календарь.ДеньНедели) деньнед, длин);
                break;

            // миллисек
            case 'f':
                длин = повториРазбор (форматируй, индекс, c);
                auto чис = Целое.itoa (врем, время.миллисек);
                if(длин > чис.length)
                {
                    результат ~= чис;

                    // добавь '0's
                    static сим[8] zeros = '0';
                    auto zc = длин - чис.length;
                    zc = (zc > zeros.length) ? zeros.length : zc;
                    результат ~= zeros[0..zc];
                }
                else
                    результат ~= чис[0..длин];
                break;

            // миллисек, no trailing zeros
            case 'F':
                длин = повториРазбор (форматируй, индекс, c);
                auto чис = Целое.itoa (врем, время.миллисек);
                auto индкс = (длин < чис.length) ? длин : чис.length;

                // откинь '0's
                while(индкс && чис[индкс-1] is '0')
                    --индкс;

                результат ~= чис[0..индкс];
                break;

            // месяц
            case 'M':
                длин = повториРазбор (форматируй, индекс, c);
                if (длин <= 2)
                    результат ~= форматируйЦел (врем, месяц, длин);
                else
                    результат ~= форматируйМесяц (месяц, длин);
                break;

            // год
            case 'y':
                длин = повториРазбор (форматируй, индекс, c);

                // Two-цифра годы for Japanese
                if (календарь.ид is календарь.ЯПОНСКИЙ)
                    результат ~= форматируйЦел (врем, год, 2);
                else
                {
                    if (длин <= 2)
                        результат ~= форматируйЦел (врем, год % 100, длин);
                    else
                        результат ~= форматируйЦел (врем, год, длин);
                }
                break;

            // час (12-час clock)
            case 'h':
                длин = повториРазбор (форматируй, индекс, c);
                цел час = время.часы % 12;
                if (час is 0)
                    час = 12;
                результат ~= форматируйЦел (врем, час, длин);
                break;

            // час (24-час clock)
            case 'H':
                длин = повториРазбор (форматируй, индекс, c);
                результат ~= форматируйЦел (врем, время.часы, длин);
                break;

            // минута
            case 'm':
                длин = повториРазбор (форматируй, индекс, c);
                результат ~= форматируйЦел (врем, время.минуты, длин);
                break;

            // секунда
            case 's':
                длин = повториРазбор (форматируй, индекс, c);
                результат ~= форматируйЦел (врем, время.сек, длин);
                break;

            // AM/PM
            case 't':
                длин = повториРазбор (форматируй, индекс, c);
                if (длин is 1)
                {
                    if (время.часы < 12)
                    {
                        if (определительДоПолудня.length != 0)
                            результат ~= определительДоПолудня[0];
                    }
                    else
                    {
                        if (определительПослеПолудня.length != 0)
                            результат ~= определительПослеПолудня[0];
                    }
                }
                else
                    результат ~= (время.часы < 12) ? определительДоПолудня : определительПослеПолудня;
                break;

            // timezone смещение
            case 'z':
                длин = повториРазбор (форматируй, индекс, c);
                auto минуты = cast(цел) (Куранты.зона.минуты);
                if (минуты < 0)
                {
                    минуты = -минуты;
                    результат ~= '-';
                }
                else
                    результат ~= '+';
                цел часы = минуты / 60;
                минуты %= 60;

                if (длин is 1)
                    результат ~= форматируйЦел (врем, часы, 1);
                else if (длин is 2)
                    результат ~= форматируйЦел (врем, часы, 2);
                else
                {
                    результат ~= форматируйЦел (врем, часы, 2);
                    результат ~= форматируйЦел (врем, минуты, 2);
                }
                break;

            // время разделитель
            case ':':
                длин = 1;
                результат ~= разделительВремени;
                break;

            // дата разделитель
            case '/':
                длин = 1;
                результат ~= разделительДаты;
                break;

            // ткст literal
            case '\"':
            case '\'':
                длин = разборКавычек (результат, форматируй, индекс);
                break;

            // другой
            default:
                длин = 1;
                результат ~= c;
                break;
            }
            индекс += длин;
        }
        return результат.получи;
    }

    /**********************************************************************

    **********************************************************************/

    private ткст форматируйМесяц (цел месяц, цел rpt)
    {
        if (rpt is 3)
            return сокращённоеИмяМесяца (месяц);
        return имяМесяца (месяц);
    }

    /**********************************************************************

    **********************************************************************/

    private ткст форматируйДеньНедели (Календарь.ДеньНедели деньНедели, цел rpt)
    {
        if (rpt is 3)
            return сокращённоеИмяДня (деньНедели);
        return имяДня (деньНедели);
    }

    /**********************************************************************

    **********************************************************************/

    private T[] мост(T) (T[] результат, ук арг, T[] формат)
    {
        return шФормат (результат, *cast(Время*) арг, формат);
    }

    /**********************************************************************

    **********************************************************************/

    private static цел повториРазбор(ткст форматируй, цел поз, сим c)
    {
        цел n = поз + 1;
        while (n < форматируй.length && форматируй[n] is c)
            n++;
        return n - поз;
    }

    /**********************************************************************

    **********************************************************************/

    private static ткст форматируйЦел (ткст врем, цел знач, цел minimum)
    {
        auto чис = Целое.itoa (врем, знач);
        if ((minimum -= чис.length) > 0)
        {
            auto p = врем.ptr + врем.length - чис.length;
            while (minimum--)
                *--p = '0';
            чис = врем [p-врем.ptr .. $];
        }
        return чис;
    }

    /**********************************************************************

    **********************************************************************/

    private static цел разборКавычек (ref Результат результат, ткст форматируй, цел поз)
    {
        цел старт = поз;
        сим chQuote = форматируй[поз++];
        бул найдено;
        while (поз < форматируй.length)
        {
            сим c = форматируй[поз++];
            if (c is chQuote)
            {
                найдено = да;
                break;
            }
            else if (c is '\\')
            {
                // эскапирован
                if (поз < форматируй.length)
                    результат ~= форматируй[поз++];
            }
            else
                результат ~= c;
        }
        return поз - старт;
    }
}

/******************************************************************************

        An english/usa локаль
        Used as генерный МестнДатаВремя.

******************************************************************************/

private МестнДатаВремя RuRU =
{
краткийОбразецДаты                : "M/d/yyyy"
    ,
краткийОбразецВремени                : "h:mm"
    ,
длинныйОбразецДаты                 : "dddd, MMMM d, yyyy"
    ,
длинныйОбразецВремени                 : "h:mm:ss tt"
    ,
полныйОбразецДатыВремени             : "dddd, MMMM d, yyyy h:mm:ss tt"
    ,
общКраткийОбразецВремени         : "M/d/yyyy h:mm"
    ,
общДлинныйОбразецВремени          : "M/d/yyyy h:mm:ss tt"
    ,
образецДняМесяца                 : "MMMM d"
    ,
образецМесяцаГода                : "MMMM, yyyy"
    ,
определительДоПолудня                    : "AM"
    ,
определительПослеПолудня                    : "PM"
    ,
разделительВремени                   : ":"
    ,
разделительДаты                   : "/"
    ,
именаДней                        :
    ["Воскресенье", "Понедельник", "Вторник", "Среда",
    "Четверг", "Пятница", "Суббота"],
именаМесяцев                      :
    ["Январь", "Февраль", "Март", "Апрель",
    "Май", "Июнь", "Июль", "Август", "Сентябрь",
    "Октябрь" "Ноябрь", "Декабрь"],
сокращённыеИменаДней             :
    ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
сокращённыеИменаМесяцев           :
    ["Янв", "Фев", "Мар", "Апр", "Май", "Июн",
    "Июл", "Авг", "Сен", "Окт", "Нбр", "Дек"],
};


/******************************************************************************

******************************************************************************/

private struct Результат
{
    private бцел    индекс;
    private ткст  цель_;

    /**********************************************************************

    **********************************************************************/

    private static Результат opCall (ткст мишень)
    {
        Результат результат;

        результат.цель_ = мишень;
        return результат;
    }

    /**********************************************************************

    **********************************************************************/

    private проц opCatAssign (ткст правткт)
    {
        auto конец = индекс + правткт.length;
        assert (конец < цель_.length);

        цель_[индекс .. конец] = правткт;
        индекс = конец;
    }

    /**********************************************************************

    **********************************************************************/

    private проц opCatAssign (сим правткт)
    {
        assert (индекс < цель_.length);
        цель_[индекс++] = правткт;
    }

    /**********************************************************************

    **********************************************************************/

    private ткст получи ()
    {
        return цель_[0 .. индекс];
    }
}

/******************************************************************************

******************************************************************************/

debug (ДатаВремя)
{
    import io.Stdout;

    проц main()
    {
        сим[100] врем;
        auto время = Куранты.сейчас;
        auto локаль = МестнДатаВремя.создай;

        Стдвыв.форматнс ("d: {}", локаль.форматируй (врем, время, "d"));
        Стдвыв.форматнс ("D: {}", локаль.форматируй (врем, время, "D"));
        Стдвыв.форматнс ("f: {}", локаль.форматируй (врем, время, "f"));
        Стдвыв.форматнс ("F: {}", локаль.форматируй (врем, время, "F"));
        Стдвыв.форматнс ("g: {}", локаль.форматируй (врем, время, "g"));
        Стдвыв.форматнс ("G: {}", локаль.форматируй (врем, время, "G"));
        Стдвыв.форматнс ("r: {}", локаль.форматируй (врем, время, "r"));
        Стдвыв.форматнс ("s: {}", локаль.форматируй (врем, время, "s"));
        Стдвыв.форматнс ("t: {}", локаль.форматируй (врем, время, "t"));
        Стдвыв.форматнс ("T: {}", локаль.форматируй (врем, время, "T"));
        Стдвыв.форматнс ("y: {}", локаль.форматируй (врем, время, "y"));
        Стдвыв.форматнс ("u: {}", локаль.форматируй (врем, время, "u"));
        Стдвыв.форматнс ("@: {}", локаль.форматируй (врем, время, "@"));
        Стдвыв.форматнс ("{}", локаль.генерный.форматируй (врем, время, "ddd, dd MMM yyyy HH':'mm':'ss zzzz"));
    }
}
