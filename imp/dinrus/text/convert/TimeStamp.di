/*******************************************************************************

        Выполняет преобразование из исконного в текстовое представление
		значения времени HTTP. Внутренне время представлено как UTC 
		с фиксацией эпохи на 1-м Января 1970. Текстовое представление
		форматируется в соответствии с RFC 1123, этот парсер настроен
		принимать один из параметров в форматах  RFC 1123, RFC 850,
		либо анзисивремя.

        Подробности в http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html.
		
        Применение механизма "import alias" высоко рекомендовано для этого
		модуля, чтобы ограничить загрязнение пространства имён:
        ---
        import ШиампВрем = text.convert.TimeStamp;

        auto t = ШиампВрем.разбор ("Sun, 06 Nov 1994 08:49:37 GMT");
        ---

*******************************************************************************/

module text.convert.TimeStamp;

private import time.Time;

private import exception;

private import Util = text.Util;

private import time.chrono.Gregorian;

private import Целое = text.convert.Integer;

/******************************************************************************

        Разбирает предоставленный ввод и возвращает время эпохи UTC.
		Когда предоставленный ткст не полностью разобран,
		выводится исключение.

******************************************************************************/

бдол воВремя(T) (T[] ист)
{
    бцел длин;

    auto x = разбор (ист, &длин);
    if (длин < ист.length)
        throw new ИсклНелегальногоАргумента ("неизвестный формат времени: "~ист);
    return x;
}

/******************************************************************************

        Рэппер шаблона, упрощающий жизнь. Возвращает текстовую версию
        предоставленного значения.

        Подробности в форматируй().

******************************************************************************/

extern(D) ткст вТкст (Время время);

/******************************************************************************

        Рэппер шаблона, упрощающий жизнь. Возвращает текстовую версию
        предоставленного значения.

        Подробности в форматируй().


******************************************************************************/

extern(D) шим[] вТкст16 (Время время);

/******************************************************************************

        Рэппер шаблона, упрощающий жизнь. Возвращает текстовую версию
        предоставленного значения.

        Подробности в форматируй().


******************************************************************************/

extern(D) дим[] вТкст32 (Время время);

/******************************************************************************

        Время, форматированное в RFC1123.

        Преобразует в формат "Sun, 06 Nov 1994 08:49:37 GMT", и
        возвращает заполненный срез предоставленного буфера. Надо учитывать,
        что формат RFC1123 всегда в абсолютном времени GMT, а буфера из
		тридцати элементов достаточно для производимого вывода.

        Выводит исключение, если указанное время непригодно.

******************************************************************************/

T[] форматируй(T, U = Время) (T[] вывод, U t)
{
    return форматируй!(T)(вывод, cast(Время) t);
}

T[] форматируй(T) (T[] вывод, Время t)
{
    static T[][] Месяцы = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    static T[][] Дни   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

    T[] преобразуй (T[] врем, дол i)
    {
        return Целое.форматёр!(T) (врем, i, 'u', 0, 8);
    }

    assert (вывод.length >= 29);
    if (t is t.макс)
        throw new ИсклНелегальногоАргумента ("ШтампВремени.формат :: аргумент Время непригоден");

    // преобразуем время в полевые значения
    auto время = t.время;
    auto дата = Грегориан.генерный.вДату (t);

    // use the featherweight форматёр ...
    T[14] врем =void;
    return Util.выкладка (вывод, cast(T[])"%0, %1 %2 %3 %4:%5:%6 GMT",
                                  Дни[дата.деньнед],
                                  преобразуй (врем[0..2], дата.день),
                                  Месяцы[дата.месяц-1],
                                  преобразуй (врем[2..6], дата.год),
                                  преобразуй (врем[6..8], время.часы),
                                  преобразуй (врем[8..10], время.минуты),
                                  преобразуй (врем[10..12], время.сек)
                                 );
}


/******************************************************************************

        Формат ISO-8601 :: "2006-01-31T14:49:30Z"

        Выводит исключение, когда задано неправильное время.

******************************************************************************/

T[] формат8601(T, U=Время) (T[] вывод, U t)
{
    return форматируй!(T)(вывод, cast(Время) t);
}

T[] формат8601(T) (T[] вывод, Время t)
{
    T[] преобразуй (T[] врем, дол i)
    {
        return Целое.форматёр!(T) (врем, i, 'u', 0, 8);
    }


    assert (вывод.length >= 29);
    if (t is t.max)
        throw new ИсклНелегальногоАргумента ("ШтампВремени.формат :: аргумент Время непригоден");

    // преобразуй время в_ field значения
    auto время = t.время;
    auto дата = Грегориан.генерный.вДату (t);

    // use the featherweight форматёр ...
    T[20] врем =void;
    return Util.выкладка (вывод, cast(T[]) "%0-%1-%2T%3%:%4:%5Z",
                                  преобразуй (врем[0..4], дата.год),
                                  преобразуй (врем[4..6], дата.месяц),
                                  преобразуй (врем[6..8], дата.день),
                                  преобразуй (врем[8..10], время.часы),
                                  преобразуй (врем[10..12], время.минуты),
                                  преобразуй (врем[12..14], время.сек)
                                 );
}

/******************************************************************************

      Разбирает предоставленный ввод и возвращает время эпохи UTC. Возвратное
	  значение Время.макс (или нет, соответственно) указывает ошибку разбора.
	  
	  Задаётся опция для возврата числа разобранных символов -
      неизменённое значение этой опции указывает на непригодный ввод.

******************************************************************************/

Время разбор(T) (T[] ист, бцел* взято = пусто)
{
    т_мера длин;
    Время   значение;

    if ((длин = рфц1123 (ист, значение)) > 0 ||
            (длин = рфц850  (ист, значение)) > 0 ||
            (длин = изо8601  (ист, значение)) > 0 ||
            (длин = досвремя  (ист, значение)) > 0 ||
            (длин = анзисивремя (ист, значение)) > 0)
    {
        if (взято)
            *взято = длин;
        return значение;
    }
    return Время.макс;
}


/******************************************************************************

      Разбирает предоставленный ввод и возвращает время эпохи UTC. Возвратное
	  значение Время.макс (или нет, соответственно) указывает ошибку разбора.

      Задаётся опция для возврата числа разобранных символов -
      неизменённое значение этой опции указывает на непригодный ввод.

******************************************************************************/

бул разбор(T) (T[] ист, ref ВремяДня врдня, ref Дата дата, бцел* взято = пусто)
{
    т_мера длин;

    if ((длин = рфц1123 (ист, врдня, дата)) > 0 ||
            (длин = рфц850   (ист, врдня, дата)) > 0 ||
            (длин = изо8601  (ист, врдня, дата)) > 0 ||
            (длин = досвремя  (ист, врдня, дата)) > 0 ||
            (длин = анзисивремя (ист, врдня, дата)) > 0)
    {
        if (взято)
            *взято = длин;
        return да;
    }
    return нет;
}

/******************************************************************************

        RFC 822, обновлённое RFC 1123 :: "Sun, 06 Nov 1994 08:49:37 GMT"

        Возвращает число элементов, использованных при разборе;
		ноль указывает на неудачный разбор.

******************************************************************************/

т_мера рфц1123(T) (T[] ист, ref Время значение)
{
    ВремяДня врдня;
    Дата      дата;

    auto r = рфц1123!(T)(ист, врдня, дата);
    if (r)
        значение = Грегориан.генерный.воВремя(дата, врдня);
    return r;
}


/******************************************************************************

        RFC 822, обновлённое RFC 1123 :: "Sun, 06 Nov 1994 08:49:37 GMT"

        Возвращает число элементов, использованных при разборе;
		ноль указывает на неудачный разбор.

******************************************************************************/

т_мера рфц1123(T) (T[] ист, ref ВремяДня врдня, ref Дата дата)
{
    T* p = ист.ptr;
    T* e = p + ист.length;

    бул dt (ref T* p)
    {
        return ((дата.день = парсируйЦел(p, e)) > 0  &&
                *p++ == ' '                     &&
                (дата.месяц = разбериМесяц(p)) > 0 &&
                *p++ == ' '                     &&
                (дата.год = парсируйЦел(p, e)) > 0);
    }

    if (разбериКороткийДень(p) >= 0 &&
            *p++ == ','           &&
            *p++ == ' '           &&
            dt (p)                &&
            *p++ == ' '           &&
            время (врдня, p, e)      &&
            *p++ == ' '           &&
            p[0..3] == "GMT")
    {
        return (p+3) - ист.ptr;
    }
    return 0;
}


/******************************************************************************

        RFC 850, переопределённое в RFC 1036 :: "Sunday, 06-Nov-94 08:49:37 GMT"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

******************************************************************************/

т_мера рфц850(T) (T[] ист, ref Время значение)
{
    ВремяДня врдня;
    Дата      дата;

    auto r = рфц850!(T)(ист, врдня, дата);
    if (r)
        значение = Грегориан.генерный.воВремя (дата, врдня);
    return r;
}

/******************************************************************************

        RFC 850, переопределённое в RFC 1036 :: "Sunday, 06-Nov-94 08:49:37 GMT"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

******************************************************************************/

т_мера рфц850(T) (T[] ист, ref ВремяДня врдня, ref Дата дата)
{
    T* p = ист.ptr;
    T* e = p + ист.length;

    бул dt (ref T* p)
    {
        return ((дата.день = парсируйЦел(p, e)) > 0  &&
                *p++ == '-'                     &&
                (дата.месяц = разбериМесяц(p)) > 0 &&
                *p++ == '-'                     &&
                (дата.год = парсируйЦел(p, e)) > 0);
    }

    if (разбериПолныйДень(p) >= 0 &&
            *p++ == ','          &&
            *p++ == ' '          &&
            dt (p)               &&
            *p++ == ' '          &&
            время (врдня, p, e)     &&
            *p++ == ' '          &&
            p[0..3] == "GMT")
    {
        if (дата.год < 70)
            дата.год += 2000;
        else if (дата.год < 100)
            дата.год += 1900;

        return (p+3) - ист.ptr;
    }
    return 0;
}


/******************************************************************************

        Формат ANSI C анзисивремя() :: "Sun Nov 6 08:49:37 1994"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

******************************************************************************/

т_мера анзисивремя(T) (T[] ист, ref Время значение)
{
    ВремяДня врдня;
    Дата      дата;

    auto r = анзисивремя!(T)(ист, врдня, дата);
    if (r)
        значение = Грегориан.генерный.воВремя (дата, врдня);
    return r;
}

/******************************************************************************

        Формат ANSI C анзисивремя() :: "Sun Nov 6 08:49:37 1994"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

******************************************************************************/

т_мера анзисивремя(T) (T[] ист, ref ВремяДня врдня, ref Дата дата)
{
    T* p = ист.ptr;
    T* e = p + ист.length;

    бул dt (ref T* p)
    {
        return ((дата.месяц = разбериМесяц(p)) > 0  &&
                *p++ == ' '                      &&
                ((дата.день = парсируйЦел(p, e)) > 0  ||
                 (*p++ == ' '                      &&
                  (дата.день = парсируйЦел(p, e)) > 0)));
    }

    if (разбериКороткийДень(p) >= 0 &&
            *p++ == ' '           &&
            dt (p)                &&
            *p++ == ' '           &&
            время (врдня, p, e)      &&
            *p++ == ' '           &&
            (дата.год = парсируйЦел (p, e)) > 0)
    {
        return p - ист.ptr;
    }
    return 0;
}

/******************************************************************************

        Формат времени DOS :: "12-31-06 08:49AM"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

******************************************************************************/

т_мера досвремя(T) (T[] ист, ref Время значение)
{
    ВремяДня врдня;
    Дата      дата;

    auto r = досвремя!(T)(ист, врдня, дата);
    if (r)
        значение = Грегориан.генерный.воВремя(дата, врдня);
    return r;
}


/******************************************************************************

        Формат времени DOS :: "12-31-06 08:49AM"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

******************************************************************************/

т_мера досвремя(T) (T[] ист, ref ВремяДня врдня, ref Дата дата)
{
    T* p = ист.ptr;
    T* e = p + ист.length;

    бул dt (ref T* p)
    {
        return ((дата.месяц = парсируйЦел(p, e)) > 0 &&
                *p++ == '-'                      &&
                ((дата.день = парсируйЦел(p, e)) > 0  &&
                 (*p++ == '-'                      &&
                  (дата.год = парсируйЦел(p, e)) > 0)));
    }

    if (dt(p) >= 0                         &&
            *p++ == ' '                        &&
            (врдня.часы = парсируйЦел(p, e)) > 0   &&
            *p++ == ':'                        &&
            (врдня.минуты = парсируйЦел(p, e)) > 0 &&
            (*p == 'A' || *p == 'P'))
    {
        if (*p is 'P')
            врдня.часы += 12;

        if (дата.год < 70)
            дата.год += 2000;
        else if (дата.год < 100)
            дата.год += 1900;

        return (p+2) - ист.ptr;
    }
    return 0;
}

/******************************************************************************

        Формат ISO-8601 :: "2006-01-31 14:49:30,001"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

        Цитата из http://en.wikipedia.org/wiki/ISO_8601 (2009-09-01):
        "Decimal fractions may also be added to any of the three time elements.
        A decimal point, either a comma or a dot (without any preference as
        stated most recently in resolution 10 of the 22nd General Conference
        CGPM in 2003), is used as a separator between the time element and
        its fraction."

******************************************************************************/

т_мера изо8601(T) (T[] ист, ref Время значение)
{
    ВремяДня врдня;
    Дата      дата;

    цел r = изо8601!(T)(ист, врдня, дата);
    if (r)
        значение = Грегориан.генерный.воВремя(дата, врдня);
    return r;
}

/******************************************************************************

        Формат ISO-8601 :: "2006-01-31 14:49:30,001"

        Возвращает число элементов, полученных при разборе; если
        разбор неудачен, возвращается ноль.

        Цитата из http://en.wikipedia.org/wiki/ISO_8601 (2009-09-01):
        "Decimal fractions may also be added to any of the three time elements.
        A decimal point, either a comma or a dot (without any preference as
        stated most recently in resolution 10 of the 22nd General Conference
        CGPM in 2003), is used as a separator between the time element and
        its fraction."

******************************************************************************/

т_мера изо8601(T) (T[] ист, ref ВремяДня врдня, ref Дата дата)
{
    T* p = ист.ptr;
    T* e = p + ист.length;

    бул dt (ref T* p)
    {
        return ((дата.год = парсируйЦел(p, e)) > 0   &&
                *p++ == '-'                       &&
                ((дата.месяц = парсируйЦел(p, e)) > 0 &&
                 (*p++ == '-'                       &&
                  (дата.день = парсируйЦел(p, e)) > 0)));
    }

    if (dt(p) >= 0       &&
            *p++ == ' '      &&
            время (врдня, p, e))
    {
        // Are there симвы лево? If да, разбор миллисек. If no, миллисек = 0.
        if (p - ист.ptr)
        {
            // проверь дво разделитель
            T frac_sep = *p++;
            if (frac_sep is ',' || frac_sep is '.')
                // разделитель is ok: разбор миллисек
                врдня.миллисек = парсируйЦел (p, e);
            else
                // wrong разделитель: ошибка
                return 0;
        }
        else
            врдня.миллисек = 0;

        return p - ист.ptr;
    }
    return 0;
}


/******************************************************************************

        Разбирает поле времени.

******************************************************************************/

private бул время(T) (ref ВремяДня время, ref T* p, T* e)
{
    return ((время.часы = парсируйЦел(p, e)) >= 0   &&
            *p++ == ':'                         &&
            (время.минуты = парсируйЦел(p, e)) >= 0 &&
            *p++ == ':'                         &&
            (время.сек = парсируйЦел(p, e)) >= 0);
}


/******************************************************************************

        Выполняет сверку месяца из ввода.

******************************************************************************/

private цел разбериМесяц(T) (ref T* p)
{
    цел месяц;

    switch (p[0..3])
    {
    case "Jan":
        месяц = 1;
        break;
    case "Feb":
        месяц = 2;
        break;
    case "Mar":
        месяц = 3;
        break;
    case "Apr":
        месяц = 4;
        break;
    case "May":
        месяц = 5;
        break;
    case "Jun":
        месяц = 6;
        break;
    case "Jul":
        месяц = 7;
        break;
    case "Aug":
        месяц = 8;
        break;
    case "Sep":
        месяц = 9;
        break;
    case "Oct":
        месяц = 10;
        break;
    case "Nov":
        месяц = 11;
        break;
    case "Dec":
        месяц = 12;
        break;
    default:
        return месяц;
    }
    p += 3;
    return месяц;
}


/******************************************************************************

        Выполняет сверку дня из ввода.

******************************************************************************/

private цел разбериКороткийДень(T) (ref T* p)
{
    цел день;

    switch (p[0..3])
    {
    case "Sun":
        день = 0;
        break;
    case "Mon":
        день = 1;
        break;
    case "Tue":
        день = 2;
        break;
    case "Wed":
        день = 3;
        break;
    case "Thu":
        день = 4;
        break;
    case "Fri":
        день = 5;
        break;
    case "Sat":
        день = 6;
        break;
    default:
        return -1;
    }
    p += 3;
    return день;
}


/******************************************************************************

        Выполняет сверку из ввода. Sunday равно 0.

******************************************************************************/

private цел разбериПолныйДень(T) (ref T* p)
{
    static  T[][] дни =
        [
                "Sunday", 
                "Monday", 
                "Tuesday", 
                "Wednesday", 
                "Thursday", 
                "Friday", 
                "Saturday", 
        ];

    foreach (i, день; дни)
    if (день == p[0..день.length])
    {
        p += день.length;
        return i;
    }
    return -1;
}


/******************************************************************************

        Извлекает целое из ввода.

******************************************************************************/

private static цел парсируйЦел(T) (ref T* p, T* e)
{
    цел значение;

    while (p < e && (*p >= '0' && *p <= '9'))
        значение = значение * 10 + *p++ - '0';
    return значение;
}


/******************************************************************************

******************************************************************************/

debug (UnitTest)
{
    unittest
    {
        шим[30] врем;
        шим[] тест = "Sun, 06 Nov 1994 08:49:37 GMT";

        auto время = разбор (тест);
        auto текст = форматируй (врем, время);
        assert (текст == тест);

        ткст garbageTest = "Wed Jun 11 17:22:07 20088";
        garbageTest = garbageTest[0..$-1];
        сим[128] tmp2;

        время = разбор(garbageTest);
        auto text2 = форматируй(tmp2, время);
        assert (text2 == "Wed, 11 Jun 2008 17:22:07 GMT");
    }
}

/******************************************************************************

******************************************************************************/

debug (TimeStamp)
{
    проц main()
    {
        Время t;

        auto dos = "12-31-06 08:49AM";
        auto iso = "2006-01-31 14:49:30,001";
        assert (досвремя(dos, t) == dos.length);
        assert (изо8601(iso, t) == iso.length);

        шим[30] врем;
        шим[] тест = "Sun, 06 Nov 1994 08:49:37 GMT";

        auto время = разбор (тест);
        auto текст = форматируй (врем, время);
        assert (текст == тест);
    }
}
