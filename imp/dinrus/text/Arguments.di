module text.Arguments;

private import text.Util;
private import col.Stack;

version = dashdash;       // -- всё установлено в аргумент пусто

/*******************************************************************************

        Парсер аргументов командной строки. Простое использование:
        ---
        auto арги = new Аргументы;
        арги.разбор ("-a -b", да);
        auto a = арги("a");
        auto b = арги("b");
        if (a.установлен && b.установлен)
            ...
        ---

        Параметры аргумента назначаются последней известной цели, при этом
        несколько параметров накапливается:
        ---
        арги.разбор ("-a=1 -a=2 foo", да);
        assert (арги('a').назначено.length is 3);
        ---

        В итоге в примере аргументу 'a' назначено три параметра.
        Два параметра назначено явно, с помощью '=', третий
        назначен косвенно. Косвенные параметры часто пригодны для
        накопления имён файлоа или других параметров без определения
        связанного аргумента:
        ---
        арги.разбор ("thisfile.txt thatfile.doc -знач", да);
        assert (арги(пусто).назначено.length is 2);
        ---
        Аргумент 'пусто' определён всегда и действует как аккумулятор
        для параметров, оставленных нетронутыми другими аргументами. В
        экземпляре выше ему назначены все параметры.

        В этих примерах используется декларация аргумента 'полого', так как
        второй аргумент функции разбор() установлен в да. Это позволяет
        парсеру создавать определения аргументов на ходу, что может
        пригодится в повседневном пользовании. Однако, большинство фич требует
        декларации аргументов априори:
        ---
        арги = new Аргументы;
        арги('x').требуется;
        if (! арги.разбор("-x"))
              // x не предоставлен!
        ---

        "Пологие" аргументы в этом примере отключены, и объявлен обязательный
        аргумент 'x'. Метод разбор() упадёт, если предусловие не полностью 
        приемлемо. К дополнительным квалификаторам относится указание того,
        сколько параметров допускается для каждого индивидуального
        аргумента, дефолтные параметры, требуется ли аргументу наличие или
        отсутствие другого и т.д. Квалификаторы, как правило, сцепляются
        вместе; следующий пример показывает аргумент "foo", который
        становится требуемым, с одним параметром, есть_алиас = 'f', и
        он зависит от присутствия другого аргумента "bar":
        ---
        арги("foo").требуется.парамы(1).есть_алиас('f').требует("bar");
        арги("помощь").есть_алиас('?').есть_алиас('h');
        ---

        Параметры могут ограничиваться набором совпадающих текстовых значений,
        и парсер упадёт, если ввод не соответствует:
        ---
        арги("приветствие").ограничь("hello", "yo", "gday");
        арги("включен").ограничь("да", "нет", "t", "f", "y", "n");
        ---

        Набор декларированных аргументов может быть сконфигурирован следующим образом,
        и парсер вернёт да, только если все условия соответствуют.
        Когда случается условие ошибки, можно обойти набор аргументов
        и найти аргумент, из-за которого происходит эта ошибка. Это
        можно делать таким образом (арг.ошибка содержит определённый код):
        ---
        if (! арги.разбор (...))
              foreach (арг; арги)
                       if (арг.ошибка)
                           ...
        ---

        Коды ошибок следующие:
        ---
        Нет:           ok (ноль)
        ПарамМлад:     слишком мало параметров для аргумента
        ПарамСтарш:    слишком много параметров для аргумента
        Требуется:     требуется отсутствующий аргумент
        Требует:       зависит от отсутствующего аргумента
        Конфликт:      присутствует конфликтующий аргумент
        Экстра:        неожиданный аргумент (см. полого)
        Опция:         параметр не соответствует опции
        ---

        Простой способ показывать ошибки - вызвать внутреннюю процедуру
        форматирования, которая конструирует сообщения об ошибках:
        ---
        if (! арги.разбор (...))
              стдош (арги.ошибки(&стдош.выкладка.sprint));
        ---

        Помните, что сообщения конструируются через обработчик "выкладка"
        и сами по себе могут быть кастомированы (для целей i18n).
        См. два метода ошибки(), чтобы получить дополнительную информацию.

        Парсер различает краткий и длинный префиксы,
        при этом аргумент длинного префикса всегда определяется, когда
        аргумент краткого префикса можно комбинировать как сокращение:
        ---
        арги.разбор ("--foo --bar -abc", да);
        assert (арги("foo").установлен);
        assert (арги("bar").установлен);
        assert (арги("a").установлен);
        assert (арги("b").установлен);
        assert (арги("c").установлен);
        ---

        В добавок, аргументы краткого префикса могут быть "smushed" с
        ассоциированным параметром, когда на это сконфигурированы:
        ---
        арги('o').парамы(1).smush;
        if (арги.разбор ("-ofile"))
            assert (арги('o').назначено[0] == "файл");
        ---

        There are two обрвызов varieties supports, where one is invoked
        when an associated аргумент is разобрано и the другой is invoked
        as параметры are назначено. See the вяжи() methods for delegate
        сигнатура details.

        You may change the аргумент префикс в_ be something другой than
        "-" и "--" via the constructor. You might, for example, need
        в_ specify a "/" indicator instead, и use ':' for explicitly
        assigning параметры:
        ---
        auto арги = new Арги ("/", "-", ':');
        арги.разбор ("-foo:param -bar /abc");
        assert (арги("foo").установлен);
        assert (арги("bar").установлен);
        assert (арги("a").установлен);
        assert (арги("b").установлен);
        assert (арги("c").установлен);
        assert (арги("foo").назначено.length is 1);
        ---

        Returning в_ an earlier example we can declare some specifics:
        ---
        арги('знач').парамы(0);
        assert (арги.разбор (`-знач thisfile.txt thatfile.doc`));
        assert (арги(пусто).назначено.length is 2);
        ---

        Note that the -знач флаг is сейчас in front of the implicit параметры
        but ignores them because it is declared в_ используй Неук. That is,
        implicit параметры are назначено в_ аргументы из_ право в_ лево,
        according в_ как many параметры saопр аргументы may используй. Each
        полого аргумент consumes параметры by default, so those implicit
        параметры would have been назначено в_ -знач without the declaration
        shown. On the другой hand, an явный assignment (via '=') always
        associates the parameter with that аргумент even when an перебор
        would occur (though will cause an ошибка в_ be raised).

        Certain параметры are использован for capturing comments or другой plain
        текст из_ the пользователь, включая пробел и другой special симвы.
        Such parameter значения should be quoted on the commandline, и be
        назначено explicitly rather than implicitly:
        ---
        арги.разбор (`--коммент="-- a коммент --"`);
        ---

        Without the явный assignment, the текст контент might иначе
        be consопрered the старт of другой аргумент (due в_ как argv/argc
        значения are очищенный of original кавычки).

        Lastly, все subsequent текст is treated as paramter-значения после a
        "--" токен is encountered. This notion is applied by unix systems
        в_ терминируй аргумент processing in a similar manner. Such значения
        are consопрered в_ be implicit, и are назначено в_ preceding арги
        in the usual право в_ лево fashion (or в_ the пусто аргумент):
        ---
        арги.разбор (`-- -thisfile --thatfile`);
        assert (арги(пусто).назначено.length is 2);
        ---

*******************************************************************************/

class Аргументы
{
    public alias получи                opCall;         // арги("имя")
    public alias получи                opIndex;        // арги["имя"]

    private Стэк!(Аргумент)        стэк;          // аргументы с параметрами
    private Аргумент[ткст]        арги;           // набор аргументов
    private Аргумент[ткст]        алиасы;        // набор псевдонимов
    private сим                    равно;             // '=' или ':'
    private ткст                  кп,             // крат префикс
            дп;             // дол префикс
    private ткст[]                сообы = ошсооб;  // сообщения об ошибках
    private const ткст[]          ошсооб =        // ошибки по умолчанию
        [
            "аргумент '{0}' ожидает {2} параметр(s) но имеется {1}\n",
            "аргумент '{0}' ожидает {3} параметр(s) но имеется {1}\n",
            "аргумент '{0}' отсутствует\n",
            "аргумент '{0}' требует '{4}'\n",
            "аргумент '{0}' конфликтует с '{4}'\n",
            "неожиданный аргумент '{0}'\n",
            "аргумент '{0}' ожидает один из {5}\n",
            "параметр не подходит для аргумента '{0}': {4}\n",
        ];

    /***********************************************************************

          Construct with the specific крат & дол prefixes, и the
          given assignment character (typically ':' on Windows but we
          установлен the дефолты в_ look like unix instead)

    ***********************************************************************/

    this (ткст кп="-", ткст дп="--", сим равно='=')
    {
        this.кп = кп;
        this.дп = дп;
        this.равно = равно;
        получи(пусто).парамы;       // установлен пусто аргумент в_ используй парамы
    }

    /***********************************************************************

            Parse ткст[] преобр_в a установлен of Аргумент экземпляры. The 'полого'
            опция допускается for неожиданный аргументы without ошибка.

            Возвращает нет where an ошибка condition occurred, whereupon the
            аргументы should be traversed в_ discover saопр condition(s):
            ---
            auto арги = new Аргументы;
            if (! арги.разбор (...))
                  стдош (арги.ошибки(&стдош.выкладка.sprint));
            ---

    ***********************************************************************/

    final бул разбор (ткст ввод, бул полого = нет)
    {
        ткст[] врем;
        foreach (s; кавычки(ввод, " "))
        врем ~= s;
        return разбор (врем, полого);
    }

    /***********************************************************************

            Parse a ткст преобр_в a установлен of Аргумент экземпляры. The 'полого'
            опция допускается for неожиданный аргументы without ошибка.

            Возвращает нет where an ошибка condition occurred, whereupon the
            аргументы should be traversed в_ discover saопр condition(s):
            ---
            auto арги = new Аргументы;
            if (! арги.разбор (...))
                  Стдош (арги.ошибки(&Стдош.выкладка.sprint));
            ---

    ***********************************************************************/

    final бул разбор (ткст[] ввод, бул полого=нет)
    {
        бул    готово;
        цел     ошибка;

        debug(Аргументы) стдвыв.форматнс ("\ncmdline: '{}'", ввод);
        стэк.сунь (получи(пусто));
        foreach (s; ввод)
        {
            debug(Аргументы) стдвыв.форматнс ("'{}'", s);
            if (готово is нет)
                if (s == "--")
                {
                    готово=да;
                    version(dashdash)
                    {
                        стэк.очисть.сунь(получи(пусто));
                    }
                    continue;
                }
                else if (аргумент (s, дп, полого, нет) ||
                         аргумент (s, кп, полого, да))
                    continue;
            стэк.верх.добавь (s);
        }
        foreach (арг; арги)
        ошибка |= арг.действителен;
        return ошибка is 0;
    }

    /***********************************************************************

            Clear parameter assignments, флаги и ошибки. Note this
            does not удали any Аргументы

    ***********************************************************************/

    final Аргументы очисть ()
    {
        стэк.очисть;
        foreach (арг; арги)
        {
            арг.установлен = нет;
            арг.значения = пусто;
            арг.ошибка = арг.Нет;
        }
        return this;
    }

    /***********************************************************************

            Obtain an аргумент reference, creating an new экземпляр where
            necessary. Use Массив indexing or opCall syntax if you prefer

    ***********************************************************************/

    final Аргумент получи (сим имя)
    {
        return получи ((&имя)[0..1]);
    }

    /***********************************************************************

            Obtain an аргумент reference, creating an new экземпляр where
            necessary. Use Массив indexing or opCall syntax if you prefer.

            Pass пусто в_ доступ the 'default' аргумент (where unassigned
            implicit параметры are gathered)

    ***********************************************************************/

    final Аргумент получи (ткст имя)
    {
        auto a = имя in арги;
        if (a is пусто)
        {
            имя=имя.dup;
            return арги[имя] = new Аргумент(имя);
        }
        return *a;
    }

    /***********************************************************************

            Traverse the установлен of аргументы

    ***********************************************************************/

    final цел opApply (цел delegate(ref Аргумент) дг)
    {
        цел результат;
        foreach (арг; арги)
        if ((результат=дг(арг)) != 0)
            break;
        return результат;
    }

    /***********************************************************************

            Construct a ткст of ошибка messages, using the given
            delegate в_ форматируй the вывод. You would typically пароль
            the system форматёр here, like so:
            ---
            auto сообы = арги.ошибки (&стдош.выкладка.sprint);
            ---

            The messages are replacable with custom (i18n) versions
            instead, using the ошибки(ткст[]) метод

    ***********************************************************************/

    final ткст ошибки (ткст delegate(ткст буф, ткст фмт, ...) дг)
    {
        сим[256] врем;
        ткст результат;
        foreach (арг; арги)
        if (арг.ошибка)
            результат ~= дг (врем, сообы[арг.ошибка-1], арг.имя,
                                        арг.значения.length, арг.мин, арг.макс,
                                        арг.bogus, арг.опции);
        return результат;
    }

    /***********************************************************************

            Use this метод в_ замени the default ошибка messages. Note
            that аргументы are passed в_ the форматёр in the following
            order, и these should be indexed appropriately by each of
            the ошибка messages (see examples in ошсооб above):
            ---
            индекс 0: the аргумент имя
            индекс 1: число of параметры
            индекс 2: configured minimum параметры
            индекс 3: configured maximum параметры
            индекс 4: conflicting/dependent аргумент (or не_годится param)
            индекс 5: Массив of configured parameter опции
            ---

    ***********************************************************************/

    final Аргументы ошибки (ткст[] ошибки)
    {
        if (ошибки.length is ошсооб.length)
            сообы = ошибки;
        else
            assert (нет);
        return this;
    }

    /***********************************************************************

            Expose the configured установлен of помощь текст, via the given
            delegate

    ***********************************************************************/

    final Аргументы помощь (проц delegate(ткст арг, ткст помощь) дг)
    {
        foreach (арг; арги)
        if (арг.текст.ptr)
            дг (арг.имя, арг.текст);
        return this;
    }

    /***********************************************************************

            Test for the presence of a switch (дол/крат префикс)
            и активируй the associated арг where найдено. Also look
            for и укз явный parameter assignment

    ***********************************************************************/

    private бул аргумент (ткст s, ткст p, бул полого, бул флаг)
    {
        if (s.length >= p.length && s[0..p.length] == p)
        {
            s = s [p.length..$];
            auto i = местоположение (s, равно);
            if (i < s.length)
                активируй (s[0..i], полого, флаг).добавь (s[i+1..$], да);
            else
                // trap пустой аргументы; прикрепи as param в_ пусто-арг
                if (s.length)
                    активируй (s, полого, флаг);
                else
                    получи(пусто).добавь (p, да);
            return да;
        }
        return нет;
    }

    /***********************************************************************

            Indicate the existance of an аргумент, и укз полого
            опции along with multИПle-флаги и smushed параметры.
            Note that полого аргументы are configured with параметры
            включен.

    ***********************************************************************/

    private Аргумент активируй (ткст элем, бул полого, бул флаг=нет)
    {
        if (флаг && элем.length > 1)
        {
            // местоположение арг for первый сим
            auto арг = активируй (элем[0..1], полого);
            элем = элем[1..$];

            // drop further processing of this флаг where in ошибка
            if (арг.ошибка is арг.Нет)
                // smush остаток текст or treat as добавьitional арги
                if (арг.склей)
                    арг.добавь (элем, да);
                else
                    арг = активируй (элем, полого, да);
            return арг;
        }

        // if not in арги, либо in алиасы, then создай new арг
        auto a = элем in арги;
        if (a is пусто)
            if ((a = элем in алиасы) is пусто)
                return получи(элем).парамы.активируй(!полого);
        return a.активируй;
    }

    /***********************************************************************

            A specific аргумент экземпляр. You получи one of these из_
            Аргументы.получи() и visit them via Аргументы.opApply()

    ***********************************************************************/

    class Аргумент
    {
        /***************************************************************

                Ошибка определители:
                ---
                Нет:           ok
                ПарамМлад:        too few парамы for an аргумент
                ПарамСтарш:        too many парамы for an аргумент
                Требуется:       missing аргумент is требуется
                Требует:       depends on a missing аргумент
                Конфликт:       conflicting аргумент is present
                Экстра:          неожиданный аргумент (see полого)
                Опция:         parameter does not сверь опции
                ---

        ***************************************************************/

        enum {Нет, ПарамМлад, ПарамСтарш, Требуется, Требует, Конфликт, Экстра, Опция, Неверный};

        alias проц   delegate() Вызывало;
        alias ткст delegate(ткст значение) Инспектор;

        public цел              мин,            /// minimum парамы
               макс,            /// maximum парамы
               ошибка;          /// ошибка condition
        public  бул            установлен;            /// арг is present
        private бул            треб,            // арг is требуется
                склей,            // арг is smushable
                эксп,            // implicit парамы
                краш;           // краш the разбор
        private ткст          имя,           // арг имя
                текст,           // помощь текст
                bogus;          // имя of conflict
        private ткст[]        значения,         // назначено значения
                опции,        // validation опции
                дефолты;       // configured дефолты
        private Вызывало         вызывало;        // invocation обрвызов
        private Инспектор       инспектор;      // inspection обрвызов
        private Аргумент[]      зависимости,      // who we require
                конфликты;    // who we conflict with

        /***************************************************************

                Созд with the given имя

        ***************************************************************/

        this (ткст имя)
        {
            this.имя = имя;
        }

        /***************************************************************

                Return the имя of this аргумент

        ***************************************************************/

        override ткст вТкст()
        {
            return имя;
        }

        /***************************************************************

                return the назначено параметры, либо the дефолты if
                no параметры were назначено

        ***************************************************************/

        final ткст[] назначено ()
        {
            return значения.length ? значения : дефолты;
        }

        /***************************************************************

                Alias this аргумент with the given имя. If you need
                дол-names в_ be есть_алиас, создай the дол-имя первый
                и alias it в_ a крат one

        ***************************************************************/

        final Аргумент есть_алиас (сим имя)
        {
            this.outer.алиасы[(&имя)[0..1].dup] = this;
            return this;
        }

        /***************************************************************

                Make this аргумент a requirement

        ***************************************************************/

        final Аргумент требуется ()
        {
            this.треб = да;
            return this;
        }

        /***************************************************************

                Набор this аргумент в_ depend upon другой

        ***************************************************************/

        final Аргумент требует (Аргумент арг)
        {
            зависимости ~= арг;
            return this;
        }

        /***************************************************************

                Набор this аргумент в_ depend upon другой

        ***************************************************************/

        final Аргумент требует (ткст другой)
        {
            return требует (this.outer.получи(другой));
        }

        /***************************************************************

                Набор this аргумент в_ depend upon другой

        ***************************************************************/

        final Аргумент требует (сим другой)
        {
            return требует ((&другой)[0..1]);
        }

        /***************************************************************

                Набор this аргумент в_ conflict with другой

        ***************************************************************/

        final Аргумент конфликтует (Аргумент арг)
        {
            конфликты ~= арг;
            return this;
        }

        /***************************************************************

                Набор this аргумент в_ conflict with другой

        ***************************************************************/

        final Аргумент конфликтует (ткст другой)
        {
            return конфликтует (this.outer.получи(другой));
        }

        /***************************************************************

                Набор this аргумент в_ conflict with другой

        ***************************************************************/

        final Аргумент конфликтует (сим другой)
        {
            return конфликтует ((&другой)[0..1]);
        }

        /***************************************************************

                Enable parameter assignment: 0 в_ 42 by default

        ***************************************************************/

        final Аргумент парамы ()
        {
            return парамы (0, 42);
        }

        /***************************************************************

                Набор an exact число of параметры требуется

        ***************************************************************/

        final Аргумент парамы (цел счёт)
        {
            return парамы (счёт, счёт);
        }

        /***************************************************************

                Набор Всё the minimum и maximum parameter counts

        ***************************************************************/

        final Аргумент парамы (цел мин, цел макс)
        {
            this.мин = мин;
            this.макс = макс;
            return this;
        }

        /***************************************************************

                Добавь другой default parameter for this аргумент

        ***************************************************************/

        final Аргумент установиДефолты (ткст значения)
        {
            this.дефолты ~= значения;
            return this;
        }

        /***************************************************************

                Набор an инспектор for this аргумент, fired when a
                parameter is appended в_ an аргумент. Return пусто
                из_ the delegate when the значение is ok, либо a текст
                ткст describing the issue в_ trigger an ошибка

        ***************************************************************/

        final Аргумент вяжи (Инспектор инспектор)
        {
            this.инспектор = инспектор;
            return this;
        }

        /***************************************************************

                Набор an вызывало for this аргумент, fired when an
                аргумент declaration is seen

        ***************************************************************/

        final Аргумент вяжи (Вызывало вызывало)
        {
            this.вызывало = вызывало;
            return this;
        }

        /***************************************************************

                Enable smushing for this аргумент, where "-ofile"
                would результат in "файл" being назначено в_ аргумент
                'o'

        ***************************************************************/

        final Аргумент smush (бул да=да)
        {
            склей = да;
            return this;
        }

        /***************************************************************

                Disable implicit аргументы

        ***************************************************************/

        final Аргумент явный ()
        {
            эксп = да;
            return this;
        }

        /***************************************************************

                Alter the титул of this аргумент, which can be
                useful for naming the default аргумент

        ***************************************************************/

        final Аргумент титул (ткст имя)
        {
            this.имя = имя;
            return this;
        }

        /***************************************************************

                Набор the помощь текст for this аргумент

        ***************************************************************/

        final Аргумент помощь (ткст текст)
        {
            this.текст = текст;
            return this;
        }

        /***************************************************************

                Fail the разбор when this арг is encountered. You
                might use this for managing помощь текст

        ***************************************************************/

        final Аргумент остановись ()
        {
            this.краш = да;
            return this;
        }

        /***************************************************************

                Ограничить значение до одного из набора

        ***************************************************************/

        final Аргумент ограничь (ткст[] опции ...)
        {
            this.опции = опции;
            return this;
        }

        /***************************************************************

                This арг is present, but установлен an ошибка condition
                (Экстра) when неожиданный и полого is not включен.
                Fires any configured вызывало обрвызов.

        ***************************************************************/

        private Аргумент активируй (бул неожиданный=нет)
        {
            this.установлен = да;
            if (макс > 0)
                this.outer.стэк.сунь(this);

            if (вызывало)
                вызывало();
            if (неожиданный)
                ошибка = Экстра;
            return this;
        }

        /***************************************************************

                Доб a parameter значение, invoking an инспектор as
                necessary

        ***************************************************************/

        private проц добавь (ткст значение, бул явный=нет)
        {
            // вынь в_ an аргумент that can прими implicit параметры?
            if (явный is нет)
                for (auto s=&this.outer.стэк; эксп && s.размер>1; this=s.верх)
                    s.вынь;

            this.установлен = да;        // needed for default assignments
            значения ~= значение;        // добавь new значение

            if (ошибка is Нет)
            {
                if (инспектор)
                    if ((bogus = инспектор(значение)).length)
                        ошибка = Неверный;

                if (опции.length)
                {
                    ошибка = Опция;
                    foreach (опция; опции)
                    if (опция == значение)
                        ошибка = Нет;
                }
            }
            // вынь в_ an аргумент that can прими параметры
            for (auto s=&this.outer.стэк; значения.length >= макс && s.размер>1; this=s.верх)
                s.вынь;
        }

        /***************************************************************

                Test и установлен the ошибка флаг appropriately

        ***************************************************************/

        private цел действителен ()
        {
            if (ошибка is Нет)
                if (треб && !установлен)
                    ошибка = Требуется;
                else if (установлен)
                {
                    // крат circuit?
                    if (краш)
                        return -1;

                    if (значения.length < мин)
                        ошибка = ПарамМлад;
                    else if (значения.length > макс)
                        ошибка = ПарамСтарш;
                    else
                    {
                        foreach (арг; зависимости)
                        if (! арг.установлен)
                            ошибка = Требует, bogus=арг.имя;

                        foreach (арг; конфликты)
                        if (арг.установлен)
                            ошибка = Конфликт, bogus=арг.имя;
                    }
                }

            debug(Аргументы) стдвыв.форматнс ("{}: ошибка={}, установлен={}, мин={}, макс={}, "
                    "треб={}, значения={}, дефолты={}, требует={}",
                    имя, ошибка, установлен, мин, макс, треб, значения,
                    дефолты, зависимости);
            return ошибка;
        }
    }
}


/*******************************************************************************

*******************************************************************************/

debug(UnitTest)
{
    unittest
    {
        auto арги = new Аргументы;

        // basic
        auto x = арги['x'];
        assert (арги.разбор (""));
        x.требуется;
        assert (арги.разбор ("") is нет);
        assert (арги.очисть.разбор ("-x"));
        assert (x.установлен);

        // alias
        x.есть_алиас('X');
        assert (арги.очисть.разбор ("-X"));
        assert (x.установлен);

        // неожиданный арг (with полого)
        assert (арги.очисть.разбор ("-y") is нет);
        assert (арги.очисть.разбор ("-y") is нет);
        assert (арги.очисть.разбор ("-y", да) is нет);
        assert (арги['y'].установлен);
        assert (арги.очисть.разбор ("-x -y", да));

        // параметры
        x.парамы(0);
        assert (арги.очисть.разбор ("-x param"));
        assert (x.назначено.length is 0);
        assert (арги(пусто).назначено.length is 1);
        x.парамы(1);
        assert (арги.очисть.разбор ("-x=param"));
        assert (x.назначено.length is 1);
        assert (x.назначено[0] == "param");
        assert (арги.очисть.разбор ("-x param"));
        assert (x.назначено.length is 1);
        assert (x.назначено[0] == "param");

        // too many арги
        x.парамы(1);
        assert (арги.очисть.разбор ("-x param1 param2"));
        assert (x.назначено.length is 1);
        assert (x.назначено[0] == "param1");
        assert (арги(пусто).назначено.length is 1);
        assert (арги(пусто).назначено[0] == "param2");

        // сейчас with default парамы
        assert (арги.очисть.разбор ("param1 param2 -x=blah"));
        assert (арги[пусто].назначено.length is 2);
        assert (арги(пусто).назначено.length is 2);
        assert (x.назначено.length is 1);
        x.парамы(0);
        assert (!арги.очисть.разбор ("-x=blah"));

        // арги as parameter
        assert (арги.очисть.разбор ("- -x"));
        assert (арги[пусто].назначено.length is 1);
        assert (арги[пусто].назначено[0] == "-");

        // multИПle флаги, with alias и полого
        assert (арги.очисть.разбор ("-xy"));
        assert (арги.очисть.разбор ("-xyX"));
        assert (x.установлен);
        assert (арги['y'].установлен);
        assert (арги.очисть.разбор ("-xyz") is нет);
        assert (арги.очисть.разбор ("-xyz", да));
        auto z = арги['z'];
        assert (z.установлен);

        // multИПle флаги with trailing арг
        assert (арги.очисть.разбор ("-xyz=10"));
        assert (z.назначено.length is 1);

        // again, but without полого param declaration
        z.парамы(0);
        assert (!арги.очисть.разбор ("-xyz=10"));
        assert (арги.очисть.разбор ("-xzy=10"));
        assert (арги('y').назначено.length is 1);
        assert (арги('x').назначено.length is 0);
        assert (арги('z').назначено.length is 0);

        // x требует y
        x.требует('y');
        assert (арги.очисть.разбор ("-xy"));
        assert (арги.очисть.разбор ("-xz") is нет);

        // дефолты
        z.дефолты("foo");
        assert (арги.очисть.разбор ("-xy"));
        assert (z.назначено.length is 1);

        // дол names, with парамы
        assert (арги.очисть.разбор ("-xy --fСПДar") is нет);
        assert (арги.очисть.разбор ("-xy --fСПДar", да));
        assert (арги["y"].установлен && x.установлен);
        assert (арги["fСПДar"].установлен);
        assert (арги.очисть.разбор ("-xy --fСПДar=10"));
        assert (арги["fСПДar"].назначено.length is 1);
        assert (арги["fСПДar"].назначено[0] == "10");

        // smush аргумент z, but not другие
        z.парамы;
        assert (арги.очисть.разбор ("-xy -zsmush") is нет);
        assert (x.установлен);
        z.smush;
        assert (арги.очисть.разбор ("-xy -zsmush"));
        assert (z.назначено.length is 1);
        assert (z.назначено[0] == "smush");
        assert (x.назначено.length is 0);
        z.парамы(0);

        // conflict x with z
        x.конфликтует(z);
        assert (арги.очисть.разбор ("-xyz") is нет);

        // word режим, with префикс elimination
        арги = new Аргументы (пусто, пусто);
        assert (арги.очисть.разбор ("foo bar wumpus") is нет);
        assert (арги.очисть.разбор ("foo bar wumpus wombat", да));
        assert (арги("foo").установлен);
        assert (арги("bar").установлен);
        assert (арги("wumpus").установлен);
        assert (арги("wombat").установлен);

        // use '/' instead of '-'
        арги = new Аргументы ("/", "/");
        assert (арги.очисть.разбор ("/foo /bar /wumpus") is нет);
        assert (арги.очисть.разбор ("/foo /bar /wumpus /wombat", да));
        assert (арги("foo").установлен);
        assert (арги("bar").установлен);
        assert (арги("wumpus").установлен);
        assert (арги("wombat").установлен);

        // use '/' for крат и '-' for дол
        арги = new Аргументы ("/", "-");
        assert (арги.очисть.разбор ("-foo -bar -wumpus -wombat /abc", да));
        assert (арги("foo").установлен);
        assert (арги("bar").установлен);
        assert (арги("wumpus").установлен);
        assert (арги("wombat").установлен);
        assert (арги("a").установлен);
        assert (арги("b").установлен);
        assert (арги("c").установлен);

        // "--" makes все subsequent be implicit параметры
        арги = new Аргументы;
        version (dashdash)
        {
            арги('f').парамы(0);
            assert (арги.разбор ("-f -- -bar -wumpus -wombat --abc"));
            assert (арги('f').назначено.length is 0);
            assert (арги(пусто).назначено.length is 4);
        }
        else
        {
            арги('f').парамы(2);
            assert (арги.разбор ("-f -- -bar -wumpus -wombat --abc"));
            assert (арги('f').назначено.length is 2);
            assert (арги(пусто).назначено.length is 2);
        }
    }
}

/*******************************************************************************

*******************************************************************************/

debug (Аргументы)
{
    import io.Stdout;

    проц main()
    {
        ткст crap = "crap";
        auto арги = new Аргументы;

        арги(пусто).титул("корень").парамы.помощь("корень помощь");
        арги('x').есть_алиас('X').парамы(0).требуется.помощь("x помощь");
        арги('y').дефолты("hi").парамы(2).smush.явный.помощь("y помощь");
        арги('a').требуется.дефолты("hi").требует('y').парамы(1).помощь("a помощь");
        арги("fСПДar").парамы(2).помощь("fСПДar помощь");
        if (! арги.разбор ("'one =two' -xa=bar -y=ff -yss --fСПДar=blah1 --fСПДar barf blah2 -- a b c d e"))
            стдвыв (арги.ошибки(&стдвыв.выкладка.sprint));
        else if (арги.получи('x'))
            арги.помощь ((ткст a, ткст b)
        {
            Стдвыв.форматнс ("{}{}\n\t{}", арги.дп, a, b);
        });
    }
}
