module io.protocol.model;

private import io.model;

/*******************************************************************************
        
*******************************************************************************/

class ИПротокол
{
        enum Тип
        {
                Проц = 0,
                Утф8, 
                Бул,
                Байт,
                ББайт,
                Утф16,
                Крат,
                БКрат,
                Утф32,
                Цел,
                БЦел,
                Плав,
                Дол,
                БДол,
                Дво,
                Реал,
                Объ,
                Указатель,
        }
        
        /***********************************************************************

        ***********************************************************************/

        alias проц   delegate (ук ист, бцел байты, Тип тип) Писатель;
        alias проц   delegate (ук ист, бцел байты, Тип тип) ПисательМассива;

        alias проц[] delegate (ук приёмн, бцел байты, Тип тип) Читатель;
        alias проц[] delegate (Читатель читатель, бцел байты, Тип тип) Разместитель;

        alias проц[] delegate (ук приёмн, бцел байты, Тип тип, Разместитель) ЧитательМассива;
        
        /***********************************************************************

        ***********************************************************************/

        abstract ИБуфер буфер ();

        /***********************************************************************

        ***********************************************************************/

        abstract проц[] читай (ук приёмн, бцел байты, Тип тип);

        /***********************************************************************

        ***********************************************************************/

        abstract проц пиши (ук ист, бцел байты, Тип тип);

        /***********************************************************************

        ***********************************************************************/

        abstract проц[] читайМассив (ук приёмн, бцел байты, Тип тип, Разместитель размести);
        
        /***********************************************************************

        ***********************************************************************/

        abstract проц пишиМассив (ук ист, бцел байты, Тип тип);
}


/*******************************************************************************

*******************************************************************************/

class ИРазместитель
{
        /***********************************************************************
        
        ***********************************************************************/

        abstract проц сбрось ();
        
        /***********************************************************************

        ***********************************************************************/

        abstract ИПротокол протокол ();

        /***********************************************************************

        ***********************************************************************/

        abstract проц[] размести (ИПротокол.Читатель, бцел байты, ИПротокол.Тип);
}

/*******************************************************************************

        Интерфейс ИЧитатель. Каждый читатель оперирует над ИБуфер, который
        предоставлен во время конструирования. Читатели - это простые преобразователи
		данных,имеющие строгий набор правил,относительно формата данных. Например,
        при каждом запросе данных ожидается наличие контента; когда это не так,
        выводится исключение. Если данные организованы более простым способом,
        в таком случае лучше напрямую использовать ИБуфер.

        Все читатели поддерживают полный набор исконных типов данных, плюс полное
        выделение типов массивов. Последний может быть сконфигурирован на произведение
        либо копии (.dup) контента этого буфера, либо среза. Смотрите классы
        КопияКучи, СрезБуфера и СрезКучи , чтобы узнать больше. Приложения могут
        отключать управление памятью, конфигурирую Читатель по одному из бинарно
        ориентированных протоколов, и шарантируя отключение 'префикса' необязательного
        протокола.

        Читатели поддерживают Java-вскую нотацию получи(). Однако, в стиле предка Динруса
        помещать элементы ввода-вывода внутри их собственных скобок, наподобии этого:
        
        ---
        цел счёт;
        ткст стих;
        
        читай (стих) (счёт);
        ---

        Заметьте, что каждый элемент читай отделён; этот стиль пристрастно
        известен как "шёпот". Код ниже иллюстрирует базовые операции над
        буфером памяти:
        
        ---
        auto буф = new Буфер (256);

        // картировать один и тот же буфер всем читателям и писателям
        auto читай = new Читатель (буф);
        auto пиши = new Писатель (буф);

        цел i = 10;
        дол j = 20;
        дво d = 3.14159;
        ткст c = "fred";

        // пишим данные используя синтаксис "шёпот"
        пиши (c) (i) (j) (d);

        // читаем их обратно
        читай (c) (i) (j) (d);


        // опять то же самое, но используем синтаксис помести() вместо прежднего
		
        пиши.помести(c).помести(i).помести(j).помести(d);
        читай.получи(c).получи(i).получи(j).получи(d);
        ---

        Заметьте, что некоторые протоколы, такие как базовая бинарная реализация, 
        ожидают получить число элементов массива из истока. Например,
        при чтении массива из файла, число элементов такде считавается
		из файла, и вывывается конфигурируемый менеджер памяти,
		предоставляющие пространство массиву. Если контент не организован в такой
        манере, прочитать контент массива напрямую можно либо создавая
        Читатель по протоколу, сконфигурированному с отступом от префиксации массива,
        либо напрямую получая доступ к буферу(через выставленные там методы),
        например:

        ---
        проц[10] данные;
                
        читатель.буфер.заполни (данные);
        ---

        Читатели также могут использоваться с любым классом, реализующим
		интерфейс ИЧитаемое, вместе с любой структурой, реализующей
		эквивалентный метод.
        
*******************************************************************************/

class ИЧитатель   // могло бы быть интерфейсом, но это даёт плохую генерацию кода
{
        alias получи opCall;

        /***********************************************************************
        
                Это основные методы читателя.

        ***********************************************************************/

        abstract ИЧитатель получи (inout бул x);
        abstract ИЧитатель получи (inout байт x);            /// описано ранее
        abstract ИЧитатель получи (inout ббайт x);           /// описано ранее
        abstract ИЧитатель получи (inout крат x);           /// описано ранее
        abstract ИЧитатель получи (inout бкрат x);          /// описано ранее
        abstract ИЧитатель получи (inout цел x);             /// описано ранее
        abstract ИЧитатель получи (inout бцел x);            /// описано ранее
        abstract ИЧитатель получи (inout дол x);            /// описано ранее
        abstract ИЧитатель получи (inout бдол x);           /// описано ранее
        abstract ИЧитатель получи (inout плав x);           /// описано ранее
        abstract ИЧитатель получи (inout дво x);          /// описано ранее
        abstract ИЧитатель получи (inout реал x);            /// описано ранее
        abstract ИЧитатель получи (inout сим x);            /// описано ранее
        abstract ИЧитатель получи (inout шим x);           /// описано ранее
        abstract ИЧитатель получи (inout дим x);           /// описано ранее

        abstract ИЧитатель получи (inout бул[] x);          /// описано ранее
        abstract ИЧитатель получи (inout байт[] x);          /// описано ранее
        abstract ИЧитатель получи (inout крат[] x);         /// описано ранее
        abstract ИЧитатель получи (inout цел[] x);           /// описано ранее
        abstract ИЧитатель получи (inout дол[] x);          /// описано ранее
        abstract ИЧитатель получи (inout ббайт[] x);         /// описано ранее
        abstract ИЧитатель получи (inout бкрат[] x);        /// описано ранее
        abstract ИЧитатель получи (inout бцел[] x);          /// описано ранее
        abstract ИЧитатель получи (inout бдол[] x);         /// описано ранее
        abstract ИЧитатель получи (inout плав[] x);         /// описано ранее
        abstract ИЧитатель получи (inout дво[] x);        /// описано ранее
        abstract ИЧитатель получи (inout реал[] x);          /// описано ранее
        abstract ИЧитатель получи (inout ткст x);          /// описано ранее
        abstract ИЧитатель получи (inout шим[] x);         /// описано ранее
        abstract ИЧитатель получи (inout дим[] x);         /// описано ранее

        /***********************************************************************
        
                Этот механизм используется для привязки произвольных классов 
                к системе ввода-вывода. Если класс реализует ИЧитаемое, он может
                быть использован как мишень для операций ИЧитатель получи(). То есть, 
                реализация ИЧитаемое нацелена на трансформирование любого класса 
                в адаптор класса ИЧитатель для содержащегося в нём контента.

        ***********************************************************************/

        abstract ИЧитатель получи (ИЧитаемое);

        alias проц delegate (ИЧитатель) Клозура;

        abstract ИЧитатель получи (Клозура);

        /***********************************************************************
        
                Возвращает буфер, асоциированный с этим читателем.

        ***********************************************************************/

        abstract ИБуфер буфер ();

        /***********************************************************************
        
                Получить разместитель для использования в управлении массивом.
				Массивы, как правило, размещаются ИЧитатель, посредством сконфигурированных
				менеджеров. Ряд классов Разместитель доступен для управления памятью
                при чтении контента Массива. Кроме того, приложение может
                обретать ответственность за размещение, выбирая одну из производных
                ПротоколНатив и устанавливая 'префикс' в значение "нет".
				Последнее отключает внутреннее управление массивом.

                Получение доступа к разместителю может давать дополнительные
				элементы управления. Например, некоторые разместители
				получают пользу от операций "сбрось" после обработки
				каждой 'записи' данных.

                По умолчанию, какой-либо ИЧитатель размещает каждый Массив в
                куче. Это можно изменить, построив Читателя с определённым
                Разместителем. Например, есть СрезБуфера, который сделает
				срез Массива прямо из буфера, если такое возможно.

                Детальную информацию можно найти в модуле io.protocol.Allocator.

        ***********************************************************************/

        abstract ИРазместитель разместитель (); 
}

/*******************************************************************************

        Каждый класс, реализующий ИЧитаемое, становится частью фреймворка Читатель.
        
*******************************************************************************/

interface ИЧитаемое
{
        проц читай (ИЧитатель ввод);
}

/*******************************************************************************

        Интерфейс ИПисатель. Писатели предоставляют средства добавления
		форматированных данных в ИБуфер, и выставляют удобный метод для обработки
        данных различных типов. В дополнение к записи таких исконных типов, как
        целое и ткст, писатели также обрабатывают любой класс, который
        реализует интерфейс ИЗаписываемое (один метод).

        Все писатели поддерживают полный набор исконных типов данных, плюс их
        фундаментальные варианты массивов. Операции могут сцепляться край-к-краю.

        Писатели поддерживают Java-вскую нотацию получи(). Однако, в стиле предка Динруса
        помещать элементы ввода-вывода внутри их собственных скобок, наподобии этого:

        ---
        пиши (счёт) (" green bottles");
        ---

        Заметьте, что каждый элемент записано отделён; этот стиль пристрастно
        известен как "шёпот". Код ниже иллюстрирует базовые операции над
        буфером памяти:
        
        ---
        auto буф = new Буфер (256);

        // картировать один и тот же буфер всем читателям и писателям
        auto читай = new Читатель (буф);
        auto пиши = new Писатель (буф);

        цел i = 10;
        дол j = 20;
        дво d = 3.14159;
        ткст c = "fred";

        // выпишим типы данных
        пиши (c) (i) (j) (d);

        // читаем их обратно
        читай (c) (i) (j) (d);


         // опять то же самое, но используем синтаксис помести()
		 
        пиши.помести(c).помести(i).помести(j).помести(d);
        читай.получи(c).получи(i).получи(j).получи(d);

        ---

        Читатели также могут использоваться с любым классом, реализующим
		интерфейс ИЗаписываемое, вместе с любой структурой, реализующей
		эквивалентную функцию.

*******************************************************************************/

class ИПисатель // могло бы быть интерфейсом, но это даёт плохую генерацию кода
{
        alias помести opCall;

        /***********************************************************************
        
                Это основные методы писателя.

        ***********************************************************************/

        abstract ИПисатель помести (бул x);
        abstract ИПисатель помести (ббайт x);         ///описано ранее
        abstract ИПисатель помести (байт x);          ///описано ранее
        abstract ИПисатель помести (бкрат x);        ///описано ранее
        abstract ИПисатель помести (крат x);         ///описано ранее
        abstract ИПисатель помести (бцел x);          ///описано ранее
        abstract ИПисатель помести (цел x);           ///описано ранее
        abstract ИПисатель помести (бдол x);         ///описано ранее
        abstract ИПисатель помести (дол x);          ///описано ранее
        abstract ИПисатель помести (плав x);         ///описано ранее
        abstract ИПисатель помести (дво x);        ///описано ранее
        abstract ИПисатель помести (реал x);          ///описано ранее
        abstract ИПисатель помести (сим x);          ///описано ранее
        abstract ИПисатель помести (шим x);         ///описано ранее
        abstract ИПисатель помести (дим x);         ///описано ранее

        abstract ИПисатель помести (бул[] x);
        abstract ИПисатель помести (байт[] x);        ///описано ранее
        abstract ИПисатель помести (крат[] x);       ///описано ранее
        abstract ИПисатель помести (цел[] x);         ///описано ранее
        abstract ИПисатель помести (дол[] x);        ///описано ранее
        abstract ИПисатель помести (ббайт[] x);       ///описано ранее
        abstract ИПисатель помести (бкрат[] x);      ///описано ранее
        abstract ИПисатель помести (бцел[] x);        ///описано ранее
        abstract ИПисатель помести (бдол[] x);       ///описано ранее
        abstract ИПисатель помести (плав[] x);       ///описано ранее
        abstract ИПисатель помести (дво[] x);      ///описано ранее
        abstract ИПисатель помести (реал[] x);        ///описано ранее
        abstract ИПисатель помести (ткст x);        ///описано ранее
        abstract ИПисатель помести (шим[] x);       ///описано ранее
        abstract ИПисатель помести (дим[] x);       ///описано ранее

        /***********************************************************************
				
                Этот механизм используется для привязки произвольных классов 
                к системе ввода-вывода. Если класс реализует ИЗаписываемое, он может
                быть использован как мишень для операций ИПисатель помести(). То есть, 
                реализация ИЗаписываемое нацелена на трансформирование любого класса 
                в адаптор класса ИПисатель для содержащегося в нём контента.

        ***********************************************************************/

        abstract ИПисатель помести (ИЗаписываемое);

        alias проц delegate (ИПисатель) Клозура;

        abstract ИПисатель помести (Клозура);

        /***********************************************************************
        
                Сгенерировать нс.
                
        ***********************************************************************/

        abstract ИПисатель нс ();
        
        /***********************************************************************
        
                Слить вывод этого писателя. Выводит исключение ВВИскл, 
                если операция не удаётся. Это псевдонимы для друг друга.

        ***********************************************************************/

        abstract ИПисатель слей ();
        abstract ИПисатель помести ();        ///описано ранее

        /***********************************************************************
        
                Вернуть ассоциированный буфер.

        ***********************************************************************/

        abstract ИБуфер буфер ();
}


/*******************************************************************************

        Интерфейс, делающий любой класс совместимым с любым ИПисатель.

*******************************************************************************/

interface ИЗаписываемое
{
        abstract проц пиши (ИПисатель ввод);
}


