/*******************************************************************************

        Разместители используются совместно с классом Читатель. Они
        предназначены для управления размещением в памяти массивов
		для разнообразных методов Читатель.получи().

*******************************************************************************/

module io.protocol.Allocator;

private import  io.protocol.model;

extern(D):

/*******************************************************************************

        Простой разместитель, копирующий в кучу каждый затребованный массив:
        это дефолтное поведение для экземпляров класса Читатель.
        
*******************************************************************************/

 class КопияКучи : ИРазместитель
{
        this (ИПротокол протокол);
        final ИПротокол протокол ();
        final проц сбрось ();
        final проц[] размести (ИПротокол.Читатель читатель, бцел байты, ИПротокол.Тип тип);
}


/*******************************************************************************

        Размещение на приватном пространстве кучи. Поддерживается чтение
        данных как 'записей', повторно используя тот же чанк памяти для
		каждой загруженной записи. Конструктор принимает аргумент, определяющий
		произведенное начальное размещение, которое при необходимости увеличивается,
		чтобы вместить записи большего размера. Метод сбрось() используется для
		указания конца записи (повторно использовать память для последующих
		запросов), либо устанавливается флаг автосброса для повторного использования
		для каждого массива.
        
*******************************************************************************/

class СрезКучи : ИРазместитель
{
        this (ИПротокол протокол, бцел ширина=4096, бул автосброс=нет);
        final ИПротокол протокол ();

        /***********************************************************************
        
                Сбрасывает длину контента в ноль.

        ***********************************************************************/

        final проц сбрось ();

        /***********************************************************************
        
                Без размещения - копирует в зарезервированную арену.

                С помощью СрезКучи, как правило, размещается достаточное
				пространство, для вмещения, скажем, записи данных. Зарезервированное
                пространство будет увеличиваться для вмещения больших записей.
				Вызов метода сбрось() производится между каждым чтением записи,
                чем гарантируется повторное использование пространства.
                
        ***********************************************************************/

        final проц[] размести (ИПротокол.Читатель читатель, бцел байты, ИПротокол.Тип тип);
}


/*******************************************************************************

        Создаёт псевдоним прямо из буфера, вместо размещения в пямять кучи.
        Этим избегается активность кучи и копирование, но требует большей
        аккуратности при использовании. Смотрите информацию о методах размести().
        
*******************************************************************************/

class СрезБуфера : ИРазместитель
{

        this (ИПротокол протокол);
        final ИПротокол протокол ();

        /***********************************************************************

                Переместить все неиспользованные данные в начало буфера, 
				освобождая дополнительное пространство.
                
        ***********************************************************************/

        final проц сбрось ();
        
        /***********************************************************************
        
                Без размещения и копирования: создание псевдонима прямо из буфера.
				Хоть это и очень эффективно (никакой кучи), следует использовать
				это только в тех сценариях, где контент заведомо помещается в
				буфер, и нет преобразования стороннего контента, например,
				при использовании протокола ПротоколЭндиан, который требует
				преобразования внутри буфера, потенциально запутывая дополнительных
				клиентов буфера.

                Используя СрезБуфера можно создавать буфер, достаточный для
				вмещения, скажем, файла, затем создавать срез всех строк/массивов
				прямо из этого буфера. Небольшие буферы можно использовать
				ориентированным на запись образов, подобно СрезКучи:
                вызывается сбрось() перед обработкой каждой записи, чтобы
				гарантировалось достаточное пространство в буфере,
				позволяющее вместить полную запись. БуферРоста может использоваться
				в последнем  случае, гарантируя что всегда будет место для
                записи большего размера.

                Неплохо использовать это при обработке сетевого трафика, где
                входящие данные часто тринзиентны и имеют известную протяженность.
				Для другого потенциального применения рассматриваем количество
				отдельных текстовых массивов, генерируемых парсером XML, -- 
				было бы удобно сделать срез их всех из единого места размещения.
               
        ***********************************************************************/

        final проц[] размести (ИПротокол.Читатель читатель, бцел байты, ИПротокол.Тип тип);
}
