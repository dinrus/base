module io.selector.model;

public import time.Time;
public import io.model;

/**
 * События, используемые для регистрации Провода к селектору и возвращаемые
 * в КлючеВыбора после вызова ИСелектор.выбери().
 */
enum Событие: бцел
{
    Нет            = 0,        // Нет события
    // ВАЖНО: Не меняйте значения следующих символов. Они установлены
    //            в соответствии со значениями, возвращаемыми системой вызовов POSIX poll().
    Чит            = (1 << 0), // POLLIN
    СрочноеЧтение      = (1 << 1), // POLLPRI
    Зап           = (1 << 2), // POLLOUT
    // Следующие события не следует использовать при регистрировании провода в
    // селектор. Они используются только при возвращении события пользователю.
    Ошибка           = (1 << 3), // POLLERR
    Зависание          = (1 << 4), // POLLHUP
    НеверныйУк   = (1 << 5)  // POLLNVAL
}


/**
 * Структура КлючВыбора содержит информацию, касающуюся проводов и их ассоциации
 * с селектором. Каждый ключ содержит ссылку на зарегистрированный провод
 * провод и события, которые бубуд на нём отслеживаться. Член 'события'
 * этого ключа может принимать два значения, в зависимости от того, где используется.
 * Если он использован с методом регистрируй() селектора, то представляет события,
 * которые нам нужно отслеживать; если использован внутри цикла foreach на ИНаборВыделений,
 * то он представляет события, которые были детектированы на проводе.
 *
 * КлючВыбора может также содержать необязательно объект через член 'атачмент'.
 * Этот член очень удобен для хранения специфичных данных приложения,
 * которые понадобятся при триггировании отслеживаемого события.
 *
 * Смотрите $(LINK $(CODEURL)io.selector.ИСелектор),
 * $(LINK $(CODEURL)io.selector.ИНаборВыделений)
 */
struct КлючВыбора
{
    /**
     * Провод, на который ссылается КлючВыбора.
     */
    ИВыбираемый провод;

    /**
     * Зарегистрированные (или селектированные) события как бит-маска 
	 * значения другого События.
     */
    Событие события;

    /**
     * Прикреплённый Объект, на который ссылается КлючВыбора.
     */
    Объект атачмент;

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Чит.
     */
    public бул читаем_ли()
    {
        return ((события & Событие.Чит) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие СрочноеЧтение.
     */
    public бул срочноеЧтен_ли()
    {
        return ((события & Событие.СрочноеЧтение) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Зап.
     */
    public бул записываем_ли()
    {
        return ((события & Событие.Зап) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Ошибка.
     */
    public бул ошибка_ли()
    {
        return ((события & Событие.Ошибка) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Зависание.
     */
    public бул зависание_ли()
    {
        return ((события & Событие.Зависание) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие НеверныйУк.
     */
    public бул невернУк_ли()
    {
        return ((события & Событие.НеверныйУк) != 0);
    }
}


/**
 * Контейнер, хранящий КлючиВыбора для всех проводов, триггировавших
 * события при первом вызове метода ИСелектор.выбери().
 * Экземпляры этого контейнера обычно возвращаются из вызова
 * ИСелектор.наборВыд().
 */
interface ИНаборВыделений
{
    /**
     * Возвращает число КлючейВыбора в этом наборе.
     */
    public abstract бцел длина();

    /**
     * Оператор для итерации по набору с помощью блока foreach. Помните, что
     * любые изменения этого КлючаВыбора будут игнорироваться.
     */
    public abstract цел opApply(цел delegate(ref КлючВыбора) дг);
}


/**
 * Селектор - это мультиплексор для событий ввода-вывода, ассоциированный с Проводом.
 * Все селекоры должны реадизовывать этот интерфейс.
 *
 * Селектор нужно инициализировать вызовом метода открой(), чтобы сообщить
 * начальное количество проводов, на которые он будет указывать, и максимальное
 * количество событий, которое будет возвращено при каждом вызове выбери().
 * В любом случае эти значени - только рекомендации;они могут даже не использоваться
 * в определённых реализациях ИСелектор, поэтому трудно предсказать результат
 * вызова метода выбери() (то есть может быть больше или меньше событий,
 * нежели вами указано в аргументе 'максСобытий'. Количество проводов, с которыми
 * может иметь дело селектор, при необходимости будет динамически увеличено.
 *
 * Для добавления или изменения регистрации проводов в селекторе, используется
 * метод регистрируй(). Для удаления регистрации проводов из селектора,- метод
 * отмениРег().
 *
 * Для ожидания событий от проводов нужно вызвать любой из методов выбери().
 * Селектор не может быть изменён из другой нити (потока), пока он блокирован
 * вызовами этих методов.
 *
 * Когда селектор больше не используется требуется вызвать метод закрой(), чтобы
 * селектор смог освободить ресурсы, размещённые им в памяти при вызове открой().
 *
  * Примеры:
 * ---
 * import io.selector.model;
 * import net.device.Socket;
 * import io.Stdout;
 *
 * АбстрактныйСелектор селектор;
 * СокетПровод провод1;
 * СокетПровод провод2;
 * МойКласс объект1;
 * МойКласс объект2;
 * бцел счётСобытий;
 *
 * // Инициализируем селектор, предполагая его работу с двумя проводами
 * // и приём им двух событий на каждый вызов метода выбери().
 * селектор.открой(2, 2);
 *
 * селектор.регистрируй(провод, Событие.Чит, объект1);
 * селектор.регистрируй(провод, Событие.Зап, объект2);
 *
 * счётСобытий = селектор.выбери();
 *
 * if (счётСобытий > 0)
 * {
 *     сим[16] буфер;
 *     цел счёт;
 *
 *     foreach (КлючВыбора ключ, селектор.наборВыд())
 *     {
 *         if (ключ.читаем_ли())
 *         {
 *             счёт = (cast(СокетПровод) ключ.провод).читай(буфер);
 *             if (счёт != ИПровод.Кф)
 *             {
 *                 Стдвыв.форматируй("Принято '{0}' из пира\n", буфер[0..счёт]);
 *                 селектор.регистрируй(ключ.провод, Событие.Зап, ключ.атачмент);
 *             }
 *             else
 *             {
 *                 селектор.отмениРег(ключ.провод);
 *                 ключ.провод.закрой();
 *             }
 *         }
 *
 *         if (ключ.записываем_ли())
 *         {
 *             счёт = (cast(СокетПровод) ключ.провод).пиши("СООБЩЕНИЕ");
 *             if (счёт != ИПровод.Кф)
 *             {
 *                 Стдвыв("'СООБЩЕНИЕ' отправлено в пир\n");
 *                 селектор.регистрируй(ключ.провод, Событие.Чит, ключ.атачмент);
 *             }
 *             else
 *             {
 *                 селектор.отмениРег(ключ.провод);
 *                 ключ.провод.закрой();
 *             }
 *         }
 *
 *         if (ключ.ошибка_ли() || ключ.зависание_ли() || ключ.невернУк_ли())
 *         {
 *             селектор.отмениРег(ключ.провод);
 *             ключ.провод.закрой();
 *         }
 *     }
 * }
 *
 * селектор.закрой();
 * ---
 */
interface ИСелектор
{
    /**
     * Инициализирует селектор.
     *
     * Параметры:
     * размер         = значение, рекомендующее максимальное число 
     *                регестрируемых проводов.
     * максСобытий    = значение, рекомендующее максимальное число событий
     *                провода, возвращаемое в наборе селекции
     *                на каждый вызов метода выбери.
     */
    public abstract проц открой(бцел размер, бцел maxEvents);

    /**
     * Освободить ресурсы операционной системы, которые могли быть размещены в
     * впамяти при вызове метода открой().
     *
     * Примечания:
     * Требуется освобождение памяти только тех ресурсов, которые размещены там селектором.
     * Не все селекторы это делают. В их деструкторе обычно присутствует метод закрой().
     */
    public abstract проц закрой();

    /**
     * Ассоциировать провод с селектором и отслеживать события ввода-вывода.
     *
     * Параметры:
     * провод      = провод, ассоциируемый с селектором.
     * события       = бит-маска значения События, представляющая события,
     *                которые будут отслеживаться на этом проводе.
     * атачмент   = необязательный объект со специфицными для приложения данными,
     *                которые будут доступны при тригерировании события для этого провода.
     *
     * Примеры:
     * ---
     * АбстрактныйСелектор селектор;
     * СокетПровод провод;
     * МойКласс объект;
     *
     * селектор.регистрируй(провод, Событие.Чит | Событие.Зап, объект);
     * ---
     */
    public abstract проц регистрируй(ИВыбираемый провод, Событие события,
    Объект атачмент = пусто);

    /**
     * Удаляет провод из селектора.
     *
     * Параметры:
     * провод      = провод, ранее ассоциированный с селектором; может быть равен пусто.
     *
     * Примечания:
     * Отрегистрирование провода со значением пусто допустимо, и  исключение не выводится.
     */
    public abstract проц отмениРег(ИВыбираемый провод);


    /**
     * Ждёт события ввода-вывода из зарегистрированных проводов неопределённое время.
     *
     * Возвращает:
     * Количество проводов, принявших события; 0 если нет проводов,
     * принявших события за обозначенный таймаут и -1, если
     * была ошибка.
     */
    public abstract цел выбери();

    /**
     *Ждёт события ввода-вывода из зарегистрированных проводов указанное время.
     *
     * Параметры:
     * таймаут  = ИнтервалВремени с максимальным временем, которое этот
     *            селектор будет ждать события из проводов; время
     *            относительно текущего системного
     *            (т.е. только число милллисекунд, которое селектор
     *            должен ждать события).
     *
     * Возвращает:
	 * Количество проводов, принявших события; 0 если нет проводов,
     * принявших события за обозначенный таймаут.
     */
    public abstract цел выбери(ИнтервалВремени таймаут);

    /**
     *Ждёт события ввода-вывода из зарегистрированных проводов указанное время.
     *
     * Примечание: Это представление таймаута не всегда точное, поэтому
     * возможно, что эта функция возвратит раньше указанного
     * периода.  Для большей точности лучше использовать версию с ИнтервалВремени.
     *
     * Примечание: Реализаторам следует определять этот метод как:
     * -------
     * выбери(ИнтервалВремени.интервал(таймаут));
     * -------
     *
     * Параметры:
     * таймаут  = Максимальное количество времени в секундах, которое
     *            селектор будет ждать события из проводов;
     *            время относительно к текущему системному
     *            (т.е. только число миллисекунд, которое селектор
     *            должен ждать события).
     *
     * Возвращает:
	 * Количество проводов, принявших события; 0 если нет проводов,
     * принявших события за обозначенный таймаут.
     */
    public abstract цел выбери(дво таймаут);

    /**
     * Возвращает набор выделений, результирующий вызов любого метода выбери().
     *
     * Примечания:
     * Если вызов выбери() не удался, либо не вернул никакого
     * события, возвратное значение будет пусто.
     */
    public abstract ИНаборВыделений наборВыд();

    /**
     * Возвращает ключ выбора, результирующий регистрацию провода
     * в селекторе.
     *
     * Примечания:
     * Если провод не зарегистрирован в селекторе, возвратное
     * значение будет КлючВыбора.init. Этот метод не выводит
     * никаких исключений.
     */
    public abstract КлючВыбора ключ(ИВыбираемый провод);

    /**
     * Итерирует по текущим зарегистрированным ключам выбора.
     * Не следует стирать или добавлять элементы селектора
	 * во время итерации, хотя можно повторно зарегистрировать
     * существующие проводы.
     */
    public abstract цел opApply(цел delegate(ref КлючВыбора sk) дг);
}
