module io.selector.Selector;

/**
 * Мулитиплексор событий проводного ввода-вывода.
 *
 * Селектор может ждать события ввода-вывода (Чит, Зап и т.п.) на нескольких
 * проводах, не напрягая процессор.
 *
 * Селектор по существу представляет ваш системный мультиплексор ввода-вывода,
 * который определяется при компиляции.
 *
 * Для создания Селектора нужно использовать метод открой(), а когда он станет
 * ненужен, следует вызвать метод закрой(), чтобы высвободить системные ресурсы,
 * которые он может потреблять. Все селекторы должны высвобождать ресурсы
 * при вызове закрой(), поэтому деструктор реализуется с автоматическим вызовом
 * этого метода. Это подразумевает, что когда экземпляр селектора декларирован с
 * ключевым словом 'auto', не стоит беспокоиться о том, чтобы проделать этого
 * вручную.
 *
 * Как только селектор открыт, с ним нужно ассоциировать провода,
 * используя метод регистрируй().Этот метод принимает провод и
 * события, которые нужно отслеживать. Например, если нужно прочитать из
 * провода, то выполняют:
 *
 * ---
 * селектор.регистрируй(провод, Событие.Чит, мойОбъект);
 * ---
 *
 * Этот метод также принимает необязательный третий параметр, который
 * ассоциирует с проводом определяемый пользователем объект.
 * Три этих параметра вместе определяют КлючВыбора,
 * то есть то, что нужно принимать, когда этот провод "выделен"
 * (т.е. принимает событие).
 *
 * Если нужно изменить регистрацию провода. используется методe
 * повториРег(), работающий как регистрируй(), но ожидающий
 * передачи ему провода, который уже ассоциирован с этим селектором:
 *
 * ---
 * селектор.повториРег(провод, Событие.Зап, мойОбъект);
 * ---
 *
 * Если требуется удалить провод из этого селектора, вызывается метод
 * отмениРег():
 *
 * ---
 * селектор.отмениРег(провод);
 * ---
 *
 * Как только настройка проводов завершена, следует ожидать событий ввода-вывода.
 * Для этого используется метод выбери(). Этот метод блокируется до тех пор пока
 * не будет выделен како-либо из проводов, либо достугнут заданный таймаут.
 * В наличии две версии:
 * a) выбери(); b) выбери(Интервал);  первая - то же самое, что и
 * выбери(Интервал.макс). В этом случае у нас нет таймаута и
 * выбери() блокируется до тех пор пока не получит событие.
 *
 * Когда выбери() возвращает, принимается целое значение; если это целое
 * больше 0,  оно указывает число выделенных проводов.
 * Если это число равно 0, это означает, что селектор достиг таймаута, и
 * если оно равно -1, значит, произошла ошибка. Нормальный блок, обрабатывающий 
 * процесс выделения, выглядит примерно так:
 *
 * ---
 * try
 * {
 *     цел числоСобытий = селектор.выбери(10.0);
 *     if (числоСобытий > 0)
 *     {
 *         // Обработать события ввода-вывода в выделенном наборе.
 *     }
 *     else if (числоСобытий == 0)
 *     {
 *         // Таймаут
 *     }
 *     else if (числоСобытий == -1)
 *     {
 *         // Ошибка
 *     }
 *     else
 *     {
 *         // Ошибка: никогда не должно случаться.
 *     }
 * }
 * catch (ИсклСелектора e)
 * {
 *     Стдвыв.форматируй("Исключение: {0}", e.вТкст()).нс();
 * }
 * ---
 *
 * Наконец, для того чтобы собрать события, нужно итерировать по
 * набору выделений селектора, который можно получить методом наборВыд().
 *
 * ---
 * foreach (КлючВыбора ключ; селектор.наборВыд())
 * {
 *     if (ключ.читаем_ли())
 *     {
 *         // Читаем из провода
 *         // [...]
 *         // Затем регистрируем его для записи
 *         селектор.повториРег(ключ.провод, Событие.Зап, ключ.атачмент);
 *     }
 *
 *     if (ключ.записываем_ли())
 *     {
 *         // Записываем в провод
 *         // [...]
 *         // Затем регистрируем его для чтения
 *         селектор.повториРег(ключ.провод, Событие.Чит, ключ.атачмент);
 *     }
 *
 *     if (ключ.ошибка_ли())
 *     {
 *         // Проблема с проводом; удалим его из селектора
 *         селектор.удали(провод);
 *     }
 * }
 * ---
 */
version (linux)
{
    public import io.selector.EpollSelector;

    /**
     * Дефолтный селектор для Linux.
     */
    alias EpollSelector Селектор;
}
else version(Posix)
{
    public import io.selector.PollSelector;

    /**
     * Дефолтный селектор для POSIX-совместимых платформ.
     */
    alias PollSelector Селектор;
}
else
{
    public import io.selector.SelectSelector;

    /**
     * Дефолтный селектор для Windows.
     */
    alias СелекторВыбора Селектор;
}
