module io.selector.SelectSelector;

public import io.model;
public import io.selector.model;

private import io.selector.AbstractSelector;
private import io.selector.SelectorException;
private import sys.common;

private import cidrus;

debug (selector)
{
    private import io.Stdout;
    private import text.convert.Integer;
}


version (Windows)
{
    private import thread;

    private
    {
        // Opaque struct
        struct набор_уд
        {
        }

        extern (C) цел выбери(цел члофд, набор_уд* фдчтен, набор_уд* фдзап,
                                    набор_уд* фдискл, значврем* таймаут);
    }
}

version (Posix)
{
    private import col.BitArray;
}


/**
 * Селектор, использующий системный вызов выбери(), чтобы принимать
 * события ввода-вывода для зарегистрированных проводов. Этот класс,
 * как правило, используется следующим образом:
 *
 * Примеры:
 * ---
 * import io.selector.SelectSelector;
 *
 * Сокет сокет;
 * ИСелектор селектор = new СелекторВыбора();
 *
 * селектор.открой(100, 10);
 *
 * // Регистрация чтения из сокета
 * селектор.регистрируй(сокет, Событие.Чит);
 *
 * цел счётСобытий = селектор.выбери(0.1); // 0.1 сек
 * if (счётСобытий > 0)
 * {
 *     // Сейчас можно читать из сокета
 *     сокет.читай();
 * }
 * else if (счётСобытий == 0)
 * {
 *     // Таймаут
 * }
 * else if (счётСобытий == -1)
 * {
 *     // другая нить вызвала метод wakeup().
 * }
 * else
 * {
 *     // Ошибка: обычно такое не происходит.
 * }
 *
 * селектор.закрой();
 * ---
 */



public class СелекторВыбора: АбстрактныйСелектор
{


    /**
     * Это синоним метода выбери(), в этом классе мы его не
     * перевоплощаем и не переделываем.
     */
    alias АбстрактныйСелектор.выбери выбери;

    бцел _размер;
    private КлючВыбора[ИВыбираемый.Дескр] _ключи;
    private НаборДескр _наборЗаписи;
    private НаборДескр _наборЧтения;
    private НаборДескр _наборИсключений;
    private НаборДескр _выбранныйНаборЧтения;
    private НаборДескр _выбранныйНаборЗаписи;
    private НаборДескр _выбранныйНаборИсключений;
    цел _счётСобытий;
    version (Posix)
    {
        private ИВыбираемый.Дескр _максфд = cast(ИВыбираемый.Дескр) -1;

        /**
         * Число КлючВыбора'в по умолчанию, которое обрабатывает
         * СелекторВыбора.
         */
        public const бцел ДефРазмер = 1024;
    }
    else
    {
        /**
         * Число КлючВыбора'в по умолчанию, которое обрабатывает
         * СелекторВыбора.
         */
        public const бцел ДефРазмер = 63;
    }

    /**
     * Открыть выбери()-основанный селектор.
     *
     * Параметры:
     * размер         = максимальное количество проводов, которое будет регистрироваться;
     *                при необходимости наращивается динамически.
     * maxEvents    = максимальное число событий провода, которое будет
     *                возвращаться в наборе выделения на каждый вызов выбери();
     *                в настоящее время это значение этим селектором не используется.
     */
    public проц открой(бцел размер = ДефРазмер, бцел maxEvents = ДефРазмер)
    in
    {
        assert(размер > 0);
    }
    body
    {
        _размер = размер;
    }

    /**
     * Закрыть селектор.
     *
     * Примечания:
     * Может быть вызвано несколько раз без вредоносных побочных эффектов.
     */
    public проц закрой()
    {
        _размер = 0;
        _ключи = пусто;
        _наборЗаписи = НаборДескр.init;
        _наборЧтения = НаборДескр.init;
        _наборИсключений = НаборДескр.init;
        _выбранныйНаборЧтения = НаборДескр.init;
        _выбранныйНаборЗаписи = НаборДескр.init;
        _выбранныйНаборИсключений = НаборДескр.init;
    }

    private НаборДескр *разместиНабор(ref НаборДескр набор, ref НаборДескр наборВыд)
    {
        if(!набор.инициализован)
        {
            набор.установи(_размер);
            наборВыд.установи(_размер);
        }
        return &набор;
    }

    /**
     * Ассоциировать провод с селектором и отслеживать специфические события ВВ.
     * Если провод уже ассоциирован с селектором, события и
     * атачмент обновляются.
     *
     * Параметры:
     * провод      = провод, ассоциируемый с селектором;
     *                должен быть действительным проводом (т.е. не пусто и открыт).
     * события       = бит-маска значений Событие, представляющая события,
     *                которые отслеживаются на проводе.
     * атачмент   = необязательный объект, со специфичными для приложения данными, который
     *                будет доступен, когда событие триггируется на этот
     *                провод.
     *
     * Выводит исключение:
     * ИсклРегистрируемогоПровода, если этот провод уже зарегистрирован
     * на этом селекторе.
     *
     * Примеры:
     * ---
     * селектор.регистрируй(провод, Событие.Чит | Событие.Зап, объект);
     * ---
     */
    public проц регистрируй(ИВыбираемый провод, Событие события, Объект атачмент = пусто)
    in
    {
        assert(провод !is пусто && провод.фукз());
    }
    body
    {
        ИВыбираемый.Дескр укз = провод.фукз();

        debug (selector)
            Стдвыв.форматируй("--- СелекторВыбора.регистрируй(укз={0}, события=0x{1:x})\n",
                          cast(цел) укз, cast(бцел) события);

        КлючВыбора *ключ = (укз in _ключи);
        if (ключ !is пусто)
        {
            if ((события & Событие.Чит) || (события & Событие.Зависание))
            {
                разместиНабор(_наборЗаписи, _выбранныйНаборЧтения).установи(укз);
            }
            else if (_наборЗаписи.инициализован)
            {
                _наборЗаписи.очисть(укз);
            }

            if ((события & Событие.Зап))
            {
                разместиНабор(_наборЧтения, _выбранныйНаборЗаписи).установи(укз);
            }
            else if (_наборЧтения.инициализован)
            {
                _наборЧтения.очисть(укз);
            }

            if (события & Событие.Ошибка)
            {
                разместиНабор(_наборИсключений, _выбранныйНаборИсключений).установи(укз);
            }
            else if (_наборИсключений.инициализован)
            {
                _наборИсключений.очисть(укз);
            }

            version (Posix)
            {
                if (укз > _максфд)
                    _максфд = укз;
            }

            ключ.события = события;
            ключ.атачмент = атачмент;
        }
        else
        {
            // Сохраняем запись проводов, из которых отслеживаем события.
            _ключи[укз] = КлючВыбора(провод, события, атачмент);

            if ((события & Событие.Чит) || (события & Событие.Зависание))
            {
                разместиНабор(_наборЗаписи, _выбранныйНаборЧтения).установи(укз);
            }

            if (события & Событие.Зап)
            {
                разместиНабор(_наборЧтения, _выбранныйНаборЗаписи).установи(укз);
            }

            if (события & Событие.Ошибка)
            {
                разместиНабор(_наборИсключений, _выбранныйНаборИсключений).установи(укз);
            }

            version (Posix)
            {
                if (укз > _максфд)
                    _максфд = укз;
            }
        }
    }

    /**
     * Удалить провод из селектора.
     *
     * Параметры:
     * провод      = провод, который ранее был ассоциирован с
     *                селектором; не может быть пусто.
     *
     * Примечания:
     * Отрегистрировать (т.е. отменить регистрацию) пустого провода
	 * можно; никаких исключений не выводится,
     * если это происходит.
     *
     * Выводит исключение:
     * ИсклОтменённогоПровода, если этот провод ранее не был зарегистрирован
     * на этом селекторе.
     */
    public проц отмениРег(ИВыбираемый провод)
    {
        if (провод !is пусто)
        {
            ИВыбираемый.Дескр укз = провод.фукз();

            debug (selector)
                Стдвыв.форматируй("--- СелекторВыбора.отмениРег(укз={0})\n",
                              cast(цел) укз);

            КлючВыбора* удаляемый = (укз in _ключи);

            if (удаляемый !is пусто)
            {
                if (удаляемый.события & Событие.Ошибка)
                {
                    _наборИсключений.очисть(укз);
                }
                if (удаляемый.события & Событие.Зап)
                {
                    _наборЧтения.очисть(укз);
                }
                if ((удаляемый.события & Событие.Чит) || (удаляемый.события & Событие.Зависание))
                {
                    _наборЗаписи.очисть(укз);
                }
                _ключи.remove(укз);

                version (Posix)
                {
                    // Если удаляется наибольший укз, до этих пор введённый,
                    // надо пересчитать это значение для набора.
                    if (укз == _максфд)
                    {
                        while (--_максфд >= 0)
                        {
                            if (_наборЗаписи.набор_ли(_максфд) ||
                                _наборЧтения.набор_ли(_максфд) ||
                                _наборИсключений.набор_ли(_максфд))
                            {
                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                debug (selector)
                    Стдвыв.форматируй("--- СелекторВыбора.отмениРег(укз={0}): провод не был найден\n",
                                  cast(цел) провод.фукз());
                throw new ИсклОтменённогоПровода(__FILE__, __LINE__);
            }
        }
    }

    /**
     * Ждёт события ВВ (ввода-вывода) из зарегистрированных проводов заданное
     * количество времени.
     *
     * Параметры:
     * таймаут  = ИнтервалВремени с максимальным количеством времени, которое
     *            селектор будет ждать события из этих проводов; это
     *            количество времени относительно текущего системного времени
     *            (т.е. только число миллисекунд, которое селектор
     *            должен ждать события).
     *
     * Возвращает:
     * Количество проводов, имеющих принятые события; 0, если нет проводов,
     * принявших события за указанный таймаут; и -1, если метод
     * wakeup()был вызван из другой нити.
     *
     * Выводит исключение:
     * ИсклПрерванногоСистВызова, если низкоуровневый системный вызов был
     * прерван сигналом и свойство 'перезапускПрерванногоСистВызова'
     * было установлено в нет; ИсклСелектора, если не было ресурсов
     * для ожидания события из этих проводов.
     */
    public цел выбери(ИнтервалВремени таймаут)
    {
        набор_уд *фдчтен;
        набор_уд *фдзап;
        набор_уд *фдискл;
        значврем зв;
        version (Windows)
            бул доступныУкз = нет;

        debug (selector)
            Стдвыв.форматируй("--- СелекторВыбора.выбери(таймаут={0} мсек)\n", таймаут.миллисек);

        if (_наборЗаписи.инициализован)
        {
            debug (selector)
                _наборЗаписи.дамп("_наборЗаписи");

            version (Windows)
                доступныУкз = доступныУкз || (_наборЗаписи.length > 0);

            фдчтен = cast(набор_уд*) _выбранныйНаборЧтения.копируй(_наборЗаписи);
        }
        if (_наборЧтения.инициализован)
        {
            debug (selector)
                _наборЧтения.дамп("_наборЧтения");

            version (Windows)
                доступныУкз = доступныУкз || (_наборЧтения.length > 0);

            фдзап = cast(набор_уд*) _выбранныйНаборЗаписи.копируй(_наборЧтения);
        }
        if (_наборИсключений.инициализован)
        {
            debug (selector)
                _наборИсключений.дамп("_наборИсключений");

            version (Windows)
                доступныУкз = доступныУкз || (_наборИсключений.length > 0);

            фдискл = cast(набор_уд*) _выбранныйНаборИсключений.копируй(_наборИсключений);
        }

        version (Posix)
        {
            while (да)
            {
                вЗначВрем(&зв, таймаут);

                // FIXME: добавить поддержку вызова wakeup().
                _счётСобытий = .выбери(_максфд + 1, фдчтен, фдзап, фдискл, таймаут is ИнтервалВремени.max ? пусто : &зв);

                debug (selector)
                    Стдвыв.форматируй("---   .выбери() вернул {0} (максуд={1})\n",
                                  _счётСобытий, cast(цел) _максфд);
                if (_счётСобытий >= 0)
                {
                    break;
                }
                else
                {
                    if (errno != EINTR || !_restartInterruptedSystemCall)
                    {
                        // проверьНомОш() всегда выводит исключение
                        проверьНомОш(__FILE__, __LINE__);
                    }
                    debug (selector)
                        Стдвыв.выведи("--- Перезапуск выбери() после прерывания\n");
                }
            }
        }
        else
        {
            // Windows возвращает ошибку, когда выбери() вызывается со всеми тремя
            // укз, установленными пустыми, поэтому здесь эмулируется поведение POSIX,
            // с помощью вызова Нить.сон().
            if (доступныУкз)
            {
                вЗначВрем(&зв, таймаут);
			ИнтервалВремени инт;
                // FIXME: Может ли быть прерван системный вызов на Windows?
                _счётСобытий = .выбери(бцел.max, фдчтен, фдзап, фдискл, таймаут is инт.макс ? пусто : &зв);

                debug (selector)
                    Стдвыв.форматируй("---   .выбери() вернул {0}\n", _счётСобытий);
            }
            else
            {
                Нить.спи(таймаут.интервал());
                _счётСобытий = 0;
            }
        }
        return _счётСобытий;
    }

    /**
     * Возвращает набор выделений, результируемый из вызова любого из
     * методов выбери().
     *
     * Примечания:
     * Если вызов выбери() был неудачен или не вернул никаких
     * событий, возвратное значение будет пусто.
     */
    public ИНаборВыделений наборВыд()
    {
        return (_счётСобытий > 0 ? new НаборСелектораВыбора(_ключи, cast(бцел) _счётСобытий, _выбранныйНаборЧтения,
                                                         _выбранныйНаборЗаписи, _выбранныйНаборИсключений) : пусто);
    }

    /**
     * Возвращает ключ выделения,  результируемый из регистрации
     * провода в селекторе.
     *
     * Примечания:
     * Если этот провод не зарегистрирован в селекторе, возвратное
     * значение будет пусто. Этот метод не выводит исключений.
     */
    public КлючВыбора ключ(ИВыбираемый провод)
    {
        if(провод !is пусто)
        {
            if(auto ключ = провод.фукз() in _ключи)
            {
                return *ключ;
            }
        }
        return КлючВыбора.init;
    }

    /**
     * Возвращает число ключей, результируемое из регистрации провода
     * в этом селекторе.
     */
    public т_мера счёт()
    {
        return _ключи.length;
    }

    /**
     * Итерирует по текущим зарегистрированным ключам выделения. При этом
     * нельзя длбавлять в селектор никаких элементов,
	 * хотя можно заново зарегистрировать существующие провода.
     */
    цел opApply(цел delegate(ref КлючВыбора) дг)
    {
        цел результат = 0;
        foreach(знач; _ключи)
        {
            if((результат = дг(знач)) != 0)
                break;
        }
        return результат;
    }
}

/**
 * НаборВыбора для выбери()-основанного Селектора.
 */
private class НаборСелектораВыбора: ИНаборВыделений
{


    КлючВыбора[ИВыбираемый.Дескр] _ключи;
    бцел _счётСобытий;
    НаборДескр _наборЗаписи;
    НаборДескр _наборЧтения;
    НаборДескр _наборИсключений;

    this(КлючВыбора[ИВыбираемый.Дескр] ключи, бцел счётСобытий,
                   НаборДескр наборЧтения, НаборДескр наборЗаписи, НаборДескр наборИсключений)
    {
        _ключи = ключи;
        _счётСобытий = счётСобытий;
        _наборЗаписи = наборЧтения;
        _наборЧтения = наборЗаписи;
        _наборИсключений = наборИсключений;
    }

    бцел длина()
    {
        return _счётСобытий;
    }

    цел opApply(цел delegate(ref КлючВыбора) дг)
    {
        цел rc = 0;
        ИВыбираемый.Дескр укз;
        Событие события;

        debug (selector)
            Стдвыв.форматируй("--- SelectSelectionSet.opApply() ({0} элементов)\n", _счётСобытий);

        foreach (КлючВыбора текущ; _ключи)
        {
            укз = текущ.провод.фукз();

            if (_наборЗаписи.набор_ли(укз))
                события = Событие.Чит;
            else
                события = Событие.Нет;

            if (_наборЧтения.набор_ли(укз))
                события |= Событие.Зап;

            if (_наборИсключений.набор_ли(укз))
                события |= Событие.Ошибка;

            // Только вызвать delegate, если на проводе есть событие.
            if (события != Событие.Нет)
            {
                текущ.события = события;

                debug (selector)
                    Стдвыв.форматируй("---   Вызов foreach delegate с ключом выделения ({0}, 0x{1:x})\n",
                                  cast(цел) укз, cast(бцел) события);

                if ((rc = дг(текущ)) != 0)
                {
                    break;
                }
            }
            else
            {
                debug (selector)
                    Стдвыв.форматируй("---   Дескр {0} не имееет ожидающего события\n",
                                  cast(цел) укз);
            }
        }
        return rc;
    }
}


version (Windows)
{
    /**
     * Вспомогательный класс, используемый основанным на методе выбери()  Селектором,
	 * для сохранения дескрипторов.
     * На Windows эти дескрипторы сохраняются в форме массива из значений беззначное целое,
	 * а в первом элементе этого массива сохраняется длина массива (т.е. число дескрипторов
     * в массиве). Всё сохраняется так, чтобы исконный выбери() API
     * мог использовать этот НаборДескр без дополнительных преобразований, просто
     * переводя его в набор_уд*.
     */
    private struct НаборДескр
    {

        /** Дефолтное число дескрипторов, которое будет содержаться в этом НаборДескр. */
        const бцел ДефРазмер = 63;

        бцел[] _буфер;

        /**
         * Кронструктор. Устанавливает начальное число дескрипторов, которое будет
         * созоаняться в этом НаборДескр.
         */
        проц установи(бцел размер = ДефРазмер)
        {
            _буфер = new бцел[1 + размер];
            _буфер[0] = 0;
        }

        /**
         *  Возвращает да, если этот набор укз инициализован.
         */
        бул инициализован()
        {
            return _буфер.length > 0;
        }

        /**
         * Возвращает число дескрипторов, находящихся в этом НаборДескр.
         */
        бцел length()
        {
            return _буфер[0];
        }

        /**
         * Добавляет укз в набор.
         */
        проц установи(ИВыбираемый.Дескр укз)
        in
        {
            assert(укз);
        }
        body
        {
            if (!набор_ли(укз))
            {
                // Если нами добавлено слишком много сокетов, нужно увеличить размер буфера
                if (++_буфер[0] >= _буфер.length)
                {
                    _буфер.length = _буфер[0] + 1;
                }
                _буфер[_буфер[0]] = cast(бцел) укз;
            }
        }

        /**
         * Удалить указатель из набора.
         */
        проц очисть(ИВыбираемый.Дескр укз)
        {
            for (бцел i = 1; i <= _буфер[0]; ++i)
            {
                if (_буфер[i] == cast(бцел) укз)
                {
                    // We don't need в_ keep the handles in the order in which
                    // they were inserted, so we оптимизируй the removal by
                    // copying the последний элемент в_ the позиция of the удаленный
                    // элемент.
                    if (i != _буфер[0])
                    {
                        _буфер[i] = _буфер[_буфер[0]];
                    }
                    _буфер[0]--;
                    return;
                }
            }
        }

        /**
         * Скопировать содержимое  НаборДескр а экземпляр this.
         */
        НаборДескр копируй(НаборДескр handleSet)
        {
            if(handleSet._буфер.length > _буфер.length)
            {
                _буфер.length = handleSet._буфер[0] + 1;
            }


            _буфер[] = handleSet._буфер[0.._буфер.length];
            return *this;
        }

        /**
         * Проверить, установлен ли указатель.
         */
        public бул набор_ли(ИВыбираемый.Дескр укз)
        {
            if(_буфер.length == 0)
                return нет;

            бцел* старт;
            бцел* stop;

            for (старт = _буфер.ptr + 1, stop = старт + _буфер[0]; старт != stop; старт++)
            {
                if (*старт == cast(бцел) укз)
                    return да;
            }
            return нет;
        }

        /**
         * Перебросить текущий объект в указатель на набор_уд, который будет использован
         * при системном вызове выбери().
         */
        public набор_уд* opCast()
        {
            return cast(набор_уд*) _буфер.ptr;
        }


        debug (selector)
        {
            /**
             * Сделать дамп содержимого НаборДескр в стдвыв.
             */
            проц дамп(ткст имя = пусто)
            {
                if (_буфер !is пусто && _буфер.length > 0 && _буфер[0] > 0)
                {
                    ткст handleStr = new сим[16];
                    ткст handleListStr;
                    бул isFirst = да;

                    if (имя is пусто)
                    {
                        имя = "НаборДескр";
                    }

                    for (бцел i = 1; i < _буфер[0]; ++i)
                    {
                        if (!isFirst)
                        {
                            handleListStr ~= ", ";
                        }
                        else
                        {
                            isFirst = нет;
                        }

                        handleListStr ~= itoa(handleStr, _буфер[i]);
                    }

                    Стдвыв.форматнс("--- {0}[{1}]: {2}", имя, _буфер[0], handleListStr);
                }
            }
        }
    }
}
else version (Posix)
{
    private import core.BitManip;


    /**
     * Helper class использован by the выбери()-based Селектор в_ сохрани handles.
     * On POSIX-compatible platforms the handles are kept in an Массив of биты.
     * Everything is stored so that the исконный выбери() API can use the
     * НаборДескр without добавьitional conversions by casting it в_ a набор_уд*.
     */
    private struct НаборДескр
    {

        /** Default число of handles that will be held in the НаборДескр. */
        const бцел ДефРазмер     = 1024;

        МассивБит _буфер;

        /**
         * Constructor. Sets the начальное число of handles that will be held
         * in the НаборДескр.
         */
        проц установи(бцел размер = ДефРазмер)
        {
            if (размер < 1024)
                размер = 1024;

            _буфер.length = размер;
        }

        /**
         * Возвращает да, если the handleset имеется been инициализован
         */
        бул инициализован()
        {
            return _буфер.length > 0;
        }

        /**
         * Добавь a укз в_ the установи.
         */
        public проц установи(ИВыбираемый.Дескр укз)
        {
            // If we добавьed too many СОКЕТs we инкремент the размер of the буфер
            бцел fd = cast(бцел)укз;
            if(fd >= _буфер.length)
                _буфер.length = fd + 1;
            _буфер[fd] = да;
        }

        /**
         * Удали a укз из_ the установи.
         */
        public проц очисть(ИВыбираемый.Дескр укз)
        {
            auto fd = cast(бцел)укз;
            if(fd < _буфер.length)
                _буфер[fd] = нет;
        }

        /**
         * Copy the contents of the НаборДескр преобр_в this экземпляр.
         */
        НаборДескр копируй(НаборДескр handleSet)
        {
            //
            // исправь the length if necessary
            //
            if(handleSet._буфер.length != _буфер.length)
                _буфер.length = handleSet._буфер.length;

            _буфер[] = handleSet._буфер;
            return *this;
        }

        /**
         * Check whether the укз имеется been установи.
         */
        бул набор_ли(ИВыбираемый.Дескр укз)
        {
            auto fd = cast(бцел)укз;
            if(fd < _буфер.length)
                return _буфер[fd];
            return нет;
        }

        /**
         * Cast the текущ объект в_ a pointer в_ an набор_уд, в_ be использован with the
         * выбери() system вызов.
         */
        набор_уд* opCast()
        {
            return cast(набор_уд*) _буфер.ptr;
        }

        debug (selector)
        {
            /**
             * Dump the contents of a НаборДескр преобр_в стдвыв.
             */
            проц дамп(ткст имя = пусто)
            {
                if (_буфер !is пусто && _буфер.length > 0)
                {
                    ткст handleStr = new сим[16];
                    ткст handleListStr;
                    бул isFirst = да;

                    if (имя is пусто)
                    {
                        имя = "НаборДескр";
                    }

                    for (бцел i = 0; i < _буфер.length * _буфер[0].sizeof; ++i)
                    {
                        if (набор_ли(cast(ИВыбираемый.Дескр) i))
                        {
                            if (!isFirst)
                            {
                                handleListStr ~= ", ";
                            }
                            else
                            {
                                isFirst = нет;
                            }
                            handleListStr ~= itoa(handleStr, i);
                        }
                    }
                    Стдвыв.форматнс("--- {0}: {1}", имя, handleListStr);
                }
            }
        }
    }
}
