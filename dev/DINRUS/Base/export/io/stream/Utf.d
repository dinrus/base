/*******************************************************************************

        Потоки преобразования UTF, поддерживающие кросс-трансляцию сим, шим 
        и дим вариантов. Для поддержки эндианных вариаций, сконфигурируте
        соответствующий эндианный поток, находящийся в апстриме этого потока
		(ближе к истоку).

*******************************************************************************/

module io.stream.Utf;

private import io.device.Conduit;

private import io.stream.Buffered;

private import Utf = text.convert.Utf;

/*******************************************************************************

        Поточный преобразователь UTF. Тип T - это целевой тип или тип назначения, 
        а S = тип истока. Все типы - это сим/шим/дим.

*******************************************************************************/

class ЮВвод(T, S) : ФильтрВвода, ФильтрВвода.Переключатель
{       
        static if (!is (S == сим) && !is (S == шим) && !is (S == дим)) 
                    pragma (msg, "Исходный тип должен быть сим, шим или дим");

        static if (!is (T == сим) && !is (T == шим) && !is (T == дим)) 
                    pragma (msg, "Целевой тип должен быть сим, шим или дим");

        private БуферВвода буфер;

        /***********************************************************************

                Создаёт буферированный преобразователь utf-ввода.

        ***********************************************************************/

        this (ИПотокВвода поток)
        {
                super (буфер = Бввод.создай (поток));
        }
        
        /***********************************************************************

                Потребляет ввод типа T, возвращает число потреблённых
				элементов массива. 

                Возвращает Кф в конце потока.

        ***********************************************************************/

        final т_мера используй (T[] приёмн)
        {
                auto x = читай (приёмн);
                if (x != Кф)
                    x /= T.sizeof;
                return x;
        }

        /***********************************************************************

        ***********************************************************************/

        final override т_мера читай (проц[] приёмн)
        {
                static if (is (S == T))
                           return super.читай (приёмн);
                else
                   {
                   бцел   consumed,
                          produced;

                   т_мера читатель (проц[] ист)
                   {
                        if (ист.length < S.sizeof)
                            return Кф;

                        auto вывод = Бввод.преобразуй!(T)(приёмн);
                        auto ввод  = Бввод.преобразуй!(S)(ист);

                        static if (is (T == сим))
                                   produced = Utf.вТкст(ввод, вывод, &consumed).length;

                        static if (is (T == шим))
                                   produced = Utf.вТкст16(ввод, вывод, &consumed).length;

                        static if (is (T == дим))
                                   produced = Utf.toString32(ввод, вывод, &consumed).length;

                        // используем контент буфера
                        return consumed * S.sizeof;
                   }

                   // должно иметься в наличии некоторое пространство для преобразования
                   if (приёмн.length < T.sizeof)
                       провод.ошибка ("UtfПоток.читай :: целевой Массив слишком мал");

                   // преобразуем следующий чанк ввода
                   if (буфер.следщ(&читатель) is нет)
                       return Кф;

                   return produced * T.sizeof;
                   }
        }
}


/*******************************************************************************
        
        Поточный преобразователь UTF. Тип T - это целевой тип или тип назначения, 
        а S = тип истока. Все типы - это сим/шим/дим.

        Заметьте, что аргументы реверсируются при получении из ЮВвод.

*******************************************************************************/

class ЮВывод (S, T) : ФильтрВывода, ФильтрВывода.Переключатель
{       
        static if (!is (S == сим) && !is (S == шим) && !is (S == дим)) 
                    pragma (msg, "Исходный тип должен быть сим, шим или дим");

        static if (!is (T == сим) && !is (T == шим) && !is (T == дим)) 
                    pragma (msg, "Целевой тип должен быть сим, шим или дим");


        private БуферВывода буфер;

        /***********************************************************************

              Создаёт буферированный преобразователь utf-вывода.

        ***********************************************************************/

        this (ИПотокВывода поток)
        {
                super (буфер = Бвыв.создай (поток));
        }

        /***********************************************************************

                Потребляет ввод типа T, возвращает число потреблённых
				элементов массива. 

                Возвращает Кф в конце потока.

        ***********************************************************************/

        final т_мера используй (S[] приёмн)
        {
                auto x = пиши (приёмн);
                if (x != Кф)
                    x /= S.sizeof;
                return x;
        }

        /***********************************************************************
        
                Записывает в поток вывода из массива-истока. Предоставленный 
                ист контент при необходимости преобразуется. Заметьте, что
                прикреплённый буфер вывода должен быть не менее 4 байтов в ширину,
				чтобы вместить преобразование.

                Возвращает число байтов, потреблённых из ист, которое может быть
                меньше предоставленного количества.

        ***********************************************************************/

        final override т_мера пиши (проц[] ист)
        {
                static if (is (S == T))
                           return super.пиши (ист);
                else
                   {
                   бцел   consumed,
                          produced;

                   т_мера писатель (проц[] приёмн)
                   {
                        // буфер должен быть минимум 4 байта шириной, 
                        // чтобы вмещать генерное преобразование
                        if (приёмн.length < 4)
                            return Кф;

                        auto ввод = Бвыв.преобразуй!(S)(ист);
                        auto вывод = Бвыв.преобразуй!(T)(приёмн);

                        static if (is (T == сим))
                                   produced = Utf.вТкст(ввод, вывод, &consumed).length;

                        static if (is (T == шим))
                                   produced = Utf.вТкст16(ввод, вывод, &consumed).length;

                        static if (is (T == дим))
                                   produced = Utf.toString32(ввод, вывод, &consumed).length;

                        return produced * T.sizeof;
                   }
                    
                   // пишим прямо в буферированный контент и
                   // сливаем, когда вывод полон.
                   if (буфер.писатель(&писатель) is Кф)
                      {
                      буфер.слей;
                      if (буфер.писатель(&писатель) is Кф)
                          return Кф;
                      }
                   return consumed * S.sizeof;
                   }
        }
}


/*******************************************************************************
        
*******************************************************************************/
        
debug (Utf)
{
        import io.Stdout;
        import io.device.Array;

        проц main()
        {
                auto inp = new ЮВвод!(дим, сим)(new Массив("hello world"));
                auto oot = new ЮВывод!(дим, сим)(new Массив(20));
                oot.копируй(inp);
                assert (oot.буфер.срез == "hello world");
        }
}
