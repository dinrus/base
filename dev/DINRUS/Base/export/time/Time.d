module time.Time;

/******************************************************************************

    Эта структура представляет длину времени. Нижележащее представление состоит
    из единиц в 100 наносекунд. Это даёт временной интервал в +/- 10000 лет.

    В ней заметно отсутствуют представления недель, месяцев и лет.
    Поскольку недели, месяцы и годы отличаются согласно местным календарям.
    С этими понятиями имеет дело модуль time.chrono.*.

    Примечание: не следует менять эту структуру без серьёзного основания,
    так как она нужна как часть некоторых интерфейсов. Надо рассматривать её как
    встроеннный тип. Также заметьте, что здесь отсутствует конструктор opCall,
    так как он потенциально производит массу проблем. Если необходимо построить
    структуру ИнтервалВремени из значения тиков, используйте встроенную
    способность Ди создавать структуру с указанными значениями членов
    (смотрите описание функции тики() как пример выполнения этого).

    Пример:
    -------------------
    Время старт = Часы.сейчас;
    Нить.сон(0.150);
    Стдвыв.форматнс("проспал {} мс", (Часы.сейчас-старт).миллисек);
    -------------------

    См_Также: thread, time.Clock

******************************************************************************/

extern(D) struct ИнтервалВремени
{
	
    // Полезные константы. Не следует использовать в обычном коде,
    // используйте лучше статические члены ИнтервалВремени.  т.е. вместо
    // ИнтервалВремени.ТиковВСек используйте ИнтервалВремени.секунда.тики
    //
    enum : дол
    {
        /// Базовые значения тиков
        НаносекВТике  = 100,
        ТиковВМикросек = 1000 / НаносекВТике,
        ТиковВМиллисек = 1000 * ТиковВМикросек,
        ТиковВСек      = 1000 * ТиковВМиллисек,
        ТиковВМин      = 60 * ТиковВСек,
        ТиковВЧас        = 60 * ТиковВМин,
        ТиковВДень         = 24 * ТиковВЧас,

        // Счёт миллисекунд
        МиллисекВСек     = 1000,
        МиллисекВМин     = МиллисекВСек * 60,
        МиллисекВЧас       = МиллисекВМин * 60,
        МиллисекВДень        = МиллисекВЧас * 24,

        /// Счёт дней
        ДнейВГоду         = 365,
        ДнейНа4Года       = ДнейВГоду * 4 + 1,
        ДнейНа100Лет     = ДнейНа4Года * 25 - 1,
        ДнейНа400Лет     = ДнейНа100Лет * 4 + 1,

        // Счёт эпох
        Эпоха1601           = ДнейНа400Лет * 4 * ТиковВДень,
        Эпоха1970           = Эпоха1601 + ТиковВСек * 11644473600L,
    }

    const дво	МиллисекНаТик = 1.0 / ТиковВМиллисек;
    const дво    СекНаТик = 1.0 / ТиковВСек;
    const дво   МинутНаТик = 1.0 / ТиковВМин;


     /**
     * Минимальный ИнтервалВремени
     */
    static ИнтервалВремени мин();

    /**
     * Максимальный ИнтервалВремени
     */
    static ИнтервалВремени макс();

    /**
     * Нулевой ИнтервалВремени.  Используется для сравнений.
     */
    static ИнтервалВремени нуль();
	
		   /**
   * Инициализует новый экземпляр.
   * Параметры: тики = Период времени, выраженный в 100-наносекундных единицах.
   */
    static ИнтервалВремени opCall(дол тики);

    /**
    *  Инициализует новый экземпляр.
    */
    static ИнтервалВремени opCall(цел часы, цел минуты, цел секунды);

    /**
     *  Инициализует новый экземпляр.
     */
   static ИнтервалВремени opCall(цел дни, цел часы, цел минуты, цел секунды, цел миллисекунды = 0);
	
	/**
	* Установить тики.
	*/	
    ИнтервалВремени opAssign(дол тики);
	
    /**
     * Получить число тиков, прелставляющее данный промежуток времени. Может
     * использоваться для построения другого ИнтервалВремени:
     *
     * --------
     * дол тики = мойИнтервалВремени.тики;
     * ИнтервалВремени копияМоегоИнтервалВремени = ИнтервалВремени(тики);
     * --------
     */
    дол тики();

    /**
     * Определяет равенство двух значений ИнтервалВремени.
     */
     бул opEquals(ИнтервалВремени t);

    /**
     * Сравнивает объект this с другим значением ИнтервалВремени.
     */
    цел opCmp(ИнтервалВремени t);

    /**
     * Добавить ИнтервалВремени к this, вернув новый ИнтервалВремени.
     *
     * Параметры: t = Добавляемое значение ИнтервалВремени.
     * Возвращает: Значение ИнтервалВремени, являющееся суммой этого экземпляра и t.
     */
    ИнтервалВремени opAdd(ИнтервалВремени t);

    /**
     * Добавить указанный ИнтервалВремени к this ИнтервалВремени, присвоив результат
     * экземпляру this.
     *
     * Параметры: t = Добавляемое значение ИнтервалВремени.
     * Возвращает: копию экземпляра this после прибавки t.
     */
    ИнтервалВремени opAddAssign(ИнтервалВремени t);

    /**
     * Отнять указанный ИнтервалВремени от this ИнтервалВремени.
     *
     * Параметры: t = Вычитаемый ИнтервалВремени.
     * Возвращает: Новый промежуток времени, являющийся разностью между this
     * экземпляром и t.
     */
    ИнтервалВремени opSub(ИнтервалВремени t);

    /**
     *
     * Отнять указанный ИнтервалВремени от this ИнтервалВремени с присвоением.
     *
     * Параметры: t = Вычитаемый ИнтервалВремени.
     * Возвращает: Копия this экземпляра после вычитания t.
     */
    ИнтервалВремени opSubAssign(ИнтервалВремени t);

    /**
     * Масштабировать ИнтервалВремени на заданное количество. Не следует
     * использовать для преобразования в иные единицы. Вместо этого используются
     * аксессоры единиц. Используется только в механизме масштабирования. 
     * Например, если имеется таймаут и нужен сон, дважды превышающий
     * таймаут, то используется таймаут * 2.
     *
     * Параметры: знач = Множитель, используемый для масштабирования этого интервала времени.
     * Возвращает: Новый ИнтервалВремени, масштабированный на знач.
     */
    ИнтервалВремени opMul(дол знач);

    /**
     * Масштабирует this ИнтервалВремени и присваивает результат this экземпляру.
     *
     * Параметры: знач = Множитель, используемый для масштабирования.
     * Возвращает: Копия this экземпляра после масштабирования.
     */
    ИнтервалВремени opMulAssign(дол знач);

    /**
     * Разделить этот ИнтервалВремени на указанное количество. Не следует
     * использовать для преобразования в иные единицы. Вместо этого используются
     * аксессоры единиц. Используется только в механизме масштабирования. 
     * Например,  если имеется таймаут и требуется сон в половину этого
     * таймаута, нужно использовать таймаут / 2.
     *
     *
     * Параметры: знач = Делитель, используемый для масштабирования этого вринтервала.
     * Возвращает: Новый ИнтервалВремени, поделенный на знач
     */
    ИнтервалВремени opDiv(дол знач);

    /**
     * Делит этот ИнтервалВремени и присваивает результат этому экземпляру.
     *
     * Параметры: знач = Множитель, используемый для деления.
     * Возвращает: Копию этого экземпляра после деления.
     */
    ИнтервалВремени opDivAssign(дол знач);

    /**
     * Выполняет целое деление с данным интервалом времени.
     *
     * Параметры: t = Делитель, используемый для деления
     * Возвращает: Результат целого деления между этим экземпляром и
     * t.
     */
    дол opDiv(ИнтервалВремени t);

    /**
     * Делает отрицательным интервал времени.
     *
     * Возвращает: Отрицательный эквивалени этого интервала времени
     */
    ИнтервалВремени opNeg();

    /**
     * Преобразует в наносекунды.
     *
     * Примечание: может происходить потеря данных, так как наносекунды не
     * могут представлять диапазон данных, который представляет ИнтервалВремени.
     *
     * Возвращает: Число наносекунд, которое представляет данный ИнтервалВремени.
     */
    дол наносек();

    /**
     * Преобразует в микросекунды.
     *
     * Возвращает: Число микросекунд, которое представляет данный ИнтервалВремени.
     */
    дол микросек();

    /**
     * Преобразует в миллисекунды.
     *
     * Возвращает: Число миллисек, которое представляет данный ИнтервалВремени.
     */
    дол миллисек();

    /**
     * Преобразует в секунды.
     *
     * Возвращает: Число сек, которое представляет данный ИнтервалВремени.
     */
     дол сек();

    /**
     * Преобразует в минуты.
     *
     * Возвращает: Число минут, которое представляет данный ИнтервалВремени.
     */
    дол минуты();

    /**
     * Преобразует в часы.
     *
     * Возвращает: Число часов, которое представляет данный ИнтервалВремени.
     */
    дол часы();

    /**
     * Преобразует в дни.
     *
     * Возвращает: Число дней, которое представляет данный ИнтервалВремени.
     */
    дол дни();

    /**
     * Преобразует в интервал плавающей точкой, представляющий сек.
     *
     * Примечание: Может вызывать потерю точности, так как дво не может точно
     * представлять некоторые дробные значения.
     *
     * Возвращает: Интервал, представляющий эту секунду и её дробную
     * часть, которые представляют данный ИнтервалВремени.
     */
    дво интервал();

    /**
     * Преобразует в ВремяДня.
     *
     * Возвращает: ВремяДня, представленное этим ИнтервалВремени.
     */
    ВремяДня время();

    /**
     * Конструирует ИнтервалВремени из заданного числа наносекунд.
     *
     * Примечание: Может приводить к потере данных, поскольку разрешение ИнтервалВремени
     * представлено в 100-наносекундных инкрементах.
     *
     * Параметры: значение = Число наносекунд.
     * Возвращает: ИнтервалВремени, представляющий данное число наносекунд.
     */
    static ИнтервалВремени изНаносек(дол значение);

    /**
     * Конструирует ИнтервалВремени из заданного числа микросекунд.
     *
     * Параметры: значение = Число микросекунд.
     * Возвращает: ИнтервалВремени, представляющий данное число микросекунд.
     */
    static ИнтервалВремени изМикросек(дол значение);

    /**
     * Конструирует ИнтервалВремени из заданного числа миллисекунд.
     *
     * Параметры: значение = Число миллисекунд.
     * Возвращает: ИнтервалВремени, представляющий данное число миллисекунд.
     */
    static ИнтервалВремени изМиллисек(дол значение);

    /**
     * Конструирует ИнтервалВремени из заданного числа сек.
     *
     * Параметры: значение = Число сек.
     * Возвращает: ИнтервалВремени, представляющий данное число сек.
     */
    static ИнтервалВремени изСек(дол значение);

    /**
     * Конструирует ИнтервалВремени из заданного числа минут.
     *
     * Параметры: значение = Число минуты.
     * Возвращает: ИнтервалВремени, представляющий данное число минуты.
     */
   static ИнтервалВремени изМин(дол значение);

    /**
     * Конструирует ИнтервалВремени из заданного числа часов.
     *
     * Параметры: значение = Число часов.
     * Возвращает: ИнтервалВремени, представляющий данное число часов.
     */
    static ИнтервалВремени изЧасов(дол значение);

    /**
     * Конструирует ИнтервалВремени из указанного число дней.
     *
     * Параметры: значение = Число дней.
     * Возвращает: ИнтервалВремени, представляющий данное число дней.
     */
    static ИнтервалВремени изДней(дол значение);

    /**
     * Конструирует ИнтервалВремени из указанного интервала.  Этот иинтервал
     * представляет сек как дво.  Это позволяет передавать целую и
     * дробную части сек.
     *
     * Параметры: значение = Интервал, передаваемый в сек.
     * Возвращает: ИнтервалВремени, представляющий данный интервал.
     */
    static ИнтервалВремени изИнтервала(дво сек);

    дво всегоМиллисек();
    дво всегоСек();
    дво всегоМин();
    /**
     * Сравнивает два значения ИнтервалВремени и возвращает целое, показывающее, короче ли первое,
	 * равно или длинее второго.
     * Возвращает: -1, если t1 короче, чем t2; 0, если t1 равно t2; 1, если t1 длинее, чем t2.
     */
    static цел сравни(ИнтервалВремени t1, ИнтервалВремени t2);

    /**
     * Сравнивает этот экземпляр с заданным ИнтервалВремени и возвращает целое, показывающее, короче ли первое,
	 * равно или длинее второго.
     * Возвращает: -1, если t1 короче, чем t2; 0, если t1 равно t2; 1, если t1 длинее, чем t2.
     */
    цел сравниС(ИнтервалВремени другой);

    /**
     * Возвращает значение, указывающее на то, равны ли два экземпляра.
     * Параметры:
     *   t1 = Первый ИнтервалВремени.
     *   t2 = Второй ИнтервалВремени.
     * Возвращает: да, если значения t1 и t2 равны; иначе нет.
     */
    static бул равны(ИнтервалВремени t1, ИнтервалВремени t2);

    /**
     * Возвращает значение, показывающее, равно ли значение экземпляра this другому экземпляру.
     * Параметры: другой = ИнтервалВремени, сравниваемый с этим экземпляром.
     * Возвращает: да, если другой rпредставляет такой же интервал времени, что и этот; иначе, нет.
     */
    бул равен(ИнтервалВремени другой);

    бцел вХэш();

    /// Возвращает текстовое представление значения экземпляра this.
    ткст вТкст();    

    /// Прибавляет заданный ИнтервалВремени к этому экземпляру.
    ИнтервалВремени прибавь(ИнтервалВремени ts);

/// описано ранее
    void opAddAssign(ИнтервалВремени ts);

    /// Вычитает заданный ИнтервалВремени от этого экземпляра.
    ИнтервалВремени вычти(ИнтервалВремени ts);

    /// описано ранее
    void opSubAssign(ИнтервалВремени ts);

    /// Возвращает ИнтервалВремени,значение которого является отрицательным значением данного экземпляра.
    ИнтервалВремени дайНегатив();

    ИнтервалВремени opPos();

}


/******************************************************************************

        Представляет точку во времени.

        Примечания: Время представляет даты и время между 12:00:00
        полуночи на 1 Января, 10000 до н.э. и 11:59:59 PM на 31 Декабря,
        9999 н.э.

        Значения Время измеряются в 100-наносекундных интервалах, тлт тиках.
        Значение даты - это число тиков, прошедшее с 12:00:00 полуночи
		на 1 Января, 0001 до н.э.  по Грегорианскому календарю.

        Отрицательные значения времени  = это смещения от точки сноски,
        но обратно по истории. Значения времени не специфицны ни для каких
        календарей, но, например, начиная с 31 Декабря, 1 до н.э.
        по Грегорианскому календарю получается, что
		Время = Время.эпоха - ИнтервалВремени.дни(1).

******************************************************************************/

extern(D) struct Время
{
    /// Представляет эпоху 1/1/1601 (Широко используется на системах Windows)
    static Время эпоха1601();

    /// Представляет эпоха of 1/1/1970 (Широко используется на системах Unix)
    static Время эпоха1970();

	/// Представляет наименьшее и наибольшее значение Времени.
    static Время мин();	 
    static Время макс();

    /// Представляет эпоху (1/1/0001)
    static Время эпоха();
	
	static Время opCall(бдол тики);	
    /**********************************************************************

            $(I Свойство.) Выдаёт число тиков для этого Время.
            Это значение может использоваться для построения другой структуры Время,
            путём написания:

            ---------
            дол тики = моёВремя.тики;
            Время копияМоегоВремени = Время(тики);
            ---------


            Возвращает: Значение дол, представленное временем этого
                     экземпляра.

    **********************************************************************/

    дол тики();

    /**********************************************************************

            Определяет, равны ли два значения Время.

            Параметры:  значение = Значение Время.
            Возвращает: да, если экземпляры равны; иначе, нет.

    **********************************************************************/

    цел opEquals(Время t);

    /**********************************************************************

            Сравнивает два значения Время.

    **********************************************************************/

    цел opCmp(Время t);

    /**********************************************************************

            Добавляет указанный интервал времени ко времени, возвращая новое
            время.

            Параметры:  t =Значение ИнтервалВремени.
            Возвращает: Время, являющееся суммой этого экземпляра и t.

    **********************************************************************/

    Время opAdd(ИнтервалВремени t);

    /**********************************************************************

            Добавляет указанный интервал времени ко времени, присваивая
            результат этому экземпляру.

            Параметры:  t =Значение ИнтервалВремени.
            Возвращает: Экземпляр текущ Время, с t, прибавленным к
                     время.

    **********************************************************************/

    Время opAddAssign(ИнтервалВремени t);

    /**********************************************************************

            Вычитает указанный интервал времени от время,
            возвращая новое время.

            Параметры:  t =Значение ИнтервалВремени.
            Возвращает: Время, значение которого равно значению этого экземпляра
                     минус значение t.

    **********************************************************************/

     Время opSub(ИнтервалВремени t);

    /**********************************************************************

            Возвращает интервал времени, представляющий разницу во времени
            между this и заданным Время.

            Параметры:  t = Значение Времени.
            Возвращает: ИнтервалВремени, представляющий разницу между
                     this и t.

    **********************************************************************/

    ИнтервалВремени opSub(Время t);

    /**********************************************************************

            Вычитает указанный интервал времени от время,
            присваивая результат this экземпляру.

            Параметры:  t =Значение ИнтервалВремени.
            Возвращает: Экземпляр текущ Время, с t, отнятым
                     от время.

    **********************************************************************/

    Время opSubAssign(ИнтервалВремени t);

    /**********************************************************************

            $(I Свойство.) Выводит комноненту дата.

            Возвращает: Новый экземпляр Время с такой же датой как у
                     this экземпляра, но с трункацией времени.

    **********************************************************************/

    Время дата();

    /**********************************************************************

            $(I Свойство.) Выводит время деня.

            Возвращает: ВремяДня, представленное как дво этого дня,
                     прошедщее с момента полуночи.

    **********************************************************************/

    ВремяДня время();

    /**********************************************************************

            $(I Свойство.) Выводит эквивалентный ИнтервалВремени.

            Возвращает: ИнтервалВремени, представляющий this Время.

    **********************************************************************/

    ИнтервалВремени вринтервал();

    /**********************************************************************

            $(I Свойство.) Выводит ИнтервалВремени, соответствующий Unix
            время (время с 1/1/1970).  Используйте аксессоры ИнтервалВремени,
            чтобы получить время в сек, миллисекундах и т.п.

            Возвращает: ИнтервалВремени, представляющий this Время как Unix время.

            -------------------------------------
            auto unixTime = Часы.сейчас.юникс.сек;
            auto javaTime = Часы.сейчас.юникс.миллисек;
            -------------------------------------

    **********************************************************************/

    ИнтервалВремени юникс();
}


/******************************************************************************

        Представляет время дня. Отличается от ИнтервалВремени тем, что
        каждый компонент представлен внутри пределов повседневного времени,
        а не от старта Эпохи. На деле, ВремяДня эпоха равна первой секунде
        каждого дня.

        Это удобно для строгой работы с 24-часовыми часами, вместо потенциальных
        тысячелетий. Например:
        ---
        auto время = Часы.сейчас.время;
        assert (время.миллисек < 1000);
        assert (время.сек < 60);
        assert (время.минуты < 60);
        assert (время.часы < 24);
        ---

        Можно создать ВремяДня из сущксвующего экземпляра Время или ИнтервалВремени
        посредством соответствующего метода время(). Чтобы преобразовать назад в ИнтервалВремени,
        используется метод вринтервал().

******************************************************************************/

extern(D) struct ВремяДня
{
    /**
     * Часовая компонента времени дня.  Должно быть между 0 и
     * 23, включительно.
     */
    public бцел часы (бцел ч = бцел.init);

    /**
     * Минутная компонента времени дня.  Должно быть между 0 и
     * 59, включительно.
     */
    public бцел минуты(бцел м = бцел.init);

    /**
     * Секундная компонента времени дня.  Должно быть между 0 и
     * 59, включительно.
     */
    public бцел сек(бцел с = бцел.init);

    /**
     * Миллисекундная компонента времени дня.  Должно быть между
     * 0 и 999, включительно.
     */
	 
	  public бцел миллисек(бцел мс = бцел.init);

    /**
     * Конструктор.
     * Параметры: часы = число часов с полуночи
     *         минуты = число минут, преобразуемых в час
     *         сек = число сек, преобразуемых в минуту
     *         миллисек = число миллисекунд, преобразуемых в секунда
     *
     * Возвращает: ВремяДня , представляющее поля заданного времени.
     *
     * Примечание: Отсутствует проверка диапазона значений и какие-либо
     * нормализации. Поэтому, если передаются большие значения, чем
     * максимумальное для поля, они будут сохранены как это значение.
     *
     * Пример:
     * --------------
     * auto врдня = ВремяДня(100, 100, 100, 10000);
     * assert(врдня.часы == 100);
     * assert(врдня.минуты == 100);
     * assert(врдня.сек == 100);
     * assert(врдня.миллисек == 10000);
     * --------------
     */
   static ВремяДня opCall (бцел часы, бцел минуты, бцел сек, бцел миллисек=0);

    /**
     * Конструктор.
     * Параметры: тики = тики, представляющие значение времени. Нормализуются
     * на представление времени дня (modulo-24 и т.п.)
     *
     * Возвращает: Значение ВремяДня, соответствующее времени дня
     * данного числа тиков.
     */
  static ВремяДня opCall(дол тики);

    /**
     * Конструирует ИнтервалВремени из текущ полей.
     *
     * Возвращает: ВремяДня, представляющее значения поля.
     *
     * Примечание: эти поля не сравниваются с действительным диапазоном,
     * так, допускается настройка 60 для минут, и будет добавлен 1 к компоненте
     * час, а компонента минута устанавливается в 0.  Результат нормализуется,
     * оборачивая часы. Если передаётся 25 часов, 
     * результирующее ВремяДня будет иметь часовую компоненту 1.
     */
   ИнтервалВремени вринтервал();

    /**
     * Внутренняя процедура для исправления тиков на один день. Также настраивает
     * смещения в BC эре.
     */
   static ИнтервалВремени модуль24 (дол тики);
}

/******************************************************************************

    Генерное представление Даты

******************************************************************************/

struct Дата
{
    public бцел         эра,            /// AD, BC
           день,            /// 1 .. 31
           год,           /// 0 в_ 9999
           месяц,          /// 1 .. 12
           деньнед,            /// 0 .. 6
           деньгода;            /// 1 .. 366
}


/******************************************************************************

    Комбинация из Дата и ВремяДня.

******************************************************************************/

struct ДатаВремя
{
    public Дата         дата;       /// представление даты
    public ВремяДня    время;       /// представление времени
}