module col.impl.RBCell;

private import  col.impl.Cell;
private import  col.model.IteratorX,
        col.model.Comparator;

/**
 * КЧЯчейка реализует базовые возможности красно-чёрных деревьев,
 * одного из эффективных видов сбалансированных двоичных деревьев.
 * Используются отдельные алгоритны, адаптированные из описанных
 * в книге Corman, Lieserson и Rivest'а <EM>Введение в Алгоритмы</EM>.
 * Данный код инспирирован подобным  ему классом у Chuck McManis.
 * Реализации ребалансирования при операциях вставки и удаления
 * немного хитростнее тех версий, иак как при этом не меняется
 * контент ячеек и не используется призрачных нулевых узлов.
 * <P>
 * Это класс-реализация. Для связки смотрите:
 * См_Также: RBTree
 * Authors: Doug Lea
**/

public class КЧЯчейка(T) : Ячейка!(T)
{
    static бул КРАСНЫЙ = нет;
    static бул ЧЁРНЫЙ = да;

    /**
     * Цвет этого узла (КРАСНЫЙ, ЧЁРНЫЙ)
    **/

    package бул цвет_;

    /**
     * Указатель на левую ветвь.
    **/

    package КЧЯчейка лево_;

    /**
     * Указатель на правую ветвь.
    **/

    package КЧЯчейка право_;

    /**
     * Указатель на родителя (пусто, если это корень).
    **/

    private КЧЯчейка родитель_;

    /**
     * Создаёт новую Ячейка с заданным элементом, пусто линками, и ЧЁРНЫЙ цветом.
     * Как правило, вызывается, чтобы установить новый корень.
    **/

    public this (T элемент)
    {
        super(элемент);
        лево_ = пусто;
        право_ = пусто;
        родитель_ = пусто;
        цвет_ = ЧЁРНЫЙ;
    }

    /**
     * Возвращает новую КЧЯчейку с тем же элементом и цветом,
     * но с пусто линки. (так как всегда нехорошо иметь
     * несколько идентичных линков в КЧ дереве.)
    **/

    protected КЧЯчейка дубликат()
    {
        КЧЯчейка t = new КЧЯчейка(элемент());
        t.цвет_ = цвет_;
        return t;
    }


    /**
     * Возвращает левую ветвь (или пусто).
    **/

    public final КЧЯчейка лево()
    {
        return лево_;
    }

    /**
     * Возвращает правую ветвь (или пусто).
    **/

    public final КЧЯчейка право()
    {
        return право_;
    }

    /**
     * Возвращает родитель (или пусто).
    **/
    public final КЧЯчейка родитель()
    {
        return родитель_;
    }


    /**
     * См_Также: col.model.View.Обзор.проверьРеализацию.
    **/
    public проц проверьРеализацию()
    {

        // Очень непросто проверить своство, когда каждый простой путь
        // от узла к листку имеет одинаковое число чёрных узлов.
        // Поэтому ограничимся следукющим.

        assert(родитель_ is пусто ||
               this is родитель_.лево_ ||
               this is родитель_.право_);

        assert(лево_ is пусто ||
               this is лево_.родитель_);

        assert(право_ is пусто ||
               this is право_.родитель_);

        assert(цвет_ is ЧЁРНЫЙ ||
               (цветУ(лево_) is ЧЁРНЫЙ) && (цветУ(право_) is ЧЁРНЫЙ));

        if (лево_ !is пусто)
            лево_.проверьРеализацию();
        if (право_ !is пусто)
            право_.проверьРеализацию();
    }

    /**
     * Возвращает минимальный элемент текущего (под)дерева.
    **/

    public final КЧЯчейка левейший()
    {
        auto p = this;
        for ( ; p.лево_ !is пусто; p = p.лево_)
        {}
        return p;
    }

    /**
     * Возвращает максимальный элемент текущего (под)дерева.
    **/
    public final КЧЯчейка правейший()
    {
        auto p = this;
        for ( ; p.право_ !is пусто; p = p.право_)
        {}
        return p;
    }

    /**
     * Возвращает корень (безродительный узел) этого дерева.
    **/
    public final КЧЯчейка корень()
    {
        auto p = this;
        for ( ; p.родитель_ !is пусто; p = p.родитель_)
        {}
        return p;
    }

    /**
     * Возвращает да, если узел - корень (т.е., имеет пусто родителя).
    **/

    public final бул корень_ли()
    {
        return родитель_ is пусто;
    }


    /**
     * Возвращает очередного потомка, либо пусто, если такового нет.
    **/

    public final КЧЯчейка потомок()
    {
        if (право_ !is пусто)
            return право_.левейший();
        else
        {
            auto p = родитель_;
            auto ch = this;
            while (p !is пусто && ch is p.право_)
            {
                ch = p;
                p = p.родитель_;
            }
            return p;
        }
    }

    /**
     * Возвращает очредного предка, либо пусто, если такового нет.
    **/

    public final КЧЯчейка предок()
    {
        if (лево_ !is пусто)
            return лево_.правейший();
        else
        {
            auto p = родитель_;
            auto ch = this;
            while (p !is пусто && ch is p.лево_)
            {
                ch = p;
                p = p.родитель_;
            }
            return p;
        }
    }

    /**
     * Возвращает число узлов в поддереве.
    **/
    public final цел размер()
    {
        цел c = 1;
        if (лево_ !is пусто)
            c += лево_.размер();
        if (право_ !is пусто)
            c += право_.размер();
        return c;
    }


    /**
     * Возвращает узел текущего поддерева, содержащий элемент как элемент(),
     * если он есть, иначе - пусто.
     * Использует Сравнитель cmp для поиска и сверки на равенство.
    **/

    public КЧЯчейка найди(T элемент, Сравнитель!(T) cmp)
    {
        auto t = this;
        for (;;)
        {
            цел рознь = cmp(элемент, t.элемент());
            if (рознь is 0)
                return t;
            else if (рознь < 0)
                t = t.лево_;
            else
                t = t.право_;
            if (t is пусто)
                break;
        }
        return пусто;
    }


    /**
     * Возвращает число узлов текущего поддерева, содержащих элемент.
     * Использует Сравнитель cmp для поиска и сверки на равенство.
    **/
    public цел счёт(T элемент, Сравнитель!(T) cmp)
    {
        цел c = 0;
        auto t = this;
        while (t !is пусто)
        {
            цел рознь = cmp(элемент, t.элемент());
            if (рознь is 0)
            {
                ++c;
                if (t.лево_ is пусто)
                    t = t.право_;
                else if (t.право_ is пусто)
                    t = t.лево_;
                else
                {
                    c += t.право_.счёт(элемент, cmp);
                    t = t.лево_;
                }
            }
            else if (рознь < 0)
                t = t.лево_;
            else
                t = t.право_;
        }
        return c;
    }




    /**
     * Возвращает новое поддерево, содержащее каждый элемент текущего поддерева.
    **/

    public final КЧЯчейка копируйДерево()
    {
        auto t = cast(КЧЯчейка)(дубликат());

        if (лево_ !is пусто)
        {
            t.лево_ = лево_.копируйДерево();
            t.лево_.родитель_ = t;
        }
        if (право_ !is пусто)
        {
            t.право_ = право_.копируйДерево();
            t.право_.родитель_ = t;
        }
        return t;
    }


    /**
     * Отсутствует вставка генерного элемента. Вмесио этого находится
     * место, куда нужно добавить узел, и далее вызывается вставьЛевый
     * или вставьПравый.
     * <P>
     * Вставляет Ячейку как левую ветвь текущего узла, и затем
     * ребалансирует дерево, в котором она находится.
     * @param Ячейка добавляемая Ячейка
     * @param корень корень текущего дерева
     * Возвращает: новый корень текущего дерева. (Ребалансировка
     * может поменять этот корень!)
    **/


    public final КЧЯчейка вставьЛевый(КЧЯчейка Ячейка, КЧЯчейка корень)
    {
        лево_ = Ячейка;
        Ячейка.родитель_ = this;
        return Ячейка.исправьПослеВставки(корень);
    }

    /**
     * Вставляет Ячейку как правую ветвь текущего узла, и затем
     * ребалансирует дерево, в котором она находится.
     * @param Ячейка добавляемая Ячейка
     * @param корень корень текущего дерева
     * Возвращает: новый корень текущего дерева.  (Ребалансировка
     * может поменять этот корень!)
    **/

    public final КЧЯчейка вставьПравый(КЧЯчейка Ячейка, КЧЯчейка корень)
    {
        право_ = Ячейка;
        Ячейка.родитель_ = this;
        return Ячейка.исправьПослеВставки(корень);
    }


    /**
     * Удаляет текущий узел, и затем ребалансирует дерево, где он находится.
     * @param корень корень текущего дерева
     * Возвращает: новый корень текущего дерева.  (Ребалансировка
     * может поменять этот корень!)
    **/


    public final КЧЯчейка удали (КЧЯчейка корень)
    {

        // укз case where we are only узел
        if (лево_ is пусто && право_ is пусто && родитель_ is пусто)
            return пусто;

        // if strictly internal, обменяй places with a потомок
        if (лево_ !is пусто && право_ !is пусто)
        {
            auto s = потомок();
            // To work nicely with arbitrary subclasses of КЧЯчейка, we don't want в_
            // just копируй потомок's fields. since we don't know что
            // they are.  Instead we обменяй positions _in the дерево.
            корень = поменяйПозиции(this, s, корень);
        }

        // Start fixup at замена узел (normally a ветвь).
        // But if no ветви, fake it by using сам

        if (лево_ is пусто && право_ is пусто)
        {

            if (цвет_ is ЧЁРНЫЙ)
                корень = this.исправьПослеУдаления(корень);

            // Unlink  (Couldn't перед since исправьПослеУдаления needs родитель ptr)

            if (родитель_ !is пусто)
            {
                if (this is родитель_.лево_)
                    родитель_.лево_ = пусто;
                else if (this is родитель_.право_)
                    родитель_.право_ = пусто;
                родитель_ = пусто;
            }

        }
        else
        {
            auto замена = лево_;
            if (замена is пусто)
                замена = право_;

            // link замена в_ родитель
            замена.родитель_ = родитель_;

            if (родитель_ is пусто)
                корень = замена;
            else if (this is родитель_.лево_)
                родитель_.лево_ = замена;
            else
                родитель_.право_ = замена;

            лево_ = пусто;
            право_ = пусто;
            родитель_ = пусто;

            // fix замена
            if (цвет_ is ЧЁРНЫЙ)
                корень = замена.исправьПослеУдаления(корень);

        }

        return корень;
    }

    /**
     * Меняем местами связи двух узлов в дереве.
     * Возвращает новый корень, в случае если он изменён.
    **/

    static final КЧЯчейка поменяйПозиции(КЧЯчейка x, КЧЯчейка y, КЧЯчейка корень)
    {

        /* Too messy. TODO: найди sequence of assigments that are всегда ОК */

        auto px = x.родитель_;
        бул xpl = px !is пусто && x is px.лево_;
        auto lx = x.лево_;
        auto rx = x.право_;

        auto py = y.родитель_;
        бул ypl = py !is пусто && y is py.лево_;
        auto ly = y.лево_;
        auto ry = y.право_;

        if (x is py)
        {
            y.родитель_ = px;
            if (px !is пусто)
                if (xpl)
                    px.лево_ = y;
                else
                    px.право_ = y;
            x.родитель_ = y;
            if (ypl)
            {
                y.лево_ = x;
                y.право_ = rx;
                if (rx !is пусто)
                    rx.родитель_ = y;
            }
            else
            {
                y.право_ = x;
                y.лево_ = lx;
                if (lx !is пусто)
                    lx.родитель_ = y;
            }
            x.лево_ = ly;
            if (ly !is пусто)
                ly.родитель_ = x;
            x.право_ = ry;
            if (ry !is пусто)
                ry.родитель_ = x;
        }
        else if (y is px)
        {
            x.родитель_ = py;
            if (py !is пусто)
                if (ypl)
                    py.лево_ = x;
                else
                    py.право_ = x;
            y.родитель_ = x;
            if (xpl)
            {
                x.лево_ = y;
                x.право_ = ry;
                if (ry !is пусто)
                    ry.родитель_ = x;
            }
            else
            {
                x.право_ = y;
                x.лево_ = ly;
                if (ly !is пусто)
                    ly.родитель_ = x;
            }
            y.лево_ = lx;
            if (lx !is пусто)
                lx.родитель_ = y;
            y.право_ = rx;
            if (rx !is пусто)
                rx.родитель_ = y;
        }
        else
        {
            x.родитель_ = py;
            if (py !is пусто)
                if (ypl)
                    py.лево_ = x;
                else
                    py.право_ = x;
            x.лево_ = ly;
            if (ly !is пусто)
                ly.родитель_ = x;
            x.право_ = ry;
            if (ry !is пусто)
                ry.родитель_ = x;

            y.родитель_ = px;
            if (px !is пусто)
                if (xpl)
                    px.лево_ = y;
                else
                    px.право_ = y;
            y.лево_ = lx;
            if (lx !is пусто)
                lx.родитель_ = y;
            y.право_ = rx;
            if (rx !is пусто)
                rx.родитель_ = y;
        }

        бул c = x.цвет_;
        x.цвет_ = y.цвет_;
        y.цвет_ = c;

        if (корень is x)
            корень = y;
        else if (корень is y)
            корень = x;
        return корень;
    }



    /**
     * Возвращает цвет узла p, либо ЧЁРНЫЙ, если p = пусто
     * (В версии CLR, для таких целей используется специальный
     * dummy `nil' узел, но здесь это не работает, так как это
     * могло бы привести к созданию по одному такому узлу для
     * каждого реального узла.)
     *
    **/

    static final бул цветУ(КЧЯчейка p)
    {
        return (p is пусто) ? ЧЁРНЫЙ : p.цвет_;
    }

    /**
     * Возвращает родитель узла p, либо пусто, если p is пусто.
    **/
    static final КЧЯчейка родительУ(КЧЯчейка p)
    {
        return (p is пусто) ? пусто : p.родитель_;
    }

    /**
     * Устанавливает цвет узла p, либо ничего не делает, если p is пусто.
    **/

    static final проц установиЦвет(КЧЯчейка p, бул c)
    {
        if (p !is пусто)
            p.цвет_ = c;
    }

    /**
     * Возвращает левую ветвь узла p, либо пусто, если p is пусто.
    **/

    static final КЧЯчейка левыйУ(КЧЯчейка p)
    {
        return (p is пусто) ? пусто : p.лево_;
    }

    /**
     * Возвращает правую ветвь узла p, либо пусто, если p is пусто.
    **/

    static final КЧЯчейка правыйУ(КЧЯчейка p)
    {
        return (p is пусто) ? пусто : p.право_;
    }


    /** ОтКого CLR **/
    protected final КЧЯчейка вращайВлево(КЧЯчейка корень)
    {
        auto r = право_;
        право_ = r.лево_;
        if (r.лево_ !is пусто)
            r.лево_.родитель_ = this;
        r.родитель_ = родитель_;
        if (родитель_ is пусто)
            корень = r;
        else if (родитель_.лево_ is this)
            родитель_.лево_ = r;
        else
            родитель_.право_ = r;
        r.лево_ = this;
        родитель_ = r;
        return корень;
    }

    /** ОтКого CLR **/
    protected final КЧЯчейка вращайВправо(КЧЯчейка корень)
    {
        auto l = лево_;
        лево_ = l.право_;
        if (l.право_ !is пусто)
            l.право_.родитель_ = this;
        l.родитель_ = родитель_;
        if (родитель_ is пусто)
            корень = l;
        else if (родитель_.право_ is this)
            родитель_.право_ = l;
        else
            родитель_.лево_ = l;
        l.право_ = this;
        родитель_ = l;
        return корень;
    }


    /** ОтКого CLR **/
    protected final КЧЯчейка исправьПослеВставки(КЧЯчейка корень)
    {
        цвет_ = КРАСНЫЙ;
        auto x = this;

        while (x !is пусто && x !is корень && x.родитель_.цвет_ is КРАСНЫЙ)
        {
            if (родительУ(x) is левыйУ(родительУ(родительУ(x))))
            {
                auto y = правыйУ(родительУ(родительУ(x)));
                if (цветУ(y) is КРАСНЫЙ)
                {
                    установиЦвет(родительУ(x), ЧЁРНЫЙ);
                    установиЦвет(y, ЧЁРНЫЙ);
                    установиЦвет(родительУ(родительУ(x)), КРАСНЫЙ);
                    x = родительУ(родительУ(x));
                }
                else
                {
                    if (x is правыйУ(родительУ(x)))
                    {
                        x = родительУ(x);
                        корень = x.вращайВлево(корень);
                    }
                    установиЦвет(родительУ(x), ЧЁРНЫЙ);
                    установиЦвет(родительУ(родительУ(x)), КРАСНЫЙ);
                    if (родительУ(родительУ(x)) !is пусто)
                        корень = родительУ(родительУ(x)).вращайВправо(корень);
                }
            }
            else
            {
                auto y = левыйУ(родительУ(родительУ(x)));
                if (цветУ(y) is КРАСНЫЙ)
                {
                    установиЦвет(родительУ(x), ЧЁРНЫЙ);
                    установиЦвет(y, ЧЁРНЫЙ);
                    установиЦвет(родительУ(родительУ(x)), КРАСНЫЙ);
                    x = родительУ(родительУ(x));
                }
                else
                {
                    if (x is левыйУ(родительУ(x)))
                    {
                        x = родительУ(x);
                        корень = x.вращайВправо(корень);
                    }
                    установиЦвет(родительУ(x), ЧЁРНЫЙ);
                    установиЦвет(родительУ(родительУ(x)), КРАСНЫЙ);
                    if (родительУ(родительУ(x)) !is пусто)
                        корень = родительУ(родительУ(x)).вращайВлево(корень);
                }
            }
        }
        корень.цвет_ = ЧЁРНЫЙ;
        return корень;
    }



    /** ОтКого CLR **/
    protected final КЧЯчейка исправьПослеУдаления(КЧЯчейка корень)
    {
        auto x = this;
        while (x !is корень && цветУ(x) is ЧЁРНЫЙ)
        {
            if (x is левыйУ(родительУ(x)))
            {
                auto пасынок = правыйУ(родительУ(x));
                if (цветУ(пасынок) is КРАСНЫЙ)
                {
                    установиЦвет(пасынок, ЧЁРНЫЙ);
                    установиЦвет(родительУ(x), КРАСНЫЙ);
                    корень = родительУ(x).вращайВлево(корень);
                    пасынок = правыйУ(родительУ(x));
                }
                if (цветУ(левыйУ(пасынок)) is ЧЁРНЫЙ && цветУ(правыйУ(пасынок)) is ЧЁРНЫЙ)
                {
                    установиЦвет(пасынок, КРАСНЫЙ);
                    x = родительУ(x);
                }
                else
                {
                    if (цветУ(правыйУ(пасынок)) is ЧЁРНЫЙ)
                    {
                        установиЦвет(левыйУ(пасынок), ЧЁРНЫЙ);
                        установиЦвет(пасынок, КРАСНЫЙ);
                        корень = пасынок.вращайВправо(корень);
                        пасынок = правыйУ(родительУ(x));
                    }
                    установиЦвет(пасынок, цветУ(родительУ(x)));
                    установиЦвет(родительУ(x), ЧЁРНЫЙ);
                    установиЦвет(правыйУ(пасынок), ЧЁРНЫЙ);
                    корень = родительУ(x).вращайВлево(корень);
                    x = корень;
                }
            }
            else
            {
                auto пасынок = левыйУ(родительУ(x));
                if (цветУ(пасынок) is КРАСНЫЙ)
                {
                    установиЦвет(пасынок, ЧЁРНЫЙ);
                    установиЦвет(родительУ(x), КРАСНЫЙ);
                    корень = родительУ(x).вращайВправо(корень);
                    пасынок = левыйУ(родительУ(x));
                }
                if (цветУ(правыйУ(пасынок)) is ЧЁРНЫЙ && цветУ(левыйУ(пасынок)) is ЧЁРНЫЙ)
                {
                    установиЦвет(пасынок, КРАСНЫЙ);
                    x = родительУ(x);
                }
                else
                {
                    if (цветУ(левыйУ(пасынок)) is ЧЁРНЫЙ)
                    {
                        установиЦвет(правыйУ(пасынок), ЧЁРНЫЙ);
                        установиЦвет(пасынок, КРАСНЫЙ);
                        корень = пасынок.вращайВлево(корень);
                        пасынок = левыйУ(родительУ(x));
                    }
                    установиЦвет(пасынок, цветУ(родительУ(x)));
                    установиЦвет(родительУ(x), ЧЁРНЫЙ);
                    установиЦвет(левыйУ(пасынок), ЧЁРНЫЙ);
                    корень = родительУ(x).вращайВправо(корень);
                    x = корень;
                }
            }
        }
        установиЦвет(x, ЧЁРНЫЙ);
        return корень;
    }
}

