module col.impl.RBPair;

private import col.impl.RBCell;
private import col.model.Comparator;

/**
 *
 * КЧПара - это КЧЯчейка с ключом.
 *
**/

public class КЧПара(К, T) : КЧЯчейка!(T) 
{
        alias КЧЯчейка!(T).элемент элемент;

        // Переменная экземпляра

        private К ключ_;

        /**
         * Создаёт ячейку с заданным ключом и значением элемента, и пусто линки.
        **/

        public this (К ключ, T знач)
        {
                super(знач);
                ключ_ = ключ;
        }

        /**
         * Создаёт новый узел с тем же ключом и значением элемента, но с пусто линками.
        **/

        protected final КЧПара дубликат()
        {
                auto t = new КЧПара(ключ_, элемент());
                t.цвет_ = цвет_;
                return t;
        }

        /**
         * Возвращает ключ.
        **/

        public final К ключ()
        {
                return ключ_;
        }


        /**
         * Устанавливает ключ.
        **/

        public final проц ключ(К ключ)
        {
                ключ_ = ключ;
        }

        /**
         * Реализует КЧЯчейка.найди.
         * Переписывает версию КЧЯчейка, поскольку были упорядочены ключи, а не элементы,
         * поэтому для поиска элемента нужно обыскать всё дерево.
         * сравнитель аргумент не был использован.
         * См_Также: КЧЯчейка.найди
        **/

        public final override КЧЯчейка!(T) найди(T элемент, Сравнитель!(T) cmp)
        {
                КЧЯчейка!(T) t = this;

                while (t !is пусто)
                      {
                      if (t.элемент() == (элемент))
                          return t;
                      else
                        if (t.право_ is пусто)
                            t = t.лево_;
                        else
                           if (t.лево_ is пусто)
                               t = t.право_;
                           else
                              {
                              auto p = t.лево_.найди(элемент, cmp);

                              if (p !is пусто)
                                  return p;
                              else
                                 t = t.право_;
                              }
                      }
                return пусто; // not reached
        }

        /**
         * Реализует КЧЯчейка.счёт.
         * См_Также: КЧЯчейка.счёт
        **/
        public final override цел счёт(T элемент, Сравнитель!(T) cmp)
        {
                цел c = 0;
                КЧЯчейка!(T) t = this;

                while (t !is пусто)
                      {
                      if (t.элемент() == (элемент))
                          ++c;

                      if (t.право_ is пусто)
                          t = t.лево_;
                      else
                         if (t.лево_ is пусто)
                             t = t.право_;
                         else
                            {
                            c += t.лево_.счёт(элемент, cmp);
                            t = t.право_;
                            }
                      }
                return c;
        }

        /**
         * Находит и возвращает ячейку, содержащую ключ, либо пусто, если такового нет.
        **/

        public final КЧПара найдиКлюч(К ключ, Сравнитель!(К) cmp)
        {
                auto t = this;

                for (;;)
                    {
                    цел рознь = cmp(ключ, t.ключ_);
                    if (рознь is 0)
                        return t;
                    else
                       if (рознь < 0)
                           t = cast(КЧПара)(t.лево_);
                       else
                          t = cast(КЧПара)(t.право_);

                    if (t is пусто)
                        break;
                    }
                return пусто;
        }

        /**
         * Находит и возвращает ячейку, содержащую (ключ, элемент), либо пусто, если такового нет.
        **/
        public final КЧПара найди(К ключ, T элемент, Сравнитель!(К) cmp)
        {
                auto t = this;

                for (;;)
                    {
                    цел рознь = cmp(ключ, t.ключ_);
                    if (рознь is 0 && t.элемент() == (элемент))
                        return t;
                    else
                       if (рознь <= 0)
                           t = cast(КЧПара)(t.лево_);
                       else
                          t = cast(КЧПара)(t.право_);

                    if (t is пусто)
                        break;
                    }
                return пусто;
        }

        /**
         *Возвращает число узлов поддерева, содержащих ключ.
        **/
        public final цел учтиКлюч(К ключ, Сравнитель!(К) cmp)
        {
                цел c = 0;
                auto t = this;

                while (t !is пусто)
                      {
                      цел рознь = cmp(ключ, t.ключ_);
                      // rely on вставь в_ всегда go лево on <=
                      if (рознь is 0)
                          ++c;

                      if (рознь <= 0)
                          t = cast(КЧПара)(t.лево_);
                      else
                         t = cast(КЧПара)(t.право_);
                      }
                return c;
        }

        /**
         *Возвращает число узлов поддерева, содержащих (ключ, элемент).
        **/
        public final цел счёт(К ключ, T элемент, Сравнитель!(К) cmp)
        {
                цел c = 0;
                auto t = this;
                
                while (t !is пусто)
                      {
                      цел рознь = cmp(ключ, t.ключ_);
                      if (рознь is 0)
                         {
                         if (t.элемент() == (элемент))
                             ++c;

                         if (t.лево_ is пусто)
                             t = cast(КЧПара)(t.право_);
                         else
                            if (t.право_ is пусто)
                                t = cast(КЧПара)(t.лево_);
                            else
                               {
                               c += (cast(КЧПара)(t.право_)).счёт(ключ, элемент, cmp);
                               t = cast(КЧПара)(t.лево_);
                               }
                         }
                      else
                         if (рознь < 0)
                             t = cast(КЧПара)(t.лево());
                         else
                            t = cast(КЧПара)(t.право());
                      }
                return c;
        }
}

