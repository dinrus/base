module col.model.Seq;

private import  col.model.SeqView,
        col.model.IteratorX,
        col.model.Dispenser;

/**
 * Сек - это Сек, владеющий методами стандартной модификации.
**/


public interface Сек(T) : ОбзорСека!(T), Расходчик!(T)
{
    public override Сек!(T) дубликат();
    public alias дубликат dup;
    /**
     * Вставить все элементы перечисления e по заданному индексу, сохраняя их
     * порядок. Индекс может быть в диапазоне от
     * 0..размер() (т.е., на один после текущего последнего индекса). Если индекс
     равен размер(), то элементы добавляюся в конце.
     *
     * @param индекс индекс, с которого начинается добавление
     * @param e добавляемые элементы
     * Возвращает: условие:
     * <PRE>
     * foreach (цел i in 0 .. индекс-1) по(i).равно(ПРЕДШ(this)по(i)); &&
     * все существующие элементы, расположенные по индексам,- от и выше данного индекса,-
     * имеют свои индексы, увеличенные на число элементов,
     * траверсируемых посредством e.получи() &&
     * Новые элементы расположены по индексам индекс + их порядок в обходе
     * методом получи этого перчня.
     * !(e.ещё()) &&
     * (версия() != ПРЕДШ(this).версия()) == ПРЕДШ(e).ещё()
     * </PRE>
     * Выводит исключение: ИсклНедопустимыйЭлемент, если !можетВключить какой-то элемент из e;
     * может либо обнулять, либо не обнулять эффект вставки других элементов.
     * Выводит исключение: НетЭлементаИскл,если индекс не в диапазоне 0..размер()
     * Выводит исключение: ИсклПовреждённыйОбходчик, которое
     * может либо обнулять, либо не обнулять эффект вставки других элементов.
    **/

    public проц добавьПо (цел индекс, Обходчик!(T) e);


    /**
     * Вставить элемент по указанному индексу. Этот индекс может быть в диапазоне от
     * 0..размер() (т.е., one past the текущ последний индекс). If the индекс is
     * equal в_ размер(), the элемент is appended as the new последний элемент.
     * @param индекс the индекс в_ добавь at
     * @param элемент добавляемый элемент
     * Возвращает: condition:
     * <PRE>
     * размер() == ПРЕДШ(this).размер()+1 &&
     * at(индекс).равно(элемент) &&
     * foreach (цел i in 0 .. индекс-1)      получи(i).равно(ПРЕДШ(this).получи(i))
     * foreach (цел i in индекс+1..размер()-1) получи(i).равно(ПРЕДШ(this).получи(i-1))
     * Версия change: всегда
     * </PRE>
     * Выводит исключение: НетЭлементаИскл, если индекс не в диапазоне 0..размер()
     * Выводит исключение: ИсклНедопустимыйЭлемент, если !можетВключить(элемент)
    **/

    public проц добавьПо (цел индекс, T элемент);

    /**
     * замени элемент по заданному индексу with new значение
     * @param индекс индекс, по которому меняется значение
     * @param элемент the new значение
     * Возвращает: condition:
     * <PRE>
     * размер() == ПРЕДШ(this).размер() &&
     * at(индекс).равно(элемент) &&
     * no spurious effects
     * Версия change <-- !элемент.равно(ПРЕДШ(this).получи(индекс)
     *                    (but MAY change even if equal).
     * </PRE>
     * Выводит исключение: НетЭлементаИскл , если индекс не в диапазоне 0..размер()-1
     * Выводит исключение: ИсклНедопустимыйЭлемент if !можетВключить(элемент)
    **/

    public проц замениПо (цел индекс, T элемент);

    /**
     * замени элемент по заданному индексу with new значение
     * @param элемент the new значение
     * @param индекс индекс, по которому меняется значение
     * Возвращает: condition:
     * <PRE>
     * размер() == ПРЕДШ(this).размер() &&
     * at(индекс).равно(элемент) &&
     * no spurious effects
     * Версия change <-- !элемент.равно(ПРЕДШ(this).получи(индекс)
     *                    (but MAY change even if equal).
     * </PRE>
     * Выводит исключение: НетЭлементаИскл , если индекс не в диапазоне 0..размер()-1
     * Выводит исключение: ИсклНедопустимыйЭлемент if !можетВключить(элемент)
    **/
    public проц opIndexAssign (T элемент, цел индекс);


    /**
     * Удалить элемент по заданному индексу. У всех элементов справа
     * индексы уменьшаются на единицу.
     * @param индекс индекс удаляемого элемента
     * Возвращает: условие:
     * <PRE>
     * размер() = ПРЕДШ(this).размер()-1 &&
     * foreach (цел i in 0..индекс-1)      получи(i).равно(ПРЕДШ(this).получи(i)); &&
     * foreach (цел i in индекс..размер()-1) получи(i).равно(ПРЕДШ(this).получи(i+1));
     * Версия меняется: всегда
     * </PRE>
     * Выводит исключение: НетЭлементаИскл, если индекс не в диапазоне 0..размер()-1
    **/
    public проц удалиПо (цел индекс);


    /**
     * Вставить элемент в начало последовательности.
     * По поведению равнозначно вставь(0, элемент)
     * @param элемент добавляемый элемент
     * Выводит исключение: ИсклНедопустимыйЭлемент, если !можетВключить(элемент)
    **/

    public проц приставь(T элемент);


    /**
     * Заменить элемент во фронте последовательности на новое значение.
     * По поведению равнозначно замени(0, элемент);
    **/
    public проц замениГолову(T элемент);

    /**
     * Удалить левейший элемент.
     * По поведению равнозначно удали(0);
    **/

    public проц удалиГолову();


    /**
     * Вставить элемент в конец последовательности.
     * По поведению равнозначно вставь(размер(), элемент)
     * @param элемент добавляемый элемент
     * Выводит исключение: ИсклНедопустимыйЭлемент, если !можетВключить(элемент).
    **/

    public проц добавь(T элемент);
    public alias добавь opCatAssign;

    /**
     * Заменить элемент в конце последовательности на новое значение.
     * По поведению равнозначно замени(размер()-1, элемент);
    **/

    public проц замениХвост(T элемент);



    /**
     * Удалить правейший элемент.
     * По поведению равнозначно удали(размер()-1);
     * Выводит исключение: НетЭлементаИскл,если пуст_ли
    **/
    public проц удалиХвост();


    /**
     * Удалить элементы от отИндекса до доИндекса, включительно.
     * Без эффекта, если отИндекса > доИндекса.
     * По поведению равнозначно
     * <PRE>
     * for (цел i = отИндекса; i &lt;= доИндекса; ++i) удали(отИндекса);
     * </PRE>
     * @param индекс the индекс of the первый элемент в_ удали
     * @param индекс the индекс of the последний элемент в_ удали
     * Возвращает: condition:
     * <PRE>
     * let n = max(0, доИндекса - отИндекса + 1 in
     *  размер() == ПРЕДШ(this).размер() - 1 &&
     *  for (цел i in 0 .. отИндекса - 1)     получи(i).равно(ПРЕДШ(this).получи(i)) &&
     *  for (цел i in отИндекса .. размер()- 1) получи(i).равно(ПРЕДШ(this).получи(i+n)
     *  Версия меняется, если n > 0
     * </PRE>
     * Выводит исключение: НетЭлементаИскл if отИндекса or доИндекса is not in
     * range 0..размер()-1
    **/

    public проц удалиДиапазон(цел отИндекса, цел доИндекса);


    /**
     * "Препендить" (приставить впереди) все элементы перечисления e,
	 * соблюдая их порядок.
     * По поведению равнозначно добавьЭлтыПо(0, e)
     * @param e добавляемые элементы
    **/

    public проц приставь(Обходчик!(T) e);


    /**
     * Добавляет все элементы перечисления e, соблюдая их порядок.
     * По поведению равнозначно добавьЭлтыПо(размер(), e)
     * @param e добавляемые элементы
    **/
    public проц добавь(Обходчик!(T) e);
}


