module col.model.Dispenser;

private import  col.model.View,
        col.model.IteratorX;

/**
 *
 * Расходчик - это корневой интерфейс всех изменяемых коллекций; т.е.,
 * коллекций, которые могут иметь динамически добавляемые, удаляемые,
 * и/или заменяемые элементы, в соответствии с семантикой их коллекций.
 *
**/

public interface Расходчик(T) : Обзор!(T)
{
    public override Расходчик!(T) дубликат ();
    public alias дубликат dup;
    /**
     * Опустошает эту коллекцию.
     * Возвращает: условие:
     * <PRE>
     * пуст_ли() &&
     * Версия меняется, если !ПРЕДШ(this).пуст_ли();
     * </PRE>
    **/

    public проц очисть ();

    /**
     * Меняет случай старЭлемент на новЭлемент.
     * Без эффекта, если does not hold старЭлемент or if старЭлемент.равно(новЭлемент).
     * The operation имеется a consistent, but slightly special interpretation
     * when applied в_ Sets. For Sets, because элементы occur at
     * most once, if новЭлемент is already included, replacing старЭлемент with
     * with новЭлемент имеется the same effect as just removing старЭлемент.
     * Возвращает: условие:
     * <PRE>
     * let цел дельта = старЭлемент.равно(новЭлемент)? 0 :
     *               max(1, ПРЕДШ(this).экземпляры(старЭлемент) in
     *  экземпляры(старЭлемент) == ПРЕДШ(this).экземпляры(старЭлемент) - дельта &&
     *  экземпляры(новЭлемент) ==  (this instanceof Набор) ?
     *         max(1, ПРЕДШ(this).экземпляры(старЭлемент) + дельта):
     *                ПРЕДШ(this).экземпляры(старЭлемент) + дельта) &&
     *  нет других изменений элементов &&
     *  Версия меняется, если дельта != 0
     * </PRE>
     * Выводит исключение: ИсклНедопустимыйЭлемент if имеется(старЭлемент) и !допускается(новЭлемент)
    **/

    public проц замени (T старЭлемент, T новЭлемент);

    /**
     * Заменят все случаи старЭлемент на новЭлемент.
     * Без эффекта, если нет старЭлемент или старЭлемент.равно(новЭлемент).
     * The operation имеется a consistent, but slightly special interpretation
     * when applied в_ Sets. For Sets, because элементы occur at
     * most once, if новЭлемент is already included, replacing старЭлемент with
     * with новЭлемент имеется the same effect as just removing старЭлемент.
     * Возвращает: условие:
     * <PRE>
     * let цел дельта = старЭлемент.равно(новЭлемент)? 0 :
                       ПРЕДШ(this).экземпляры(старЭлемент) in
     *  экземпляры(старЭлемент) == ПРЕДШ(this).экземпляры(старЭлемент) - дельта &&
     *  экземпляры(новЭлемент) ==  (this instanceof Набор) ?
     *         max(1, ПРЕДШ(this).экземпляры(старЭлемент) + дельта):
     *                ПРЕДШ(this).экземпляры(старЭлемент) + дельта) &&
     *  нет других изменений элементов &&
     *  Версия меняется, если дельта != 0
     * </PRE>
     * Выводит исключение: ИсклНедопустимыйЭлемент if имеется(старЭлемент) и !допускается(новЭлемент)
    **/

    public проц замениВсе(T старЭлемент, T новЭлемент);

    /**
     * Удаляет и возвращает элемент.  Implementations
     * may strengthen the guarantee about the nature of this элемент.
     * but in general it is the most convenient or efficient элемент в_ удали.
     * <P>
     * Пример usage. One way в_ перемести все элементы из_
     * Расходчик a в_ MutableBag b is:
     * <PRE>
     * while (!a.пустой()) b.добавь(a.возьми());
     * </PRE>
     * Возвращает: an элемент знач such that ПРЕДШ(this).имеется(знач)
     * и the postconditions of removeOneOf(знач) hold.
     * Выводит исключение: НетЭлементаИскл iff пуст_ли.
    **/

    public T возьми ();


    /**
     * Исключает все случаи каждого элемента этого обходчика.
     * По поведению равнозначно
     * <PRE>
     * while (e.ещё()) удалиВсе(e.значение());
     * @param e перечисление исключаемых элементов.
     * Выводит исключение: ИсклПовреждённыйОбходчик
    **/

    public проц удалиВсе (Обходчик!(T) e);

    /**
     * Удаляет случай каждого элемента этого обходчика.
     * По поведению равнозначно
     * <PRE>
     * while (e.ещё()) удали (e.значение());
     * @param e перечисление удаляемых элементов.
     * Выводит исключение: ИсклПовреждённыйОбходчик
    **/

    public проц удали (Обходчик!(T) e);

    /**
     * Исключает все случаи указанного элемента из этой коллекции.
     * Без эффекта, если элемент отсутствует.
     * @param элемент исключаемый элемент.
     * Возвращает: условие:
     * <PRE>
     * !имеется(элемент) &&
     * размер() == ПРЕДШ(this).размер() - ПРЕДШ(this).экземпляры(элемент) &&
     * нет других изменений элементов &&
     * Версия меняется, если ПРЕДШ(this).имеется(элемент)
     * </PRE>
    **/

    public проц удалиВсе (T элемент);


    /**
     * Удаляет экземпляр указанного элемента из этой коллекции.
     * Без эффекта, если !имеется(элемент)
     * @param элемент удаляемый элемент
     * Возвращает: условие:
     * <PRE>
     * let occ = max(1, экземпляры(элемент)) in
     *  размер() == ПРЕДШ(this).размер() - occ &&
     *  экземпляры(элемент) == ПРЕДШ(this).экземпляры(элемент) - occ &&
     *  нет других изменений элементов &&
     *  версия меняется, если occ == 1
     * </PRE>
    **/

    public проц удали (T элемент);
}


