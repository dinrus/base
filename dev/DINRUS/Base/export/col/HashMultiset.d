module col.HashMultiset;

public import col.model.Multiset;
public import col.Functions;
private import col.Hash;

/+ ИНТЕРФЕЙС:

class ХэшМультинабор(З, alias ШаблРеализац=ХэшДуб, alias хэшФункц=ДефХэш) : Мультинабор!(З)
{

    alias ШаблРеализац!(З, хэшФункц) Реализ;

    struct курсор
    {
        З значение();
        курсор opPostInc();
        курсор opPostDec();
        курсор opAddAssign(цел прир);
        курсор opSubAssign(цел прир);
        бул opEquals(курсор обх);
    }

    цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг);
    цел opApply(цел delegate(ref З з) дг);
    this();
    private this(ref Реализ дубИз);
    ХэшМультинабор зачисть();
    бцел длина();
	alias длина length;
    курсор начало();
    курсор конец();
    курсор удали(курсор обх);
    курсор найди(З з);
    курсор найди(курсор обх, З з);
    бул содержит(З з);
    ХэшМультинабор удали(З з);
    ХэшМультинабор удали(З з, ref бул былУдалён);
    ХэшМультинабор добавь(З з);
    ХэшМультинабор добавь(З з, ref бул былДобавлен);
    ХэшМультинабор добавь(Обходчик!(З) обх);
    ХэшМультинабор добавь(Обходчик!(З) обх, ref бцел члоДобавленных);
    ХэшМультинабор добавь(З[] массив);
    ХэшМультинабор добавь(З[] массив, ref бцел члоДобавленных);
    бцел счёт(З з);
    ХэшМультинабор удалиВсе(З з);
    ХэшМультинабор удалиВсе(З з, ref бцел члоУдалённых);
    ХэшМультинабор dup();
    З дай();
    З изыми();
}

+/

/**
 * Реализация мультинабора, использующая Хэш для ближней вставки,
 * время поиска и удаления составляет O(1).
 *
 * Добавка элемента может делать курсоры недействительными, в зависимости от реализации.
 *
 * Удаление элемента приводит лишь к недействительности курсоров, которые на него
 * указывали.
 *
 * (члены-нефункции могут быть свойствами, если не указано иного):
 *
 *
 * Эту реализацию Хэш можно заменить адаптированной своей, этот
 * Хэш должен быть шаблоном структуры, который может создавать экземпляр по единичному
 * шаблонному аргументу З, и должен реализовывать следующие члены (члены-нефункции
 * могут быть свойствами дай/установи, если не указано иного):
 *
 *
 * параметры -> должны быть структурой, как минимум, со следующими членами:
 *   хэшФункц -> используемая хэш-функция (должна быть ХэшФунк!(З))
 * 
 * проц установка(параметры p) -> инициализует хэш с указанными параметрами.
 *
 * бцел счёт -> счёт элементов в этом хэше
 *
 * позиция -> должно быть struct/class со следующими членами:
 *   укз -> должно определять следующий член:
 *     значение -> значение, на которое указывает позиция (не может быть
 *                свойством)
 *   позиция следщ -> следующая позиция в этой хэш-карте
 *   позиция предш -> предыдущая позиция в этой хэш-карте
 *
 * бул добавь(З з) -> добавить указанное значение в хэш. Хэш значения
 * будет задан функцией хэшФункц(з). Если значение уже имеется в хэше,
 * следует вызывать обновлФункц(з) и не увеличивать на единицу счёт.
 *
 * позиция начало -> должно быть позицией, указывающей на самый первый действительный
 * элемент в хэше, или конец, если элементов нет.
 *
 * позиция конец -> должно быть позицией, указывающей сразу после самого крайнего
 * действительного элемента.
 *
 * позиция найди(З з) -> возвращает позицию, указывающую на элемент, который
 * содержит з, или конец, если этого элемента не существует.
 *
 * позиция удали(позиция p) -> удаляет заданный элемент из хэша,
 * возвращает следщ действительный элемент или конец, если p был последним в хэше.
 *
 * проц зачисть() -> удаляет все элементы из хэша, устанавливает счёт в 0.
 *
 * бцел удалиВсе(З з) -> удаляет все экземпляры указанного значения, возвращает
 * число удалённых.
 *
 * бцел считайВсе(З з) -> возвращает число экземпляров указанного значения в
 * хэше.
 *
 * проц копируйВ(ref Хэш h) -> делает копию-дубликат этого хэша в
 * целевой h.
 */
class ХэшМультинабор(З, alias ШаблРеализац=ХэшДуб, alias хэшФункц=ДефХэш) : Мультинабор!(З)
{
    /**
     * Псевдоним экземпляра шаблонной реализации.
     */
    alias ШаблРеализац!(З, хэшФункц) Реализ;

    private Реализ _хэш;

    /**
     * Курсор для хэш-мультинабора.
     */
    struct курсор
    {
        private Реализ.Позиция позиция;

        /**
         * Даёт значение по текущей позиции.
         */
        З значение()
        {
            return позиция.ptr.значение;
        }

        /**
         * Наращивает этот курсор, возвращает курсор перед
         * инкрементированием.
         */
        курсор opPostInc()
        {
            курсор врм = *this;
            позиция = позиция.следщ;
            return врм;
        }

        /**
         * Уменьшает этот курсор, возвращает курсор перед
         * декрементированием.
         */
        курсор opPostDec()
        {
            курсор врм = *this;
            позиция = позиция.предш;
            return врм;
        }

        /**
         * Наращивает этот курсор на заданное количество.
         *
         * Это операция  O(прир)! Следует использовать
         * этот оператор только в форме:
		 *
         * ++i;
         */
        курсор opAddAssign(цел прир)
        {
            if(прир < 0)
                return opSubAssign(-прир);
            while(прир--)
                позиция = позиция.следщ;
            return *this;
        }

        /**
         * Уменьшает этот курсор на заданное количество.
         *
         * Это операция  O(прир)! Следует использовать
         * этот оператор только в форме:
         *
         * --i;
         */
        курсор opSubAssign(цел прир)
        {
            if(прир < 0)
                return opAddAssign(-прир);
            while(прир--)
                позиция = позиция.предш;
            return *this;
        }

        /**
         * Сравнивает два курсора на равенство.
         */
        бул opEquals(курсор обх)
        {
            return обх.позиция == позиция;
        }
    }

    /**
     * Итерирует через все элементы в мультинаборе, указывает,
     * какие элементы следует удалить.
     *
     *
     * Используйте так:
     * ----------
     * // удалить все нечётные элементы
     * foreach(ref чистить_ли, з; &hashMultiset.очистить)
     * {
     *   чистить_ли = ((з & 1) == 1);
     * }
     */
    цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг)
    {
        return _примени(дг);
    }

    private цел _примени(цел delegate(ref бул чистить_ли, ref З з) дг)
    {
        курсор обх = начало;
        бул чистить_ли;
        цел возврдг = 0;
        курсор _конец = конец; // кэшируем конец, чтобы обходчик не всегда генерировался.
        while(!возврдг && обх != _конец)
        {
            //
            // не позволяем пользователю менять значение.
            //
            З врмзначение = обх.значение;
            чистить_ли = нет;
            if((возврдг = дг(чистить_ли, врмзначение)) != 0)
                break;
            if(чистить_ли)
                удали(обх++);
            else
                обх++;
        }
        return возврдг;
    }

    /**
     * Итерирует по значениям коллекции.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел _дг(ref бул чистить_ли, ref З з)
        {
            return дг(з);
        }
        return _примени(&_дг);
    }

    /**
     * Создаёт экземпляр, используя дефолтные параметры.
     */
    this()
    {
        _хэш.установка();
    }

    private this(ref Реализ дубИз)
    {
        дубИз.копируйВ(_хэш);
    }

    /**
     * Очищает эту коллекцию от всех элементов.
     */
    ХэшМультинабор зачисть()
    {
        _хэш.зачисть();
        return this;
    }

    /**
     * Возвращает число элементов в этой коллекции.
     */
    бцел длина()
    {
        return _хэш.счёт;
    }
	alias длина length;
    /**
     * Возвращает курсор на первый элемент в этой коллекции.
     */
    курсор начало()
    {
        курсор обх;
        обх.позиция = _хэш.начало();
        return обх;
    }

    /**
     * Возвращает курсор, указывающий сразу за последним элементом в
     * этой коллекции.
     */
    курсор конец()
    {
        курсор обх;
        обх.позиция = _хэш.конец();
        return обх;
    }

    /**
     * Удаляет элемент, перед которым показывает данный курсор, возвращая
     * курсор, указывающий на следующий элемент в этой коллекции.
     *
     * В среднем выполняется за время O(1).
     */
    курсор удали(курсор обх)
    {
        обх.позиция = _хэш.удали(обх.позиция);
        return обх;
    }

    /**
     * Находит первый экземпляр значения в этой коллекции.  Возвращает конец,
     * если значение отсутствует.
     *
     * В среднем выполняется за время O(1).
     */
    курсор найди(З з)
    {
        курсор обх;
        обх.позиция = _хэш.найди(з);
        return обх;
    }

    /**
     * Находит следующий курсор, указывающий на значение З.
     *
     * Возвращает конец, если в коллекции больше не существует экземпляров з.
     */
    курсор найди(курсор обх, З з)
    {
        обх.позиция = _хэш.найди(з, обх.позиция);
        return обх;
    }

    /**
     * Возвращает да, если данное значение существует в этой коллекции.
     *
     * В среднем выполняется за время O(1).
     */
    бул содержит(З з)
    {
        return найди(з) != конец;
    }

    /**
     * Удаляет первый элемент со значением з. Возвращает да, если
     * значение имелось и было удалено.
     *
     * Выполняется за время O(n).
     */
    ХэшМультинабор удали(З з)
    {
        бул пропущен;
        return удали(з, пропущен);
    }

    /**
     * Удаляет первый элемент со значением з. Возвращает да, если
     * значение имелось и было удалено.
     *
     * Выполняется за время O(n).
     */
    ХэшМультинабор удали(З з, ref бул былУдалён)
    {
        курсор обх = найди(з);
        if(обх == конец)
        {
            былУдалён = нет;
        }
        else
        {
            былУдалён = да;
            удали(обх);
        }
        return this;
    }

    /**
     * Добавляет элемент в набор. Возвращает да, если элемента
     * до этого не существовало.
     *
     * В среднем выполняется за время O(1).
     */
    ХэшМультинабор добавь(З з)
    {
        _хэш.добавь(з);
        return this;
    }

    /**
     * Добавляет элемент в набор. Возвращает да, если элемента
     * до этого не существовало.
     *
     * В среднем выполняется за время O(1).
     */
    ХэшМультинабор добавь(З з, ref бул былДобавлен)
    {
        былДобавлен = _хэш.добавь(з);
        return this;
    }

    /**
     * Добавляет все элементы из обходчика в набор. Возвращает число
     * добавленных элементов.
     *
     * Выполняется в среднем за время O(1) + O(m), где m - число элементов
     * в этом обходчике.
     */
    ХэшМультинабор добавь(Обходчик!(З) обх)
    {
        foreach(з; обх)
            _хэш.добавь(з);
        return this;
    }

    /**
     * Добавляет все элементы из обходчика в набор. Возвращает число
     * добавленных элементов.
     *
     * Выполняется в среднем за время O(1) + O(m), где m - число элементов
     * в этом обходчике.
     */
    ХэшМультинабор добавь(Обходчик!(З) обх, ref бцел члоДобавленных)
    {
        бцел исхдлина = длина;
        добавь(обх);
        члоДобавленных = длина - исхдлина;
        return this;
    }

    /**
     * Добавляет все элементы из массива в набор. Возвращает число
     * добавленных элементов.
     *
     * Выполняется в среднем за время O(1) * O(m), где m - длина массива.
     */
    ХэшМультинабор добавь(З[] массив)
    {
        бцел пропущен;
        return добавь(массив, пропущен);
    }

    /**
     * Добавляет все элементы из массива в набор. Возвращает число
     * добавленных элементов.
     *
     * Выполняется в среднем за время O(1) * O(m), где m - длина массива.
     */
    ХэшМультинабор добавь(З[] массив, ref бцел члоДобавленных)
    {
        бцел исхдлина = длина;
        foreach(з; массив)
            _хэш.добавь(з);
        члоДобавленных = длина - исхдлина;
        return this;
    }

    /**
     * Возвращает число элементов в коллекции, равных з.
     *
     * Выполняется в среднем за время O(m * 1), где m - число элементов,
     * которыя являются з.
     */
    бцел счёт(З з)
    {
        return _хэш.считайВсе(з);
    }

    /**
     * Удаляет все элементы, равные з.
     *
     * Выполняется в среднем за время O(m * 1), где m - число элементов,
     * которыя являются з.
     */
    ХэшМультинабор удалиВсе(З з)
    {
        _хэш.удалиВсе(з);
        return this;
    }

    /**
     * Удаляет все элементы, равные з.
     *
     * Выполняется в среднем за время O(m * 1), где m - число элементов,
     * которыя являются з.
     */
    ХэшМультинабор удалиВсе(З з, ref бцел члоУдалённых)
    {
        члоУдалённых = _хэш.удалиВсе(з);
        return this;
    }

    /**
     * Делает поверхностную копию этого хэш-мультинабора.
     */
    ХэшМультинабор dup()
    {
        return new ХэшМультинабор(_хэш);
    }

    /**
     * Выдаёт наиболее удобный элемент в набора. Это элемент, который
     * итерируется первым. Следовательно, вызов удали(дай()) гарантированно
     * длится менеее, чем операция O(n).
     */
    З дай()
    {
        return начало.значение;
    }

    /**
     * Удаляет наиболее удобный элемент в наборе, и возвращает его значение.
     * Это равнозначно удали(дай()), за исключением того, что выполняется лишь
     * один поиск элемента.
     */
    З изыми()
    {
        auto c = начало;
        auto возврзнач = c.значение;
        удали(c);
        return возврзнач;
    }
}

version(UnitTest)
{
    unittest
    {
        auto hms = new ХэшМультинабор!(бцел);
        Мультинабор!(бцел) ms = hms;
        hms.добавь([0U, 1, 2, 3, 4, 5, 5]);
        assert(hms.длина == 7);
        assert(ms.счёт(5U) == 2);
        foreach(ref чистить_ли, i; &ms.очистить)
        {
            чистить_ли = (i % 2 == 1);
        }
        assert(ms.счёт(5U) == 0);
        assert(ms.длина == 3);
    }
}
