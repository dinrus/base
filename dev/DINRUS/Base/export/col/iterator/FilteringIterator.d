module col.iterator.FilteringIterator;

private import exception;
private import col.model.IteratorX;

/**
 *
 * Фильтрующие итераторы позволяют отфильтровывать элементы из
 * другого перечисления перед их появлением в "поле зрения" их `потребителей'
 * (т.е., вызывающих `получи' функций).
 *
 * ФильтрОбходчики работают как обёртки вокруг других итераторов.
 * Чтобы построить его, нужен существующий Обходчик (это может быть один
 * из coll.элементы(), для вызова какой-либо Коллекции), и объект Предикат
 * (т.е., реализующий интерфейс Предикат). 
 * Например, если вы хотите экранировать (скрыть) всё, кроме объектов Panel,
 * из коллекции "колл", в которой могут быть иные вещи, не только Panels,
 * пишим что-то типа:
 * ---
 * Обходчик e = колл.элементы();
 * Обходчик панели = ФильтрОбходчик(e, IsPanel);
 * while (панели.ещё())
 *  делаю_ЧтоТо_с(cast(Panel)(панели.получи()));
 * ---
 * Чтобы использовать это, нужно также написать небольшой класс в форме:
 * ---
 * class IsPanel : Предикат {
 *  бул предикат(Объект знач) { return cast(Panel) знач !is пусто; }
 * }
 * ---
 * См_Также: col.Предикат.предикат
 * author: Doug Lea
 *
**/

public class ФильтрОбходчик(T) : Обходчик!(T)
{
        alias бул delegate(T) Предикат;
        
        // переменные экземпляра

        /**
         * Оборачиваемое нами перечисление.
        **/

        private Обходчик!(T) ист_;

        /**
         * Экранирующий предикат.
        **/

        private Предикат пред_;

        /**
         * Смысл предиката. Нет означает "инвертировать"
		 **/

        private бул знак_;

        /**
         * Следующий элемент.
        **/

        private T добыча_;

        /**
         * Да, если следующий элемент имеется. 
        **/

        private бул естьСледщ_;

        /**
         * Создаёт Фильтр, используя ист для элементов, и p как скринер,
         * выбирая только те элементы ист, для которых p is да.
        **/

        public this (Обходчик!(T) ист, Предикат p)
        {
                this(ист, p, да);
        }

        /**
         * Создаёт Фильтр, используя ист для элементов, и p как скринер,
         * выбирая только те элементы ист, для которых p.предикат(знач) == смысл.
         * Значение да для смысл выбирает только значения, для которых p.предикат
         * is да. Значение нет выбирает только те, для которых он is нет.
        **/
        public this (Обходчик!(T) ист, Предикат p, бул смысл)
        {
                ист_ = ист;
                пред_ = p;
                знак_ = смысл;
                найдиСледщ();
        }

        /**
         * Реализует col.model.IteratorX.ещё
        **/

        public final бул ещё()
        {
                return естьСледщ_;
        }

        /**
         * Реализует col.model.IteratorX.получи.
        **/
        public final T получи()
        {
                if (! естьСледщ_)
                      throw new НетЭлементаИскл("перечисление завершилось");
                else
                   {
                   auto результат = добыча_;
                   найдиСледщ();
                   return результат;
                   }
        }


        цел opApply (цел delegate (inout T значение) дг)
        {
                цел результат;

                while (естьСледщ_)
                      {
                      auto значение = получи();
                      if ((результат = дг(значение)) != 0)
                           break;
                      }
                return результат;
        }


        /**
         * Траверсирует по элементам ист_ , находя то, которое передаёт предикат.
        **/
        private final проц найдиСледщ()
        {
                естьСледщ_ = нет;

                for (;;)
                    {
                    if (! ист_.ещё())
                          return ;
                    else
                       {
                       try {
                           auto знач = ист_.получи();
                           if (пред_(знач) is знак_)
                              {
                              естьСледщ_ = да;
                              добыча_ = знач;
                              return;
                              }
                           } catch (НетЭлементаИскл ex)
                                   {
                                   return;
                                   }
                       }
                    }
        }
}