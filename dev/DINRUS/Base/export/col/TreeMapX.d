module col.TreeMapX;

private import  exception;

private import  col.model.Comparator,
                col.model.SortedKeys,
                col.model.GuardIterator;

private import  col.impl.RBPair,
                col.impl.RBCell,
                col.impl.MapCollection,
                col.impl.AbstractIterator;


/**
 *
 *
 * КрасноЧёрные Деревья из пар (ключ, элемент).
 *
        author: Doug Lea
 * @version 0.93
**/


deprecated public class КартаДерево(К, T) : КоллекцияКарт!(К, T), СортированныеКлючи!(К, T)
{
        alias КЧЯчейка!(T)                КЧЯчейкаТ;
        alias КЧПара!(К, T)             RBPairT;
        alias Сравнитель!(К)            КомпараторТ;
        alias СтражОбходчик!(T)         GuardIteratorT;

        alias КоллекцияКарт!(К, T).удали     удали;
        alias КоллекцияКарт!(К, T).удалиВсе  удалиВсе;


        // переменные экземпляра

        /**
         * Корень этого дерева. Пусто, если он пустой.
        **/

        package RBPairT дерево;

        /**
         * Сравнитель, используемый для упорядочивания.
        **/

        protected КомпараторТ           cmp;
        protected Сравнитель!(T)        cmpElem;

        /**
         * Создаёт пустое дерево, используя DefaultComparator для упорядочивания.
        **/

        public this ()
        {
                this (пусто, пусто, пусто, 0);
        }


        /**
         * Создаёт пустое дерево, используя заданный скринер для скрининга элементов (не ключи).
        **/
        public this (Предикат скринер)
        {
                this(скринер, пусто, пусто, 0);
        }

        /**
         * Создаёт пустое дерево, используя заданный Сравнитель для упорядочивания.
        **/
        public this (КомпараторТ c)
        {
                this(пусто, c, пусто, 0);
        }

        /**
         * Создаёт пустое дерево, используя заданный скринер и Сравнитель.
        **/
        public this (Предикат s, КомпараторТ c)
        {
                this(s, c, пусто, 0);
        }

        /**
         * Особая версия конструктора, необходимая для клонируй().
        **/

        protected this (Предикат s, КомпараторТ c, RBPairT t, цел n)
        {
                super(s);
                счёт = n;
                дерево = t;
                cmp = (c is пусто) ? &сравниКлюч : c;
                cmpElem = &сравниЭлем;
        }

        /**
         * Дефолтный сравнитель ключа.
         *
         * @param перв первый аргумент
         * @param втор второй аргумент
         * Возвращает: отрицательное число, если перв меньше чем втор;
         * положительное число, если перв больше чем втор; иначе 0.
        **/

        private final цел сравниКлюч(К перв, К втор)
        {
                if (перв is втор)
                    return 0;

                return typeid(К).сравни (&перв, &втор);
        }


        /**
         * Дефолтный сравнитель элемента.
         *
         * @param перв первый аргумент
         * @param втор второй аргумент
         * Возвращает: отрицательное число, если перв меньше чем втор;
         * положительное число, если перв больше чем втор; иначе 0.
        **/

        private final цел сравниЭлем(T перв, T втор)
        {
                if (перв is втор)
                    return 0;

                return typeid(T).сравни (&перв, &втор);
        }


        /**
         * Создаёт независимую копию. Не клонирует элементы.
        **/

        public КартаДерево!(К, T) дубликат()
        {
                if (счёт is 0)
                    return new КартаДерево!(К, T)(скринер, cmp);
                else
                   return new КартаДерево!(К, T)(скринер, cmp, cast(RBPairT)(дерево.копируйДерево()), счёт);
        }


        // Методы коллекции

        /**
         * Реализует col.impl.Collection.Коллекция.содержит
         * Временная ёмкость: O(лог n).
         * См_Также: col.impl.Collection.Коллекция.содержит
        **/
        public final бул содержит(T элемент)
        {
                if (!действительныйАргумент(элемент) || счёт is 0)
                     return нет;
                return дерево.найди(элемент, cmpElem) !is пусто;
        }

        /**
         * Реализует col.impl.Collection.Коллекция.экземпляры
         * Временная ёмкость: O(лог n).
         * См_Также: col.impl.Collection.Коллекция.экземпляры
        **/
        public final бцел экземпляры(T элемент)
        {
                if (!действительныйАргумент(элемент) || счёт is 0)
                     return 0;
                return дерево.счёт(элемент, cmpElem);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.элементы
         * Временная ёмкость: O(1).
         * См_Также: col.impl.Collection.Коллекция.элементы
        **/
        public final СтражОбходчик!(T) элементы()
        {
                return ключи();
        }

        /***********************************************************************

                Реализует col.model.View.Обзор.opApply
                Временная ёмкость: O(n)

                См_Также: col.model.View.Обзор.opApply

        ************************************************************************/

        цел opApply (цел delegate (inout T значение) дг)
        {
                auto scope обходчик = new ОбходчикКарты!(К, T)(this);
                return обходчик.opApply (дг);
        }


        /***********************************************************************

                Реализует col.ОбзорКарты.opApply
                Временная ёмкость: O(n)

                См_Также: col.ОбзорКарты.opApply

        ************************************************************************/

        цел opApply (цел delegate (inout К ключ, inout T значение) дг)
        {
                auto scope обходчик = new ОбходчикКарты!(К, T)(this);
                return обходчик.opApply (дг);
        }

        // KeySortedCollection methods

        /**
         * Реализует col.KeySortedCollection.сравнитель
         * Временная ёмкость: O(1).
         * См_Также: col.KeySortedCollection.сравнитель
        **/
        public final КомпараторТ сравнитель()
        {
                return cmp;
        }

        /**
         * Использует новый Сравнитель. Вызывает реорганизацию.
        **/

        public final проц сравнитель (КомпараторТ c)
        {
                if (cmp !is c)
                   {
                   cmp = (c is пусто) ? &сравниКлюч : c;

                   if (счёт !is 0)
                      {
                      // must rebuild дерево!
                      инкрВерсию();
                      auto t = cast(RBPairT) (дерево.левейший());
                      дерево = пусто;
                      счёт = 0;

                      while (t !is пусто)
                            {
                            добавь_(t.ключ(), t.элемент(), нет);
                            t = cast(RBPairT)(t.потомок());
                            }
                      }
                   }
        }

        // Карта methods

        /**
         * Реализует col.Map.содержитКлюч.
         * Временная ёмкость: O(лог n).
         * См_Также: col.Map.содержитКлюч
        **/
        public final бул содержитКлюч(К ключ)
        {
                if (!действительныйКлюч(ключ) || счёт is 0)
                    return нет;
                return дерево.найдиКлюч(ключ, cmp) !is пусто;
        }

        /**
         * Реализует col.Map.содержитПару.
         * Временная ёмкость: O(n).
         * См_Также: col.Map.содержитПару
        **/
        public final бул содержитПару(К ключ, T элемент)
        {
                if (счёт is 0 || !действительныйКлюч(ключ) || !действительныйАргумент(элемент))
                    return нет;
                return дерево.найди(ключ, элемент, cmp) !is пусто;
        }

        /**
         * Реализует col.Map.ключи.
         * Временная ёмкость: O(1).
         * См_Также: col.Map.ключи
        **/
        public final ОбходчикПар!(К, T) ключи()
        {
                return new ОбходчикКарты!(К, T)(this);
        }

        /**
         * Реализует col.Map.получи.
         * Временная ёмкость: O(лог n).
         * См_Также: col.Map.получи
        **/
        public final T получи(К ключ)
        {
                if (счёт !is 0)
                   {
                   RBPairT p = дерево.найдиКлюч(ключ, cmp);
                   if (p !is пусто)
                       return p.элемент();
                   }
                throw new НетЭлементаИскл("no совпадают Key ");
        }

        /**
         * Возвращает the элемент associated with Key ключ.
         * @param ключ a ключ
         * Возвращает: whether the ключ is contained or not
        **/

        public final бул получи(К ключ, inout T значение)
        {
                if (счёт !is 0)
                   {
                   RBPairT p = дерево.найдиКлюч(ключ, cmp);
                   if (p !is пусто)
                      {
                      значение = p.элемент();
                      return да;
                      }
                   }
                return нет;
        }



        /**
         * Реализует col.Map.ключК.
         * Временная ёмкость: O(n).
         * См_Также: col.Map.ключК
        **/
        public final бул ключК(inout К ключ, T значение)
        {
                if (!действительныйАргумент(значение) || счёт is 0)
                     return нет;

                auto p = (cast(RBPairT)( дерево.найди(значение, cmpElem)));
                if (p is пусто)
                    return нет;

                ключ = p.ключ();
                return да;
        }


        // MutableCollection methods

        /**
         * Реализует col.impl.Collection.Коллекция.очисть.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.Collection.Коллекция.очисть
        **/
        public final проц очисть()
        {
                устСчёт(0);
                дерево = пусто;
        }


        /**
         * Реализует col.impl.Collection.Коллекция.удалиВсе.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.удалиВсе
        **/
        public final проц удалиВсе(T элемент)
        {
                if (!действительныйАргумент(элемент) || счёт is 0)
                      return ;

                RBPairT p = cast(RBPairT)(дерево.найди(элемент, cmpElem));
                while (p !is пусто)
                      {
                      дерево = cast(RBPairT)(p.удали(дерево));
                      декрСчёт();
                      if (счёт is 0)
                          return ;
                      p = cast(RBPairT)(дерево.найди(элемент, cmpElem));
                      }
        }

        /**
         * Реализует col.impl.Collection.Коллекция.removeOneOf.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.removeOneOf
        **/
        public final проц удали (T элемент)
        {
                if (!действительныйАргумент(элемент) || счёт is 0)
                      return ;

                RBPairT p = cast(RBPairT)(дерево.найди(элемент, cmpElem));
                if (p !is пусто)
                   {
                   дерево = cast(RBPairT)(p.удали(дерево));
                   декрСчёт();
                   }
        }


        /**
         * Реализует col.impl.Collection.Коллекция.replaceOneOf.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.replaceOneOf
        **/
        public final проц замени(T старЭлемент, T новЭлемент)
        {
                if (счёт is 0 || !действительныйАргумент(старЭлемент) || !действительныйАргумент(старЭлемент))
                    return ;

                RBPairT p = cast(RBPairT)(дерево.найди(старЭлемент, cmpElem));
                if (p !is пусто)
                   {
                   проверьЭлемент(новЭлемент);
                   инкрВерсию();
                   p.элемент(новЭлемент);
                   }
        }

        /**
         * Реализует col.impl.Collection.Коллекция.replaceAllOf.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.replaceAllOf
        **/
        public final проц замениВсе(T старЭлемент, T новЭлемент)
        {
                RBPairT p = cast(RBPairT)(дерево.найди(старЭлемент, cmpElem));
                while (p !is пусто)
                      {
                      проверьЭлемент(новЭлемент);
                      инкрВерсию();
                      p.элемент(новЭлемент);
                      p = cast(RBPairT)(дерево.найди(старЭлемент, cmpElem));
                      }
        }

        /**
         * Реализует col.impl.Collection.Коллекция.возьми.
         * Временная ёмкость: O(лог n).
         * Takes the элемент associated with the least ключ.
         * См_Также: col.impl.Collection.Коллекция.возьми
        **/
        public final T возьми()
        {
                if (счёт !is 0)
                   {
                   RBPairT p = cast(RBPairT)(дерево.левейший());
                   T знач = p.элемент();
                   дерево = cast(RBPairT)(p.удали(дерево));
                   декрСчёт();
                   return знач;
                   }

                проверьИндекс(0);
                return T.init; // not reached
        }


        // MutableMap methods

        /**
         * Реализует col.impl.MapCollection.КоллекцияКарт.добавь.
         * Временная ёмкость: O(лог n).
         * См_Также: col.impl.MapCollection.КоллекцияКарт.добавь
        **/
        public final проц добавь(К ключ, T элемент)
        {
                добавь_(ключ, элемент, да);
        }


        /**
         * Реализует col.impl.MapCollection.КоллекцияКарт.удали.
         * Временная ёмкость: O(лог n).
         * См_Также: col.impl.MapCollection.КоллекцияКарт.удали
        **/
        public final проц удалиКлюч (К ключ)
        {
                if (!действительныйКлюч(ключ) || счёт is 0)
                      return ;

                КЧЯчейкаТ p = дерево.найдиКлюч(ключ, cmp);
                if (p !is пусто)
                   {
                   дерево = cast(RBPairT)(p.удали(дерево));
                   декрСчёт();
                   }
        }


        /**
         * Реализует col.impl.MapCollection.КоллекцияКарт.replaceElement.
         * Временная ёмкость: O(лог n).
         * См_Также: col.impl.MapCollection.КоллекцияКарт.replaceElement
        **/
        public final проц замениПару (К ключ, T старЭлемент,
                                              T новЭлемент)
        {
                if (!действительныйКлюч(ключ) || !действительныйАргумент(старЭлемент) || счёт is 0)
                    return ;

                RBPairT p = дерево.найди(ключ, старЭлемент, cmp);
                if (p !is пусто)
                   {
                   проверьЭлемент(новЭлемент);
                   p.элемент(новЭлемент);
                   инкрВерсию();
                   }
        }


        // Вспомогательные методы


        private final проц добавь_(К ключ, T элемент, бул проверьOccurrence)
        {
                проверьКлюч(ключ);
                проверьЭлемент(элемент);

                if (дерево is пусто)
                   {
                   дерево = new RBPairT(ключ, элемент);
                   инкрСчёт();
                   }
                else
                   {
                   RBPairT t = дерево;
                   for (;;)
                       {
                       цел рознь = cmp(ключ, t.ключ());
                       if (рознь is 0 && проверьOccurrence)
                          {
                          if (t.элемент() != элемент)
                             {
                             t.элемент(элемент);
                             инкрВерсию();
                             }
                          return ;
                          }
                       else
                          if (рознь <= 0)
                             {
                             if (t.лево() !is пусто)
                                 t = cast(RBPairT)(t.лево());
                             else
                                {
                                дерево = cast(RBPairT)(t.вставьЛевый(new RBPairT(ключ, элемент), дерево));
                                инкрСчёт();
                                return ;
                                }
                             }
                          else
                             {
                             if (t.право() !is пусто)
                                 t = cast(RBPairT)(t.право());
                             else
                                {
                                дерево = cast(RBPairT)(t.вставьПравый(new RBPairT(ключ, элемент), дерево));
                                инкрСчёт();
                                return ;
                                }
                             }
                       }
                   }
        }

        // ImplementationCheckable methods

        /**
         * Реализует col.model.View.Обзор.проверьРеализацию.
         * См_Также: col.model.View.Обзор.проверьРеализацию
        **/
        public override проц проверьРеализацию()
        {
                super.проверьРеализацию();
                assert(cmp !is пусто);
                assert(((счёт is 0) is (дерево is пусто)));
                assert((дерево is пусто || дерево.размер() is счёт));

                if (дерево !is пусто)
                   {
                   дерево.проверьРеализацию();
                   К последний = К.init;
                   RBPairT t = cast(RBPairT)(дерево.левейший());

                   while (t !is пусто)
                         {
                         К знач = t.ключ();
                         assert((последний is К.init || cmp(последний, знач) <= 0));
                         последний = знач;
                         t = cast(RBPairT)(t.потомок());
                         }
                   }
        }


        /***********************************************************************

                opApply() имеется migrated here в_ mitigate the virtual вызов
                on метод получи()

        ************************************************************************/

        private static class ОбходчикКарты(К, З) : АбстрактныйОбходчикКарты!(К, З)
        {
                private RBPairT пара;

                public this (КартаДерево карта)
                {
                        super (карта);

                        if (карта.дерево)
                            пара = cast(RBPairT) карта.дерево.левейший;
                }

                public final З получи(inout К ключ)
                {
                        if (пара)
                            ключ = пара.ключ;
                        return получи();
                }

                public final З получи()
                {
                        декрементируйОстаток();
                        auto знач = пара.элемент();
                        пара = cast(RBPairT) пара.потомок();
                        return знач;
                }

                цел opApply (цел delegate (inout З значение) дг)
                {
                        цел результат;

                        for (auto i=остаток(); i--;)
                            {
                            auto значение = получи();
                            if ((результат = дг(значение)) != 0)
                                 break;
                            }
                        return результат;
                }

                цел opApply (цел delegate (inout К ключ, inout З значение) дг)
                {
                        К   ключ;
                        цел результат;

                        for (auto i=остаток(); i--;)
                            {
                            auto значение = получи(ключ);
                            if ((результат = дг(ключ, значение)) != 0)
                                 break;
                            }
                        return результат;
                }
        }
}



debug (Test)
{
        import io.Console;

        проц main()
        {
                auto карта = new КартаДерево!(ткст, дво);
                карта.добавь ("foo", 1);
                карта.добавь ("baz", 1);
                карта.добавь ("bar", 2);
                карта.добавь ("wumpus", 3);

                foreach (ключ, значение; карта.ключи) {typeof(ключ) x; x = ключ;}

                foreach (значение; карта.ключи) {}

                foreach (значение; карта.элементы) {}

                auto ключи = карта.ключи();
                while (ключи.ещё)
                       auto знач = ключи.получи();

                foreach (значение; карта) {}

                foreach (ключ, значение; карта)
                         Квывод (ключ).нс;

                карта.проверьРеализацию();
        }
}
