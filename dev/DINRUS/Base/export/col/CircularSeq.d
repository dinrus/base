module col.CircularSeq;

private import  col.model.IteratorX,
                col.model.GuardIterator;

private import  col.impl.CLCell,
                col.impl.SeqCollection,
                col.impl.AbstractIterator;


/**
 * Циркулярно связанные списки (ЦСТ). Реализуют
 * методы, определённые в интерфейсах.
 * Автор: Doug Lea
**/
deprecated public class ЦиркулярСек(T) : КоллекцияСек!(T)
{
        alias ЯчейкаЦС!(T) ЯчейкаЦСТ;

        alias КоллекцияСек!(T).удали     удали;
        alias КоллекцияСек!(T).удалиВсе  удалиВсе;

        // Переменные экземпляра

        /**
         * Голова списка. Пусто, если он пустой.
        **/
        package ЯчейкаЦСТ список;

        // constructors

        /**
         * Создаёт пустой список без скринера элементов.
        **/
        public this ()
        {
                this(пусто, пусто, 0);
        }

        /**
         * Создаёт пустой список с поставляемым скринером элементов.
        **/
        public this (Предикат скринер)
        {
                this(скринер, пусто, 0);
        }

        /**
         * Особая версия конструктора, необходимая для метода клонируй().
        **/
        protected this (Предикат s, ЯчейкаЦСТ h, цел c)
        {
                super(s);
                список = h;
                счёт = c;
        }

        /**
         * Создаёт независимую копию этого списка. Сами элементы не клонируются.
        **/
        public final ЦиркулярСек!(T) дубликат()
        {
               if(список is пусто)
                    return new ЦиркулярСек!(T) (скринер, пусто, 0);
                else
                   return new ЦиркулярСек!(T) (скринер, список.копируйСписок(), счёт);
        }


        // Методы коллекции

        /**
         * Реализует col.impl.Collection.Коллекция.содержит
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.содержит
        **/
        public final бул содержит(T элемент)
        {
               if(!действительныйАргумент(элемент) || список is пусто)
                    return нет;
                return список.найди(элемент) !is пусто;
        }

        /**
         * Реализует col.impl.Collection.Коллекция.экземпляры
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.экземпляры
        **/
        public final бцел экземпляры(T элемент)
        {
               if(!действительныйАргумент(элемент) || список is пусто)
                    return 0;
                return список.счёт(элемент);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.элементы
         * Временная ёмкость: O(1).
         * См_Также: col.impl.Collection.Коллекция.элементы
        **/
        public final СтражОбходчик!(T) элементы()
        {
                return new ОбходчикЯчейки!(T)(this);
        }

        /**
         * Реализует col.model.View.Обзор.opApply
         * Временная ёмкость: O(n).
         * См_Также: col.model.View.Обзор.opApply
        **/
        цел opApply (цел delegate (inout T значение) дг)
        {
                auto scope обходчик = new ОбходчикЯчейки!(T)(this);
                return обходчик.opApply (дг);
        }


        // Методы Сека.

        /**
         * Реализует col.model.Seq.Сек.голова.
         * Временная ёмкость: O(1).
         * См_Также: col.model.Seq.Сек.голова
        **/
        public final T голова()
        {
                return перваяЯчейка().элемент();
        }

        /**
         * Реализует col.model.Seq.Сек.хвост.
         * Временная ёмкость: O(1).
         * См_Также: col.model.Seq.Сек.хвост
        **/
        public final T хвост()
        {
                return последняяЯчейка().элемент();
        }

        /**
         * Реализует col.model.Seq.Сек.получи.
         * Временная ёмкость: O(n).
         * См_Также: col.model.Seq.Сек.получи
        **/
        public final T получи(цел индекс)
        {
                return ячейкаПо(индекс).элемент();
        }

        /**
         * Реализует col.model.Seq.Сек.первый.
         * Временная ёмкость: O(n).
         * См_Также: col.model.Seq.Сек.первый
        **/
        public final цел первый(T элемент, цел стартовыйИндекс = 0)
        {
               if(стартовыйИндекс < 0)
                    стартовыйИндекс = 0;

                ЯчейкаЦСТ p = список;
               if(p is пусто || !действительныйАргумент(элемент))
                    return -1;

                for (цел i = 0; да; ++i)
                    {
                   if(i >= стартовыйИндекс && p.элемент() == (элемент))
                        return i;

                    p = p.следщ();
                   if(p is список)
                        break;
                    }
                return -1;
        }


        /**
         * Реализует col.model.Seq.Сек.последний.
         * Временная ёмкость: O(n).
         * См_Также: col.model.Seq.Сек.последний
        **/
        public final цел последний(T элемент, цел стартовыйИндекс = 0)
        {
               if(!действительныйАргумент(элемент) || счёт is 0)
                    return -1;

               if(стартовыйИндекс >= размер())
                    стартовыйИндекс = размер() - 1;

               if(стартовыйИндекс < 0)
                    стартовыйИндекс = 0;

                ЯчейкаЦСТ p = ячейкаПо(стартовыйИндекс);
                цел i = стартовыйИндекс;
                for (;;)
                    {
                   if(p.элемент() == (элемент))
                        return i;
                    else
                      if(p is список)
                           break;
                       else
                          {
                          p = p.предш();
                          --i;
                          }
                    }
                return -1;
        }

        /**
         * Реализует col.model.Seq.Сек.subseq.
         * Временная ёмкость: O(length).
         * См_Также: col.model.Seq.Сек.subseq
        **/
        public final ЦиркулярСек поднабор (цел из_, цел длина)
        {
               if(длина > 0)
                   {
                   проверьИндекс(из_);
                   ЯчейкаЦСТ p = ячейкаПо(из_);
                   ЯчейкаЦСТ новый_список = new ЯчейкаЦСТ(p.элемент());
                   ЯчейкаЦСТ текущ = новый_список;

                   for (цел i = 1; i < длина; ++i)
                       {
                       p = p.следщ();
                      if(p is пусто)
                           проверьИндекс(из_ + i); // force исключение

                       текущ.добавьСледщ(p.элемент());
                       текущ = текущ.следщ();
                       }
                   return new ЦиркулярСек (скринер, новый_список, длина);
                   }
                else
                   return new ЦиркулярСек ();
        }

        // Методы MutableCollection.

        /**
         * Реализует col.impl.Collection.Коллекция.очисть.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.Collection.Коллекция.очисть
        **/
        public final проц очисть()
        {
                список = пусто;
                устСчёт(0);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.exclude.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.exclude
        **/
        public final проц удалиВсе (T элемент)
        {
                удали_(элемент, да);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.removeOneOf.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.removeOneOf
        **/
        public final проц удали (T элемент)
        {
                удали_(элемент, нет);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.replaceOneOf
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.replaceOneOf
        **/
        public final проц замени (T старЭлемент, T новЭлемент)
        {
                замени_(старЭлемент, новЭлемент, нет);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.replaceAllOf.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.replaceAllOf
        **/
        public final проц замениВсе (T старЭлемент, T новЭлемент)
        {
                замени_(старЭлемент, новЭлемент, да);
        }


        /**
         * Реализует col.impl.Collection.Коллекция.возьми.
         * Временная ёмкость: O(1).
         * takes the последний элемент on the список.
         * См_Также: col.impl.Collection.Коллекция.возьми
        **/
        public final T возьми()
        {
                auto знач = хвост();
                удалиХвост();
                return знач;
        }



        // Методы MutableSeq.

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.приставь.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.приставь
        **/
        public final проц приставь(T элемент)
        {
                проверьЭлемент(элемент);
               if(список is пусто)
                    список = new ЯчейкаЦСТ(элемент);
                else
                   список = список.добавьПредш(элемент);
                инкрСчёт();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.замениГолову.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.замениГолову
        **/
        public final проц замениГолову(T элемент)
        {
                проверьЭлемент(элемент);
                перваяЯчейка().элемент(элемент);
                инкрВерсию();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.удалиГолову.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.удалиГолову
        **/
        public final проц удалиГолову()
        {
               if(перваяЯчейка().синглтон_ли())
                   список = пусто;
                else
                   {
                   auto n = список.следщ();
                   список.отвяжи();
                   список = n;
                   }
                декрСчёт();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавь.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавь
        **/
        public final проц добавь(T элемент)
        {
               if(список is пусто)
                    приставь(элемент);
                else
                   {
                   проверьЭлемент(элемент);
                   список.предш().добавьСледщ(элемент);
                   инкрСчёт();
                   }
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.замениХвост.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.замениХвост
        **/
        public final проц замениХвост(T элемент)
        {
                проверьЭлемент(элемент);
                последняяЯчейка().элемент(элемент);
                инкрВерсию();
        }


        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.удалиХвост.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.удалиХвост
        **/
        public final проц удалиХвост()
        {
                auto l = последняяЯчейка();
               if(l is список)
                    список = пусто;
                else
                   l.отвяжи();
                декрСчёт();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавьПо.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавьПо
        **/
        public final проц добавьПо(цел индекс, T элемент)
        {
               if(индекс is 0)
                    приставь(элемент);
                else
                   {
                   проверьЭлемент(элемент);
                   ячейкаПо(индекс - 1).добавьСледщ(элемент);
                   инкрСчёт();
                   }
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.замениПо.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.замениПо
        **/
        public final проц замениПо(цел индекс, T элемент)
        {
                проверьЭлемент(элемент);
                ячейкаПо(индекс).элемент(элемент);
                инкрВерсию();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.удалиПо.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.удалиПо
        **/
        public final проц удалиПо(цел индекс)
        {
               if(индекс is 0)
                    удалиГолову();
                else
                   {
                   ячейкаПо(индекс - 1).отвяжиСледщ();
                   декрСчёт();
                   }
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.приставь.
         * Временная ёмкость: O(число элементов в e).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.приставь
        **/
        public final проц приставь(Обходчик!(T) e)
        {
                ЯчейкаЦСТ hd = пусто;
                ЯчейкаЦСТ текущ = пусто;
      
                while (e.ещё())
                      {
                      auto элемент = e.получи();
                      проверьЭлемент(элемент);
                      инкрСчёт();

                     if(hd is пусто)
                         {
                         hd = new ЯчейкаЦСТ(элемент);
                         текущ = hd;
                         }
                      else
                         {
                         текущ.добавьСледщ(элемент);
                         текущ = текущ.следщ();
                         }
                      }

               if(список is пусто)
                    список = hd;
                else
                  if(hd !is пусто)
                      {
                      auto tl = список.предш();
                      текущ.следщ(список);
                      список.предш(текущ);
                      tl.следщ(hd);
                      hd.предш(tl);
                      список = hd;
                      }
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавь.
         * Временная ёмкость: O(число элементов в e).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавь
        **/
        public final проц добавь(Обходчик!(T) e)
        {
               if(список is пусто)
                    приставь(e);
                else
                   {
                   ЯчейкаЦСТ текущ = список.предш();
                   while (e.ещё())
                         {
                         T элемент = e.получи();
                         проверьЭлемент(элемент);
                         инкрСчёт();
                         текущ.добавьСледщ(элемент);
                         текущ = текущ.следщ();
                         }
                   }
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавьПо.
         * Временная ёмкость: O(размер() + число элементов в e).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавьПо
        **/
        public final проц добавьПо(цел индекс, Обходчик!(T) e)
        {
               if(список is пусто || индекс is 0)
                    приставь(e);
                else
                   {
                   ЯчейкаЦСТ текущ = ячейкаПо(индекс - 1);
                   while (e.ещё())
                         {
                         T элемент = e.получи();
                         проверьЭлемент(элемент);
                         инкрСчёт();
                         текущ.добавьСледщ(элемент);
                         текущ = текущ.следщ();
                         }
                   }
        }


        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.removeFromTo.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.removeFromTo
        **/
        public final проц удалиДиапазон (цел отИндекса, цел доИндекса)
        {
                проверьИндекс(доИндекса);
                ЯчейкаЦСТ p = ячейкаПо(отИндекса);
                ЯчейкаЦСТ последний = список.предш();
                for (цел i = отИндекса; i <= доИндекса; ++i)
                    {
                    декрСчёт();
                    ЯчейкаЦСТ n = p.следщ();
                    p.отвяжи();
                   if(p is список)
                       {
                      if(p is последний)
                          {
                          список = пусто;
                          return ;
                          }
                       else
                          список = n;
                       }
                    p = n;
                    }
        }


        // Вспомогательные методы.

        /**
         * Возвращает первую ячейку, или выводит исключение, если пустой.
        **/
        private final ЯчейкаЦСТ перваяЯчейка()
        {
               if(список !is пусто)
                    return список;

                проверьИндекс(0);
                return пусто; // not reached!
        }

        /**
         * Возвращает последнюю ячейку, или выводит исключение, если пустой.
        **/
        private final ЯчейкаЦСТ последняяЯчейка()
        {
               if(список !is пусто)
                    return список.предш();

                проверьИндекс(0);
                return пусто; // not reached!
        }

        /**
         * Возвращает ячейку индекса, или выводит исключение, если плохой индекс.
        **/
        private final ЯчейкаЦСТ ячейкаПо(цел индекс)
        {
                проверьИндекс(индекс);
                return список.н_ый(индекс);
        }

        /**
         * Ассистент-метод для удали/исключи.
        **/
        private final проц удали_(T элемент, бул всеСлучаи)
        {
               if(!действительныйАргумент(элемент) || список is пусто)
                    return;

                ЯчейкаЦСТ p = список;
                for (;;)
                    {
                    ЯчейкаЦСТ n = p.следщ();
                   if(p.элемент() == (элемент))
                       {
                       декрСчёт();
                       p.отвяжи();
                      if(p is список)
                          {
                         if(p is n)
                             {
                             список = пусто;
                             break;
                             }
                          else
                             список = n;
                          }

                      if(! всеСлучаи)
                             break;
                       else
                          p = n;
                       }
                    else
                      if(n is список)
                           break;
                       else
                          p = n;
                    }
        }


        /**
         * Ассистент-метод для замени *
        **/
        private final проц замени_(T старЭлемент, T новЭлемент, бул всеСлучаи)
        {
               if(!действительныйАргумент(старЭлемент) || список is пусто)
                    return;

                ЯчейкаЦСТ p = список;
                do {
                  if(p.элемент() == (старЭлемент))
                      {
                      проверьЭлемент(новЭлемент);
                      инкрВерсию();
                      p.элемент(новЭлемент);
                     if(! всеСлучаи)
                            return;
                      }
                   p = p.следщ();
                } while (p !is список);
        }

        // Методы ImplementationCheckable.

        /**
         * Реализует col.model.View.Обзор.проверьРеализацию.
         * См_Также: col.model.View.Обзор.проверьРеализацию
        **/

        public override проц проверьРеализацию()
        {
                super.проверьРеализацию();

                assert(((счёт is 0) is (список is пусто)));
                assert((список is пусто || список.длина() is счёт));

               if(список is пусто)
                    return;

                цел c = 0;
                ЯчейкаЦСТ p = список;
                do {
                   assert(p.предш().следщ() is p);
                   assert(p.следщ().предш() is p);
                   assert(допускается(p.элемент()));
                   assert(экземпляры(p.элемент()) > 0);
                   assert(содержит(p.элемент()));
                   p = p.следщ();
                   ++c;
                   } while (p !is список);

                assert(c is счёт);
        }


        /***********************************************************************

                opApply() мигрировал сюда, чтобы выполнять виртуальный вызов
                метода получи().
                
        ************************************************************************/

        static class ОбходчикЯчейки(T) : АбстрактныйОбходчик!(T)
        {
                private ЯчейкаЦСТ ячейка;

                public this (ЦиркулярСек пследвтн)
                {
                        super (пследвтн);
                        ячейка = пследвтн.список;
                }

                public final T получи()
                {
                        декрементируйОстаток();
                        auto знач = ячейка.элемент();
                        ячейка = ячейка.следщ();
                        return знач;
                }

                цел opApply (цел delegate (inout T значение) дг)
                {
                        цел результат;

                        for (auto i=остаток(); i--;)
                            {
                            auto значение = получи();
                           if((результат = дг(значение)) != 0)
                                 break;
                            }
                        return результат;
                }
        }
}



debug (Test)
{
        import io.Console;
        
        проц main()
        {
                auto Массив = new ЦиркулярСек!(ткст);
                Массив.добавь ("foo");
                Массив.добавь ("bar");
                Массив.добавь ("wumpus");

                foreach (значение; Массив.элементы) {}

                auto элементы = Массив.элементы();
                while (элементы.ещё)
                       auto знач = элементы.получи();

                foreach (значение; Массив)
                         Квывод (значение).нс;

                Массив.проверьРеализацию();
        }
}
