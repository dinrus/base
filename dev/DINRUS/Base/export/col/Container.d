module col.Container;

private import cidrus;


/*******************************************************************************

        Вспомогательные функции и константы

*******************************************************************************/

struct Контейнер
{
    /***********************************************************************

           Дефолтное начальное число корзин непустой хэш-карты.

    ***********************************************************************/

    static т_мера дефНачКорзины = 31;

    /***********************************************************************

            Дефолтный фактор загрузки для непустой хэш-карты. Эта хэш-
            таблица изменяется в размере, когда соотношение элементов на
            корзины превысит данный предел.

    ***********************************************************************/

    static плав дефФакторЗагрузки = 0.75f;

    /***********************************************************************

            Генерный рипер значения, который ничего не делает.

    ***********************************************************************/

    static проц извлеки(З) (З знач) {}

    /***********************************************************************

            Генерный рипер ключ/значение, который ничего не делает.

    ***********************************************************************/

    static проц извлеки(К, З) (К ключ, З знач) {}

    /***********************************************************************

            Генерная хэш-функция, использующая дефолтное хэширование.

    ***********************************************************************/

    static т_мера хэш(К) (К ключ, т_мера длина)
    {
        static if (is(К : цел)   || is(К : бцел)   ||
                   is(К : дол)  || is(К : бдол)  ||
                   is(К : крат) || is(К : бкрат) ||
                   is(К : байт)  || is(К : ббайт)  ||
                   is(К : сим)  || is(К : шим)  || is (К : дим))
            return cast(т_мера) (ключ % длина);
        else
            return (typeid(К).дайХэш(&ключ) & 0x7FFFFFFF) % длина;
    }


    /***********************************************************************

            Разместитель чанков СМ

            Может сохранять около 30% памяти для мелких элементов (проверялось
    		с целочисленными элементами и чанком размером 1000), и как минимум
            дважды быстрее при добавке элементов в сравнении с генерным
            аллокатором (примерно в 50x быстрее со СвязныйСписок).

            Безопасно оперирует с управляемыми сущностями СМ.

    ***********************************************************************/

    struct ЧанкСМ(T)
    {
        static assert (T.sizeof >= (T*).sizeof, "ЧанкСМ аллокатор может использоваться только для данных размером не менее " ~ ((T*).sizeof).stringof[0..$-1] ~ " байт!");

        private struct Кэш
        {
            Кэш* следщ;
        }

        private Кэш*  кэш;
        private T[][]   списки;
        private т_мера  чанки = 256;

        /***************************************************************

                Размещает чанк памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            if (кэш is пусто)
                новый_список;
            auto p = кэш;
            кэш = p.следщ;
            return cast(T*) p;
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером Т*.

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            auto p = (cast(T**) кразмести(счёт, (T*).sizeof)) [0 .. счёт];
            смДобавьПространство (cast(ук) p, счёт * (T*).sizeof);
            return p;
        }

        /***************************************************************

                Вызывается, когда заданный T*[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t.ptr)
            {
                смУдалиПространство (t.ptr);
                освободи (t.ptr);
            }
        }

        /***************************************************************

                Вызывается, когда заданный T сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            assert (p);
            auto d = cast(Кэш*) p;
            //*p = T.init;
            d.следщ = кэш;
            кэш = d;
        }

        /***************************************************************

                Вызывается, когда вызван очисть/сбрось на этом хосте.
                Быстрая очистка всего размещённого в памяти.
				
                Должен вернуть да, если поддерживается, либо нет иначе.
                Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            if (все)
            {
                foreach (ref список; списки)
                {
                    смУдалиПространство (список.ptr);
                    освободи (список.ptr);
                    список = пусто;
                }
                кэш = пусто;
                списки = пусто;
                return да;
            }
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и предварительно заполняет узлами.

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
            this.чанки = чанки;
            if (размести)
                for (цел i=размести/чанки+1; i--;)
                    новый_список;
        }

        /***************************************************************

                Менеджер списка

        ***************************************************************/

        private проц новый_список ()
        {
            списки.length = списки.length + 1;
            auto p = (cast(T*) кразмести (чанки, T.sizeof)) [0 .. чанки];
            списки[$-1] = p;
            смДобавьПространство (p.ptr, T.sizeof * чанки);
            auto голова = кэш;
            foreach (ref узел; p)
            {
                auto d = cast(Кэш*) &узел;
                d.следщ = голова;
                голова = d;
            }
            кэш = голова;
        }
    }


    /***********************************************************************

            Разместитель чанков (не СМ)

            Can save approximately 30% память for small элементы (tested
            with целое элементы и a размер чанка of 1000), и is at
            least twice as быстро at добавим элементы when compared в_ the
            default разместитель (approximately 50x faster with СвязныйСписок)

            Note that, due в_ СМ behaviour, you should not конфигурируй
            a custom разместитель for containers holding anything managed
            by the СМ. Например, you cannot use a MallocAllocator
            в_ manage a container of classes or strings where those
            were allocated by the СМ. Once something is owned by a СМ
            then it's lifetime must be managed by СМ-managed entities
            (иначе the СМ may think there are no live references
            и prematurely собери container contents).

            You can explicity manage the collection of ключи и значения
            yourself by provопрing a рипер delegate. Например, if
            you use a MallocAllocator в_ manage ключ/значение pairs which
            are themselves allocated via malloc, then you should also
            предоставляет a рипер delegate в_ собери those as требуется.

            The primary benefit of this разместитель is в_ avoопр the СМ
            scanning the дата-structures involved. Use ЧанкСМ where
            that опция is unwarranted, либо if you have СМ-managed данные
            instead

    ***********************************************************************/

    struct Чанк(T)
    {
        static assert (T.sizeof >= (T*).sizeof, "Чанк аллокатор может использоваться только для данных размером не менее " ~ ((T*).sizeof).stringof[0..$-1] ~ " байт!");

        private struct Кэш
        {
            Кэш* следщ;
        }

        private Кэш*  кэш;
        private T[][]   списки;
        private т_мера  чанки = 256;

        /***************************************************************

                Размещает чанк памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            if (кэш is пусто)
                новый_список;
            auto p = кэш;
            кэш = p.следщ;
            return cast(T*) p;
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером T* .				

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            return (cast(T**) кразмести(счёт, (T*).sizeof)) [0 .. счёт];
        }

        /***************************************************************

                Вызывается, когда заданный T*[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t.ptr)
                освободи (t.ptr);
        }

        /***************************************************************

                Вызывается, когда заданный T сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            assert (p);
            auto d = cast(Кэш*) p;
            d.следщ = кэш;
            кэш = d;
        }

        /***************************************************************

                Вызывается, когда очисть/сбрось вызван на этом хосте.
                Быстрая очистка всего размещённого в памяти.

                Должен вернуть да, если это поддерживается, либо нет иначе.
				Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            if (все)
            {
                foreach (ref список; списки)
                {
                    освободи (список.ptr);
                    список = пусто;
                }
                кэш = пусто;
                списки = пусто;
                return да;
            }
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и prepopulate with узелs

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
            this.чанки = чанки;
            if (размести)
                for (цел i=размести/чанки+1; i--;)
                    новый_список;
        }

        /***************************************************************

                Менеджер списка

        ***************************************************************/

        private проц новый_список ()
        {
            списки.length = списки.length + 1;
            auto p = (cast(T*) кразмести (чанки, T.sizeof)) [0 .. чанки];
            списки[$-1] = p;
            auto голова = кэш;
            foreach (ref узел; p)
            {
                auto d = cast(Кэш*) &узел;
                d.следщ = голова;
                голова = d;
            }
            кэш = голова;
        }
    }


    /***********************************************************************

            Генерный менеджер аллокации памяти СМ

            Slow и expensive in память costs

    ***********************************************************************/

    struct Сбор(T)
    {
        /***************************************************************

                Размещает чанк памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            return cast(T*) смКразмести (T.sizeof);
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером Т.

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            return new T*[счёт];
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            if (p)
                delete p;
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t)
                delete t;
        }

        /***************************************************************

                Вызывается, когда очисть/сбрось вызван на этом хосте.
                Быстрая очистка всего размещённого в памяти.

                Должен вернуть да, если это поддерживается, либо нет иначе.
                Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и prepopulate with узелs

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
        }
    }


    /***********************************************************************

            Празмест allocation manager.

            Note that, due в_ СМ behaviour, you should not конфигурируй
            a custom разместитель for containers holding anything managed
            by the СМ. Например, you cannot use a MallocAllocator
            в_ manage a container of classes or strings where those
            were allocated by the СМ. Once something is owned by a СМ
            then it's lifetime must be managed by СМ-managed entities
            (иначе the СМ may think there are no live references
            и prematurely собери container contents).

            You can explicity manage the collection of ключи и значения
            yourself by provопрing a рипер delegate. Например, if
            you use a MallocAllocator в_ manage ключ/значение pairs which
            are themselves allocated via malloc, then you should also
            предоставляет a рипер delegate в_ собери those as требуется.

    ***********************************************************************/

    struct Празмест(T)
    {
        /***************************************************************

                Размещает Массив из чанков памяти размером Т.

        ***************************************************************/

        T* размести ()
        {
            return cast(T*) кразмести (1, T.sizeof);
        }

        /***************************************************************

                Размещает Массив из чанков памяти размером Т.

        ***************************************************************/

        T*[] размести (т_мера счёт)
        {
            return (cast(T**) кразмести(счёт, (T*).sizeof)) [0 .. счёт];
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T*[] t)
        {
            if (t.length)
                освободи (t.ptr);
        }

        /***************************************************************

                Вызывается, когда заданный T[] сброшен.

        ***************************************************************/

        проц собери (T* p)
        {
            if (p)
                освободи (p);
        }

        /***************************************************************

                Вызывается, когда очисть/сбрось вызван на этом хосте.
                Быстрая очистка всего размещённого в памяти.

                Должен вернуть да, если это поддерживается, либо нет иначе.
                Возврат нет приводит к ряду дискретных вызовов метода собери.

        ***************************************************************/

        бул собери (бул все = да)
        {
            return нет;
        }

        /***************************************************************

                Устанавливает размер чанка и prepopulate with узелs

        ***************************************************************/

        проц конфиг (т_мера чанки, цел размести=0)
        {
        }
    }


    version (prior_allocator)
    {
        /***********************************************************************

                СМЧанк разместитель

                Like the Чанк разместитель, this allocates элементы in чанки,
                but допускается you в_ размести элементы that can have СМ pointers.

                Tests have shown about a 60% speedup when using the СМ чанк
                разместитель for a Хэшmap!(цел, цел).

        ***********************************************************************/

        struct СМЧанк(T, бцел размЧанка)
        {
            static if(T.sizeof < (ук).sizeof)
            {
                static assert(нет, "Ошибка, аллокатор для " ~ T.stringof ~ " не удалось инстанциировать");
            }

            /**
             * This is the form использован в_ link recyclable элементы together.
             */
            struct элемент
            {
                элемент *следщ;
            }

            /**
             * A чанк of элементы
             */
            struct чанк
            {
                /**
                 * The следщ чанк in the chain
                 */
                чанк *следщ;

                /**
                 * The previous чанк in the chain.  Требуется for O(1) removal
                 * из_ the chain.
                 */
                чанк *предш;

                /**
                 * The linked список of освободи элементы in the чанк.  This список is
                 * amended each время an элемент in this чанк is освободиd.
                 */
                элемент *списокОсвобождений;

                /**
                 * The число of освободи элементы in the списокОсвобождений.  Used в_ determine
                 * whether this чанк can be given задний в_ the СМ
                 */
                бцел члоОсвобождений;

                /**
                 * The элементы in the чанк.
                 */
                T[размЧанка] элемы;

                /**
                 * Размести a T* из_ the освободи список.
                 */
                T *разместиИзОсвобСписка()
                {
                    элемент *x = списокОсвобождений;
                    списокОсвобождений = x.следщ;
                    //
                    // очисть the pointer, this clears the элемент as if it was
                    // newly allocated
                    //
                    x.следщ = пусто;
                    члоОсвобождений--;
                    return cast(T*)x;
                }

                /**
                 * вымести a T*, шли it в_ the освободи список
                 *
                 * returns да, если this чанк no longer имеется any использован элементы.
                 */
                бул вымести(T *t)
                {
                    //
                    // очисть the элемент so the СМ does not interpret the элемент
                    // as pointing в_ anything else.
                    //
                    устбуф(t, 0, (T).sizeof);
                    элемент *x = cast(элемент *)t;
                    x.следщ = списокОсвобождений;
                    списокОсвобождений = x;
                    return (++члоОсвобождений == размЧанка);
                }
            }

            /**
             * The chain of использован чанки.  Used чанки have had все their элементы
             * allocated at least once.
             */
            чанк *использован;

            /**
             * The свежий чанк.  This is only использован if no элементы are available in
             * the использован chain.
             */
            чанк *свежий;

            /**
             * The следщ элемент in the свежий чанк.  Because we don't worry about
             * the освободи список in the свежий чанк, we need в_ keep track of the следщ
             * свежий элемент в_ use.
             */
            бцел свежийСледщ;

            /**
             * Размести a T*
             */
            T* размести()
            {
                if(использован !is пусто && использован.члоОсвобождений > 0)
                {
                    //
                    // размести one элемент of the использован список
                    //
                    T* результат = использован.разместиИзОсвобСписка();
                    if(использован.члоОсвобождений == 0)
                        //
                        // перемести использован в_ the конец этого списка
                        //
                        использован = использован.следщ;
                    return результат;
                }

                //
                // no использован элементы are available, размести out of the свежий
                // элементы
                //
                if(свежий is пусто)
                {
                    свежий = new чанк;
                    свежийСледщ = 0;
                }

                T* результат = &свежий.элемы[свежийСледщ];
                if(++свежийСледщ == размЧанка)
                {
                    if(использован is пусто)
                    {
                        использован = свежий;
                        свежий.следщ = свежий;
                        свежий.предш = свежий;
                    }
                    else
                    {
                        //
                        // вставь свежий преобр_в the использован chain
                        //
                        свежий.предш = использован.предш;
                        свежий.следщ = использован;
                        свежий.предш.следщ = свежий;
                        свежий.следщ.предш = свежий;
                        if(свежий.члоОсвобождений != 0)
                        {
                            //
                            // can recycle элементы из_ свежий
                            //
                            использован = свежий;
                        }
                    }
                    свежий = пусто;
                }
                return результат;
            }

            T*[] размести(бцел счёт)
            {
                return new T*[счёт];
            }


            /**
             * Освобождает из памяти T*
             */
            проц собери(T* t)
            {
                //
                // need в_ figure out which чанк t is in
                //
                чанк *тек = cast(чанк *)смАдрес(t);

                if(тек !is свежий && тек.члоОсвобождений == 0)
                {
                    //
                    // перемести тек в_ the front of the использован список, it имеется освободи узелs
                    // в_ be использован.
                    //
                    if(тек !is использован)
                    {
                        if(использован.члоОсвобождений != 0)
                        {
                            //
                            // первый, отвяжи тек из_ its текущ location
                            //
                            тек.предш.следщ = тек.следщ;
                            тек.следщ.предш = тек.предш;

                            //
                            // сейчас, вставь тек перед использован.
                            //
                            тек.предш = использован.предш;
                            тек.следщ = использован;
                            использован.предш = тек;
                            тек.предш.следщ = тек;
                        }
                        использован = тек;
                    }
                }

                if(тек.вымести(t))
                {
                    //
                    // тек no longer имеется any элементы in use, it can be deleted.
                    //
                    if(тек.следщ is тек)
                    {
                        //
                        // only one элемент, don't освободи it.
                        //
                    }
                    else
                    {
                        //
                        // удали тек из_ список
                        //
                        if(использован is тек)
                        {
                            //
                            // обнови использован pointer
                            //
                            использован = использован.следщ;
                        }
                        тек.следщ.предш = тек.предш;
                        тек.предш.следщ = тек.следщ;
                        delete тек;
                    }
                }
            }

            проц собери(T*[] t)
            {
                if(t)
                    delete t;
            }

            /**
             * Освобождает из памяти все чанки использован by this разместитель.  Depends on the СМ в_ do
             * the actual collection
             */
            бул собери(бул все = да)
            {
                использован = пусто;

                //
                // keep свежий around
                //
                if(свежий !is пусто)
                {
                    свежийСледщ = 0;
                    свежий.списокОсвобождений = пусто;
                }

                return да;
            }

            проц конфиг (т_мера чанки, цел размести=0)
            {
            }
        }

        /***********************************************************************

                алиасы в_ the correct Default разместитель depending on как big
                the тип is.  It makes less sense в_ use a СМЧанк разместитель
                if the тип is going в_ be larger than a страница (currently there
                is no way в_ получи the страница размер из_ the СМ, so we assume 4096
                байты).  If not ещё than one unit can fit преобр_в a страница, then
                we use the default СМ разместитель.

        ***********************************************************************/
        template ДефСбор(T)
        {
            static if((T).sizeof + ((ук).sizeof * 3) + бцел.sizeof >= 4095 / 2)
            {
                alias Сбор!(T) ДефСбор;
            }
            else
            {
                alias СМЧанк!(T, (4095 - ((проц *).sizeof * 3) - бцел.sizeof) / (T).sizeof) ДефСбор;
            }
            // TODO: see if we can automatically figure out whether a тип имеется
            // any pointers in it, this would allow automatic usage of the
            // Чанк разместитель for добавьed скорость.
        }
    }
    else
        template ДефСбор(T)
    {
        alias ЧанкСМ!(T) ДефСбор;
    }

}


