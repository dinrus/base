module col.ArraySeq;

private import  col.model.IteratorX,
                col.model.Sortable,
                col.model.Comparator,
                col.model.GuardIterator;
				
private import  col.impl.SeqCollection,
                col.impl.AbstractIterator;


/**
 *
 * Динамически размещаемые в памяти и изменяемые в размере Массивы.
 * 
 * За реализациями этих интерфейсов, добавляются методы
 * для исправления ёмкостей. Дефолтная эвристика изменения размера,
 * как правило, работает отлично, но при необходимости ёмкости можно
 * менять вручную.
 *
 * ArraySeqs в основном подобны java.util.Vectors. Но в отличие от них,
 * ArraySeqs при своём конструировании в действительности не размещают массивов.
 * Среди прочего, можно исправлять ёмкость `свободно'
 * после конструкции, но перед добавкой элементов. Можно исправить
 * это в другое время, но это может повлечь её более ресурсозатратную
 * операцию. Также, в отличие от Vectors, они освобождают свои внутренние массивы,
 * когда опустошаются.
 *
**/

deprecated public class СекМассив(T) : КоллекцияСек!(T), Сортируемый!(T)
{
        alias КоллекцияСек!(T).удали     удали;
        alias КоллекцияСек!(T).удалиВсе  удалиВсе;

        /**
         * Минимальная ёмкость любого непустого буфера.
        **/

        public static цел минЁмкость = 16;


        // переменные экземпляра

        /**
         * Элементы, либо пусто, если ещё не размещён буфер.
        **/

        package T Массив[];


        // конструкторы

        /**
         * Создаёт новый пустой СекМассив. 
        **/

        public this ()
        {
                this (пусто, пусто, 0);
        }

        /**
         * Создаёт пустой СекМассив с заданным скринером элементов.
        **/

        public this (Предикат скринер)
        {
                this (скринер, пусто, 0);
        }

        /**
         * Особая версия конструктора, необходимая для метода клонируй().
        **/
        package this (Предикат s, T[] b, цел c)
        {
                super(s);
                Массив = b;
                счёт = c;
        }

        /**
         * Создаёт независимую копию. Сами элементы не клонируются.
        **/

        public final СекМассив!(T) дубликат()
        {
                цел cap = счёт;
                if (cap is 0)
                    return new СекМассив!(T) (скринер, пусто, 0);
                else
                   {
                   if (cap < минЁмкость)
                       cap = минЁмкость;

                   T newArray[] = new T[cap];
                   //System.копируй (Массив[0].sizeof, Массив, 0, newArray, 0, счёт);

                   newArray[0..счёт] = Массив[0..счёт];
                   return new СекМассив!(T)(скринер, newArray, счёт);
                   }
        }

        // методы, введённые в СекМассив

        /**
         * Возвращает текущую ёмкость внутреннего буфера (ноль, если буферы не размещены).
         * Возвращает: ёмкость (всегда большую или равную размер())
        **/

        public final цел ёмкость()
        {
                return (Массив is пусто) ? 0 : Массив.length;
        }

        /**
         * Устанавливает ёмкость внутреннего буфера в макс(размер(), новЁмк).
         * То есть, если дан аргумент меньший текущего числа
         * элементов, то ёмкость просто установится в
         * текущее число элементов. Таким образом, при настройке ёмкости
         * элементы никогда не теряются. 
         * 
         * @param новЁмк требуемая ёмкость.
         * Возвращает: условие: 
         * <PRE>
         * ёмкость() >= размер() &&
         * версия() != ПРЕДШ(this).версия() == (ёмкость() != ПРЕДШ(this).ёмкость())
         * </PRE>
        **/

        public final проц ёмкость(цел новЁмк)
        {
                if (новЁмк < счёт)
                    новЁмк = счёт;

                if (новЁмк is 0)
                   {
                   очисть();
                   }
                else
                   if (Массив is пусто)
                      {
                      Массив = new T[новЁмк];
                      инкрВерсию();
                      }
                   else
                      if (новЁмк !is Массив.length)
                         {
                         //T newArray[] = new T[новЁмк];
                         //newArray[0..счёт] = Массив[0..счёт];
                         //Массив = newArray;
                         Массив ~= new T[новЁмк - Массив.length];
                         инкрВерсию();
                         }
        }


        // Методы коллекции

        /**
         * Реализует col.impl.Collection.Коллекция.содержит
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.содержит
        **/
        public final бул содержит(T элемент)
        {
                if (! действительныйАргумент (элемент))
                      return нет;

                for (цел i = 0; i < счёт; ++i)
                     if (Массив[i] == (элемент))
                         return да;
                return нет;
        }

        /**
         * Реализует col.impl.Collection.Коллекция.экземпляры
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.экземпляры
        **/
        public final бцел экземпляры(T элемент)
        {
                if (! действительныйАргумент(элемент))
                      return 0;

                бцел c = 0;
                for (бцел i = 0; i < счёт; ++i)
                     if (Массив[i] == (элемент))
                         ++c;
                return c;
        }

        /**
         * Реализует col.impl.Collection.Коллекция.элементы
         * Временная ёмкость: O(1).
         * См_Также: col.impl.Collection.Коллекция.элементы
        **/
        public final СтражОбходчик!(T) элементы()
        {
                return new ОбходчикМассива!(T)(this);
        }

        /**
         * Реализует col.model.View.Обзор.opApply
         * Временная ёмкость: O(n).
         * См_Также: col.model.View.Обзор.opApply
        **/
        цел opApply (цел delegate (inout T значение) дг)
        {
                auto scope обходчик = new ОбходчикМассива!(T)(this);
                return обходчик.opApply (дг);
        }


        // Методы Сека:

        /**
         * Реализует col.model.Seq.Сек.голова.
         * Временная ёмкость: O(1).
         * См_Также: col.model.Seq.Сек.голова
        **/
        public final T голова()
        {
                проверьИндекс(0);
                return Массив[0];
        }

        /**
         * Реализует col.model.Seq.Сек.хвост.
         * Временная ёмкость: O(1).
         * См_Также: col.model.Seq.Сек.хвост
        **/
        public final T хвост()
        {
                проверьИндекс(счёт -1);
                return Массив[счёт -1];
        }

        /**
         * Реализует col.model.Seq.Сек.получи.
         * Временная ёмкость: O(1).
         * См_Также: col.model.Seq.Сек.получи
        **/
        public final T получи(цел индекс)
        in {
           проверьИндекс(индекс);
           }
        body
        {
                return Массив[индекс];
        }

        /**
         * Реализует col.model.Seq.Сек.первый.
         * Временная ёмкость: O(n).
         * См_Также: col.model.Seq.Сек.первый
        **/
        public final цел первый(T элемент, цел стартовыйИндекс = 0)
        {
                if (стартовыйИндекс < 0)
                    стартовыйИндекс = 0;

                for (цел i = стартовыйИндекс; i < счёт; ++i)
                     if (Массив[i] == (элемент))
                         return i;
                return -1;
        }

        /**
         * Реализует col.model.Seq.Сек.последний.
         * Временная ёмкость: O(n).
         * См_Также: col.model.Seq.Сек.последний
        **/
        public final цел последний(T элемент, цел стартовыйИндекс = 0)
        {
                if (стартовыйИндекс >= счёт)
                    стартовыйИндекс = счёт -1;
 
                for (цел i = стартовыйИндекс; i >= 0; --i)
                     if (Массив[i] == (элемент))
                         return i;
                return -1;
        }


        /**
         * Реализует col.model.Seq.Сек.subseq.
         * Временная ёмкость: O(length).
         * См_Также: col.model.Seq.Сек.subseq
        **/
        public final СекМассив поднабор (цел из_, цел длина)
        {
                if (длина > 0)
                   {
                   проверьИндекс(из_);
                   проверьИндекс(из_ + длина - 1);

                   T newArray[] = new T[длина];
                   //System.копируй (Массив[0].sizeof, Массив, из_, newArray, 0, длина);

                   newArray[0..длина] = Массив[из_..из_+длина];
                   return new СекМассив!(T)(скринер, newArray, длина);
                   }
                else
                   return new СекМассив!(T)(скринер);
        }


        // Методы MutableCollection

        /**
         * Реализует col.impl.Collection.Коллекция.очисть.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.Collection.Коллекция.очисть
        **/
        public final проц очисть()
        {
                Массив = пусто;
                устСчёт(0);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.removeOneOf.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.removeOneOf
        **/
        public final проц удали(T элемент)
        {
                удали_(элемент, нет);
        }


        /**
         * Реализует col.impl.Collection.Коллекция.replaceOneOf
         * Временная ёмкость: O(n).
         * См_Также: col.impl.Collection.Коллекция.replaceOneOf
        **/
        public final проц замени(T старЭлемент, T новЭлемент)
        {
                замени_(старЭлемент, новЭлемент, нет);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.replaceAllOf.
         * Временная ёмкость: O(n * число of replacements).
         * См_Также: col.impl.Collection.Коллекция.replaceAllOf
        **/
        public final проц замениВсе(T старЭлемент, T новЭлемент)
        {
                замени_(старЭлемент, новЭлемент, да);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.exclude.
         * Временная ёмкость: O(n * экземпляры(элемент)).
         * См_Также: col.impl.Collection.Коллекция.exclude
        **/
        public final проц удалиВсе(T элемент)
        {
                удали_(элемент, да);
        }

        /**
         * Реализует col.impl.Collection.Коллекция.возьми.
         * Временная ёмкость: O(1).
         * Takes the правейший элемент of the Массив.
         * См_Также: col.impl.Collection.Коллекция.возьми
        **/
        public final T возьми()
        {
                T знач = хвост();
                удалиХвост();
                return знач;
        }


        // Методы SortableCollection:


        /**
         * Реализует col.SortableCollection.сортируй.
         * Временная ёмкость: O(n лог n).
         * Uses a быстросорт-based algorithm.
         * См_Также: col.SortableCollection.сортируй
        **/
        public проц сортируй(Сравнитель!(T) сравн)
        {
                if (счёт > 0)
                   {
                   быстрСорт(Массив, 0, счёт - 1, сравн);
                   инкрВерсию();
                   }
        }


        // Методы MutableSeq

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.приставь.
         * Временная ёмкость: O(n)
         * См_Также: col.impl.SeqCollection.КоллекцияСек.приставь
        **/
        public final проц приставь(T элемент)
        {
                проверьЭлемент(элемент);
                ростПо_(1);
                for (цел i = счёт -1; i > 0; --i)
                     Массив[i] = Массив[i - 1];
                Массив[0] = элемент;
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.замениГолову.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.замениГолову
        **/
        public final проц замениГолову(T элемент)
        {
                проверьЭлемент(элемент);
                Массив[0] = элемент;
                инкрВерсию();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.удалиГолову.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.удалиГолову
        **/
        public final проц удалиГолову()
        {
                удалиПо(0);
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавь.
         * Временная ёмкость: normally O(1), but O(n) if размер() == ёмкость().
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавь
        **/
        public final проц добавь(T элемент)
        in {
           проверьЭлемент (элемент);
           }
        body
        {
                цел последний = счёт;
                ростПо_(1);
                Массив[последний] = элемент;
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.замениХвост.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.замениХвост
        **/
        public final проц замениХвост(T элемент)
        {
                проверьЭлемент(элемент);
                Массив[счёт -1] = элемент;
                инкрВерсию();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.удалиХвост.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.удалиХвост
        **/
        public final проц удалиХвост()
        {
                проверьИндекс(0);
                Массив[счёт -1] = T.init;
                ростПо_( -1);
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавьПо.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавьПо
        **/
        public final проц добавьПо(цел индекс, T элемент)
        {
                if (индекс !is счёт)
                    проверьИндекс(индекс);

                проверьЭлемент(элемент);
                ростПо_(1);
                for (цел i = счёт -1; i > индекс; --i)
                     Массив[i] = Массив[i - 1];
                Массив[индекс] = элемент;
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.удали.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.удалиПо
        **/
        public final проц удалиПо(цел индекс)
        {
                проверьИндекс(индекс);
                for (цел i = индекс + 1; i < счёт; ++i)
                     Массив[i - 1] = Массив[i];
                Массив[счёт -1] = T.init;
                ростПо_( -1);
        }


        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.замениПо.
         * Временная ёмкость: O(1).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.замениПо
        **/
        public final проц замениПо(цел индекс, T элемент)
        {
                проверьИндекс(индекс);
                проверьЭлемент(элемент);
                Массив[индекс] = элемент;
                инкрВерсию();
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.приставь.
         * Временная ёмкость: O(n + число элементов в e) if (e 
         * instanceof CollectionIterator) else O(n * число элементов в e)
         * См_Также: col.impl.SeqCollection.КоллекцияСек.приставь
        **/
        public final проц приставь(Обходчик!(T) e)
        {
                вставь_(0, e);
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавь.
         * Временная ёмкость: O(число элементов в e) 
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавь
        **/
        public final проц добавь(Обходчик!(T) e)
        {
                вставь_(счёт, e);
        }

        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.добавьПо.
         * Временная ёмкость: O(n + число элементов в e) if (e 
         * instanceof CollectionIterator) else O(n * число элементов в e)
         * См_Также: col.impl.SeqCollection.КоллекцияСек.добавьПо
        **/
        public final проц добавьПо(цел индекс, Обходчик!(T) e)
        {
                if (индекс !is счёт)
                    проверьИндекс(индекс);
                вставь_(индекс, e);
        }


        /**
         * Реализует col.impl.SeqCollection.КоллекцияСек.removeFromTo.
         * Временная ёмкость: O(n).
         * См_Также: col.impl.SeqCollection.КоллекцияСек.removeFromTo
        **/
        public final проц удалиДиапазон (цел отИндекса, цел доИндекса)
        {
                проверьИндекс(отИндекса);
                проверьИндекс(доИндекса);
                if (отИндекса <= доИндекса)
                   {
                   цел gap = доИндекса - отИндекса + 1;
                   цел j = отИндекса;
                   for (цел i = доИндекса + 1; i < счёт; ++i)
                        Массив[j++] = Массив[i];
 
                   for (цел i = 1; i <= gap; ++i)
                        Массив[счёт -i] = T.init;
                   добавьВСчёт( -gap);
                   }
        }

        /**
         * Реализация Quicksort с использованием медиан 3 для отделов.
         * Используется внутреннее методом сортируй.
         * Она публична и статична, и может быть использована для сортировки плоских
         * массивов.
         * @param s, сортируемый Массив
         * @param ми, наименьший индекс, от которого идёт сортировка
         * @param би, наибольший индекс
         * @param сравн, сравнитель, используемый при сравнении элементов
        **/

        public final static проц быстрСорт(T s[], цел ми, цел би, Сравнитель!(T) сравн)
        {
                if (ми >= би)
                    return;

                /*
                   Use median-of-three(ми, средн, би) в_ pick a partition. 
                   Also обменяй them преобр_в relative order while we are at it.
                */

                цел средн = (ми + би) / 2;

                if (сравн(s[ми], s[средн]) > 0)
                   {
                   T врем = s[ми];
                   s[ми] = s[средн];
                   s[средн] = врем; // обменяй
                   }

                if (сравн(s[средн], s[би]) > 0)
                   {
                   T врем = s[средн];
                   s[средн] = s[би];
                   s[би] = врем; // обменяй

                   if (сравн(s[ми], s[средн]) > 0)
                      {
                      T tmp2 = s[ми];
                      s[ми] = s[средн];
                      s[средн] = tmp2; // обменяй
                      }
                   }

                цел лево = ми + 1;           // старт one past ми since already handled ми
                цел право = би - 1;          // similarly
                if (лево >= право)
                    return;                  // if three or fewer we are готово

                T partition = s[средн];

                for (;;)
                    {
                    while (сравн(s[право], partition) > 0)
                           --право;

                    while (лево < право && сравн(s[лево], partition) <= 0)
                           ++лево;

                    if (лево < право)
                       {
                       T врем = s[лево];
                       s[лево] = s[право];
                       s[право] = врем; // обменяй
                       --право;
                       }
                    else
                       break;
                    }

                быстрСорт(s, ми, лево, сравн);
                быстрСорт(s, лево + 1, би, сравн);
        }

        /***********************************************************************

                Выставить контент коллекции как Массив.

        ************************************************************************/

        override public T[] вМассив ()
        {
                return Массив[0..счёт].dup;
        }
        
        // Вспомогательные методы

        /**
         * Главный метод для контроля размера буфера.
         * Используется следующая эвристика для роста:
         * <PRE>
         * если нехватка пространства:
         *   если нужно меньше, чем минЁмкость, наращивание до минЁмкость
         *   иначе нарост до среднего от требуемого размера и минЁмкости.
         * </PRE>
         * <P>
         * Для маленьких буферов, это вызывает у них наполнение на около 1/2.
         * В то время как для больших буферов,- на около 2/3.
         * <P>
         * Для эластичности, единственно, что выполняем,- отвязку буфера, если он пустой.
         * @param inc количество пространства для роста. Отрицательное значение означает сжатие.
         * Возвращает: условие: исправить запись счёта, и, если применимо любое
         * из вышеописанных условий, разместить и копировать в новый
         * буфер соответствующего размера.
        **/

        private final проц ростПо_(цел inc)
        {
                цел needed = счёт + inc;
                if (inc > 0)
                   {
                   /* heuristic: */
                   цел текущ = ёмкость();
                   if (needed > текущ)
                      {
                      инкрВерсию();
                      цел новЁмк = needed + (needed + минЁмкость) / 2;

                      if (новЁмк < минЁмкость)
                          новЁмк = минЁмкость;

                      if (Массив is пусто)
                         {
                         Массив = new T[новЁмк];
                         }
                      else
                         {
                         //T newArray[] = new T[новЁмк];
                         //newArray[0..счёт] = Массив[0..счёт];
                         //Массив = newArray;
                         Массив ~= new T[новЁмк - Массив.length];
                         }
                      }
                   }
                else
                   if (needed is 0)
                       Массив = пусто;

                устСчёт(needed);
        }


        /**
         * Utility в_ splice in enumerations
        **/

        private final проц вставь_(цел индекс, Обходчик!(T) e)
        {
                if (cast(СтражОбходчик!(T)) e)
                   { 
                   // we know размер!
                   цел inc = (cast(СтражОбходчик!(T)) (e)).остаток();
                   цел oldcount = счёт;
                   цел oldversion = vershion;
                   ростПо_(inc);

                   for (цел i = oldcount - 1; i >= индекс; --i)
                        Массив[i + inc] = Массив[i];

                   цел j = индекс;
                   while (e.ещё())
                         {
                         T элемент = e.получи();
                         if (!допускается (элемент))
                            { // Ugh. Can only do full rollback
                            for (цел i = индекс; i < oldcount; ++i)
                                 Массив[i] = Массив[i + inc];

                            vershion = oldversion;
                            счёт = oldcount;
                            проверьЭлемент(элемент); // force throw
                            }
                         Массив[j++] = элемент;
                         }
                   }
                else
                   if (индекс is счёт)
                      { // следщ best; we can добавь
                      while (e.ещё())
                            {
                            T элемент = e.получи();
                            проверьЭлемент(элемент);
                            ростПо_(1);
                            Массив[счёт -1] = элемент;
                            }
                      }
                   else
                      { // do it the медленно way
                      цел j = индекс;
                      while (e.ещё())
                            {
                            T элемент = e.получи();
                            проверьЭлемент(элемент);
                            ростПо_(1);

                            for (цел i = счёт -1; i > j; --i)
                                 Массив[i] = Массив[i - 1];
                            Массив[j++] = элемент;
                            }
                      }
        }

        private final проц удали_(T элемент, бул всеСлучаи)
        {
                if (! действительныйАргумент(элемент))
                      return;

                for (цел i = 0; i < счёт; ++i)
                    {
                    while (i < счёт && Массив[i] == (элемент))
                          {
                          for (цел j = i + 1; j < счёт; ++j)
                               Массив[j - 1] = Массив[j];

                          Массив[счёт -1] = T.init;
                          ростПо_( -1);

                          if (!всеСлучаи || счёт is 0)
                               return ;
                          }
                    }
        }

        private final проц замени_(T старЭлемент, T новЭлемент, бул всеСлучаи)
        {
                if (действительныйАргумент(старЭлемент) is нет || счёт is 0)
                    return;

                for (цел i = 0; i < счёт; ++i)
                    {
                    if (Массив[i] == (старЭлемент))
                       {
                       проверьЭлемент(новЭлемент);
                       Массив[i] = новЭлемент;
                       инкрВерсию();

                       if (! всеСлучаи)
                             return;
                       }
                    }
        }

        /**
         * Реализует col.model.View.Обзор.проверьРеализацию.
         * См_Также: col.model.View.Обзор.проверьРеализацию
        **/
        public override проц проверьРеализацию()
        {
                super.проверьРеализацию();
                assert(!(Массив is пусто && счёт !is 0));
                assert((Массив is пусто || счёт <= Массив.length));

                for (цел i = 0; i < счёт; ++i)
                    {
                    assert(допускается(Массив[i]));
                    assert(экземпляры(Массив[i]) > 0);
                    assert(содержит(Массив[i]));
                    }
        }

        /***********************************************************************

                opApply() мигрировал сюда, чтобы осуществлять виртуальный вызов
                метода получи().
                
        ************************************************************************/

        static class ОбходчикМассива(T) : АбстрактныйОбходчик!(T)
        {
                private цел ряд;
                private T[] Массив;

                public this (СекМассив пследвтн)
                {
                        super (пследвтн);
                        Массив = пследвтн.Массив;
                }

                public final T получи()
                {
                        декрементируйОстаток();
                        return Массив[ряд++];
                }

                цел opApply (цел delegate (inout T значение) дг)
                {
                        цел результат;

                        for (auto i=остаток(); i--;)
                            {
                            auto значение = получи();
                            if ((результат = дг(значение)) != 0)
                                 break;
                            }
                        return результат;
                }
        }
}



debug (Test)
{
        import io.Console;
        
        проц main()
        {
                auto Массив = new СекМассив!(ткст);
                Массив.добавь ("foo");
                Массив.добавь ("bar");
                Массив.добавь ("wumpus");

                foreach (значение; Массив.элементы) {}

                auto элементы = Массив.элементы();
                while (элементы.ещё)
                       auto знач = элементы.получи();

                foreach (значение; Массив)
                         Квывод (значение).нс;

                auto a = Массив.вМассив;
                a.сортируй;
                foreach (значение; a)
                         Квывод (значение).нс;

                 Массив.проверьРеализацию();
        }
}
