/*********************************************************
   Copyright: (C) 2008 by Steven Schveighoffer.
              All rights reserved

   License: $(LICENSE)

**********************************************************/
module col.Hash;

private import col.Link;
private import col.model.Iterator;
private import col.DefaultAllocator;

/+  ИНТЕРФЕЙС:

struct ДефолтыХэш
{
    const плав факторЗагрузки = .75;
    const бцел размерТаблицы = 31;
}


struct Хэш(З, alias хэшФункц, alias обновлФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель, бул допускатьДубликаты=нет, бул обновить_ли=да)
{
 Связка!(З).Узел узел;
 alias Разместитель!(Связка!(З)) разместитель;
 разместитель разм;
 узел[] таблица;
 бцел счёт;
    struct Позиция
    {
        Хэш *владелец;
        узел укз; alias укз ptr;
        цел инд;
        Позиция следщ();
        Позиция предш();
    бул добавь(З з);
    проц перемерьПод(бцел ёмкость);
    проц проверьФакторЗагрузки();
    Позиция начало();
    Позиция конец();
    Позиция найди(З з);
    Позиция удали(Позиция поз);
    проц очисти();
    бцел накладка(Обходчик!(З) поднабор);;
        бцел считайВсе(З з);
        бцел удалиВсе(З з);
        Позиция найди(З з, Позиция начатьС);
    проц копируйВ(ref Хэш цель);
    узел размести();
    узел размести(З з);
    проц установка();
}


template ХэшБезОбновлений(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель);

template ХэшДуб(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель);

+/
//==================================================================
struct ДефолтыХэш
{
    const плав факторЗагрузки = .75;
    const бцел размерТаблицы = 31;
}

/**
 * Дефолтная реализация Хэша. Используется в контейнерах Хэш* по
 * умолчанию.
 *
 * Реализация содержит таблицу из линкованных списков. Тааблица индексирует
 * входящие элементы, основываясь на хэн-коде.
 */
struct Хэш(З, alias хэшФункц, alias обновлФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель, бул допускатьДубликаты=false, бул обновить_ли=true)
{
    /**
     * Псевдоним для Узел
     */
    alias Связка!(З).Узел узел;

    /**
     * Псевдоним для Разместитель
     */
    alias Разместитель!(Связка!(З)) разместитель;

    /**
     * Разместитель для хэша
     */
    разместитель разм;

    /**
     * Таблица бакетов (buckets)
     */
    узел[] таблица;

    /**
     * Число элементов в этой таблице
     */
    бцел счёт;

    /**
     * Подобно указателю, используется для указания на заданный элемент в хэше.
     */
    struct Позиция
    {
        Хэш *владелец;
        узел укз; alias укз ptr;
        цел инд;

        /**
         * Возвращает Позиицию вслед за p.
         */
        Позиция следщ()
        {
            Позиция p = *this;
            auto таблица = владелец.таблица;

            if(p.ptr !is null)
            {
                if(p.ptr.следщ is таблица[p.инд])
                    //
                    // Особый случай в конце бакета, переход к следщ
                    // бакету.
                    //
                    p.ptr = null;
                else
                {
                    //
                    // Всё ещё в бакете
                    //
                    p.ptr = p.ptr.следщ;
                    return p;
                }
            }

            //
            // Перейти за бакет, к следующему валидному бакету
            //
            while(p.инд < cast(цел)таблица.length && p.ptr is null)
            {
                if(++p.инд < таблица.length)
                    p.ptr = таблица[p.инд];
                else
                    p.ptr = null;
            }
            return p;
        }

        /**
         * Возвращает Позицию перед p.
         */
        Позиция предш()
        {
            Позиция p = *this;
            auto таблица = владелец.таблица;
            if(p.ptr !is null)
            {
                if(p.ptr is таблица[p.инд])
                    p.ptr = null;
                else
                {
                    p.ptr = p.ptr.предш;
                    return p;
                }
            }

            while(p.инд > 0 && p.ptr is null)
                p.ptr = таблица[--p.инд];
            if(p.ptr)
                //
                // Перейти в конец нового бакета
                //
                p.ptr = p.ptr.предш;
            return p;
        }
    }

    /**
     * Добавить значение в этот хэш. Возвращает да, если значение отсутствует,
     * или нет, если обх обновлён.
     */
    бул добавь(З з)
    {
        if(таблица is null)
            перемерьПод(исходнРазмерТаблицы);

        auto h = хэшФункц(з) % таблица.length;
        узел хвост = таблица[h];
        if(хвост is null)
        {
            //
            // Узла пока ещё нет, добавим здесь новый узел.
            //
            хвост = таблица[h] = размести(з);
            узел.крепи(хвост, хвост);
            счёт++; 
            return true;
        }
        else
        {
            static if(!допускатьДубликаты)
            {
                узел элт = findInBucket(хвост, з, хвост);
                if(элт is null)
                {
                    счёт++;
                    хвост.приставь(размести(з));
                    // Не единичный элемент, нужно проверить фактор загрузки.
                    проверьФакторЗагрузки();
                    return true;
                }
                else
                {
                    //
                    // Найден узел, установить значение.
                    //
                    static if(обновить_ли)
                        обновлФункц(элт.значение, з);
                    return false;
                }
            }
            else
            {
                //
                // always добавь, even if the узел already exists.
                //
                счёт++;
                хвост.приставь(размести(з));
                // not single элемент, need to проверь load factor
                проверьФакторЗагрузки();
                return true;
            }
        }
    }

    /**
     * Resize the hash таблица to the given ёмкость.  Normally only called
     * privately.
     */
    проц перемерьПод(бцел ёмкость)
    {
        if(ёмкость > таблица.length)
        {
            auto новТабл = new узел[ёмкость];

            foreach(голова; таблица)
            {
                if(голова)
                {
                    //
                    // make the последн узел point to null, to mark the конец of
                    // the bucket
                    //
                    узел.крепи(голова.предш, null);
                    for(узел тек = голова, следщ = голова.следщ; тек !is null;
                            тек = следщ)
                    {
                        следщ = тек.следщ;
                        auto h = хэшФункц(тек.значение) % новТабл.length;
                        узел новГолова = новТабл[h];
                        if(новГолова is null)
                        {
                            новТабл[h] = тек;
                            узел.крепи(тек, тек);
                        }
                        else
                            новГолова.приставь(тек);
                    }
                }
            }
            delete таблица;
            таблица = новТабл;
        }
    }

    /**
     * Check to see whether the load factor dictates a перемерьПод is in order.
     */
    проц проверьФакторЗагрузки()
    {
        if(таблица !is null)
        {
            плав fc = cast(плав) счёт;
            плав ft = таблица.length;

            if(fc / ft > факторЗагрузки)
                перемерьПод(2 * cast(бцел)(fc / факторЗагрузки) + 1);
        }
    }

    /**
     * Returns a Позиция that points to the первый элемент in the hash.
     */
    Позиция начало()
    {
        if(счёт == 0)
            return конец;
        Позиция рез;
        рез.ptr = null;
        рез.владелец = this;
        рез.инд = -1;
        //
        // this finds the первый valid узел
        //
        return рез.следщ;
    }

    /**
     * Returns a Позиция that points past the последн элемент of the hash.
     */
    Позиция конец()
    {
        Позиция рез;
        рез.инд = таблица.length;
        рез.владелец = this;
        return рез;
    }

    // private function используется to implement common pieces
    private узел findInBucket(узел bucket, З з, узел начатьС)
    in
    {
        assert(bucket !is null);
    }
    body
    {
        if(начатьС.значение == з)
            return начатьС;
        узел n;
        for(n = начатьС.следщ; n !is bucket && n.значение != з; n = n.следщ)
        {
        }
        return (n is bucket ? null : n);
    }

    /**
     * Find the первый instance of a значение
     */
    Позиция найди(З з)
    {
        if(счёт == 0)
            return конец;
        auto h = хэшФункц(з) % таблица.length;
        // if bucket is empty, or doesn'т contain з, return конец
        узел укз;
        if(таблица[h] is null || (укз = findInBucket(таблица[h], з, таблица[h])) is null)
            return конец;
        Позиция p;
        p.владелец = this;
        p.инд = h;
        p.ptr = укз;
        return p;
    }

    /**
     * Remove a given Позиция from the hash.
     */
    Позиция удали(Позиция поз)
    {
        Позиция возврзнач = поз.следщ;
        if(поз.ptr is таблица[поз.инд])
        {
            if(поз.ptr.следщ is поз.ptr)
                таблица[поз.инд] = null;
            else
                таблица[поз.инд] = поз.ptr.следщ;
        }
        поз.ptr.открепи;
        static if(разместитель.нужноСвоб)
            разм.освободи(поз.ptr);
        счёт--;
        return возврзнач;
    }

    /**
     * Remove all values from the hash
     */
    проц очисти()
    {
        static if(разместитель.нужноСвоб)
            разм.освободиВсе();
        delete таблица;
        таблица = null;
        счёт = 0;
    }

    /**
     * keep only elements that appear in поднабор
     *
     * returns the number of elements removed
     */
    бцел накладка(Обходчик!(З) поднабор)
    {
        if(счёт == 0)
            return 0;
        //
        // старт out removing all nodes, then filter out ones that are in the
        // установи.
        //
        бцел рез = счёт;
        auto врм = new узел[таблица.length];

        foreach(ref з; поднабор)
        {
            Позиция p = найди(з);
            if(p.инд != таблица.length)
            {
                //
                // found the узел in the current таблица, добавь обх to the new
                // таблица.
                //
                узел голова = врм[p.инд];

                //
                // need to update the таблица pointer if this is the голова узел in that cell
                //
                if(p.ptr is таблица[p.инд])
                {
                    if(p.ptr.следщ is p.ptr)
                        таблица[p.инд] = null;
                    else
                        таблица[p.инд] = p.ptr.следщ;
                }

                if(голова is null)
                {
                    врм[p.инд] = p.ptr.открепи;
                    узел.крепи(p.ptr, p.ptr);
                }
                else
                    голова.приставь(p.ptr.открепи);
                рез--;
            }
        }

        static if(разместитель.нужноСвоб)
        {
            //
            // now, we must освободи all the unused nodes
            //
            foreach(голова; таблица)
            {
                if(голова !is null)
                {
                    //
                    // since we will освободи голова, mark the конец of the list with
                    // a null pointer
                    //
                    узел.крепи(голова.предш, null);
                    while(голова !is null)
                    {
                        auto newhead = голова.следщ;
                        разм.освободи(голова);
                        голова = newhead;
                    }
                }
            }
        }
        таблица = врм;
        счёт -= рез;
        return рез;
    }

    static if(допускатьДубликаты)
    {
        // private function to do the dirty work of считайВсе and удалиВсе
        private бцел _applyAll(З з, бул удали)
        {
            Позиция p = найди(з);
            бцел рез = 0;
            if(p.инд != таблица.length)
            {
                auto bucket = таблица[p.инд];
                do
                {
                    if(p.ptr.значение == з)
                    {
                        рез++;
                        if(удали)
                        {
                            auto исх = p.ptr;
                            p.ptr = p.ptr.следщ;
                            исх.открепи();
                            static if(разместитель.нужноСвоб)
                            {
                                разм.освободи(исх);
                            }
                            continue;
                        }
                    }

                    p.ptr = p.ptr.следщ;
                }
                while(p.ptr !is bucket)
            }
            return рез;
        }

        /**
         * счёт the number of times a given значение appears in the hash
         */
        бцел считайВсе(З з)
        {
            return _applyAll(з, false);
        }

        /**
         * удали all the экземпляры of з that appear in the hash
         */
        бцел удалиВсе(З з)
        {
            return _applyAll(з, true);
        }

        /**
         * Find a given значение in the hash, starting from the given Позиция.
         * If the Позиция is beyond the последн instance of з (which can be
         * determined if the Позиция's bucket is beyond the bucket where з
         * should go).
         */
        Позиция найди(З з, Позиция начатьС)
        {
            if(счёт == 0)
                return конец;
            auto h = хэшФункц(з) % таблица.length;
            if(начатьС.инд < h)
            {
                // if bucket is empty, return конец
                if(таблица[h] is null)
                    return конец;

                // старт from the bucket that the значение would live in
                начатьС.инд = h;
                начатьС.ptr = таблица[h];
            }
            else if(начатьС.инд > h)
                // beyond the bucket, return конец
                return конец;

            if((начатьС.ptr = findInBucket(таблица[h], з, начатьС.ptr)) !is
                    null)
                return начатьС;
            return конец;
        }
    }

    /**
     * copy all the elements from this hash to цель.
     */
    проц копируйВ(ref Хэш цель)
    {
        //
        // copy all local values
        //
        цель = *this;

        //
        // reset разместитель
        //
        цель.разм = цель.разм.init;

        //
        // reallocate all the nodes in the таблица
        //
        цель.таблица = new узел[таблица.length];
        foreach(i, n; таблица)
        {
            if(n !is null)
                цель.таблица[i] = n.dup(&цель.размести);
        }
    }

    узел размести()
    {
        return разм.размести();
    }

    узел размести(З з)
    {
        auto рез = размести();
        рез.значение = з;
        return рез;
    }

    /**
     * Perform any установка necessary (none for this hash impl)
     */
    проц установка()
    {
    }
}

/**
 * используется to define a Хэш that does not perform updates
 */
template ХэшБезОбновлений(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель)
{
    // note the второй хэшФункц isn'т используется because обновлять_ли is false
    alias Хэш!(З, хэшФункц, хэшФункц, факторЗагрузки, исходнРазмерТаблицы, Разместитель, false, false) ХэшБезОбновлений;
}

/**
 * используется to define a Хэш that takes duplicates
 */
template ХэшДуб(З, alias хэшФункц, плав факторЗагрузки=ДефолтыХэш.факторЗагрузки, бцел исходнРазмерТаблицы=ДефолтыХэш.размерТаблицы, alias Разместитель=ДефолтныйРазместитель)
{
    // note the второй хэшФункц isn'т используется because обновлять_ли is false
    alias Хэш!(З, хэшФункц, хэшФункц, факторЗагрузки, исходнРазмерТаблицы, Разместитель, true, false) ХэшДуб;
}
