module col.Heap;
import util = tpl.Std;

/+ ИНТЕРФЕЙС:

struct ИнтерфейсКучиШ(ЗаписьКучи)
{
  бул меньше( ref ЗаписьКучи _e1, ref ЗаписьКучи _e2);
  бул больше( ref ЗаписьКучи _e1, ref ЗаписьКучи _e2);
  цел  дайПоложение( ref ЗаписьКучи _e);
  проц установиПоложение(ref ЗаписьКучи _e, цел _i);
}
 
struct Куча(ЗаписьКучи, ИнтерфейсКучи = ЗаписьКучи)
{
    static Куча opCall();
    static Куча opCall(ref ИнтерфейсКучи _интерфейс);
    проц очисть() ;
    бул пуста();
    бцел размер() ;
    бцел длина();
    проц резервируй(бцел _n) ;
    проц сбросьПоложение(ЗаписьКучи _h);
    бул сохранена(ЗаписьКучи _h);
    проц вставь(ЗаписьКучи _h)  ;
    ЗаписьКучи первая();
    проц удалиПервую();
    проц удали(ЗаписьКучи _h);
    проц обнови(ЗаписьКучи _h);
    бул проверь();

protected:  
    ИнтерфейсКучи интерфейс_;
    ЗаписьКучи[]            Основа;


}
+/

//== ОПРЕДЕЛЕНИЕ КЛАССА =========================================================


/** Этот класс демонстрирует интерфейс ИнтерфейсКучи. Если вам нужно
 *  построить свою адаптированную кучу, вам нужно определить класс
 *  интерфейса кучи и использовать его, как шаблонный параметр для
 *  класса Куча. Этот класс определяет интерфейс, который этот интерфейс
 *  кучи должен реализовать.
 *   
 *  См_Также: Куча
 */
struct ИнтерфейсКучиШ(ЗаписьКучи)
{
  /// Сравнение двух ЗаписьКучи: строго меньше
  бул меньше( ref ЗаписьКучи _e1, ref ЗаписьКучи _e2);

  /// Сравнение двух ЗаписьКучи: строго больше
  бул больше( ref ЗаписьКучи _e1, ref ЗаписьКучи _e2);

  /// Получить положение в куче ЗаписьКучи _e
  цел  дайПоложение( ref ЗаписьКучи _e);

  /// Установить положение в куче ЗаписьКучи _e
  проц установиПоложение(ref ЗаписьКучи _e, цел _i);
}



/**
 *  Эффективная, высоко адаптивная куча.
 *
 *  Главная разница (и увеличение производительности) этой кучи в сравнении,
 *  например, с кучей из STL, в том, что позиции элементов кучи здесь
 *  доступны из самих элементов.
 *  Следовательно, если поменять приоритет какого-либо элемента, который
 *  не следует удалять, и повторно вставить его, нужно просто вызвать метод
 *  обнови(ЗаписьКучи).
 *
 *  Этот класс кучи параметрирован двумя шаблонными аргументами: 
 *  $(UL
 *    $(LI классом \c ЗаписьКучи, который будет сохранён на куче)
 *    $(LI ИнтерфейсКучи, сообщающим как в куче сравниваются записи и
 *        как сохранять позиции записей в этих записях кучи.)
 *  )
 *
 *  Как пример использования класса, см. декларацию класса 
 *  Decimater.DecimaterT.
 *
 *  См_Также: ИнтерфейсКучиШ
 */
 
struct Куча(ЗаписьКучи, ИнтерфейсКучи = ЗаписьКучи)
{
public:

    /// Конструктор
    static Куча opCall() { Куча M; return M; }
  
    /// Крнструирует с заданным \c HeapIterface. 
    static Куча opCall(ref ИнтерфейсКучи _интерфейс) 
    { 
        Куча M; with (M) {
            интерфейс_=(_интерфейс);
        } return M; 
    }

    /// Очищает кучу.
    проц очисть() { Основа.длина = 0; }

    /// Куча пуста?
    бул пуста() { return Основа.длина == 0; }

    /// Возвращает размер кучи.
    бцел размер() { return Основа.длина; }
    бцел длина() { return Основа.длина; }

    /// Резервирует пространство для _n записей.
    проц резервируй(бцел _n) { util.резервируй(Основа,_n); }

    /// сСбросить положение в куче в -1 (нет в куче).
    проц сбросьПоложение(ЗаписьКучи _h)
    { интерфейс_.установиПоложение(_h, -1); }
  
    /// Запись есть в куче?
    бул сохранена(ЗаписьКучи _h)
    { return интерфейс_.дайПоложение(_h) != -1; }
  
    /// Вставить запись _h.
    проц вставь(ЗаписьКучи _h)  
    { 
        Основа ~= _h; 
        вверхКучи(размер()-1); 
    }

    /// Получить первую запись.
    ЗаписьКучи первая()
    { 
        assert(!пуста()); 
        return запись(0); 
    }

    /// Удалить первую запись.
    проц удалиПервую()
    {    
        assert(!пуста());
        сбросьПоложение(запись(0));
        if (размер() > 1)
        {
            запись(0, запись(размер()-1));
            pop_back();
            внизКучи(0);
        }
        else
        {
            pop_back();
        }
    }

    /// Удалить запись.
    проц удали(ЗаписьКучи _h)
    {
        цел поз = интерфейс_.дайПоложение(_h);
        сбросьПоложение(_h);

        assert(поз != -1);
        assert(cast(бцел) поз < размер());
    
        // последний элт ?
        if (cast(бцел) поз == размер()-1)
        {
            pop_back();    
        }
        else 
        {
            запись(поз, запись(размер()-1)); // переместить последний элт в поз
            pop_back();
            внизКучи(поз);
            вверхКучи(поз);
        }
    }

    /** Обновить запись: изменить ключ и обновить положение, чтобы
        восстановить свойство кучи.
    */
    проц обнови(ЗаписьКучи _h)
    {
        цел поз = интерфейс_.дайПоложение(_h);
        assert(поз != -1, "ЗаписьКучи не в куче (поз=-1)");
        assert(cast(бцел)поз < размер());
        внизКучи(поз);
        вверхКучи(поз);
    }
  
    /// Проверить состояние кучи.
    бул проверь()
    {
        бул ok = true;
        бцел i, j;
        for (i=0; i<размер(); ++i)
        {
            if (((j=левый(i))<размер()) && интерфейс_.больше(запись(i), запись(j))) 
            {
                ошибка("Нарушение условий для Кучи");
                ok=false;
            }
            if (((j=правый(i))<размер()) && интерфейс_.больше(запись(i), запись(j)))
            {
                ошибка("Нарушение условий для Кучи");
                ok=false;
            }
        }
        return ok;
    }

protected:  
    /// Экземпляр ИнтерфейсКучи
    ИнтерфейсКучи интерфейс_;
    ЗаписьКучи[]            Основа;
  

private:
    // typedef
    alias ЗаписьКучи[] ВекторКучи;

  
    проц pop_back() {
        assert(!пуста());
        Основа.длина = Основа.длина-1;
    }

    /// Вверх по куче. Установить свойство кучи.
    проц вверхКучи(бцел _инд)
    {
        ЗаписьКучи     h = запись(_инд);
        бцел  индРодителя;

        while ((_инд>0) &&
               интерфейс_.меньше(h, запись(индРодителя=родитель(_инд))))
        {
            запись(_инд, запись(индРодителя));
            _инд = индРодителя;    
        }
  
        запись(_инд, h);
    }

  
    /// Вниз по куче. E Установить свойство кучи.
    проц внизКучи(бцел _инд)
    {
        ЗаписьКучи     h = запись(_инд);
        бцел  индОтпрыска;
        бцел  s = размер();
  
        while(_инд < s)
        {
            индОтпрыска = левый(_инд);
            if (индОтпрыска >= s) break;
    
            if ((индОтпрыска+1 < s) &&
                (интерфейс_.меньше(запись(индОтпрыска+1), запись(индОтпрыска))))
                ++индОтпрыска;
    
            if (интерфейс_.меньше(h, запись(индОтпрыска))) break;

            запись(_инд, запись(индОтпрыска));
            _инд = индОтпрыска;
        }  

        запись(_инд, h);

    }

      /// Установить запись _h в индекс _инд aи обновить положение _h в куче.
    проц запись(бцел _инд, ЗаписьКучи _h) 
    {
        assert(_инд < размер());
        Основа[_инд] = _h;
        интерфейс_.установиПоложение(_h, _инд);
    }

  
    /// Получить запись по индексу _инд.
    ЗаписьКучи запись(бцел _инд)
    {
        assert(_инд < размер());
        return (Основа[_инд]);
    }
  
    /// Получить индекс родителя.
    бцел родитель(бцел _i) { return (_i-1)>>1; }
    /// Получить индекс левого отпрыска.
    бцел левый(бцел _i)   { return (_i<<1)+1; }
    /// Получить индекс правого отпрыска.
    бцел правый(бцел _i)  { return (_i<<1)+2; }

}