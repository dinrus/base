module col.HashMap;

public import col.model.Map;
public import col.Functions;
private import col.Hash;

private import col.Iterators;

/+ ИНТЕРФЕЙС:

class ХэшКарта(К, З, alias ШаблРеализац=Хэш, alias хэшФункц=ДефХэш) : Карта!(К, З)
{

    struct элемент
    {
        К ключ;
        З знач;
        цел opEquals(элемент e);
    }
    struct курсор
    {
        З значение();
        К ключ();
        З значение(З з);
        курсор opPostInc();
        курсор opPostDec();
        курсор opAddAssign(цел прир);
        курсор opSubAssign(цел прир);
        бул opEquals(курсор обх);
    }

    final цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг);
    final цел чисть_ключ(цел delegate(ref бул чистить_ли, ref К к, ref З з) дг);	
    цел opApply(цел delegate(ref К к, ref З з) дг);
    цел opApply(цел delegate(ref З з) дг);
    this();
    ХэшКарта зачисть();
    бцел длина();
    курсор начало();
    курсор конец();
    курсор удали(курсор обх);
    курсор найдиЗначение(курсор обх, З з);
    курсор найдиЗначение(З з);
    курсор найди(К к);
    бул содержит(З з);
    ХэшКарта удали(З з);
    ХэшКарта удали(З з, ref бул былУдалён);
    ХэшКарта удалиПо(К ключ);
    ХэшКарта удалиПо(К ключ, ref бул былУдалён);
    З opIndex(К ключ);
    З opIndexAssign(З значение, К ключ);
    ХэшКарта установи(К ключ, З значение);
    ХэшКарта установи(К ключ, З значение, ref бул былДобавлен);
    ХэшКарта установи(Ключник!(К, З) исток);
    ХэшКарта установи(Ключник!(К, З) исток, ref бцел члоДобавленных);
    ХэшКарта удали(Обходчик!(К) поднабор);
    ХэшКарта удали(Обходчик!(К) поднабор, ref бцел члоУдалённых);
    ХэшКарта накладка(Обходчик!(К) поднабор);
    ХэшКарта накладка(Обходчик!(К) поднабор, ref бцел члоУдалённых);
    бул имеетКлюч(К ключ);
    бцел счёт(З з);
    ХэшКарта удалиВсе(З з);
    ХэшКарта удалиВсе(З з, ref бцел члоУдалённых);
    Обходчик!(К) ключи();
    ХэшКарта dup();
    цел opEquals(Объект o);
    ХэшКарта установи(З[К] исток);
    ХэшКарта установи(З[К] исток, ref бцел члоДобавленных);
    ХэшКарта удали(К[] поднабор);
    ХэшКарта удали(К[] поднабор, ref бцел члоУдалённых);
    ХэшКарта накладка(К[] поднабор);
    ХэшКарта накладка(К[] поднабор, ref бцел члоУдалённых);
}
+///===========================================================

/**
 * Реализация карты, использующая Хэш для ближней вставки O(1),
 * удаления и поиска по времени.
 *
 * Добавка элемента может вывести из строя курсоры, в зависимости от реализации.
 *
 * Удаление элемента выводит из строя лишь те курсоры, которые указывали на
 * данный элемент.
 *
 * Реализацию Хэш можно заменить на адаптированную, этот
 * Хэш должен быть шаблонной структурой, инстанциируемой единственным
 * шаблонным аргументом З, и реализующей следующие члены (члены, не функции,
 * могут быть свойствами дай/установи, если иное не указано):
 *
 *
 * параметры -> должно быть структурой с, как минимум, следующими членами:
 *   хэшФункц -> используемая хэш-функция (должно быть ХэшФунк!(З))
 *   обновлФункц -> используемая функция обновления (должно быть
 *                     ФункцОбновления!(З))
 * 
 * проц установка(параметры p) -> инициализирует хэш с заданными параметрами.
 *
 * бцел счёт -> счёт элементов в хэше
 *
 * позиция -> должно быть struct/class wсо следующим членом:
 *   укз -> должен определять следующий член:
 *     значение -> значение, на которое указывает данная позиция (не может быть
 *                свойством)
 *   позиция следщ -> следующая позиция в этой хэш-карте
 *   позиция предш -> предыдущая позиция в этой хэш-карте
 *
 * бул добавь(З з) -> добавить заданное значение в этот хэш. Хэш этого значения
 * будет дан хэшФункц(з).  Если значение уже существует в хэше,
 * следует вызывать обновлФункц(з) и не инкрементировать счёт.
 *
 * позиция начало -> должно быть позицией, которая указывает на самый первый валидный
 * элемент в этом хэше, или на конец, если элементов не существует.
 *
 * позиция конец -> должно быть позицией, которая указывает сразу за самым последним
 * валидным элементом.
 *
 * позиция найди(З з) -> возвращает позицию, которая указывает на элемент, который
 * содержит з, или на конец, если элемента не существует.
 *
 * позиция удали(позиция p) -> удаляет заданный элемент из хэша,
 * возвращает следующий валидный элемент или конец, если p был последнимс в этом хэше.
 *
 * проц зачисть() -> удаляет все элементы из этого хэша, устанавливает счёт на 0.
 */
class ХэшКарта(К, З, alias ШаблРеализац=Хэш, alias хэшФункц=ДефХэш) : Карта!(К, З)
{
    /**
     * Используется для реализации пары ключ/значение, хранимой в реализации хэша.
     */
    struct элемент
    {
        К ключ;
        З знач;

        /**
         * Сравнивает 2 элемента на равенство.  Сравнивает только по ключам.
         */
        цел opEquals(элемент e)
        {
            return ключ == e.ключ;
        }
    }

    private КлючОбходчик _ключи;

    /**
     * Функция, дающая хэш элемента.
     */
    static бцел _хэшФункция(ref элемент e)
    {
        return хэшФункц(e.ключ);
    }

    /**
     * Функция, обновляющая элемент, в соответствии с новым элементом.
     */
    static проц _функцияОбнова(ref элемент исх, ref элемент новэлт)
    {
        //
        // копировать только значение, оставить ключ в покое
        //
        исх.знач = новэлт.знач;
    }

    /**
     * Удобный псевдоним.
     */
    alias ШаблРеализац!(элемент, _хэшФункция, _функцияОбнова) Реализ;

    private Реализ _хэш;

    /**
     * Курсор для хэш-карты.
     */
    struct курсор
    {
        private Реализ.Позиция позиция;

        /**
         * Даёт значение по этому курсору.
         */
        З значение()
        {
            return позиция.ptr.значение.знач;
        }

        /**
         * Даёт ключ по этому курсору.
         */
        К ключ()
        {
            return позиция.ptr.значение.ключ;
        }

        /**
         * Устанавливает значение по этому курсору.
         */
        З значение(З з)
        {
            позиция.ptr.значение.знач = з;
            return з;
        }

        /**
         * Инкрементирует этот курсор, возвращает курсор, который был до
         * инкрементации.
         */
        курсор opPostInc()
        {
            курсор врм = *this;
            позиция = позиция.следщ;
            return врм;
        }

        /**
         * Декрементирует этот курсор, возвращает курсор, который был до
         * декрементации.
         */
        курсор opPostDec()
        {
            курсор врм = *this;
            позиция = позиция.предш;
            return врм;
        }

        /**
         * Инкрементирует курсор на заданное количество.
         *
         * Это операция O(прир)! Его следует использовать только в форме:
         *
         * ++i;
         */
        курсор opAddAssign(цел прир)
        {
            if(прир < 0)
                return opSubAssign(-прир);
            while(прир--)
                позиция = позиция.следщ;
            return *this;
        }

        /**
         * Декрементирует курсор на заданное количество.
         *
         * Это операция O(прир)! Его следует использовать только в форме:
         *
         * --i;
         */
        курсор opSubAssign(цел прир)
        {
            if(прир < 0)
                return opAddAssign(-прир);
            while(прир--)
                позиция = позиция.предш;
            return *this;
        }

        /**
         * Сравнивает два курсора на равенство.
         */
        бул opEquals(курсор обх)
        {
            return обх.позиция is позиция;
        }
    }

    /**
     * Итерирует по значением этой ХэшКарты, сообщая обходчику, какие следует
     * удалить.
     */
    final цел очистить(цел delegate(ref бул чистить_ли, ref З з) дг)
    {
        цел _дг(ref бул чистить_ли, ref К к, ref З з)
        {
            return дг(чистить_ли, з);
        }
        return _примени(&_дг);
    }

    /**
     * Итерирует по парам ключ/значение этой ХэшКарты, сообщая обходчику, которые
     * удалить.
     */
    final цел чисть_ключ(цел delegate(ref бул чистить_ли, ref К к, ref З з) дг)
    {
        return _примени(дг);
    }

    private class КлючОбходчик : Обходчик!(К)
    {
        final бцел длина()
        {
            return this.outer.length;
        }

		alias длина length;
		
        final цел opApply(цел delegate(ref К) дг)
        {
            цел _дг(ref бул чистить_ли, ref К к, ref З з)
            {
                return дг(к);
            }
            return _примени(&_дг);
        }
    }

    private цел _примени(цел delegate(ref бул чистить_ли, ref К к, ref З з) дг)
    {
        курсор обх = начало;
        бул чистить_ли;
        цел возврдг = 0;
        курсор _конец = конец; // кэшируем конец, чтобы обходчик не всегда генерировался.
        while(!возврдг && обх != _конец)
        {
            //
            // не позволяем пользователю менять ключ.
            //
            К врмключ = обх.ключ;
            чистить_ли = нет;
            if((возврдг = дг(чистить_ли, врмключ, обх.позиция.ptr.значение.знач)) != 0)
                break;
            if(чистить_ли)
                обх = удали(обх);
            else
                обх++;
        }
        return возврдг;
    }

    /**
     * Итерирует по парам ключ/значение этой коллекции.
     */
    цел opApply(цел delegate(ref К к, ref З з) дг)
    {
        цел _дг(ref бул чистить_ли, ref К к, ref З з)
        {
            return дг(к, з);
        }

        return _примени(&_дг);
    }

    /**
     * Итерирует по значениям этой коллекции.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел _дг(ref бул чистить_ли, ref К к, ref З з)
        {
            return дг(з);
        }
        return _примени(&_дг);
    }

    /**
     * Создаёт экземпляр хэш-карты.
     */
    this()
    {
        _хэш.установка();
        _ключи = new КлючОбходчик;
    }

    //
    // приватный конструктор для dup
    //
    private this(ref Реализ дубИз)
    {
        дубИз.копируйВ(_хэш);
        _ключи = new КлючОбходчик;
    }

    /**
     * Очищает коллекцию от всех элементов.
     */
    ХэшКарта зачисть()
    {
        _хэш.зачисть();
        return this;
    }

    /**
     * Возвращает число элементов в коллекции.
     */
    бцел длина()
    {
        return _хэш.счёт;
    }
	alias длина length;

    /**
     * Возвращает курсор на первый элемент в коллекции.
     */
    курсор начало()
    {
        курсор обх;
        обх.позиция = _хэш.начало();
        return обх;
    }

    /**
     * Возвращает курсор, который указывает сразу после последнего элемента
     * в этой коллекции.
     */
    курсор конец()
    {
        курсор обх;
        обх.позиция = _хэш.конец();
        return обх;
    }

    /**
     * Удаляет элемент, на который указывает данный курсор, возвращая
     * курсор, который указывает на следующий элемент в этой коллекции.
     *
     * В среднем выполняется за время O(1).
     */
    курсор удали(курсор обх)
    {
        обх.позиция = _хэш.удали(обх.позиция);
        return обх;
    }

    /**
     * Находит указанное значение в коллекции, начиная с указанного курсора.
     * Применяется для итерирования по всем элементам с одинаковыми значениями.
     *
     * Выполняется за время O(1).
     */
    курсор найдиЗначение(курсор обх, З з)
    {
        return _найдиЗначение(обх, конец, з);
    }

    /**
     * Находит экземпляр значения в коллекции. Равнозначно
     * найдиЗначение(начало, з);
     *
     * Выполняется за время O(1).
     */
    курсор найдиЗначение(З з)
    {
        return _найдиЗначение(начало, конец, з);
    }

    private курсор _найдиЗначение(курсор обх, курсор последн, З з)
    {
        while(обх != последн && обх.значение != з)
            обх++;
        return обх;
    }

    /**
     * Находит экземпляр ключа в коллекции.  Возвращает конец, если такой ключ
     * отсутствует.
     *
     * В среднем выполняется за время O(1).
     */
    курсор найди(К к)
    {
        курсор обх;
        элемент врм;
        врм.ключ = к;
        обх.позиция = _хэш.найди(врм);
        return обх;
    }

    /**
     * Возвращает да, если данное значение существует в коллекции.
     *
     * Выполняется за время O(1).
     */
    бул содержит(З з)
    {
        return найдиЗначение(з) != конец;
    }

    /**
     * Удаляет первый элемент со значением з. Возвращает да, если
     * значение имелось и было удалено.
     *
     * Выполняется за время O(1).
     */
    ХэшКарта удали(З з)
    {
        бул пропущен;
        return удали(з, пропущен);
    }

    /**
     * Удаляет первый элемент со значением з. Возвращает да, если
     * значение имелось и было удалено.
     *
     * Выполняется за время O(1).
     */
    ХэшКарта удали(З з, ref бул былУдалён)
    {
        курсор обх = найдиЗначение(з);
        if(обх == конец)
        {
            былУдалён = нет;
        }
        else
        {
            удали(обх);
            былУдалён = да;
        }
        return this;
    }

    /**
     * Удаляет элемент с указанным ключом. Возвращает да, если
     * элемент имелся и был удалён.
     *
     * В среднем выполняется за время O(1).
     */
    ХэшКарта удалиПо(К ключ)
    {
        бул пропущен;
        return удалиПо(ключ, пропущен);
    }

    /**
     * Удаляет элемент с указанным ключом. Возвращает да, если
     * элемент имелся и был удалён.
     *
     * В среднем выполняется за время O(1).
     */
    ХэшКарта удалиПо(К ключ, ref бул былУдалён)
    {
        курсор обх = найди(ключ);
        if(обх == конец)
        {
            былУдалён = нет;
        }
        else
        {
            удали(обх);
            былУдалён = да;
        }
        return this;
    }

    /**
     * Возвращает значение, сохранённое в элементе с указанным ключом.
     * Если ключа нет в коллекции, выводит исключение.
     *
     * В среднем выполняется за время O(1).
     */
    З opIndex(К ключ)
    {
        курсор обх = найди(ключ);
        if(обх == конец)
            throw new Искл("Индекс вне диапазона");
        return обх.значение;
    }

    /**
     * Присваивает указанное значение элементу с указанным ключом. Если ключа
     * не существует, добавляет этот ключ и значение в коллекцию.
     *
     * В среднем выполняется за время O(1).
     */
    З opIndexAssign(З значение, К ключ)
    {
        установи(ключ, значение);
        return значение;
    }

    /**
     * Устанавливает пару ключ/значение. Если пары ключ/значение ещё не существует,
     * добавляется и обходчик.
     */
    ХэшКарта установи(К ключ, З значение)
    {
        бул пропущен;
        return установи(ключ, значение, пропущен);
    }

    /**
     * Устанавливает пару ключ/значение.  Если пары ключ/значение ещё не существует,
     * добавляется и обходчик. Параметр былДобавлен устанавливается в да.
     */
    ХэшКарта установи(К ключ, З значение, ref бул былДобавлен)
    {
        элемент элт;
        элт.ключ = ключ;
        элт.знач = значение;
        былДобавлен = _хэш.добавь(элт);
        return this;
    }

    /**
     * Устанавливает все значения из итератора в карте. Если каких-либо элементов
     * ранее н есуществовало, они будут добавлены.
     */
    ХэшКарта установи(Ключник!(К, З) исток)
    {
        бцел пропущен;
        return установи(исток, пропущен);
    }

    /**
     * Устанавливает все значения из итератора в карте. Если каких-либо элементов
     * ранее н есуществовало, они будут добавлены.  члоДобавленных установится в число
     * добавленных при этой операции элементов.
     */
    ХэшКарта установи(Ключник!(К, З) исток, ref бцел члоДобавленных)
    {
        бцел исхдлина = длина;
        бул пропущен;
        foreach(к, з; исток)
        {
            установи(к, з, пропущен);
        }
        члоДобавленных = длина - исхдлина;
        return this;
    }

    /**
     * Удаляет все ключи из карты, находящейся в поднаборе.
     */
    ХэшКарта удали(Обходчик!(К) поднабор)
    {
        foreach(к; поднабор)
            удалиПо(к);
        return this;
    }

    /**
     * Удаляет все ключи из карты, находящейся в поднаборе. члоУдалённых
     * устанавливается в число действительно удалённых ключей.
     */
    ХэшКарта удали(Обходчик!(К) поднабор, ref бцел члоУдалённых)
    {
        бцел исхдлина = длина;
        удали(поднабор);
        члоУдалённых = исхдлина - длина;
        return this;
    }

    ХэшКарта накладка(Обходчик!(К) поднабор)
    {
        бцел пропущен;
        return накладка(поднабор, пропущен);
    }

    /**
     * Эта функция сохраняет только элементы, наблюдаемые в поднаборе.
     */
    ХэшКарта накладка(Обходчик!(К) поднабор, ref бцел члоУдалённых)
    {
        //
        // Это гораздо сложнее, чем просто удалить. Нужно найти каждый
        // элемент Хэша, затем переместить обходчик в новую таблицу.
        // Но этой реализацией мы не владеем и не можем предвидеть её
        // поведение. Поэтому пересечение выделяется в реализацию
        // хэша.
        //
        // Если бы нас не волновал рантайм, это можно было бы сделать так:
        //
        // удали((new ХэшНабор!(К)).добавь(this.ключи).удали(поднабор));
        //

        //
        // Нужно создать обходчик-обмотку, передать его реализации,
        // а он будет "обматывать" каждый ключ в поднаборе как элемент.
        //
        // Весь масштаб размещается на стэке.
        //
        scope w = new ТрансформОбходчик!(элемент, К)(поднабор, function проц(ref К к, ref элемент e) { e.ключ = к;});

        члоУдалённых = _хэш.накладка(w);
        return this;
    }

    /**
     * Возвращает да, если указанный ключ в коллекции.
     *
     * В среднем выполняется за время O(1).
     */
    бул имеетКлюч(К ключ)
    {
        return найди(ключ) != конец;
    }

    /**
     * Возвращает число элементов, содержащих значение з.
     *
     * Выполняется за время O(1).
     */
    бцел счёт(З з)
    {
        бцел экземпляры = 0;
        foreach(x; this)
        {
            if(x == з)
                экземпляры++;
        }
        return экземпляры;
    }

    /**
     * Удаляет все элементы, содержащие значение з.
     *
     * Выполняется за время O(1).
     */
    ХэшКарта удалиВсе(З з)
    {
        бцел пропущен;
        return удалиВсе(з, пропущен);
    }
    /**
     * Удаляет все элементы, содержащие значение з.
     *
     * Выполняется за время O(1).
     */
    ХэшКарта удалиВсе(З з, ref бцел члоУдалённых)
    {
        бцел исхдлина = длина;
        foreach(ref b, x; &очистить)
        {
            b = cast(бул)(x == з);
        }
        члоУдалённых = исхдлина - длина;
        return this;
    }

    /**
     * Возвращает итератор, который можно использовать для чтения всех ключей.
     */
    Обходчик!(К) ключи()
    {
        return _ключи;
    }

    /**
     * Делает неглубокую копию этой хэш-карты.
     */
    ХэшКарта dup()
    {
        return new ХэшКарта(_хэш);
    }

    /**
     * Сравнивает эту ХэшКарта с другой Карта.
     *
     * Возвращает 0, если o - не объект из Карта, равен пусто или эта ХэшКарта
     * не содержит одинаковые пары ключ/значение, как указанная карта.
     * Возвращает 1, если пары ключ/значение из заданной карты строго имеются
     * и в этой ХэшКарта.
     */
    цел opEquals(Объект o)
    {
        //
        // пробует перебросить в тип карта, иначе сравнение не получится.
        //
        auto m = cast(Карта!(К, З))o;
        if(m !is пусто && m.length == длина)
        {
            auto _конец = конец;
            foreach(К к, З з; m)
            {
                auto cu = найди(к);
                if(cu is _конец || cu.значение != з)
                    return 0;
            }
            return 1;
        }

        return 0;
    }

    /**
     * Устанавливает все элементы из заданного ассоциативного массива в эту карту.
     * Будет переписан любой уже существующий ключ.
     *
     * Возвращает this.
     */
    ХэшКарта установи(З[К] исток)
    {
        foreach(К к, З з; исток)
            this[к] = з;
        return this;
    }

    /**
     * Устанавливает все элементы из заданного ассоциативного массива в эту карту.
     * Будет переписан любой уже существующий ключ.
     *
     * Устанавливает члоДобавленных в число добавленных пар ключ/значение.
     *
     * Возвращает this.
     */
    ХэшКарта установи(З[К] исток, ref бцел члоДобавленных)
    {
        бцел оригДлина = длина;
        установи(исток);
        члоДобавленных = длина - оригДлина;
        return this;
    }

    /**
     * Удалить все заданные ключи из этой карты.
     *
     * Возвращает this.
     */
    ХэшКарта удали(К[] поднабор)
    {
        foreach(к; поднабор)
            удалиПо(к);
        return this;
    }

    /**
     * Удалить все заданные ключи из этой карты.
     *
     * Возвращает this.
     *
     * члоУдалённых устанавливается в число удалённых элементов.
     */
    ХэшКарта удали(К[] поднабор, ref бцел члоУдалённых)
    {
        бцел оригДлина = длина;
        удали(поднабор);
        члоУдалённых = оригДлина - длина;
        return this;
    }

    /**
     * Удалить все ключи, которых нет в заданном массиве.
     *
     * Возвращает this.
     */
    ХэшКарта накладка(К[] поднабор)
    {
        scope обход = new ОбходчикМассива!(К)(поднабор);
        return накладка(обход);
    }

    /**
     * Удалить все ключи, которых нет в указанном массиве.
     *
     * Устанавливает члоУдалённых в число удалённых элементов.
     *
     * Возвращает this.
     */
    ХэшКарта накладка(К[] поднабор, ref бцел члоУдалённых)
    {
        scope обход = new ОбходчикМассива!(К)(поднабор);
        return накладка(обход, члоУдалённых);
    }
}

version(UnitTest)
{
    unittest
    {
        ХэшКарта!(бцел, бцел) хк = new ХэшКарта!(бцел, бцел);
        Карта!(бцел, бцел) m = хк;
        for(цел i = 0; i < 10; i++)
            хк[i * i + 1] = i;
        assert(хк.длина == 10);
        foreach(ref бул чистить_ли, бцел к, бцел з; &хк.чисть_ключ)
        {
            чистить_ли = (з % 2 == 1);
        }
        assert(хк.длина == 5);
        assert(хк.содержит(6));
        assert(хк.имеетКлюч(6 * 6 + 1));
    }
}
