/*******************************************************************************
        Based upon Doug Lea's Java collection package
******************************************************************************/
module col.LinkedList;

private import  col.Slink;
public  import  col.Container;
private import col.model.IContainer;

/*******************************************************************************

        Список of singly-linked значения

        ---
	Обходчик обходчик ()
        цел opApply (цел delegate(ref З значение) дг)

        З голова ()
        З хвост ()
        З голова (З значение)
        З хвост (З значение)
        З удалиГолову ()
        З удалиХвост ()

        бул содержит (З значение)
        т_мера первый (З значение, т_мера стартовыйИндекс = 0)
        т_мера последний (З значение, т_мера стартовыйИндекс = 0)

        СвязныйСписок добавь (З значение)
        СвязныйСписок приставь (З значение)
        т_мера приставь (ИКонтейнер!(З) e)
        СвязныйСписок добавь (З значение)
        т_мера добавь (ИКонтейнер!(З) e)
        СвязныйСписок добавьПо (т_мера индекс, З значение)
        т_мера добавьПо (т_мера индекс, ИКонтейнер!(З) e)

        З получи (т_мера индекс)
        бул возьми (ref З знач)
        т_мера удали (З значение, бул все)
        бул удалиПо (т_мера индекс)
        т_мера удалиДиапазон (т_мера отИндекса, т_мера доИндекса)
        т_мера замени (З старЭлемент, З новЭлемент, бул все)
        бул замениПо (т_мера индекс, З значение)

        СвязныйСписок очисть ()
        СвязныйСписок сбрось ()

        СвязныйСписок поднабор (т_мера из_, т_мера length = т_мера.max)
        СвязныйСписок dup ()

        т_мера размер ()
        бул пуст_ли ()
        З[] вМассив (З[] приёмн)
        СвязныйСписок сортируй (Сравни!(З) cmp)
        СвязныйСписок проверь ()
        ---

*******************************************************************************/

class СвязныйСписок (З, alias Извл = Контейнер.извлеки, 
                     alias Куча = Контейнер.ДефСбор) 
                     : ИКонтейнер!(З)
{
        //этот тип использкется для конфигурации разместителя
        private alias ССвязка!(З) Тип;
        
        private alias Тип*     Реф;
        private alias З*        ЗРеф;

        private alias Куча!(Тип) Размест;

        // число содежащихся элементов
        private т_мера          счёт;

        // конфигурируемый менеджер кучи
        private Размест           куча;
        
        // тэг изменения, обновляемый при каждом изменении
        private т_мера          изменение;

        // голова этого списка. Пусто, если он пустой
        private Реф             список;

        /***********************************************************************

                Создаёт новый пустой список.

        ***********************************************************************/

        this ()
        {
                this (пусто, 0);
        }

        /***********************************************************************

                Особая версия конструктора, необходимая для dup.

        ***********************************************************************/

        protected this (Реф l, т_мера c)
        {
                список = l;
                счёт = c;
        }

        /***********************************************************************

                Очистка для удвлении.

        ***********************************************************************/

        ~this ()
        {
                сбрось;
        }

        /***********************************************************************

                Возвращает генерный обходчик для входящих элементов.
                
        ***********************************************************************/

        final Обходчик обходчик ()
        {
                Обходчик i =void;
                i.изменение = изменение;
                i.узел = список ? *(i.hook = &список) : пусто;
                i.приор = пусто;
                i.хозяин = this;
                return i;
        }

        /***********************************************************************

                Конфигурирует назначеный разместитель с размером каждого
                блока аллокации (числом узлов, размещаемых за раз)
                и числом узлов, которыми преднаполняется кэш.
                
                Временная ёмкость: O(n)

        ***********************************************************************/

        final СвязныйСписок кэш (т_мера чанк, т_мера счёт=0)
        {
                куча.конфиг (чанк, счёт);
                return this;
        }

        /***********************************************************************


        ***********************************************************************/

        final цел opApply (цел delegate(ref З значение) дг)
        {
                return обходчик.opApply (дг);
        }

        /***********************************************************************

                Возвращает число содежащихся элементов.
                
        ***********************************************************************/

        final т_мера размер ()
        {
                return счёт;
        }

        /***********************************************************************

                Строит независимую копию этого списка.
                Сами элементы не клонируются.

        ***********************************************************************/

        final СвязныйСписок dup ()
        {
                return new СвязныйСписок!(З, Извл, куча) (список ? список.копируй(&куча.размести) : пусто, счёт);
        }

        /***********************************************************************

                Временная ёмкость: O(n)

        ***********************************************************************/

        final бул содержит (З значение)
        {
                if (счёт is 0)
                    return нет;

                return список.найди(значение) !is пусто;
        }

        /***********************************************************************

                 Временная ёмкость: O(1)

        ***********************************************************************/

        final З голова ()
        {
                return перваяЯчейка.значение;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final З хвост ()
        {
                return последняяЯчейка.значение;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final З получи (т_мера индекс)
        {
                return ячейкаПо(индекс).значение;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)
                 Возвращает т_мера.max, если элементов не найдено.

        ***********************************************************************/

        final т_мера первый (З значение, т_мера стартовыйИндекс = 0)
        {
                if (список is пусто || стартовыйИндекс >= счёт)
                    return т_мера.max;

                if (стартовыйИндекс < 0)
                    стартовыйИндекс = 0;

                auto p = список.н_ый (стартовыйИндекс);
                if (p)
                   {
                   auto i = p.индекс (значение);
                   if (i >= 0)
                       return i + стартовыйИндекс;
                   }
                return т_мера.max;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)
                 Возвращает т_мера.max, если элементов не найдено.

        ***********************************************************************/

        final т_мера последний (З значение, т_мера стартовыйИндекс = 0)
        {
                if (список is пусто)
                    return т_мера.max;

                auto i = 0;
                if (стартовыйИндекс >= счёт)
                    стартовыйИндекс = счёт - 1;

                auto индекс = т_мера.max;
                auto p = список;
                while (i <= стартовыйИндекс && p)
                      {
                      if (p.значение == значение)
                          индекс = i;
                      ++i;
                      p = p.следщ;
                      }
                return индекс;
        }

        /***********************************************************************

                 Временная ёмкость: O(length)

        ***********************************************************************/

        final СвязныйСписок поднабор (т_мера из_, т_мера length = т_мера.max)
        {
                Реф новый_список = пусто;

                if (length > 0)
                   {
                   auto p = ячейкаПо (из_);
                   auto текущ = новый_список = куча.размести.установи (p.значение, пусто);
         
                   for (auto i = 1; i < length; ++i)
                        if ((p = p.следщ) is пусто)
                             length = i;
                        else
                           {
                           текущ.прикрепи (куча.размести.установи (p.значение, пусто));
                           текущ = текущ.следщ;
                           }
                   }

                return new СвязныйСписок (новый_список, length);
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final СвязныйСписок очисть ()
        {
                return очисть (нет);
        }

        /***********************************************************************

                Сбросить содержимое ХэшКарты и опционально сконфигурировать новый
                менеджер кучи. Нет гарантии, что удастся зачистить реконфигурированные 
                разместители, обязательно вызывайте сбрось() перед сбросом
                этого класса.

                Временная ёмкость: O(n)
                
        ***********************************************************************/

        final СвязныйСписок сбрось ()
        {
                return очисть (да);
        }

        /***********************************************************************
        
                Принимает первое значение в список.

                Временная ёмкость: O(1)

        ***********************************************************************/

        final бул возьми (ref З знач)
        {
                if (счёт)
                   {
                   знач = голова;
                   удалиГолову;
                   return да;
                   }
                return нет;
        }

        /***********************************************************************

                Мспользует алгоритм, основанный на a совмести-сортируй.

                Временная ёмкость: O(n лог n)

        ***********************************************************************/

        final СвязныйСписок сортируй (Сравни!(З) cmp)
        {
                if (список)
                   {
                   список = Реф.сортируй (список, cmp);
                   измени;
                   }
                return this;
        }

        /***********************************************************************

                Временная ёмкость: O(1)

        ***********************************************************************/

        final СвязныйСписок добавь (З значение)
        {
                return приставь (значение);
        }

        /***********************************************************************

                Временная ёмкость: O(1)

        ***********************************************************************/

        final СвязныйСписок приставь (З значение)
        {
                список = куча.размести.установи (значение, список);
                инкремент;
                return this;
        }

        /***********************************************************************

                Временная ёмкость: O(n)

        ***********************************************************************/

        final т_мера удали (З значение, бул все = нет)
        {
                auto c = счёт;
                if (c)
                   {
                   auto p = список;
                   auto хвост = p;

                   while (p)
                         {
                         auto n = p.следщ;
                         if (p.значение == значение)
                            {
                            декремент (p);
                            if (p is список)
                               {
                               список = n;
                               хвост = n;
                               }
                            else
                               хвост.следщ = n;

                            if (!все || счёт is 0)
                                 break;
                            else
                               p = n;
                            }
                         else
                            {
                            хвост = p;
                            p = n;
                            }
                         }
                   }
                return c - счёт;
        }

        /***********************************************************************

                Временная ёмкость: O(n)

        ***********************************************************************/

        final т_мера замени (З старЭлемент, З новЭлемент, бул все = нет)
        {
                т_мера c;
                if (счёт && старЭлемент != новЭлемент)
                   {
                   auto p = список.найди (старЭлемент);
                   while (p)
                         {
                         ++c;
                         измени;
                         p.значение = новЭлемент;
                         if (!все)
                              break;
                         p = p.найди (старЭлемент);
                         }
                   }
                return c;
        }

        /***********************************************************************

                 Временная ёмкость: O(1)

        ***********************************************************************/

        final З голова (З значение)
        {
                auto ячейка = перваяЯчейка;
                auto знач = ячейка.значение;
                ячейка.значение = значение;
                измени;
                return знач;
        }

        /***********************************************************************

                 Временная ёмкость: O(1)

        ***********************************************************************/

        final З удалиГолову ()
        {
                auto p = перваяЯчейка;
                auto знач = p.значение;
                список = p.следщ;
                декремент (p);
                return знач;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final СвязныйСписок добавь (З значение)
        {
                if (список is пусто)
                    приставь (значение);
                else
                   {
                   список.хвост.следщ = куча.размести.установи (значение, пусто);
                   инкремент;
                   }
                return this;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final З хвост (З значение)
        {
                auto p = последняяЯчейка;
                auto знач = p.значение;
                p.значение = значение;
                измени;
                return знач;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final З удалиХвост ()
        {
                if (перваяЯчейка.следщ is пусто)
                    return удалиГолову;

                auto хвост = список;
                auto p = хвост.следщ;

                while (p.следщ)
                      {
                      хвост = p;
                      p = p.следщ;
                      }
                хвост.следщ = пусто;
                auto знач = p.значение;
                декремент (p);
                return знач;
        }

        /***********************************************************************

                Временная ёмкость: O(n)

        ***********************************************************************/

        final СвязныйСписок добавьПо (т_мера индекс, З значение)
        {
                if (индекс is 0)
                    приставь (значение);
                else
                   {
                   ячейкаПо(индекс - 1).прикрепи (куча.размести.установи(значение, пусто));
                   инкремент;
                   }
                return this;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final СвязныйСписок удалиПо (т_мера индекс)
        {
                if (индекс is 0)
                    удалиГолову;
                else
                   {
                   auto p = ячейкаПо (индекс - 1);
                   auto t = p.следщ;
                   p.отторочьСледщ;
                   декремент (t);
                   }
                return this;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        final СвязныйСписок замениПо (т_мера индекс, З значение)
        {
                ячейкаПо(индекс).значение = значение;
                измени;
                return this;
        }

        /***********************************************************************

                 Временная ёмкость: O(число элементов в e)

        ***********************************************************************/

        final т_мера приставь (ИКонтейнер!(З) e)
        {
                auto c = счёт;
                splice_ (e, пусто, список);
                return счёт - c;
        }

        /***********************************************************************

                 Временная ёмкость: O(n + число элементов в e)

        ***********************************************************************/

        final т_мера добавь (ИКонтейнер!(З) e)
        {
                auto c = счёт;
                if (список is пусто)
                    splice_ (e, пусто, пусто);
                else
                   splice_ (e, список.хвост, пусто);
                return счёт - c;
        }

        /***********************************************************************

                Временная ёмкость: O(n + число элементов в e)

        ***********************************************************************/

        final т_мера добавьПо (т_мера индекс, ИКонтейнер!(З) e)
        {
                auto c = счёт;
                if (индекс is 0)
                    splice_ (e, пусто, список);
                else
                   {
                   auto p = ячейкаПо (индекс - 1);
                   splice_ (e, p, p.следщ);
                   }
                return счёт - c;
        }

        /***********************************************************************

                Временная ёмкость: O(n)

        ***********************************************************************/

        final т_мера удалиДиапазон (т_мера отИндекса, т_мера доИндекса)
        {
                auto c = счёт;
                if (отИндекса <= доИндекса)
                   {
                   if (отИндекса is 0)
                      {
                      auto p = перваяЯчейка;
                      for (т_мера i = отИндекса; i <= доИндекса; ++i)
                           p = p.следщ;
                      список = p;
                      }
                   else
                      {
                      auto f = ячейкаПо (отИндекса - 1);
                      auto p = f;
                      for (т_мера i = отИндекса; i <= доИндекса; ++i)
                           p = p.следщ;
                      f.следщ = p.следщ;
                      }

                  счёт -= (доИндекса - отИндекса + 1);
                  измени;
                  }
                return c - счёт;
        }

        /***********************************************************************

                Копирует и возвращает содержащийся набор значений в массиве, 
                используя опциональный приёмн как реципиент (размер которого меняется 
                при необхожимости).

                Возвращает срез приёмн, представляющий значения этого контейнера.
                
                Временная ёмкость: O(n)
                
        ***********************************************************************/

        final З[] вМассив (З[] приёмн = пусто)
        {
                if (приёмн.length < счёт)
                    приёмн.length = счёт;

                т_мера i = 0;
                foreach (знач; this)
                         приёмн[i++] = знач;
                return приёмн [0 .. счёт];                        
        }

        /***********************************************************************

                Пуст ли этот контейнер?
                
                Временная ёмкость: O(1)
                
        ***********************************************************************/

        final бул пуст_ли ()
        {
                return счёт is 0;
        }

        /***********************************************************************

        ***********************************************************************/

        final СвязныйСписок проверь ()
        {
                assert(((счёт is 0) is (список is пусто)));
                assert((список is пусто || список.счёт is размер));

                т_мера c = 0;
                for (Реф p = список; p; p = p.следщ)
                    {
                    assert(экземпляры(p.значение) > 0);
                    assert(содержит(p.значение));
                    ++c;
                    }
                assert(c is счёт);
                return this;
        }

        /***********************************************************************

                 Временная ёмкость: O(n)

        ***********************************************************************/

        private т_мера экземпляры (З значение)
        {
                if (счёт is 0)
                    return 0;

                return список.счёт (значение);
        }

        /***********************************************************************

        ***********************************************************************/

        private Реф перваяЯчейка ()
        {
                проверьИндекс (0);
                return список;
        }

        /***********************************************************************

        ***********************************************************************/

        private Реф последняяЯчейка ()
        {
                проверьИндекс (0);
                return список.хвост;
        }

        /***********************************************************************

        ***********************************************************************/

        private Реф ячейкаПо (т_мера индекс)
        {
                проверьИндекс (индекс);
                return список.н_ый (индекс);
        }

        /***********************************************************************

        ***********************************************************************/

        private проц проверьИндекс (т_мера индекс)
        {
                if (индекс >= счёт)
                    throw new Исключение ("вне диапазона");
        }

        /***********************************************************************

                Splice элементы e между hd и tl. Если hd 
                пусто, вернуть новый hd.

                Возвращает счёт новых добавленных элементов.

        ***********************************************************************/

        private проц splice_ (ИКонтейнер!(З) e, Реф hd, Реф tl)
        {
                Реф новый_список = пусто;
                Реф текущ = пусто;

                foreach (знач; e)
                        {
                        инкремент;

                        auto p = куча.размести.установи (знач, пусто);
                        if (новый_список is пусто)
                            новый_список = p;
                        else
                           текущ.следщ = p;
                        текущ = p;
                        }

                if (текущ)
                   {
                   текущ.следщ = tl;

                   if (hd is пусто)
                       список = новый_список;
                   else
                      hd.следщ = новый_список;
                   }
        }

        /***********************************************************************

                Временная ёмкость: O(n)

        ***********************************************************************/

        private СвязныйСписок очисть (бул все)
        {
                измени;

                if (куча.собери(все) is нет && счёт)
                   {
                   auto p = список;
                   while (p)
                         {
                         auto n = p.следщ;
                         декремент (p);
                         p = n;
                         }
                   }
        
                список = пусто;
                счёт = 0;
                return this;
        }

        /***********************************************************************

                Был добавлен новый элемент.
                
        ***********************************************************************/

        private проц инкремент ()
        {
                ++изменение;
                ++счёт;
        }
        
        /***********************************************************************

                Элемент был удалён.
                
        ***********************************************************************/

        private проц декремент (Реф p)
        {
                Извл (p.значение);
                куча.собери (p);
                ++изменение;
                --счёт;
        }
        
        /***********************************************************************

                Набор изменён.
                
        ***********************************************************************/

        private проц измени ()
        {
                ++изменение;
        }

        /***********************************************************************

                Обходчик списка.

        ***********************************************************************/

        private struct Обходчик
        {
                Реф             узел;
                Реф*            hook,
                                приор;
                СвязныйСписок      хозяин;
                т_мера          изменение;

                /***************************************************************

                        Не изменился ли контейнер без нас?

                ***************************************************************/

                бул действителен ()
                {
                        return хозяин.изменение is изменение;
                }               

                /***************************************************************

                        Даёт доступ к следщ значение, и возвращает нет, когда
                        больше не осталось значений для обхода.

                ***************************************************************/

                бул следщ (ref З знач)
                {
                        auto n = следщ;
                        return (n) ? знач = *n, да : нет;
                }
                
                /***************************************************************

                        Возвращает указатель на следщ значение, либо пусто, когда
                        больше не осталось значений для обхода.

                ***************************************************************/

                З* следщ ()
                {
                        З* r;
                        if (узел)
                           {
                           приор = hook;
                           r = &узел.значение;
                           узел = *(hook = &узел.следщ);
                           }
                        return r;
                }

                /***************************************************************

                        Вставить новое значение перед узлом, который
                        вскоре будет обходиться
                        (или после узла, который был только что обойдён).

                ***************************************************************/

                проц вставь(З значение)
                {
                        // вставить узел перед узлом, котоый
                        // предстоит под итерацию.
                        *hook = хозяин.куча.размести.установи(значение, *hook);
                        узел = *hook;
                        следщ();

                        // обновить счёт хозяина, и проигнорировать это
                        // изменение в "изменение".
                        хозяин.инкремент;
                        изменение++;
                }

                /***************************************************************

                        Вставить новое значение перед значением, которое
                        только что итерировано.

                        Возвращает да, если приор узел существовал и
                        вставка сработала.  Нет иначе.

                ***************************************************************/

                бул вставьПрежде(З значение)
                {
                    if(приор)
                    {
                        // вставь a узел previous в_ the узел that we just
                        // iterated.
                        *приор = хозяин.куча.размести.установи(значение, *приор);
                        приор = &(*приор).следщ;

                        // обнови the счёт of the хозяин, и ignore this
                        // change in the изменение.
                        хозяин.инкремент;
                        изменение++;
                        return да;
                    }
                    return нет;
                }

                /***************************************************************

                       Поддержка Foreach.

                ***************************************************************/

                цел opApply (цел delegate(ref З значение) дг)
                {
                        цел результат;

                        auto n = узел;
                        while (n)
                              {
                              приор = hook;
                              hook = &n.следщ;
                              if ((результат = дг(n.значение)) != 0)
                                   break;
                              n = *hook;
                              }
                        узел = n;
                        return результат;
                }                               

                /***************************************************************

                        Удалить значение в текущей локации обходчика.

                ***************************************************************/

                бул удали ()
                {
                        if (приор)
                           {
                           auto p = *приор;
                           *приор = p.следщ;
                           хозяин.декремент (p);
                           hook = приор;
                           приор = пусто;

                           // ignore this change
                           ++изменение;
                           return да;
                           }
                        return нет;
                }
        }
}


/*******************************************************************************

*******************************************************************************/

debug (СвязныйСписок)
{
        import io.Stdout;
        import thread;
        import time.StopWatch;

        проц main()
        {
                // usage examples ...
                auto установи = new СвязныйСписок!(ткст);
                установи.добавь ("foo");
                установи.добавь ("bar");
                установи.добавь ("wumpus");

                // implicit генерный iteration
                foreach (значение; установи)
                         Стдвыв (значение).нс;

                // явный генерный iteration   
                foreach (значение; установи.обходчик)
                         Стдвыв.форматнс ("{}", значение);

                // генерный iteration with optional удали и вставь
                auto s = установи.обходчик;
                foreach (значение; s)
                {
                         if (значение == "foo")
                             s.удали;
                         if (значение == "bar")
                             s.вставьПрежде("bloomper");
                         if (значение == "wumpus")
                             s.вставь("rumple");
                }

                установи.проверь();

                // incremental iteration, with optional удали
                ткст знач;
                auto обходчик = установи.обходчик;
                while (обходчик.следщ(знач))
                      {} //обходчик.удали;
                
                // incremental iteration, with optional failfast
                auto it = установи.обходчик;
                while (it.действителен && it.следщ(знач))
                      {}

                // удали specific элемент
                установи.удали ("wumpus");

                // удали первый элемент ...
                while (установи.возьми(знач))
                       Стдвыв.форматнс ("taking {}, {} лево", знач, установи.размер);
                
                
                // установи for benchmark, with набор of целыйs. We
                // use a чанк разместитель, и presize the бакет[]
                auto тест = new СвязныйСписок!(цел, Контейнер.извлеки, Контейнер.Чанк);
                тест.кэш (2000, 1_000_000);
                const счёт = 1_000_000;
                Секундомер w;

                // benchmark добавим
                w.старт;
                for (цел i=счёт; i--;)
                     тест.приставь(i);
                Стдвыв.форматнс ("{} добавьs: {}/s", тест.размер, тест.размер/w.stop);

                // benchmark добавим without allocation overhead
                тест.очисть;
                w.старт;
                for (цел i=счёт; i--;)
                     тест.приставь(i);
                Стдвыв.форматнс ("{} добавьs (после очисть): {}/s", тест.размер, тест.размер/w.stop);

                // benchmark duplication
                w.старт;
                auto dup = тест.dup;
                Стдвыв.форматнс ("{} элемент dup: {}/s", dup.размер, dup.размер/w.stop);

                // benchmark iteration
                w.старт;
                auto xx = тест.обходчик;
                цел ii;
                while (xx.следщ()) {}
                Стдвыв.форматнс ("{} элемент iteration: {}/s", тест.размер, тест.размер/w.stop);

                // benchmark iteration
                w.старт;
                foreach (знач; тест) {}
                Стдвыв.форматнс ("{} foreach iteration: {}/s", тест.размер, тест.размер/w.stop);


                // benchmark iteration
                w.старт;             
                foreach (ref iii; тест) {} 
                Стдвыв.форматнс ("{} pointer iteration: {}/s", тест.размер, тест.размер/w.stop);

                тест.проверь;
        }
}
                
