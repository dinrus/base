module col.Iterators;

public import col.model.Iterator;

/+ ИНТЕРФЕЙС:

class ТрансформОбходчик(З, U=З) : Обходчик!(З)
{
    this(Обходчик!(U) исток, проц delegate(ref U, ref З) дг);
    this(Обходчик!(U) исток, проц function(ref U, ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
}


class ТрансформКлючник(К, З, J=К, U=З) : Ключник!(К, З)
{
    this(Ключник!(J, U) исток, проц delegate(ref J, ref U, ref К, ref З) дг);
    this(Ключник!(J, U) исток, проц function(ref J, ref U, ref К, ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
    цел opApply(цел delegate(ref К к, ref З з) дг);
}

class ОбходчикЦепи(З) : Обходчик!(З)
{

    this(Обходчик!(З)[] цепь ...);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
}

class КлючникЦепи(К, З) : Ключник!(К, З)
{
    this(Ключник!(К, З)[] цепь ...);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
    цел opApply(цел delegate(ref К, ref З) дг);
}

class ФильтрОбходчик(З) : Обходчик!(З)
{
    this(Обходчик!(З) исток, бул delegate(ref З) дг);
    this(Обходчик!(З) исток, бул function(ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
}

class ФильтрКлючник(К, З) : Ключник!(К, З)
{
    this(Ключник!(К, З) исток, бул delegate(ref К, ref З) дг);
    this(Ключник!(К, З) исток, бул function(ref К, ref З) фн);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З з) дг);
    цел opApply(цел delegate(ref К к, ref З з) дг);
}

class ОбходчикМассива(З) : Обходчик!(З)
{
    this(З[] массив);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref З) дг);
}

class ОбходчикАМ(К, З) : Ключник!(К, З)
{
    this(З[К] массив);
    бцел длина();
	alias длина length;
    цел opApply(цел delegate(ref К, ref З) дг);
}

З[] вМассив(З)(Обходчик!(З) обх);
З[К] вАссоцМасс(К, З)(Ключник!(К, З) обх);

+/

/**
 * Этот обходчик преобразует каждый элемент из другого обходчика
 * с помощью функции преобразования.
 */
class ТрансформОбходчик(З, U=З) : Обходчик!(З)
{
    private Обходчик!(U) _ист;
    private проц delegate(ref U, ref З) _дг;
    private проц function(ref U, ref З) _фн;

    /**
     * Конструирует трансформ-обходчик, используя делегат.
     *
     * Функция преобразования преобразует объект типа U в типа З.
     */
    this(Обходчик!(U) исток, проц delegate(ref U, ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * Конструирует обходчик, используя указатель на функцию преобразования.
     *
     * Функция преобразования преобразует объект типа U в объект типа З.
     */
    this(Обходчик!(U) исток, проц function(ref U, ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает длину истока.
     */
    бцел длина()
    {
        return _ист.length;
    }
	alias длина length;
    /**
     * Обходит исток, работая с временными копиями
     * трансформируемого элемента З.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел приватныйДГ(ref U u)
        {
            З з;
            _дг(u, з);
            return дг(з);
        }

        цел приватнаяФН(ref U u)
        {
            З з;
            _фн(u, з);
            return дг(з);
        }

        if(_дг is пусто)
            return _ист.opApply(&приватнаяФН);
        else
            return _ист.opApply(&приватныйДГ);
    }
}

/**
 * Трансформ для обходчика с ключом.
 */
class ТрансформКлючник(К, З, J=К, U=З) : Ключник!(К, З)
{
    private Ключник!(J, U) _ист;
    private проц delegate(ref J, ref U, ref К, ref З) _дг;
    private проц function(ref J, ref U, ref К, ref З) _фн;

    /**
     * Конструирует трансформ-обходчик с помощью трансформ-делегата.
     *
     * Функция преобразования преобразует пару J, U в пару К, З.
     */
    this(Ключник!(J, U) исток, проц delegate(ref J, ref U, ref К, ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * Конструирует трансформ-обходчик с помощью указателя на трансформ-функцию.
     *
     * Функция преобразования преобразует пару J, U в пару К, З.
     */
    this(Ключник!(J, U) исток, проц function(ref J, ref U, ref К, ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает длину истока.
     */
    бцел длина()
    {
        return _ист.length;
    }
	alias длина length;

    /**
     * Итерирует через обходчик исходника, работая с трансформированными копиями
     * трансформированного элемента З. К может быть пропущен, если это единственное
     * использование для этого обходчика.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел приватныйДГ(ref J j, ref U u)
        {
            К к;
            З з;
            _дг(j, u, к, з);
            return дг(з);
        }

        цел приватнаяФН(ref J j, ref U u)
        {
            К к;
            З з;
            _фн(j, u, к, з);
            return дг(з);
        }

        if(_дг is пусто)
            return _ист.opApply(&приватнаяФН);
        else
            return _ист.opApply(&приватныйДГ);
    }

    /**
     * Итерирует через обходчик исходника, работая с трансформированными копиями
     * пары К,З.
     */
    цел opApply(цел delegate(ref К к, ref З з) дг)
    {
        цел приватныйДГ(ref J j, ref U u)
        {
            К к;
            З з;
            _дг(j, u, к, з);
            return дг(к, з);
        }

        цел приватнаяФН(ref J j, ref U u)
        {
            К к;
            З з;
            _фн(j, u, к, з);
            return дг(к, з);
        }

        if(_дг is пусто)
            return _ист.opApply(&приватнаяФН);
        else
            return _ист.opApply(&приватныйДГ);
    }
}

/**
 * Цепной обходчик создаёт цепочку из нескольких обходчиков.
 */
class ОбходчикЦепи(З) : Обходчик!(З)
{
    private Обходчик!(З)[] _цепь;
    private бул _поддержкаДлины;

    /**
     * Конструктор. Передаёт обходчики, которые нужно сцепить вместе, в том
     * порядке, который нужен.
     *
     * Если все эти обходчики поддерживают длину, то и этот обходчик поддерживает
     * длину.  Если хоть один не поддерживает, то длина не поддерживается вообще.
     */
    this(Обходчик!(З)[] цепь ...)
    {
        _цепь = цепь.dup;
        _поддержкаДлины = да;
        foreach(обх; _цепь)
            if(обх.length == ~0)
            {
                _поддержкаДлины = нет;
                break;
            }
    }

    /**
     * Возвращает сумму длин всех обходчиков в цепи.
     *
     * Возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ, если хоть один обходчик в цепи не поддерживает
     * длину.
     */
    бцел длина()
    {
        if(_поддержкаДлины)
        {
            бцел рез = 0;
            foreach(обх; _цепь)
                рез += обх.length;
            return рез;
        }
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     * Итерирует через цепочку обходчиков.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел рез = 0;
        foreach(обх; _цепь)
        {
            if((рез = обх.opApply(дг)) != 0)
                break;
        }
        return рез;
    }
}

/**
 * Обходчик цепи, который сцепляет вместе несколько обходчиков.
 */
class КлючникЦепи(К, З) : Ключник!(К, З)
{
    private Ключник!(К, З)[] _цепь;
    private бул _поддержкаДлины;

    /**
     * Конструктор. Передаёт обходчики, которые нужно сцепить вместе, в том
     * порядке, который нужен.
     *
     * Если все эти обходчики поддерживают длину, то и этот обходчик поддерживает
     * длину.  Если хоть один не поддерживает, то длина не поддерживается вообще.
     */
    this(Ключник!(К, З)[] цепь ...)
    {
        _цепь = цепь.dup;
        _поддержкаДлины = да;
        foreach(обх; _цепь)
            if(обх.length == ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ)
            {
                _поддержкаДлины = нет;
                break;
            }
    }

    /**
     * Возвращает сумму длин всех обходчиков в цепи.
     *
     * Возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ, если любой из обходчиков в цепи возвращает -1 для свойства длина.
     */
    бцел длина()
    {
        if(_поддержкаДлины)
        {
            бцел рез = 0;
            foreach(обх; _цепь)
                рез += обх.length;
            return рез;
        }
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     * Итерирует через цепочку обходчиков, используя только значения.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел рез = 0;
        foreach(обх; _цепь)
        {
            if((рез = обх.opApply(дг)) != 0)
                break;
        }
        return рез;
    }

    /**
     * Итерирует через цепочку обходчиков, используя ключи и значения.
     */
    цел opApply(цел delegate(ref К, ref З) дг)
    {
        цел рез = 0;
        foreach(обх; _цепь)
        {
            if((рез = обх.opApply(дг)) != 0)
                break;
        }
        return рез;
    }
}

/**
 * Фильтрующий обходчик, который фильтрует нежелаемые элементы, основываясь на функции или
 * делегате.
 */
class ФильтрОбходчик(З) : Обходчик!(З)
{
    private Обходчик!(З) _ист;
    private бул delegate(ref З) _дг;
    private бул function(ref З) _фн;

    /**
     * Конструирует фильтрующий обходчик с заданным делегатом, который решает,
     * делать обход элемента или нет.
     *
     * Этот делегат должен возвращать да для элементов, которые следует итерировать.
     */
    this(Обходчик!(З) исток, бул delegate(ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * Конструирует фильтрующий обходчик с заданной функцией, которая решает,
     * делать обход элемента или нет.
     *
     * Эта функция должна возвращать да для элементов, которые следует итерировать.
     */
    this(Обходчик!(З) исток, бул function(ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ.
     */
    бцел длина()
    {
        //
        // Ей не известно, что фильтрующий делегат/функция решит.
        //
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     * Итерирует через обходчик исходника, принимая только элементы, в которых
     * делегат/функция возвращает да.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел приватныйДГ(ref З з)
        {
            if(_дг(з))
                return дг(з);
            return 0;
        }

        цел приватнаяФН(ref З з)
        {
            if(_фн(з))
                return дг(з);
            return 0;
        }

        if(_дг is пусто)
            return _ист.opApply(&приватнаяФН);
        else
            return _ист.opApply(&приватныйДГ);
    }
}

/**
 * Фильтрующий обходчик фильтрует нежелательные элементы на базе функции или
 * делегата. Эта версия фильтрует на обходчике с ключами.
 */
class ФильтрКлючник(К, З) : Ключник!(К, З)
{
    private Ключник!(К, З) _ист;
    private бул delegate(ref К, ref З) _дг;
    private бул function(ref К, ref З) _фн;

    /**
     * Конструирует фильтрующий обходчик с заданным делегатом, который решает,
     * делать обход пары ключ/значение или нет.
     *
     * Этот делегат должен возвращать да для элементов, которые следует итерировать.
     */
    this(Ключник!(К, З) исток, бул delegate(ref К, ref З) дг)
    {
        _ист = исток;
        _дг = дг;
    }

    /**
     * Конструирует фильтрующий обходчик с заданной функцией, которая решает,
     * делать обход пары ключ/значение или нет.
     *
     * Эта функция должна возвращать да для элементов, которые следует итерировать.
     */
    this(Ключник!(К, З) исток, бул function(ref К, ref З) фн)
    {
        _ист = исток;
        _фн = фн;
    }

    /**
     * Возвращает ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ.
     */
    бцел длина()
    {
        //
        //Ей не известно, что фильтрующий делегат/функция решит.
        //
        return ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ;
    }
	alias длина length;
    /**
     * Итерирует через обходчик исходника, принимая только элементы, в которых
     * делегат/функция возвращает да.
     */
    цел opApply(цел delegate(ref З з) дг)
    {
        цел приватныйДГ(ref К к, ref З з)
        {
            if(_дг(к, з))
                return дг(з);
            return 0;
        }

        цел приватнаяФН(ref К к, ref З з)
        {
            if(_фн(к, з))
                return дг(з);
            return 0;
        }

        if(_дг is пусто)
            return _ист.opApply(&приватнаяФН);
        else
            return _ист.opApply(&приватныйДГ);
    }

    /**
     * Итерирует через обходчик исходника, принимая только элементы, в которых
     * делегат/функция возвращает да.
     */
    цел opApply(цел delegate(ref К к, ref З з) дг)
    {
        цел приватныйДГ(ref К к, ref З з)
        {
            if(_дг(к, з))
                return дг(к, з);
            return 0;
        }

        цел приватнаяФН(ref К к, ref З з)
        {
            if(_фн(к, з))
                return дг(к, з);
            return 0;
        }

        if(_дг is пусто)
            return _ист.opApply(&приватнаяФН);
        else
            return _ист.opApply(&приватныйДГ);
    }
}

/**
 * Простой итератор-обёртка для массива.
 */
class ОбходчикМассива(З) : Обходчик!(З)
{
    private З[] _массив;

    /**
     * Оборачивает заданный массив. Заметьте, что этим копия не делается.
     */
    this(З[] массив)
    {
        _массив = массив;
    }
	
    /**
     * Возвращает длину массива.
     */
    бцел длина()
    {
        return _массив.length;
    }
	alias длина length;
	
    /**
     * Итерирует через массив.
     */
    цел opApply(цел delegate(ref З) дг)
    {
        цел возврзнач = 0;
        foreach(ref x; _массив)
            if((возврзнач = дг(x)) != 0)
                break;
        return возврзнач;
    }
}

/**
 *  Итератор-обёртка для ассоциативного массива.
 */
class ОбходчикАМ(К, З) : Ключник!(К, З)
{
    private З[К] _массив;

    /**
     * Конструирует итератор-обёртку для заданного массива.
     */
    this(З[К] массив)
    {
        _массив = массив;
    }

    /**
     * Возвращает длину обёрнутого AA.
     */
    бцел длина()
    {
        return _массив.length;// || _массив.length;
    }

	alias длина length;
    /**
     * Итерирует по AA.
     */
    цел opApply(цел delegate(ref К, ref З) дг)
    {
        цел возврзнач;
        foreach(к, ref з; _массив)
            if((возврзнач = дг(к, з)) != 0)
                break;
        return возврзнач;
    }
}

/**
 * Функция, которая преобразует обходчик в массив.
 *
 * Более оптимизирована для итераторов, поддерживающих длину.
 */
З[] вМассив(З)(Обходчик!(З) обх)
{
    З[] рез;
    бцел длин = обх.length;
    if(длин != ДЛИНА_НЕ_ПОДДЕРЖИВАЕТСЯ)
    {
        //
        // can optimize a bit
        //
        рез.length = длин;
        цел i = 0;
        foreach(з; обх)
            рез[i++] = з;
    }
    else
    {
        foreach(з; обх)
            рез ~= з;
    }
    return рез;
}

/**
 * Преобразует итератор с ключами в ассоциативный массив.
 */
З[К] вАссоцМасс(К, З)(Ключник!(К, З) обх)
{
    З[К] рез;
    foreach(к, з; обх)
        рез[к] = з;
    return рез;
}
