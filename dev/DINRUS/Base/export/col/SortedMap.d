/*******************************************************************************
        Based upon Doug Lea's Java collection package
*******************************************************************************/

module col.SortedMap;

public  import  col.Container;
private import  col.RedBlack;
private import  col.model.IContainer;
private import exception: НетЭлементаИскл;

/*******************************************************************************

        КрасноЧёрное trees of (ключ, значение) pairs

        ---
        Обходчик обходчик (бул вперёд)
        Обходчик обходчик (К ключ, бул вперёд)
        цел opApply (цел delegate (ref З значение) дг)
        цел opApply (цел delegate (ref К ключ, ref З значение) дг)

        бул содержит (З значение)
        бул содержитКлюч (К ключ)
        бул содержитПару (К ключ, З значение)
        бул ключК (З значение, ref К ключ)
        бул получи (К ключ, ref З значение)

        бул возьми (ref З знач)
        бул возьми (К ключ, ref З знач)
        бул удалиКлюч (К ключ)
        т_мера удали (З значение, бул все)
        т_мера удали (ИКонтейнер!(З) e, бул все)

        бул добавь (К ключ, З значение)
        т_мера замени (З старЭлемент, З новЭлемент, бул все)
        бул замениПару (К ключ, З старЭлемент, З новЭлемент)
        бул opIndexAssign (З элемент, К ключ)
        К    близкийКлюч (К ключ, бул greater)
        З    opIndex (К ключ)
        З*   opIn_r (К ключ)

        т_мера размер ()
        бул пуст_ли ()
        З[] вМассив (З[] приёмн)
        СортированнаяКарта dup ()
        СортированнаяКарта очисть ()
        СортированнаяКарта сбрось ()
        СортированнаяКарта сравнитель (Сравнитель c)
        ---

*******************************************************************************/

class СортированнаяКарта (К, З, alias Извл = Контейнер.извлеки,
                     alias Куча = Контейнер.ДефСбор)
        : ИКонтейнер!(З)
{
    // use this тип for Разместитель configuration
    public alias КрасноЧёрное!(К, З)    Тип;
    private alias Тип              *Реф;

    private alias Куча!(Тип)       Размест;
    private alias Сравни!(К)       Сравнитель;

    // корень of the дерево. Пусто if пустой.
    package Реф                     дерево;

    // configured куча manager
    private Размест                   куча;

    // Comparators использован for ordering
    private Сравнитель              cmp;
    private Сравни!(З)             cmpElem;

    private т_мера                  счёт,
            изменение;


    /***********************************************************************

            Make an пустой дерево, using given Сравнитель for ordering

    ***********************************************************************/

    public this (Сравнитель c = пусто)
    {
        this (c, 0);
    }

    /***********************************************************************

            Special version of constructor needed by dup()

    ***********************************************************************/

    private this (Сравнитель c, т_мера n)
    {
        счёт = n;
        cmpElem = &сравниЭлем;
        cmp = (c is пусто) ? &сравниКлюч : c;
    }

    /***********************************************************************

            Clean up when deleted

    ***********************************************************************/

    ~this ()
    {
        сбрось;
    }

    /***********************************************************************

            Return a генерный обходчик for contained элементы

    ***********************************************************************/

    final Обходчик обходчик (бул вперёд = да)
    {
        Обходчик i =void;
        i.узел = счёт ? (вперёд ? дерево.левейший : дерево.правейший) : пусто;
        i.bump = вперёд ? &Обходчик.передний : &Обходчик.задний;
        i.изменение = изменение;
        i.хозяин = this;
        i.приор = пусто;
        return i;
    }

    /***********************************************************************

            Return an обходчик which return все элементы совпадают
            or greater/lesser than the ключ in аргумент. The секунда
            аргумент dictates traversal direction.

            Return a генерный обходчик for contained элементы

    ***********************************************************************/

    final Обходчик обходчик (К ключ, бул вперёд)
    {
        Обходчик i = обходчик (вперёд);
        i.узел = счёт ? дерево.найдиПервый(ключ, cmp, вперёд) : пусто;
        return i;
    }

    /***********************************************************************

            Configure the назначено разместитель with the размер of each
            allocation блок (число of узелs allocated at one время)
            и the число of узелs в_ pre-наполни the кэш with.

            Временная ёмкость: O(n)

    ***********************************************************************/

    final СортированнаяКарта кэш (т_мера чанк, т_мера счёт=0)
    {
        куча.конфиг (чанк, счёт);
        return this;
    }

    /***********************************************************************

            Return the число of элементы contained

    ***********************************************************************/

    final т_мера размер ()
    {
        return счёт;
    }

    /***********************************************************************

            Созд an independent копируй. Does not клонируй элементы

    ***********************************************************************/

    final СортированнаяКарта dup ()
    {
        auto клонируй = new СортированнаяКарта!(К, З, Извл, куча) (cmp, счёт);
        if (счёт)
            клонируй.дерево = дерево.копируйДерево (&клонируй.куча.размести);

        return клонируй;
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

    ***********************************************************************/

    final бул содержит (З значение)
    {
        if (счёт is 0)
            return нет;
        return дерево.найдиАтрибут (значение, cmpElem) !is пусто;
    }

    /***********************************************************************

    ***********************************************************************/

    final цел opApply (цел delegate (ref З значение) дг)
    {
        return обходчик.opApply ((ref К ключ, ref З знач)
        {
            return дг(знач);
        });
    }


    /***********************************************************************

    ***********************************************************************/

    final цел opApply (цел delegate (ref К ключ, ref З значение) дг)
    {
        return обходчик.opApply (дг);
    }

    /***********************************************************************

            Use a new Сравнитель. Causes a reorganization

    ***********************************************************************/

    final СортированнаяКарта сравнитель (Сравнитель c)
    {
        if (cmp !is c)
        {
            cmp = (c is пусто) ? &сравниКлюч : c;

            if (счёт !is 0)
            {
                // must rebuild дерево!
                измени;
                auto t = дерево.левейший;
                дерево = пусто;
                счёт = 0;

                while (t)
                {
                    добавь_ (t.значение, t.атрибут, нет);
                    t = t.потомок;
                }
            }
        }
        return this;
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

    ***********************************************************************/

    final бул содержитКлюч (К ключ)
    {
        if (счёт is 0)
            return нет;

        return дерево.найди (ключ, cmp) !is пусто;
    }

    /***********************************************************************

            Временная ёмкость: O(n)

    ***********************************************************************/

    final бул содержитПару (К ключ, З значение)
    {
        if (счёт is 0)
            return нет;

        return дерево.найди (ключ, значение, cmp) !is пусто;
    }

    /***********************************************************************

            Return the значение associated with Key ключ.

            param: ключ a ключ
            Возвращает: whether the ключ is contained or not

    ***********************************************************************/

    final бул получи (К ключ, ref З значение)
    {
        if (счёт)
        {
            auto p = дерево.найди (ключ, cmp);
            if (p)
            {
                значение = p.атрибут;
                return да;
            }
        }
        return нет;
    }

    /***********************************************************************

            Return the значение of the ключ exactly совпадают the предоставленный
            ключ or, if Неук, the ключ just после/before it based on the
            настройка of the секунда аргумент

            param: ключ a ключ
            param: после indicates whether в_ look beyond or before
                   the given ключ, where there is no exact сверь
            throws: НетЭлементаИскл if Неук найдено
            returns: a pointer в_ the значение, or пусто if not present

    ***********************************************************************/

    К близкийКлюч (К ключ, бул после)
    {
        if (счёт)
        {
            auto p = дерево.найдиПервый (ключ, cmp, после);
            if (p)
                return p.значение;
        }

        нетТакогоЭлемента ("такой ключ отсутствует");
        assert (0);
    }

    /***********************************************************************

            Return the первый ключ of the карта

            throws: НетЭлементаИскл where the карта is пустой

    ***********************************************************************/

    К первыйКлюч ()
    {
        if (счёт)
            return дерево.левейший.значение;

        нетТакогоЭлемента ("такой ключ отсутствует");
        assert (0);
    }

    /***********************************************************************

            Return the последний ключ of the карта

            throws: НетЭлементаИскл where the карта is пустой

    ***********************************************************************/

    К последнийКлюч ()
    {
        if (счёт)
            return дерево.правейший.значение;

        нетТакогоЭлемента ("такой ключ отсутствует");
        assert (0);
    }

    /***********************************************************************

            Return the значение associated with Key ключ.

            param: ключ a ключ
            Возвращает: a pointer в_ the значение, or пусто if not present

    ***********************************************************************/

    final З* opIn_r (К ключ)
    {
        if (счёт)
        {
            auto p = дерево.найди (ключ, cmp);
            if (p)
                return &p.атрибут;
        }
        return пусто;
    }

    /***********************************************************************

            Временная ёмкость: O(n)

    ***********************************************************************/

    final бул ключК (З значение, ref К ключ)
    {
        if (счёт is 0)
            return нет;

        auto p = дерево.найдиАтрибут (значение, cmpElem);
        if (p is пусто)
            return нет;

        ключ = p.значение;
        return да;
    }

    /***********************************************************************

            Временная ёмкость: O(n)

    ***********************************************************************/

    final СортированнаяКарта очисть ()
    {
        return очисть (нет);
    }

    /***********************************************************************

            Reset the СортированнаяКарта contents. This releases ещё память
            than очисть() does

            Временная ёмкость: O(n)

    ***********************************************************************/

    final СортированнаяКарта сбрось ()
    {
        return очисть (да);
    }

    /***********************************************************************

    ************************************************************************/

    final т_мера удали (ИКонтейнер!(З) e, бул все)
    {
        auto c = счёт;
        foreach (знач; e)
        удали (знач, все);
        return c - счёт;
    }

    /***********************************************************************

            Временная ёмкость: O(n

    ***********************************************************************/

    final т_мера удали (З значение, бул все = нет)
    {
        т_мера i = счёт;
        if (счёт)
        {
            auto p = дерево.найдиАтрибут (значение, cmpElem);
            while (p)
            {
                дерево = p.удали (дерево);
                декремент (p);
                if (!все || счёт is 0)
                    break;
                p = дерево.найдиАтрибут (значение, cmpElem);
            }
        }
        return i - счёт;
    }

    /***********************************************************************

            Временная ёмкость: O(n)

    ***********************************************************************/

    final т_мера замени (З старЭлемент, З новЭлемент, бул все = нет)
    {
        т_мера c;

        if (счёт)
        {
            auto p = дерево.найдиАтрибут (старЭлемент, cmpElem);
            while (p)
            {
                ++c;
                измени;
                p.атрибут = новЭлемент;
                if (!все)
                    break;
                p = дерево.найдиАтрибут (старЭлемент, cmpElem);
            }
        }
        return c;
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

            Takes the значение associated with the least ключ.

    ***********************************************************************/

    final бул возьми (ref З знач)
    {
        if (счёт)
        {
            auto p = дерево.левейший;
            знач = p.атрибут;
            дерево = p.удали (дерево);
            декремент (p);
            return да;
        }
        return нет;
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

    ***********************************************************************/

    final бул возьми (К ключ, ref З значение)
    {
        if (счёт)
        {
            auto p = дерево.найди (ключ, cmp);
            if (p)
            {
                значение = p.атрибут;
                дерево = p.удали (дерево);
                декремент (p);
                return да;
            }
        }
        return нет;
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

            Возвращает да if inserted, нет where an existing ключ
            есть_ли и was updated instead

    ***********************************************************************/

    final бул добавь (К ключ, З значение)
    {
        return добавь_ (ключ, значение, да);
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

            Возвращает да if inserted, нет where an existing ключ
            есть_ли и was updated instead

    ***********************************************************************/

    final бул opIndexAssign (З элемент, К ключ)
    {
        return добавь (ключ, элемент);
    }

    /***********************************************************************

            Оператор retreival function

            Throws НетЭлементаИскл where ключ is missing

    ***********************************************************************/

    final З opIndex (К ключ)
    {
        auto p = opIn_r (ключ);
        if (p)
            return *p;

        нетТакогоЭлемента ("отсутствующий или непригодный ключ");
        assert (0);
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

    ***********************************************************************/

    final бул удалиКлюч (К ключ)
    {
        З значение;

        return возьми (ключ, значение);
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

    ***********************************************************************/

    final бул замениПару (К ключ, З старЭлемент, З новЭлемент)
    {
        if (счёт)
        {
            auto p = дерево.найди (ключ, старЭлемент, cmp);
            if (p)
            {
                p.атрибут = новЭлемент;
                измени;
                return да;
            }
        }
        return нет;
    }

    /***********************************************************************

            Copy и return the contained установи of значения in an Массив,
            using the optional приёмн as a реципиент (which is resized
            as necessary).

            Возвращает срез of приёмн representing the container значения.

            Временная ёмкость: O(n)

    ***********************************************************************/

    final З[] вМассив (З[] приёмн = пусто)
    {
        if (приёмн.length < счёт)
            приёмн.length = счёт;

        т_мера i = 0;
        foreach (ключ, знач; this)
        приёмн[i++] = знач;
        return приёмн [0 .. счёт];
    }

    /***********************************************************************

            Is this container пустой?

            Временная ёмкость: O(1)

    ***********************************************************************/

    final бул пуст_ли ()
    {
        return счёт is 0;
    }

    /***********************************************************************


    ***********************************************************************/

    final СортированнаяКарта проверь ()
    {
        assert(cmp !is пусто);
        assert(((счёт is 0) is (дерево is пусто)));
        assert((дерево is пусто || дерево.размер() is счёт));

        if (дерево)
        {
            дерево.проверьРеализацию;
            auto t = дерево.левейший;
            К последний = К.init;

            while (t)
            {
                auto знач = t.значение;
                assert((последний is К.init || cmp(последний, знач) <= 0));
                последний = знач;
                t = t.потомок;
            }
        }
        return this;
    }


    /***********************************************************************


    ***********************************************************************/

    private проц нетТакогоЭлемента (ткст сооб)
    {
        throw new НетЭлементаИскл (сооб);
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

    ***********************************************************************/

    private т_мера экземпляры (З значение)
    {
        if (счёт is 0)
            return 0;
        return дерево.учтиАтрибут (значение, cmpElem);
    }

    /***********************************************************************

            Возвращает да where an элемент is добавьed, нет where an
            existing ключ is найдено

    ***********************************************************************/

    private final бул добавь_ (К ключ, З значение, бул проверьOccurrence)
    {
        if (дерево is пусто)
        {
            дерево = куча.размести.установи (ключ, значение);
            инкремент;
        }
        else
        {
            auto t = дерево;
            for (;;)
            {
                цел рознь = cmp (ключ, t.значение);
                if (рознь is 0 && проверьOccurrence)
                {
                    if (t.атрибут != значение)
                    {
                        t.атрибут = значение;
                        измени;
                    }
                    return нет;
                }
                else if (рознь <= 0)
                {
                    if (t.лево)
                        t = t.лево;
                    else
                    {
                        дерево = t.вставьЛевый (куча.размести.установи(ключ, значение), дерево);
                        инкремент;
                        break;
                    }
                }
                else
                {
                    if (t.право)
                        t = t.право;
                    else
                    {
                        дерево = t.вставьПравый (куча.размести.установи(ключ, значение), дерево);
                        инкремент;
                        break;
                    }
                }
            }
        }

        return да;
    }

    /***********************************************************************

            Временная ёмкость: O(n)

    ***********************************************************************/

    private СортированнаяКарта очисть (бул все)
    {
        измени;

        // собери each узел if we can't собери все at once
        if (куча.собери(все) is нет & счёт)
        {
            auto узел = дерево.левейший;
            while (узел)
            {
                auto следщ = узел.потомок;
                декремент (узел);
                узел = следщ;
            }
        }

        счёт = 0;
        дерево = пусто;
        return this;
    }

    /***********************************************************************

            Временная ёмкость: O(лог n)

    ***********************************************************************/

    private проц удали (Реф узел)
    {
        дерево = узел.удали (дерево);
        декремент (узел);
    }

    /***********************************************************************

            new элемент was добавьed

    ***********************************************************************/

    private проц инкремент ()
    {
        ++изменение;
        ++счёт;
    }

    /***********************************************************************

            элемент was removed

    ***********************************************************************/

    private проц декремент (Реф p)
    {
        Извл (p.значение, p.атрибут);
        куча.собери (p);
        ++изменение;
        --счёт;
    }

    /***********************************************************************

            установи was изменён

    ***********************************************************************/

    private проц измени ()
    {
        ++изменение;
    }

    /***********************************************************************

            The default ключ сравнитель

            @param перв первый аргумент
            @param втор секунда аргумент

            Возвращает: a негатив число if перв is less than втор; a
            positive число if перв is greater than втор; else 0

    ***********************************************************************/

    private static цел сравниКлюч (ref К перв, ref К втор)
    {
        if (перв is втор)
            return 0;

        return typeid(К).сравни (&перв, &втор);
    }


    /***********************************************************************

            The default значение сравнитель

            @param перв первый аргумент
            @param втор секунда аргумент

            Возвращает: a негатив число if перв is less than втор; a
            positive число if перв is greater than втор; else 0

    ***********************************************************************/

    private static цел сравниЭлем(ref З перв, ref З втор)
    {
        if (перв is втор)
            return 0;

        return typeid(З).сравни (&перв, &втор);
    }

    /***********************************************************************

            Обходчик with no filtering

    ***********************************************************************/

    private struct Обходчик
    {
        Реф function(Реф) bump;
        Реф               узел,
        приор;
        СортированнаяКарта         хозяин;
        т_мера            изменение;

        /***************************************************************

                Dопр the container change underneath us?

        ***************************************************************/

        бул действителен ()
        {
            return хозяин.изменение is изменение;
        }

        /***************************************************************

                Accesses the следщ значение, и returns нет when
                there are no further значения в_ traverse

        ***************************************************************/

        бул следщ (ref К ключ, ref З знач)
        {
            auto n = следщ (ключ);
            return (n) ? знач = *n, да : нет;
        }

        /***************************************************************

                Return a pointer в_ the следщ значение, or пусто when
                there are no further значения в_ traverse

        ***************************************************************/

        З* следщ (ref К ключ)
        {
            З* r;

            if (узел)
            {
                приор = узел;
                ключ = узел.значение;
                r = &узел.атрибут;
                узел = bump (узел);
            }
            return r;
        }

        /***************************************************************

                Foreach support

        ***************************************************************/

        цел opApply (цел delegate(ref К ключ, ref З значение) дг)
        {
            цел результат;

            auto n = узел;
            while (n)
            {
                приор = n;
                auto следщ = bump (n);
                if ((результат = дг(n.значение, n.атрибут)) != 0)
                    break;
                n = следщ;
            }
            узел = n;
            return результат;
        }

        /***************************************************************

                Удали значение at the текущ обходчик location

        ***************************************************************/

        бул удали ()
        {
            if (приор)
            {
                хозяин.удали (приор);

                // ignore this change
                ++изменение;
                return да;
            }

            приор = пусто;
            return нет;
        }

        /***************************************************************

        ***************************************************************/

        Обходчик реверс ()
        {
            if (bump is &передний)
                bump = &задний;
            else
                bump = &передний;
            return *this;
        }

        /***************************************************************

        ***************************************************************/

        private static Реф передний (Реф p)
        {
            return p.потомок;
        }

        /***************************************************************

        ***************************************************************/

        private static Реф задний (Реф p)
        {
            return p.предок;
        }
    }
}



/*******************************************************************************

*******************************************************************************/

debug (СортированнаяКарта)
{
    import io.Stdout;
    import thread;
    import time.StopWatch;
    import math.random.Kiss;

    проц main()
    {
        // usage examples ...
        auto карта = new СортированнаяКарта!(ткст, цел);
        карта.добавь ("foo", 1);
        карта.добавь ("bar", 2);
        карта.добавь ("wumpus", 3);

        // implicit генерный iteration
        foreach (ключ, значение; карта)
        Стдвыв.форматнс ("{}:{}", ключ, значение);

        // явный iteration
        foreach (ключ, значение; карта.обходчик("foo", нет))
        Стдвыв.форматнс ("{}:{}", ключ, значение);

        // генерный iteration with optional удали
        auto s = карта.обходчик;
        foreach (ключ, значение; s)
        {} // s.удали;

        // incremental iteration, with optional удали
        ткст ключ;
        цел    знач;
        auto обходчик = карта.обходчик;
        while (обходчик.следщ(ключ, знач))
        {} //обходчик.удали;

        // incremental iteration, with optional failfast
        auto it = карта.обходчик;
        while (it.действителен && it.следщ(ключ, знач))
        {}

        // удали specific элемент
        карта.удалиКлюч ("wumpus");

        // удали первый элемент ...
        while (карта.возьми(знач))
            Стдвыв.форматнс ("taking {}, {} лево", знач, карта.размер);


        // установи for benchmark, with a установи of целыйs. We
        // use a чанк разместитель, и presize the бакет[]
        auto тест = new СортированнаяКарта!(цел, цел, Контейнер.извлеки, Контейнер.Чанк);
        тест.кэш (1000, 500_000);
        const счёт = 500_000;
        Секундомер w;

        auto ключи = new цел[счёт];
        foreach (ref vv; ключи)
        vv = Kiss.экземпляр.вЦел(цел.max);

        // benchmark добавим
        w.старт;
        for (цел i=счёт; i--;)
            тест.добавь(ключи[i], i);
        Стдвыв.форматнс ("{} добавьs: {}/s", тест.размер, тест.размер/w.stop);

        // benchmark reading
        w.старт;
        for (цел i=счёт; i--;)
            тест.получи(ключи[i], знач);
        Стдвыв.форматнс ("{} lookups: {}/s", тест.размер, тест.размер/w.stop);

        // benchmark добавим without allocation overhead
        тест.очисть;
        w.старт;
        for (цел i=счёт; i--;)
            тест.добавь(ключи[i], i);
        Стдвыв.форматнс ("{} добавьs (после очисть): {}/s", тест.размер, тест.размер/w.stop);

        // benchmark duplication
        w.старт;
        auto dup = тест.dup;
        Стдвыв.форматнс ("{} элемент dup: {}/s", dup.размер, dup.размер/w.stop);

        // benchmark iteration
        w.старт;
        foreach (ключ, значение; тест) {}
        Стдвыв.форматнс ("{} элемент iteration: {}/s", тест.размер, тест.размер/w.stop);

        тест.проверь;
    }
}
