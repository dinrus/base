/**
 * Модуль "Сигнал" обеспечивает базовую реализацию образца listener,
 * используя модель "Сигналов  Слотов" из Qt.
 *
 */
module tpl.sigstruct;


private import tpl.array;


/**
 * Сигнал - это событие, которое содержит коллекцию датчиков или по-англ. 'listeners'
 * (по-другому называемых слотами, англ. 'slots').  При вызове сигнала этот
 * вызов распространяется по каждому прикреплённому слоту синхронным образом.
 * Слот вполне законно может вызывать методы "прикрепи" и "открепи", когда есть сигнал.
 * При этом события "прикрепи" выстраиваются в очередь и обрабатываются после того, как
 * этот сигнал распространится на все слоты, а события "открепи" обрабатываются
 * незамедлительно. Это гарантирует безопасное удаление слотов в любое время,
 * даже во время процедуры со слотом.
 *
 * Пример:
 * -----------------------------------------------------------------------------
 *
 * class Кнопка
 * {
 *     Сигнал!(Кнопка) нажми;
 * }
 *
 * проц нажата( Кнопка b )
 * {
 *     скажи( "Кнопка нажата.\n" );
 * }
 *
 * Кнопка b = new Кнопка;
 *
 * b.нажми.прикрепи( &нажата );
 * b.нажми( b );
 *
 * -----------------------------------------------------------------------------
 *
 * Отметим, что в этой реализации не использьзованы слабые указатели, чтобы сохранить
 * ссылки на слоты. Такой дизайн был выбран, потому как слабые указатели
 * наследственно небезопасны, в сочетании с недетерминистической деструкцией, и с
 * множеством ограничений, которые есть в тех же ситуациях у деструкторов.
 * Конечно получить слабо-указательное поведение всё ещё можно, но это нужно
 * реализовывать через объект-прокси.
 */
struct Сигнал( Арги... )
{
    alias проц delegate(Арги) СлотДг; ///
    alias проц function(Арги) СлотФн; ///

    alias opCall вызов; /// Алиас для упрощения цепочечного вызова.

    /**
     * Сигнальная процедура. При вызове каждый прикреплённый слот
     * будет вызываться синхронно.
     *
     * арги = Аргументы сигнала.
     */
    проц opCall( Арги арги )
    {
        synchronized
        {
            m_blk = да;

            for( т_мера i = 0; i < m_dgs.length; ++i )
            {
                if( m_dgs[i] !is пусто )
                    m_dgs[i]( арги );
            }
            m_dgs.length = m_dgs.удали( cast(СлотДг) пусто );

            for( т_мера i = 0; i < m_fns.length; ++i )
            {
                if( m_fns[i] !is пусто )
                    m_fns[i]( арги );
            }
            m_fns.length = m_fns.удали( cast(СлотФн) пусто );

            m_blk = нет;

            процады();
        }
    }


    /**
     * Прикрепляет делегат к этому сигналу. Делегат может быть либо
     * прикреплён, либо откреплён, поэтому последующие вызовы "прикрепи"
     * к одному и тому же делегату не будут иметь эффекта.
     *
     * дг = Прикрепляемый делегат.
     */
    проц прикрепи( СлотДг дг )
    {
        synchronized
        {
            if( m_blk )
            {
                m_add ~= Добавка( дг );
            }
            else
            {
                auto поз = m_dgs.найди( дг );
                if( поз == m_dgs.length )
                    m_dgs ~= дг;
            }
        }
    }


    /**
     * Прикрепляет к этому сигналу функцию.  Функция может быть либо
     * прикреплённой, либо откреплённой, поэтому последующие вызовы "прикрепи"
     * к одной и той же функции не будут иметь эффекта.
     *
     * дг = Прикрепляемая функция.
     */
    проц прикрепи( СлотФн фн )
    {
        synchronized
        {
            if( m_blk )
            {
                m_add ~= Добавка( фн );
            }
            else
            {
                auto поз = m_fns.найди( фн );
                if( поз == m_fns.length )
                    m_fns ~= фн;
            }
        }
    }


    /**
     * Открепляет делегат от этого сигнала.
     *
     * дг = Открепляемый делегат.
     */
    проц открепи( СлотДг дг )
    {
        synchronized
        {
            auto поз = m_dgs.найди( дг );
            if( поз < m_dgs.length )
                m_dgs[поз] = пусто;
        }
    }


    /**
     * Открепляет функцию от этого сигнала.
     *
     * фн = Открепляемая функция.
     */
    проц открепи( СлотФн фн )
    {
        synchronized
        {
            auto поз = m_fns.найди( фн );
            if( поз < m_fns.length )
                m_fns[поз] = пусто;
        }
    }


private:
    struct Добавка
    {
        enum Тип
        {
            ДГ,
            ФН
        }

        static Добавка opCall( СлотДг d )
        {
            Добавка e;
            e.ty = Тип.ДГ;
            e.дг = d;
            return e;
        }

        static Добавка opCall( СлотФн f )
        {
            Добавка e;
            e.ty = Тип.ФН;
            e.фн = f;
            return e;
        }

        union
        {
            СлотДг  дг;
            СлотФн  фн;
        }
        Тип        ty;
    }


    проц процады()
    {
        foreach( a; m_add )
        {
            if( a.ty == Добавка.Тип.ДГ )
                m_dgs ~= a.дг;
            else
                m_fns ~= a.фн;
        }
        m_add.length = 0;
    }


    СлотДг[]    m_dgs;
    СлотФн[]    m_fns;
    Добавка[]       m_add;
    бул        m_blk;
}


debug( UnitTest )
{
  unittest
  {
    class Кнопка
    {
        Сигнал!(Кнопка) нажми;
    }

    цел счёт = 0;

    проц wasPressedA( Кнопка b )
    {
        ++счёт;
    }

    проц wasPressedB( Кнопка b )
    {
        ++счёт;
    }

    Кнопка b = new Кнопка;

    b.нажми.прикрепи( &wasPressedA );
    b.нажми( b );
    assert( счёт == 1 );

    счёт = 0;
    b.нажми.прикрепи( &wasPressedB );
    b.нажми( b );
    assert( счёт == 2 );

    счёт = 0;
    b.нажми.прикрепи( &wasPressedA );
    b.нажми( b );
    assert( счёт == 2 );

    счёт = 0;
    b.нажми.открепи( &wasPressedB );
    b.нажми( b );
    assert( счёт == 1 );

    счёт = 0;
    b.нажми.открепи( &wasPressedA );
    b.нажми( b );
    assert( счёт == 0 );
  }
}
