/*******************************************************************************

        copyright:      Copyright (c) 2005-2006 Lars Ivar Igesund, 
                        Eric Anderton. Все права защищены

        license:        BSD стиль: $(LICENSE)

        version:        Initial release: December 2005      
        
        author:         Lars Ivar Igesund, Eric Anderton

*******************************************************************************/

module util.ArgParser;

private import exception;

/**
    Алиас делегату, принимающему тип ткст в качестве параметра.
	В значении параметра будут содержаться любые символы,
	следующие сразу же за аргументом. 
*/
alias проц delegate (ткст значение) ОбрвызПарсераАргов;

/**
    Алиас делегату, принимающуму тип ткст в качестве параметра.
	В значении параметра будут содержаться любые символы,
	следующие сразу же за аргументом.

    Аргумент "порядковый" представляет дефолтный аргумент для данного
	потока аргументов. Первым дефолтным аргументом становится
    порядковый=0 с каждым последующим вызовом этого обратного вызова,
	имеющим значения "порядковый" равно 1, 2, 3 и т.д. Его можно
	обнулить при новом вызлве разбора агргументов.
*/
alias проц delegate (ткст значение,бцел порядковый) ДефолтнОбрвызПарсераАргов;

/**
    Алиас делегату, не принимающуму никаких параметров.
*/
alias проц delegate () ПростойОбрвызПарсераАргов;


/**
    Структура, представляющая ткст "{Префикс}{Идентификатор}".
*/
struct Аргумент {
    ткст префикс;
    ткст определитель;

    /**
        Создаёт новый экземпляр Аргумент с указанным префиксом и определителем.
    */
    static Аргумент opCall ( ткст префикс, ткст определитель ) {
        Аргумент результат;

        результат.префикс = префикс;
        результат.определитель = определитель;

        return результат;
    }
}

/**
    Ленивый алиас.
*/
alias Аргумент Арг;

/**
    Утилитный класс для её разбора и указания на строку арсунентов команды.
*/
class АргПарсер{

    /**
        вспомогательная структура, содержащая обрвызов и ид, соответствующие
        аргОпр, переданному одному из методов "свяжи".
    */
    protected struct ОбрвызПрефикса {
        ткст ид;
        ОбрвызПарсераАргов ов;
    }   

    protected ОбрвызПрефикса[][ткст] привязки;
    protected ДефолтнОбрвызПарсераАргов[ткст] дефолтнПривязки;
    protected бцел[ткст] порядковыеПрефикса;
    protected ткст[] порядокПоискаПрефикса;
    protected ДефолтнОбрвызПарсераАргов дефолтнпривяз;
    private бцел дефолтныйПорядковый = 0;

    protected проц добавьПривязки(ОбрвызПрефикса овп, ткст аргПрефикс){
        if (!(аргПрефикс in привязки)) {
            порядокПоискаПрефикса ~= аргПрефикс;
        }
        привязки[аргПрефикс] ~= овп;
    }

    /**
        Связывает обрвызов делегата к аргументу с префиксом и аргОпр.
        
        Параметры:
            аргПрефикс = префикс аргумента, напр., тире '-'.
            аргОпр = имя аргумента, следующее за префиксом
            ов = делегат, который следует вызывать, когда найден аргумент this.
    */
    public проц свяжи(ткст аргПрефикс, ткст аргОпр, ОбрвызПарсераАргов ов){
        ОбрвызПрефикса овп;
        овп.ид = аргОпр;
        овп.ов = ов;
        добавьПривязки(овп, аргПрефикс);
    } 

    /**
        Конструктор, создающий пустой экземпляр АргПарсера.
    */
    public this(){
        дефолтнпривяз = пусто;
    }
     
    /**
        Конструктор, создаёт АргПарсер экземпляр с заданным дефолтным обрвызовом.
    */    
    public this(ДефолтнОбрвызПарсераАргов обрвызов){
        дефолтнпривяз = обрвызов;
    }    

    protected class ПростойАдаптерОбрвызова{
        ПростойОбрвызПарсераАргов обрвызов;
        public this(ПростойОбрвызПарсераАргов обрвызов){ 
            this.обрвызов = обрвызов; 
        }
        
        public проц обрвызАдаптера(ткст значение){
            обрвызов();
        }
    }

    /**
        Привязывает обрвызов делегата к аргументу с префикс-ом и 
        аргОпр-ом.
        
        Параметры:
            аргПрефикс = префикс этого аргумента, напримр, dash '-'.
            аргОпр = имя этого аргумента, следующее за префиксом.
            ов = делегат, который вызывается, когда аргумент найден.
    */
    public проц свяжи(ткст аргПрефикс, ткст аргОпр, ПростойОбрвызПарсераАргов ов){
        ПростойАдаптерОбрвызова адаптер = new ПростойАдаптерОбрвызова(ов);
        ОбрвызПрефикса овп;
        овп.ид = аргОпр;
        овп.ов = &адаптер.обрвызАдаптера;
        добавьПривязки(овп, аргПрефикс);
    }
    
    /**
        Binds a delegate обрвызов в_ все аргументы with префикс аргПрефикс, but that
        do not conform в_ an аргумент bound in a вызов в_ свяжи(). 

        Параметры:
            аргПрефикс = the префикс for the обрвызов
            обрвызов = the default обрвызов
    */
    public проц свяжиДефолт(ткст аргПрефикс, ДефолтнОбрвызПарсераАргов обрвызов){
        дефолтнПривязки[аргПрефикс] = обрвызов;
        порядковыеПрефикса[аргПрефикс] = 0;
        if (!(аргПрефикс in привязки)) {
            порядокПоискаПрефикса ~= аргПрефикс;
        }
    }

    /**
        Binds a delegate обрвызов в_ все аргументы not conforming в_ an
        аргумент bound in a вызов в_ свяжи(). These аргументы will be passed в_ the
        delegate without having any совпадают prefixes removed.

        Параметры:
            обрвызов = the default обрвызов
    */
    public проц свяжиДефолт(ДефолтнОбрвызПарсераАргов обрвызов){
        дефолтнпривяз = обрвызов;
    }

    /**
        Binds a delegate обрвызов в_ an аргумент.

        Параметры:
            аргумент = аргумент в_ respond в_
            обрвызов = the delegate that should be called when the аргумент is найдено
    */
    public проц свяжи (Аргумент аргумент, ОбрвызПарсераАргов обрвызов) {
        свяжи(аргумент.префикс, аргумент.определитель, обрвызов);
    }

    /**
        Binds a delegate обрвызов в_ any число of аргументы.

        Параметры:
            аргументы = an Массив of Аргумент struct instances
            обрвызов = the delegate that should be called when one of the аргументы is найдено
    */
    public проц свяжи ( Аргумент[] аргументы, проц delegate(ткст) обрвызов ) {
        foreach (аргумент; аргументы) { свяжи(аргумент, обрвызов); }
    }

    /**
        Binds a delegate обрвызов в_ an определитель with Posix-like prefixes. This means,
        it binds for Всё prefixes "-" and "--", as well as определитель with, and
        without a delimiting "=" between определитель and значение.

        Параметры:
            определитель = аргумент определитель
            обрвызов = the delegate that should be called when one of the аргументы is найдено
    */
    public проц свяжиПосикс ( ткст определитель, ОбрвызПарсераАргов обрвызов ) {
        свяжи([ Аргумент("-", определитель ~ "="), Аргумент("-", определитель),
               Аргумент("--", определитель ~ "="), Аргумент("--", определитель) ], обрвызов);
    }

    /**
        Binds a delegate обрвызов в_ any число of определители with Posix-like prefixes.
        See свяжиПосикс(определитель, обрвызов).

        Параметры:
            аргументы = an Массив of аргумент определители
            обрвызов = the delegate that should be called when one of the аргументы is найдено
    */
    public проц свяжиПосикс ( ткст[] определители, ОбрвызПарсераАргов обрвызов ) {
        foreach (определитель; определители) { свяжиПосикс(определитель, обрвызов); }
    }

    /**
        Parses the аргументы предоставленный by the parameter. The bound обрвызовы are called as
        аргументы are recognized. If two аргументы have the same префикс, and старт with 
        the same characters (e.g.: --открой, --opened), the longest совпадают bound обрвызов
        is called.

        Параметры:
            аргументы = the команда строка аргументы из_ the application
            сбросьПорядковые = if да, все порядковый counts will be установи в_ zero
    */
    public проц разбор(ткст[] аргументы, бул сбросьПорядковые = нет){
        if (привязки.length == 0) return;

        if (сбросьПорядковые) {
            дефолтныйПорядковый = 0;
            foreach (ключ; порядковыеПрефикса.keys) {
                порядковыеПрефикса[ключ] = 0;
            }
        }

        foreach (ткст арг; аргументы) {
            ткст argData = арг;
            ткст argOrig = argData;
            бул найдено = нет;

            foreach (ткст префикс; порядокПоискаПрефикса) {
                if(argData.length < префикс.length) continue; 

                if(argData[0..префикс.length] != префикс) continue;
                else argData = argData[префикс.length..$];

                if (префикс in привязки) {
                    ОбрвызПрефикса[] кандидаты;

                    foreach (ОбрвызПрефикса ов; привязки[префикс]) {
                        if (argData.length < ов.ид.length) continue;
                        
                        т_мера cbil = ов.ид.length;

                        if (ов.ид == argData[0..cbil]) {
                            найдено = да;
                            кандидаты ~= ов;
                        }
                    }

                    if (найдено) {
                        // Find the longest совпадают обрвызов определитель из_ the кандидаты.
                        т_мера indexLongestMatch = 0;

						if (кандидаты.length > 1) {
							foreach (i, кандидат; кандидаты) {
								if (кандидат.ид.length > кандидаты[indexLongestMatch].ид.length) {
									indexLongestMatch = i;
								}
							}
						}

                        // Вызов the best совпадают обрвызов.
                        with(кандидаты[indexLongestMatch]) { ов(argData[ид.length..$]); }
                    }
                }
                if (найдено) {
                    break;
                }
                else if (префикс in дефолтнПривязки){
                    дефолтнПривязки[префикс](argData,порядковыеПрефикса[префикс]);
                    порядковыеПрефикса[префикс]++;
                    найдено = да;
                    break;
                }
                argData = argOrig;
            }
            if (!найдено) {
                if (дефолтнпривяз !is пусто) {
                    дефолтнпривяз(argData,дефолтныйПорядковый);
                    дефолтныйПорядковый++;
                }
                else {
                    throw new ИсклНелегальногоАргумента("Недопустимый аргумент "~ argData);
                }
            }
        }
    }
}

debug (UnitTest) {
    import Целое = text.convert.Integer;

    //проц main() {}

unittest {

    АргПарсер парсер = new АргПарсер();
    бул h = нет;
    бул h2 = нет;
    бул b = нет;
    бул bb = нет;
    бул булево = нет;
    цел n = -1;
    цел dashOrdinalCount = -1;
    цел ordinalCount = -1;

    парсер.свяжи("--", "h2", delegate проц(){
        h2 = да;
    });

    парсер.свяжи("-", "h", delegate проц(){
        h = да;
    });

    парсер.свяжи("-", "bb", delegate проц(){
        bb = да;
    });

    парсер.свяжи("-", "бул", delegate проц(ткст значение){
        assert(значение.length == 5);
        assert(значение[0] == '=');
        if (значение[1..5] == "да") {
            булево = да;
        }
        else {
            assert(нет);
        }
    });

    парсер.свяжи("-", "b", delegate проц(){
        b = да;
    });

    парсер.свяжи("-", "n", delegate проц(ткст значение){
        assert(значение[0] == '=');
        n = cast(цел) Целое.разбор(значение[1..5]);
        assert(n == 4349);
    });

    парсер.свяжиДефолт(delegate проц(ткст значение, бцел порядковый){
        ordinalCount = порядковый;
        if (порядковый == 0) {
            assert(значение == "ordinalTest1");
        }
        else if (порядковый == 1) {
            assert(значение == "ordinalTest2");
        }
    });

    парсер.свяжиДефолт("-", delegate проц(ткст значение, бцел порядковый){
        dashOrdinalCount = порядковый;
        if (порядковый == 0) {
            assert(значение == "dashTest1");
        }
        else if (порядковый == 1) {
            assert(значение == "dashTest2");
        }
    });

    парсер.свяжиДефолт("@", delegate проц(ткст значение, бцел порядковый){
        assert (значение == "atTest");
    });

    static ткст[] test1 = ["--h2", "-h", "-bb", "-b", "-n=4349", "-бул=да", "ordinalTest1", "ordinalTest2", "-dashTest1", "-dashTest2", "@atTest"];

    парсер.разбор(test1);
    assert(h2);
    assert(h);
    assert(b);
    assert(bb);
    assert(n == 4349);
    assert(ordinalCount == 1);
    assert(dashOrdinalCount == 1);
    
    h = h2 = b = bb = нет;
    булево = нет;
    n = ordinalCount = dashOrdinalCount = -1;

    static ткст[] test2 = ["-n=4349", "ordinalTest1", "@atTest", "--h2", "-b", "-bb", "-h", "-dashTest1", "-dashTest2", "ordinalTest2", "-бул=да"];

    парсер.разбор(test2, да);
    assert(h2 && h && b && bb && булево && (n ==4349));
    assert(ordinalCount == 1);
    assert(dashOrdinalCount == 1);
 
    h = h2 = b = bb = нет;
    булево = нет;
    n = ordinalCount = dashOrdinalCount = -1;

    static ткст[] test3 = ["-n=4349", "ordinalTest1", "@atTest", "--h2", "-b", "-bb", "-h", "-dashTest1", "-dashTest2", "ordinalTest2", "-бул=да"];

    парсер.разбор(test3, да);
    assert(h2 && h && b && bb && булево && (n ==4349));
    assert((ordinalCount == 1) && (dashOrdinalCount == 1));
 
    ordinalCount = dashOrdinalCount = -1;

    static ткст[] test4 = ["ordinalTest1", "ordinalTest2", "ordinalTest3", "ordinalTest4"];
    static ткст[] test5 = ["-dashTest1", "-dashTest2", "-dashTest3"];

    парсер.разбор(test4, да);
    assert(ordinalCount == 3);

    парсер.разбор(test5, да);
    assert(dashOrdinalCount == 2);
}
}
