/**
Модуль структур WIN API для языка Динрус.
Разработчик Виталий Кулич.
*/
module sys.WinStructs;
import sys.WinConsts, sys.WinIfaces, sys.WinFuncs;
import tpl.com;
version = Dinrus;

//СПЕЦИФИЧНЫЕ МОДУЛЬНЫЕ КОНСТАНТЫ
const{
/***
Имя:
Описание:
	Ещё не документировано.
***/
 ЛУИД СИСТЛУИД = { квадрЧасть:999 };//SYSTEM_LUID
alias СИСТЛУИД SYSTEM_LUID;
//////////////////////////////////
/***
***/						 
БИДИДЕНТАВТОРИТ
	НИЧЕЙ_БИД        = {[5: 0]},
	ОБЩИЙ_БИД       = {[5: 1]},
	МЕСТНЫЙ_БИД       = {[5: 2]},
	БИД_СОЗДАТЕЛЯ     = {[5: 3]},
	НЕ_УНИК_БИД      = {[5: 4]},
	НТ_БИД              = {[5: 5]},
	ОБЯЗАТ_БИД = {[5: 6]};//SECURITY_MANDATORY_LABEL_AUTHORITY

}//СПЕЦИФИЧНЫЕ МОДУЛЬНЫЕ КОНСТАНТЫ

extern (Windows){

	align(1) struct GUID {  // size is 16
    align(1):
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE[8] Data4;
}
alias GUID UUID, FMTID, uuid_t, т_ууид;
////////////////////////////////////
//WIN32_FILE_ATTRIBUTE_DATA
 struct ФАЙЛ_АТР_ДАН_ВИН32
		{		
		бцел файлАтры;
		ФВРЕМЯ времяСозд;
		ФВРЕМЯ времяПоследнДоступа;
		ФВРЕМЯ времяПоследнЗаписи;
		бцел    размФайлаМакс;
		бцел    размФайлаМин;
	  }	
	  
	alias ФАЙЛ_АТР_ДАН_ВИН32 WIN32_FILE_ATTRIBUTE_DATA;	  
	alias ФАЙЛ_АТР_ДАН_ВИН32* LPWIN32_FILE_ATTRIBUTE_DATA;
///////////////////////////////////////
////OSVERSIONINFOA
struct ИНФОВЕРСИИОС_А {
	бцел     размИнфОВерсииОс;
	бцел     версияМажор;
	бцел     версияМинор;
	бцел     номерПостроения;
	бцел     идПлатформы;
	сим[128] версияЦСД;
}
alias ИНФОВЕРСИИОС_А* POSVERSIONINFOA, LPOSVERSIONINFOA;
alias ИНФОВЕРСИИОС_А OSVERSIONINFOA;
/////////////////////////////////////////////////////
struct ИНФОВЕРСИИОС {
	бцел      размИнфОВерсииОс;
	бцел      версияМажор;
	бцел      версияМинор;
	бцел      номерПостроения;
	бцел      идПлатформы;
	шим[128] версияЦСД;
}
alias OSVERSIONINFOW* POSVERSIONINFOW, LPOSVERSIONINFOW;
alias  ИНФОВЕРСИИОС OSVERSIONINFOW;
////////////////////////////////////////////////////
struct ИНФОВЕРСИИОСДОП_А {
	бцел     размИнфОВерсииОс;
	бцел     версияМажор;
	бцел     версияМинор;
	бцел     номерПостроения;
	бцел     идПлатформы;
	сим[128] версияЦСД;
	бкрат      сервисПакМажор;
	бкрат      сервисПакМинор;
	бкрат      сьютМаска;
	ббайт      типПродукта;
	ббайт      резерв;
}
alias OSVERSIONINFOEXA* POSVERSIONINFOEXA, LPOSVERSIONINFOEXA;
alias ИНФОВЕРСИИОСДОП_А OSVERSIONINFOEXA;
///////////////////////////////////////////////////////
struct ИНФОВЕРСИИОСДОП {
	бцел      размИнфОВерсииОс;
	бцел      версияМажор;
	бцел      версияМинор;
	бцел      номерПостроения;
	бцел      идПлатформы;
	шим[128] версияЦСД;
	бкрат       сервисПакМажор;
	бкрат       сервисПакМинор;
	бкрат       сьютМаска;
	ббайт       типПродукта;
	ббайт       резерв;
}
alias OSVERSIONINFOEXW* POSVERSIONINFOEXW, LPOSVERSIONINFOEXW;
alias ИНФОВЕРСИИОСДОП OSVERSIONINFOEXW;

version (Unicode) {
	alias OSVERSIONINFOW OSVERSIONINFO;
	alias OSVERSIONINFOEXW OSVERSIONINFOEX;
} else {
	alias OSVERSIONINFOA OSVERSIONINFO;
	alias OSVERSIONINFOEXA OSVERSIONINFOEX;
}

alias OSVERSIONINFO*   POSVERSIONINFO,   LPOSVERSIONINFO;
alias OSVERSIONINFOEX* POSVERSIONINFOEX, LPOSVERSIONINFOEX;
///////////////////////////////////////////////////
}
extern(D)
{

    struct ГУИД //Глобальный Универсальный Идентификатор
    {
        бцел a;
        бкрат b, c;
        ббайт d, e, f, g, h, i, j, k;

        /**
         * ГУИД, все значения которого являются нулями.
         */
        static ГУИД пустой = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };

        /**
         * Инициализует _новый экземпляр, используя заданные целые и байты.
         * Параметры:
         *   a = Первые 4 байта.
         *   b = Следующие 2 байта.
         *   c = Следующие 2 байта.
         *   d = Следующий байт.
         *   e = Следующий байт.
         *   f = Следующий байт.
         *   g = Следующий байт.
         *   h = Следующий байт.
         *   i = Следующий байт.
         *   j = Следующий байт.
         *   k = Следующий байт.
         * Возвращает: Результирующий ГУИД.
         */

        static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт d, ббайт e, ббайт f, ббайт g, ббайт h, ббайт i, ббайт j, ббайт k);
        static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт[] d);
        static ГУИД opCall(ткст s) ;

        /**
         * Инициализует новый экземпляр структуры ГУИД.
         */
        static ГУИД создай() ;

        /**
         * Возвращает значение, которое показывает, одинаковы ли значения у двух экземпляров.
         * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
         * Возвращает: да, если другой равен этому экземпляру; otherwise, false.
         */
        бул opEquals(ГУИД другой);

        /**
         * Сравнивает данный экземпляр с указанным ГУИДом и возвращает указание на их относительные значения.
         * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
         * Возвращает: Число, показывающее относительные значения этого и другого экземпляров.
         */
        цел opCmp(ГУИД другой) ;

        /**
        * Возвращает текстовое представление значения данного экземпляра в реестровом формате.
        * Возвращает: Текст, форматированный по образцу {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx},
        *где ГУИД представлен серией прописных шестнадцатиричных цифр, сгруппированных по
        * 8, 4, 4, 4 и 12, и разделенных дефисами.
         */

        ткст вТкст() ;

        /// описано ранее
        ткст вТкст(ткст формат);

        /**
         * Выводит хеш-код для данного экземпляра.
         */
        бцел вХэш();

    }
    alias ГУИД ИИД, КЛСИД;

    struct БЕЗОПМАС
    {

        бкрат члоИзм;
        бкрат  фичи;
        бцел размЭлта;
        бцел счБлк;
        ук укНаДан;
        ГРАНБЕЗОПМАСА[1] рбмгран;

        static БЕЗОПМАС* opCall(T)(T[] массив)
        {
            auto предел = ГРАНБЕЗОПМАСА(массив.length);
            auto sa = СоздайБезопмас(ТипВариант!(T), 1, &предел);

            static if (is(T : ткст)) alias шим* Тип;
            else                       alias T Тип;

            Тип* данные;

            ДоступКДаннымБезопмаса(sa, возврзнач(данные));
            for (auto i = 0; i < массив.length; i++)
            {
                static if (is(T : ткст)) данные[i] = массив[i].вБткст();
                else                       данные[i] = массив[i];
            }
            ОтступОтДаныхБезопмаса(sa);

            return sa;
        }


        T[] вМассив(T)()
        {
            цел верхГран, нижГран;
            ДайВПределБезопмаса(this, 1, верхГран);
            ДайНПределБезопмаса(this, 1, нижГран);
            цел посчитай = верхГран - нижГран + 1;

            if (посчитай == 0) return пусто;

            T[] результат = new T[посчитай];

            static if (is(T : ткст)) alias шим* Тип;
            else                       alias T Тип;

            Тип* данные;
            ДоступКДаннымБезопмаса(this, возврзнач(данные));
            for (auto i = нижГран; i < верхГран + 1; i++)
            {
                static if (is(T : ткст)) результат[i] = бткстВТкст(данные[i]);
                else                       результат[i] = данные[i];
            }
            ОтступОтДаныхБезопмаса(this);

            return результат;
        }

        проц удали() ;
        проц блокируй();
        проц разблокируй() ;
        проц длина(цел значение);
        цел длина();

    }
    alias БЕЗОПМАС SAFEARRAY;

    /**
    * Представляет десятичное число в пределах от положительного 79,228,162,514,264,337,593,543,950,335 до отрицательного 79,228,162,514,264,337,593,543,950,335.
    */
    alias ДЕСЯТОК DECIMAL;
    struct ДЕСЯТОК
    {

        бкрат резерв;
        ббайт шкала;
        ббайт знак;
        бцел Старш32;
        бцел Младш32;
        бцел Средн32;

        /// Represents the smallest possible value.
        static ДЕСЯТОК мин = { 0, 0, ОТРИЦ_ДЕСЯТОК, бцел.max, бцел.max, бцел.max };
        /// Represents the largest possible value.
        static ДЕСЯТОК макс = { 0, 0, 0, бцел.max, бцел.max, бцел.max };
        /// Represents -1.
        static ДЕСЯТОК минусОдин = { 0, 0, ОТРИЦ_ДЕСЯТОК, 0, 1, 0 };
        /// Represents 0.
        static ДЕСЯТОК ноль = { 0, 0, 0, 0, 0, 0 };
        /// Represents 1.
        static ДЕСЯТОК один = { 0, 0, 0, 0, 1, 0 };

        /// Инициализует новый экземпляр.
        static ДЕСЯТОК opCall(T)(T значение)
        {
            ДЕСЯТОК сам;

            static if (is(T == бцел))
                ДесВарИзБцел(значение, сам);
            else static if (is(T == цел))
                ДесВарИзЦел(значение, сам);
            else static if (is(T == бдол))
                ДесВарИзБдол(значение, сам);
            else static if (is(T == дол))
                ДесВарИзДол(значение, сам);
            else static if (is(T == плав))
                ДесВарИзПлав(значение, сам);
            else static if (is(T == дво))
                ДесВарИзДво(значение, сам);
            else static assert(нет);

            return сам;
        }

        /// описано ранее
        static ДЕСЯТОК opCall(T = проц)(бцел lo, бцел mid, бцел hi, бул isNegative, ббайт шкала)
        {
            ДЕСЯТОК сам;
            сам.Старш32 = hi, сам.Средн32 = mid, сам.Младш32 = lo, сам.шкала = шкала, сам.знак = isNegative ? ОТРИЦ_ДЕСЯТОК : 0;
            return сам;
        }
        /// Преобразует строковое представление числа в его ДЕСЯТИЧный эквивалент.
        static ДЕСЯТОК разбор(ткст s);

        static ДЕСЯТОК абс(ДЕСЯТОК d) ;


        /// Округляет значение до ближайшего или специфичного числа.
        static ДЕСЯТОК округли(ДЕСЯТОК d, цел десятки = 0);

        /// Округляет значение до ближайшего к отрицательной бесконечности целого.
        static ДЕСЯТОК кОтрБеск(ДЕСЯТОК d) ;

        /// Возвращает интегральные числа значения.
        static ДЕСЯТОК сократи(ДЕСЯТОК d) ;

        /// Вычисляет остаток после деления двух значений.
        static ДЕСЯТОК остаток(ДЕСЯТОК d1, ДЕСЯТОК d2) ;

        /// Складывает два значения.
        static ДЕСЯТОК сложи(ДЕСЯТОК d1, ДЕСЯТОК d2) ;
        /// Отнимает одно значение от другого.
        static ДЕСЯТОК вычти(ДЕСЯТОК d1, ДЕСЯТОК d2) ;

        /// Перемножает два значения.
        static ДЕСЯТОК умножь(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Делит два значения.
        static ДЕСЯТОК раздели(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Возвращает результат умножения значения на -1.
        static ДЕСЯТОК вОтриц(ДЕСЯТОК d) ;

        бцел вХэш() ;

        /// Преобразует численное значение данного экземпляра в эквивалентное текстовое представление.
        ткст вТкст() ;

        /// Сравнивает два значения.
        static цел сравни(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Сравнивает данный экземпляр с указанным экземпляром.
        цел сравни_с(ДЕСЯТОК значение);

        цел opCmp(ДЕСЯТОК d) ;

        /// Возвращает значение, определяющее являются ли два экземпляра одинаковыми по значению.
        static бул равны(ДЕСЯТОК d1, ДЕСЯТОК d2);

        /// Returns a значение indicating whether this экземпляр and a specified экземпляр represent the same _value.
        бул равны(ДЕСЯТОК значение) ;

        бул opEquals(ДЕСЯТОК d) ;

        ДЕСЯТОК opAdd(ДЕСЯТОК d) ;
        проц opAddAssign(ДЕСЯТОК d) ;

        ДЕСЯТОК opSub(ДЕСЯТОК d) ;
        проц opSubAssign(ДЕСЯТОК d) ;


        ДЕСЯТОК opMul(ДЕСЯТОК d);
        проц opMulAssign(ДЕСЯТОК d);


        ДЕСЯТОК opDiv(ДЕСЯТОК d) ;
        проц opDivAssign(ДЕСЯТОК d) ;


        ДЕСЯТОК opMod(ДЕСЯТОК d) ;
        ДЕСЯТОК opNeg() ;
        ДЕСЯТОК opPos() ;
        ДЕСЯТОК opPostInc() ;
        ДЕСЯТОК opPostDec() ;

    }

    /**
     * Контейнер для множества различных типов.
     * Примеры:
     * ---
     * ВАРИАНТ var = 10;     // Экземпляр содержит ПТипВарианта.Ц4.
     * var = "Hello, World"; // Экземпляр теперь содержит ПТипВарианта.БинТекст.
     * var = 234.5;          // Экземпляр теперь содержит ПТипВарианта.Р8.
     * ---
     */

    alias ВАРИАНТ VARIANT;
    struct ВАРИАНТ
    {

        	  union {	  
		export struct {
		  /// Описывает тип данного экземпляра.
		  бкрат вт;//VARTYPE vt
		  бкрат Резерв1;//WORD wReserved1
		  бкрат Резерв2;//WORD wReserved2
		  бкрат Резерв3;//WORD wReserved3
		  export union {
			дол долЗнач;//LONGLONG llVal 
			цел целЗнач;//цел lVal
			ббайт ббайтЗнач;//bVal
			крат кратЗнач;//iVal
			плав плавЗнач;//fltVal
			дво двоЗнач;//dblVal
			БУЛ_ВАРИАНТ булЗнач;//boolVal
			цел скод;//SCODE scode
			дол долЗнач2;//CY cyVal
			/*
			union CY {
						struct {
							бцел Lo;
							цел Hi;
						}
						LONGLONG int64;
					}
			*/
			дво дата;//DATE date 
			шткст0 бстрЗнач;//BSTR bstrVal
			Инкогнито инкЗнач;//punkVal
			ИДиспетчер депЗнач;//pdispVal
			БЕЗОПМАС* массив;//SAFEARRAY* parray
			ббайт* уббайтЗнач;//pbVal
			крат* укратЗнач;//piVal
			цел* уцелЗнач;//plVal
			дол* удолЗнач;
			плав* уплавЗнач;//pfltVal
			дво* удвоЗнач;//pdblVal
			БУЛ_ВАРИАНТ* убулЗнач;// VARIANT_BOOL* pboolVal
					//_VARIANT_BOOL*  pbool; 
			цел* ускод;//SCODE* pscode
			дол* удолЗнач2;;//CY* pcyVal
			дво* удата;//DATE* pdate
			шткст0* убстрЗнач;//BSTR* pbstrVal
			Инкогнито* уинкЗнач;//IUnknown* ppunkVal
			ИДиспетчер* удепЗнач;//IDispatch* ppdispVal
			БЕЗОПМАС** умассив;//SAFEARRAY** pparray
			ВАРИАНТ* уварЗнач;//VARIANT* pvarVal
			ук байреф;//byref
			байт байтЗнач;//CHAR cVal 
			бкрат бкратЗнач;//ULONGLONG ullVal
			бцел бцелЗнач;//INT intVal, <ulVal>
			бдол бдолЗнач;//UINT uintVal
			ДЕСЯТОК* удесЗнач;//DECIMAL* pdecVal
			байт* убайтЗнач;//CHAR*  pcVal
			крат* укратЗнач2;//USHORT*  puiVal
			бцел* убцелЗнач;//INT*  pintVal
			бдол* убдолЗнач;//UINT*  puintVal
			export struct {
			  ук запись;//PVOID pvRecord
			  ИИнфОЗаписи инфОЗап;//IRecordInfo pRecInfo
			}
		  }
		}
		ДЕСЯТОК десЗнач;//DECIMAL decVal
	  }
		
	
        /// Представляет значение _missing.
        static ВАРИАНТ Отсутствует = { вт: ПТипВарианта.Ошибка, скод: ПОшДисп.ПарамНеНайден };

        /// Представляет значение _nothing.
        static ВАРИАНТ Ничто = { вт: ПТипВарианта.Диспетчер, депЗнач: пусто };

        /// Представляет значение _null.
        static ВАРИАНТ Пусто = { вт: ПТипВарианта.Пусто };


        /**
         * Инициализует новый экземпляр с помощью указанных _значения и _типа.
         * Параметры:
         *   значение = Значение одного из приемлемых типов.
         *   тип = бкрат, идентифицирующий тип значения.
         * Возвращает: Итоговый ВАРИАНТ.
         */
        static ВАРИАНТ opCall(T)(T значение, бкрат тип = ТипВариант!(T))
        {
            ВАРИАНТ сам;
            инициализуй(сам, значение, тип);
            return сам;
        }


        private static проц инициализуй(T)(ref ВАРИАНТ ret, T значение, бкрат тип = ТипВариант!(T))
        {
            static if (is(T E == enum))
            {
                инициализуй(ret, cast(E) значение, тип);
            }
            else
            {
                ret = cast(ВАРИАНТ) значение;
                if (тип != ret.вт)
                    ИзмениТипВариантаДоп(ret, ret,  ДайЛокальНити(), ПВар.АльфаБул, тип);
            }
        }

        проц opAssign(дол значение);
        проц opAssign(цел значение);
        проц opAssign(ббайт значение);
        проц opAssign(крат значение);
        проц opAssign(плав значение);
        проц opAssign(дво значение);
        проц opAssign(бул значение);
        проц opAssign(БУЛ_ВАРИАНТ значение);
        проц opAssign(ткст значение);
        проц opAssign(Инкогнито значение);
        проц opAssign(БЕЗОПМАС* значение);
        проц opAssign(байт значение);
        проц opAssign(бкрат значение);
        проц opAssign(бцел значение);
        проц opAssign(бдол значение);
        проц opAssign(ДЕСЯТОК значение);
        проц opAssign(ббайт[] значение);

        /**
         * Стирает значение данного экземпляра и высвобождает связанную с ним память.
         * См_Также: $(LINK2 http://msdn2.microsoft.com/en-us/library/ms221165.aspx, VariantClear).
         */
        проц сотри() ;

        /**
         * Копирует данный экземпляр в целевое значение.
         * Параметры: dest = Вариант, в который копируется.
         */
        проц копируй_в(out ВАРИАНТ куда);

        /**
         * Преобразует вариант из одного типа в другой.
         * Параметры: новТип = Тип для изменения.
         */
        ВАРИАНТ измениТип(бкрат новТип);

        /**
         * Преобразует содержащееся в данном экземпле значение в текст.
         * Возвращает: Текстовое представление содержащегося в экземпле значения.
         */
        ткст вТкст() ;

        /**
         * Возвращает _value, заключённое в этом экземпляре.
         */
        V значение(V)()
        {
            static if (is(V == дол)) return долЗнач;
            else static if (is(V == цел)) return целЗнач;
            else static if (is(V == ббайт)) return ббайтЗнач;
            else static if (is(V == крат)) return кратЗнач;
            else static if (is(V == плав)) return плавЗнач;
            else static if (is(V == дво)) return двоЗнач;
            else static if (is(V == бул)) return (булЗнач == ДА_ВАРИАНТ) ? да : нет;
            else static if (is(V == БУЛ_ВАРИАНТ)) return булЗнач;
            else static if (is(V : ткст)) return бткстВТкст(бстрЗнач);
            else static if (is(V == шим*)) return бстрЗнач;
            else static if (is(V : ИДиспетчер)) return cast(V)депЗнач;
            else static if (is(V : Инкогнито)) return cast(V)инкЗнач;
            else static if (is(V == БЕЗОПМАС*)) return массив;
            else static if (массив!(V)) return массив.вМассив!(typeof(*V))();
            else static if (is(V == ВАРИАНТ*)) return уварЗнач;
            else static if (is(V : Объект)) return cast(V)байреф;
            else static if (указатель!(V)) return cast(V)байреф;
            else static if (is(V == байт)) return байтЗнач;
            else static if (is(V == бкрат)) return бкратЗнач;
            else static if (is(V == бцел)) return бцелЗнач;
            else static if (is(V == бдол)) return бдолЗнач;
            else static if (is(V == ДЕСЯТОК)) return десЗнач;
            else static assert(нет, stdrus.вЮ8(cast(ткст)"'" ~ V.stringof ~ "' не относится к допустимым типам."));
        }

        /**
         * Определяет, пуст ли данный экземпляр.
         */
        бул пуст_ли();
        /**
         * Определяет, является ли экземпляр _null.
         */
        бул нулл_ли();

        /**
         * Определяет, является ли экземпляр Nothing.
         */
        бул ничто_ли() ;

        цел opCmp(ВАРИАНТ тот);

        бул opEquals(ВАРИАНТ тот);

        ВАРИАНТ opCat(ВАРИАНТ тот);
        проц opCatAssign(ВАРИАНТ тот);

        ВАРИАНТ opSub(ВАРИАНТ тот) ;
        проц opSubAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opDiv(ВАРИАНТ тот) ;
        проц opDivAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opMul(ВАРИАНТ тот);
        проц opMulAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opMod(ВАРИАНТ тот);
        проц opModAssign(ВАРИАНТ тот);

        ВАРИАНТ opAnd(ВАРИАНТ тот);
        проц opAndAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opOr(ВАРИАНТ тот);
        проц opOrAssign(ВАРИАНТ тот) ;

        ВАРИАНТ opXor(ВАРИАНТ тот) ;
        проц opXorAssign(ВАРИАНТ тот);

    }

}

extern (Windows):

    struct ОтладИнфОбАдр
{
    align(1)
    {
        т_мера  адр;
        ткст0   файл;
        ткст0   функц;
        бкрат  строка;
    }
}

struct КонтекстСледа
{
    КОНТЕКСТ контекст;
    ук процесс;
    ук нить;
}
////////////////////////////////////////////////////////////////

struct АСИНХРОН // OVERLAPPED
{
    бцел внутрен;
    бцел внутренСтарш;
    бцел смещение;
    бцел смещениеСтарш;
    ук событие;
}
	alias АСИНХРОН OVERLAPPED;
	alias OVERLAPPED* POVERLAPPED, LPOVERLAPPED;
////////////////////////////////////////////////////////////////////
struct ЖАНРОВЫЙ_МАППИНГ //GENERIC_MAPPING
{
    МАСКА_ДОСТУПА ЖанрЗап;
    МАСКА_ДОСТУПА ЖанрЧтен;
    МАСКА_ДОСТУПА ЖанрВып;
    МАСКА_ДОСТУПА ЖанрВсё;
}
alias ЖАНРОВЫЙ_МАППИНГ ЖАНРМАП;

///////////////////////////////////////////////////////////////////

struct АТРИБУТЫ_БЕЗОПАСНОСТИ //SECURITY_ATTRIBUTES
{
    бцел длина;
    ук дескрБезоп;
    бул наследДескр;//BOOL: 1 или 0.
}
	alias АТРИБУТЫ_БЕЗОПАСНОСТИ БЕЗАТРЫ, SECURITY_ATTRIBUTES;
	alias SECURITY_ATTRIBUTES* PSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES;
///////////////////////////////////////////////////////////////

struct СКД //ACL (Список Контроля Доступа (СКД))
{
    ббайт ревизияСКД;
    ббайт Sbsz1;
    бкрат размерСКД;
    бкрат счётЗкд; //ACE - Запись Контроля Доступа (ЗКД)
    бкрат Sbsz2;
}
	alias СКД ACL;
	alias ACL* PACL;
////////////////////////////////////////////////
struct ИНФО_РЕВИЗИИ_СКД//ACL_REVISION_INFORMATION
{
    бцел ревСкд;
}
alias ИНФО_РЕВИЗИИ_СКД ACL_REVISION_INFORMATION;
////////////////////////////////////////////////
struct ИНФО_РАЗМЕРА_СКД//ACL_SIZE_INFORMATION
{
    бцел счётЗкд;
    бцел испБайтовСкд;
    бцел свобБайтовСкд;
}
	alias ИНФО_РАЗМЕРА_СКД ACL_SIZE_INFORMATION;
////////////////////////////////////
struct ЗКДЗАГ//ACE_HEADER
{
    ббайт типЗкд;
    ббайт флагиЗкд;
    бкрат размЗкд;
}
	alias ЗКДЗАГ ACE_HEADER;
	alias ACE_HEADER* PACE_HEADER;
/////////////////////////

struct ЗКД_ДОСТУП_ОТКРЫТ//ACCESS_ALLOWED_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}
	alias ЗКД_ДОСТУП_ОТКРЫТ ACCESS_ALLOWED_ACE;
	alias ACCESS_ALLOWED_ACE* PACCESS_ALLOWED_ACE;
//////////////////////
struct ЗКД_ДОСТУП_ЗАКРЫТ//ACCESS_DENIED_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}
	alias ЗКД_ДОСТУП_ЗАКРЫТ ACCESS_DENIED_ACE;
	alias ACCESS_DENIED_ACE* PACCESS_DENIED_ACE;
//////////////////
struct ЗКД_СИСТ_АУДИТ//SYSTEM_AUDIT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}

alias ЗКД_СИСТ_АУДИТ SYSTEM_AUDIT_ACE;
//////////////////////////////////////
struct ЗКД_СИСТ_ТРЕВОГА //SYSTEM_ALARM_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел начСид;
}
alias ЗКД_СИСТ_ТРЕВОГА SYSTEM_ALARM_ACE;
//////////////////////////////////////////
struct ЗКД_ОБЪЕКТ_ОТКРЫТ//ACCESS_ALLOWED_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}
alias ЗКД_ОБЪЕКТ_ОТКРЫТ ACCESS_ALLOWED_OBJECT_ACE;
//////////////////////////////////////////////////
struct ЗКД_ОБЪЕКТ_ЗАКРЫТ//ACCESS_DENIED_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}
alias ЗКД_ОБЪЕКТ_ЗАКРЫТ ACCESS_DENIED_OBJECT_ACE;
//////////////////////////////////////////////////
struct ЗКД_ОБЪЕКТ_СИСТ_АУДИТА//SYSTEM_AUDIT_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}
alias ЗКД_ОБЪЕКТ_СИСТ_АУДИТА SYSTEM_AUDIT_OBJECT_ACE ;
//////////////////////////////////////////////////////////
struct ЗКД_ОБЪЕКТ_СИСТ_ТРЕВОГИ//SYSTEM_ALARM_OBJECT_ACE
{
    ЗКДЗАГ заг;
    МАСКА_ДОСТУПА маска;
    бцел флаги;
    ГУИД   типОбъекта;
    ГУИД унаследованныйТипОбъекта;
    бцел начСид;
}
alias  ЗКД_ОБЪЕКТ_СИСТ_ТРЕВОГИ SYSTEM_ALARM_OBJECT_ACE;
////////////////////////////////////////////////////////
struct ДЕСКРИПТОР_БЕЗОПАСНОСТИ //SECURITY_DESCRIPTOR
{
    ббайт ревизия;
    ббайт Sbz1;
    УПР_ДЕСКРИПТОРА_БЕЗОПАСНОСТИ упр;
    УкБИД владелец;
    УкБИД группа;
    СКД* сскд;//SACL
    СКД* дскд;//DACL
}
alias ДЕСКРИПТОР_БЕЗОПАСНОСТИ ДЕСКРБЕЗОП;
	
alias  ДЕСКРИПТОР_БЕЗОПАСНОСТИ SECURITY_DESCRIPTOR;
alias SECURITY_DESCRIPTOR* PSECURITY_DESCRIPTOR, PISECURITY_DESCRIPTOR;
/////////////////////////////////////////////////
struct ФВРЕМЯ //FILETIME
{
    бцел датаВремяМладш;
    бцел датаВремяСтарш;
}
	alias ФВРЕМЯ FILETIME;
alias FILETIME* PFILETIME, LPFILETIME;
/////////////////////////////////////////////	
	struct ПОИСК_ДАННЫХ_А //WIN32_FIND_DATA
	{
	бцел атрибутыФайла;
	ФВРЕМЯ времяСоздания;
	ФВРЕМЯ времяПоследнегоДоступа;
	ФВРЕМЯ времяПоследнейЗаписи;
	бцел размерФайлаВ;
	бцел размерФайлаН;
	бцел резерв0;
	бцел резерв1;
	сим[sys.WinConsts.МАКС_ПУТЬ] имяФайла;
	сим[14] альтИмяФайла;
	}
	alias ПОИСК_ДАННЫХ_А ПДАН_А, WIN32_FIND_DATA;

/////////////////////////////////	

	struct ПОИСК_ДАННЫХ //WIN32_FIND_DATAW
	{
	бцел атрибутыФайла;
	ФВРЕМЯ времяСоздания;
	ФВРЕМЯ времяПоследнегоДоступа;
	ФВРЕМЯ времяПоследнейЗаписи;
	бцел размерФайлаВ;
	бцел размерФайлаН;
	бцел резерв0;
	бцел резерв1;
	шим[МАКС_ПУТЬ] имяФайла;
	шим[14] альтИмяФайла;
	}
	alias ПОИСК_ДАННЫХ ПДАН, WIN32_FIND_DATAW;
/////////////////////////////////////////////

struct СТАТУС_ПАМЯТИ //MEMORYSTATUS
{
    бцел длина;
    бцел загрузкаПамяти;
    бцел всегоФиз;
    бцел всегоДоступнФиз;
    бцел всегоФайлСтр;
    бцел всегоДоступнФайлСтр;
    бцел всегоВиртуал;
    бцел всегоДоступнВиртуал;

}
	alias СТАТУС_ПАМЯТИ СТАТПАМ, MEMORYSTATUS;
	alias MEMORYSTATUS *LPMEMORYSTATUS;
/////////////////////////////////////////////////////////
struct БАЗОВАЯ_ИНФ_О_ПАМЯТИ // MEMORY_BASIC_INFORMATION
{
    ук АдресБазы;
    ук БазаАллокации;
    бцел ПротектАллокации;
    бцел РазмерОбласти;
    бцел Состояние;
    бцел Протект;
    бцел Тип;

}
	alias БАЗОВАЯ_ИНФ_О_ПАМЯТИ БАЗИОП, MEMORY_BASIC_INFORMATION;
	alias MEMORY_BASIC_INFORMATION* PMEMORY_BASIC_INFORMATION;
//////////////////////////////////////////////////
struct ЗАПИСЬ_СПИСКА //LIST_ENTRY
{
    ЗАПИСЬ_СПИСКА *СЗук;//Flink - указание на следующщую запись
    ЗАПИСЬ_СПИСКА *ПЗук;//Blink - указание на предыдущую запись
}
	alias ЗАПИСЬ_СПИСКА СПИСЗАП, _LIST_ENTRY, LIST_ENTRY;
/////////////////////////////////////////////////////////////

	struct КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА //RTL_CRITICAL_SECTION_DEBUG
	{
	бкрат Тип;
	бкрат ИндексОбратнойТрассировкиСоздателя;
	КРИТИЧЕСКАЯ_СЕКЦИЯ *КритическаяСекция;
	ЗАПИСЬ_СПИСКА СписокБлокировокПроцесса;
	бцел СчётЗаписей;
	бцел СчётРасхождений;
	бцел[2] Свободно; //Spare

	}
	alias КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА КРИТСЕКЦОТЛ, _RTL_CRITICAL_SECTION_DEBUG, RTL_CRITICAL_SECTION_DEBUG;
//////////////////////////////////////////////////////////////////////////////////
struct КРИТИЧЕСКАЯ_СЕКЦИЯ //_RTL_CRITICAL_SECTION,
{

    КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА *ОтладИнфо;// Используется операционной системой
	/**
	* Поле LockCount увеличивается на единицу при каждом вызове ::EnterCriticalSection()
	* и уменьшается при каждом вызове ::LeaveCriticalSection(). Это первая (а часто и
	* единственная проверка) на пути к "захвату" критической секции. Если после увеличения
	* в этом поле находится ноль, это означает, что до этого момента непарных вызовов 
	* ::EnterCriticalSection() из других ниток не было. В этом случае можно забрать данные, 
	* охраняемые этой критической секцией в монопольное пользование. Таким образом, если 
	* критическая секция интенсивно используется не более чем одной нитью, ::EnterCriticalSection() 
	* практически вырождается в ++LockCount, а ::LeaveCriticalSection() в --LockCount. 
	* Это очень важно. Это означает, что использование многих тысяч критических секций в одном процессе 
	* не повлечет значительного расхода ни системных ресурсов, ни процессорного времени.
	*/
    цел СчётБлокировок;// Счетчик использования этой критической секции
	/**
	* В поле RecursionCount хранится количество повторных вызовов ::EnterCriticalSection() 
	* из одной и той же нити.
	*/
    цел СчётРекурсий;// Счетчик повторного захвата из нити-владельца
	
    ук ВладеющаяНить;// Уникальный ID нити-владельца
    ук СемафорБлокировок;// Объект ядра используемый для ожидания
    бцел СпинСчёт;// Количество холостых циклов перед вызовом ядра

}
	alias КРИТИЧЕСКАЯ_СЕКЦИЯ КРИТСЕКЦ, _RTL_CRITICAL_SECTION, CRITICAL_SECTION;
//////////////////////////////////////////////////////////////
	struct СИСТВРЕМЯ // SYSTEMTIME
	{

	бкрат год;
	бкрат месяц;
	бкрат день_недели;
	бкрат день;
	бкрат час;
	бкрат минута;
	бкрат секунда;
	бкрат миллисекунды;
	}
	alias СИСТВРЕМЯ SYSTEMTIME;
////////////////////////////////////

	struct ИНФ_О_ЧАСОВОМ_ПОЯСЕ
	{
	цел Разница;
	шим[32] СтандартноеНазвание;
	СИСТВРЕМЯ СтандартнаяДата;
	цел СтандартнаяРазница;
	шим[32] ИмяДейлайт;
	СИСТВРЕМЯ ДатаДейлайт;
	цел РазницаДейлайт;

	}
	alias ИНФ_О_ЧАСОВОМ_ПОЯСЕ ИНФОЧП, TIME_ZONE_INFORMATION;
///////////////////////////////////////////////////

	struct ЗОНА_СОХР_ПЛАВ //FLOATING_SAVE_AREA
	{
	бцел СловоУправления;
	бцел СловоСостояния;
	бцел СловоТег;
	бцел СмещениеОшибки;
	бцел СелекторОшибки;
	бцел СмещениеДанных;
	бцел СелекторДанных;
	ббайт[80] ЗонаРегистра;
	бцел  СостояниеCr0Npx;
	}
	alias ЗОНА_СОХР_ПЛАВ FLOATING_SAVE_AREA;
///////////////////////////////////////////////////////
struct КОНТЕКСТ //CONTEXT
{
    бцел ФлагиКонтекста;
    бцел Рд0;
    бцел Рд1;
    бцел Рд2;
    бцел Рд3;
    бцел Рд6;
    бцел Рд7;
    ЗОНА_СОХР_ПЛАВ ПлавСохр;
    бцел СегГс;
    бцел СегФс;
    бцел СегЕс;
    бцел СегДс;
    бцел   Edi;
    бцел   Esi;
    бцел   Ebx;
    бцел   Edx;
    бцел   Ecx;
    бцел   Eax;

    бцел   Ebp;
    бцел   Eip;
    бцел   SegCs;
    бцел   EFlags;
    бцел   Esp;
    бцел   SegSs;
    ббайт[512/*ПКонтекст.МаксПоддержРасш*/] РасширенныеРегистры;
}
	alias КОНТЕКСТ CONTEXT;
	alias CONTEXT* PCONTEXT, LPCONTEXT;
//////////////////////////////////////////

alias ПРежим_Адресации ADDRESS_MODE;
struct АДРЕС //ADDRESS
{
    бцел Смещение;
    бкрат Сегмент;
    ПРежим_Адресации  Режим;
}
	alias АДРЕС ADDRESS;
///////////////////////////////////////
struct АДРЕС64 //ADDRESS64
{
    бдол Смещение;
    бкрат Сегмент;
    ПРежим_Адресации  Режим;
}
	alias АДРЕС64 ADDRESS64;
/////////////////////////////////////////////
struct ПОМОЩЬОЯ //KDHELP
// вспомогательная структура для отладчика уровня ядра
{
    бцел       Нить;
    //Адрес объекта нити ядра, предоставленный в пакете WAIT_STATE_CHANGE.
    бцел       СтэкОбрВызова;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бцел       АдрФцииЯдраВызПользРеж;
    бцел      АдрФцииДиспетчераПользРеж;
    бцел       МладшАдрУрЯдра;
    бцел       СмещКУкВозврХр;
    бцел       АдрФцииДиспетчераИсклПользРеж;
    бцел       ОваСтэка;
    бцел       ЛимитСтэка;
    бцел[5]    Резерв;
}
	alias ПОМОЩЬОЯ KDHELP;
//////////////////////////////////////////////////
struct ПОМОЩЬОЯ64 //KDHELP64
{
    бдол     Нить;
    бцел       СтэкОбрВызова;
    бцел       СмещКУкВозврХр;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бдол     АдрФцииЯдраВызПользРеж;
    бдол    АдрФцииДиспетчераПользРеж;
    бдол     МладшАдрУрЯдра;
    бдол     АдрФцииДиспетчераИсклПользРеж;
    бдол     ОваСтэка;
    бдол     ЛимитСтэка;
    бдол[5]  Резерв;
}
	alias ПОМОЩЬОЯ64 KDHELP64;
///////////////////////////////////
struct КАДР_СТЕКА //STACKFRAME
{
    АДРЕС     АдрСчётчикаПрограммы; //x86:EIP, x64:RIP
    АДРЕС     АдрВозврата;
    АДРЕС     АдрКадра;//x86:EBP, x64:RBP
    АДРЕС     АдрСтэка;//x86:ESP, x64:RSP
    ук       ЗаписьТабФций;//_FPO_DATA struct
    бцел[4]    АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бцел[3]    Резерв;//для ф-ции StackWalk64

    ПОМОЩЬОЯ      помОЯ;
    АДРЕС     АдрВозврХр;
}
	alias КАДР_СТЕКА STACKFRAME;
///////////////////////////

struct КАДР_СТЕКА64 //STACKFRAME64
{
    АДРЕС64   АдрСчётчикаПрограммы;
    АДРЕС64   АдрВозврата;
    АДРЕС64   АдрКадра;
    АДРЕС64   АдрСтэка;
    АДРЕС64   АдрВозврХр;
    ук       ЗаписьТабФций;
    бдол[4]  АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бдол[3]  Резерв;
    ПОМОЩЬОЯ64    помОЯ;
}
	alias КАДР_СТЕКА64 STACKFRAME64;
////////////////////////////////

struct ТОЧКА //POINT
{
    цел x;//ш - координата ширины
    цел y;//в - коордиата высоты
    alias x ш, ширина;
    alias y в, высота;
}
	alias ТОЧКА POINT;
	alias POINT* PPOINT, NPPOINT, LPPOINT;
/////////////////////////////////////////////////////////
struct РАЗМЕР //SIZE
{
    цел cx;//дш - дельта координат ширины
    цел cy;//дв - дельта координат высоты
    alias cx дш, ширина;
    alias cy дв, высота;
}
	alias РАЗМЕР SIZE, SIZEL;
	alias SIZE* PSIZE, LPSIZE, PSIZEL, LPSIZEL;
//////////////////////////////
struct ПРЯМ  //RECT
{
    цел    лево;
    цел    верх;
    цел    право;
    цел    низ;
}
	alias ПРЯМ  RECT;
alias RECT* PRECT, NPRECT, LPRECT;
/////////////////////////////////////////////////
struct РИССТРУКТ //PAINTSTRUCT
{
    ук ку;
    бул cтереть;
    ПРЯМ        пкРис;
    бул восстановить;
    бул инкОбнов;
    ббайт[32]        кзсРезерв;
}
	alias РИССТРУКТ PAINTSTRUCT;
	alias PAINTSTRUCT* PPAINTSTRUCT, NPPAINTSTRUCT, LPPAINTSTRUCT;
////////////////////////////////////////////////
struct ЗАПОБИСКЛ //EXCEPTION_RECORD
{
    бцел кодИскл;
    бцел флагиИскл;
    ЗАПОБИСКЛ* запОбИскл;
    ук адрИскл;
    бцел парамыНомера;
    бцел[МАКС_ИСКЛ_ПАРАМЫ] исклИнфо;
}
	alias ЗАПОБИСКЛ ЗАПИСЬ_ОБ_ИСКЛЮЧЕНИИ, EXCEPTION_RECORD;
	alias EXCEPTION_RECORD* PEXCEPTION_RECORD, LPEXCEPTION_RECORD;
/////////////////////////////////////

struct ИСКЛУКАЗАТЕЛИ//EXCEPTION_POINTERS
{
    ЗАПОБИСКЛ* исклЗап;
    КОНТЕКСТ* контЗап;
}
	alias ИСКЛУКАЗАТЕЛИ ИСКЛУКАЗЫ, УКАЗАТЕЛИ_НА_ИСКЛ, EXCEPTION_POINTERS;
	alias EXCEPTION_POINTERS* PEXCEPTION_POINTERS, LPEXCEPTION_POINTERS;
//////////////////////////////////////////
struct протзап //protoent
{
    ткст0 имя;
    ткст0* алиасы;
    крат прот;
}
	alias протзап protoent;
/////////////////////////

struct служзап //servent
{
    ткст0 имя;
    ткст0* алиасы;
    крат порт;
    ткст0 прот;
}
alias служзап servent;
//////////////////////////
struct хостзап //hostent
{
    ткст0 имя;
    ткст0* алиасы;
    version(Win32)
    {
        крат типадр;
        крат длина;
    }
    else version(BsdSockets)
    {
        цел типадр;
        цел длина;
    }
    ткст0* списадр;

    ткст0 адр()
    {
        return списадр[0];
    }
}
alias хостзап hostent;
////////////////////////

struct адрессок //sockaddr
{
    крат семейство;
    ббайт[14] данные;
}
alias адрессок sockaddr;
///////////////////////
struct адрессок_ин //sockaddr_in
{
    крат семейство =cast(крат) ПСемействоАдресов.ИНЕТ;
    крат порт;
    адрес_ин адр;
    ббайт[8] иас_ноль;
}
alias адрессок_ин sockaddr_in;

struct адрессок_ин6 //sockaddr_in6
{
    крат семейство = cast(крат) ПСемействоАдресов.ИНЕТ6;
    крат порт;
    бцел инфПоток;
    адрес_ин6 адр;
    бцел скопид;
}
alias адрессок_ин6 sockaddr_in6;
////////////////////////////
union адрес_ин //in_addr
{
    private union _С_ун_т
    {
        private struct _С_ун_б_т
        {
            ббайт с_б1, с_б2, с_б3, с_б4;
        }
        _С_ун_в_т С_ун_б;

        private struct _С_ун_в_т
        {
            бкрат с_в1, с_в2;
        }
        _С_ун_в_т С_ун_в;

        бцел С_адр;
    }
    _С_ун_т S_ун;

    бцел с_адр;

    struct
    {
        ббайт с_сеть, с_хост;

        union
        {
            бкрат с_имп;

            struct
            {
                ббайт с_лх, с_импнет;
            }
        }
    }
}
alias адрес_ин in_addr;
/////////////////////////////
	union адрес_ин6 //in6_addr
	{
		private union _ин6_у_т
		{
			ббайт[16] у6_адр8;
			бкрат[8] у6_адр16;
			бцел[4] у6_адр32;
		}
		_ин6_у_т ин6_у;
		ббайт[16] с6_адр8;
		
		бкрат[8] с6_адр16;
		бцел[4] с6_адр32;
		
		alias с6_адр8 с6_адр, s6_addr;
		alias _ин6_у_т _in6_u_t;
	}
	alias адрес_ин6 in6_addr;
//////////////////////////
struct значврем //timeval
{
    цел сек;//-унды;
    цел микросек;//-унды;
    alias сек секунды;
    alias микросек микросекунды;
}
	alias значврем timeval;
////////////////////////////
struct набор_уд //fd_set
{
    бцел счёт_уд;
    СОКЕТ[РАЗМНАБ_УД] массив_уд;
}
	alias набор_уд уднаб, fd_set;
//////////////////////////////
union заминка //linger
{
    struct
    {
        бкрат вкл;
        бкрат время;
    }
    бкрат[2] массив;
}
	alias заминка linger;
/////////////////////////////
struct адринфо //addrinfo
{
    цел флаги;
    цел семейство;
    цел типсок;
    цел протокол;
    т_мера длинадр;
    ткст0 канонимя;
    адрессок* адр;
    адринфо* следщ;
}
	alias адринфо addrinfo;
/////////////////////////////////////
struct КВАДКЗС //RGBQUAD
{
    ббайт    кзсСиний;
    ббайт    кзсЗелёный;
    ббайт    кзсКрасный;
    ббайт    кзсРезерв;
}
	alias КВАДКЗС RGBQUAD;
	alias RGBQUAD* LPRGBQUAD;
//////////////////////////////////////////////////
struct ИНФОБИТМАПЗАГ //BITMAPINFOHEADER
{
    бцел      размер;
    цел       ширина;
    цел       высота;
    бкрат       плоскости;
    бкрат       счётБит;
    бцел      сжатие;
    бцел      размОбр;
    цел       горизПиксНаМетр;
    цел       вертПиксНаМетр;
    бцел      использУпр;
    бцел      важнЦвета;//biClrImportant;
}
	alias ИНФОБИТМАПЗАГ BITMAPINFOHEADER;
	alias BITMAPINFOHEADER* LPBITMAPINFOHEADER, PBITMAPINFOHEADER;
////////////////////////////////////////////
struct ИНФОБИТМАП //BITMAPINFO
{
    ИНФОБИТМАПЗАГ    заголовок;//bmiHeader;
    КВАДКЗС[1]             цвета;
}
	alias ИНФОБИТМАП BITMAPINFO;
	alias BITMAPINFO* LPBITMAPINFO, PBITMAPINFO;
////////////////////////////////////////
struct ЗАПИСЬ_ПАЛИТРЫ //PALETTEENTRY
{
    ббайт        крас;
    ббайт        зел;
    ббайт        син;
    ббайт        флаги;
}
	alias ЗАПИСЬ_ПАЛИТРЫ ПАЛИТЗАП, PALETTEENTRY;
	alias PALETTEENTRY* PPALETTEENTRY, LPPALETTEENTRY;
////////////////////////////////////////////////////
struct ЛОГ_ПАЛИТРЫ //LOGPALETTE
{
    бкрат        версия;
    бкрат        члоЗап;
    ПАЛИТЗАП[1]        палЗап;
}
	alias ЛОГ_ПАЛИТРЫ ПАЛИТЛОГ, LOGPALETTE;
	alias LOGPALETTE* PLOGPALETTE, NPLOGPALETTE, LPLOGPALETTE;
/////////////////////////////////////////////
	/* Описатель формата пикселя */
struct ДЕСКРФОРМАТАПИКСЕЛЯ //PIXELFORMATDESCRIPTOR
{
    бкрат  размер;
    бкрат  версия;
    бцел   флаги;
    ббайт  типПикселя;
    ббайт  битыЦвета;
    ббайт  кБиты;//к - красный
    ббайт  кСдвиг;
    ббайт  зБиты;//з -зелёный
    ббайт  зСдвиг;
    ббайт  сБиты;//с - синий
    ббайт  сСдвиг;
    ббайт  аБиты;//а - альфа (прозрачность)
    ббайт  аСдвиг;
    ббайт  аккумБиты;
    ббайт  аккумКБиты;
    ббайт  аккумЗБиты;
    ббайт  аккумСБиты;
    ббайт  аккумАБиты;
    ббайт  битыДали; //даль = depth = "глубина" пикселей на экране
    ббайт  битыШаблона;//шаблон = stencil
    ббайт  допБуферы;
    ббайт  типСлоя;
    ббайт  резерв;
    бцел   маскаСлоя;
    бцел   маскаВидимого;
    бцел   маскаПовреждения;
}
	alias ДЕСКРФОРМАТАПИКСЕЛЯ PIXELFORMATDESCRIPTOR;
	alias PIXELFORMATDESCRIPTOR* PPIXELFORMATDESCRIPTOR, LPPIXELFORMATDESCRIPTOR;

//////////////////////////////////////////
struct КЛАССОКДОП_А //WNDCLASSEXA
{
    бцел        стиль;
    ОКОНПРОЦ    оконПроц;
    цел         упрэлтыЭкстра;
    цел         окЭкстра;
    экз  		экземпляр;
    УИконка      	пиктограмма;
    УКурсор    		курсор;
    УКисть      	фон;
    ткст0       имяМеню;
    ткст0       имяКласса;
   УИконка  пиктограммаМал;
}
	alias КЛАССОКДОП_А WNDCLASSEXA;
	alias WNDCLASSEXA* LPWNDCLASSEXA, PWNDCLASSEXA;
///////////////////////////////////////
///////////////////////////////
struct КЛАССОКДОП //WNDCLASSEXW
{
    бцел     размер= КЛАССОКДОП.sizeof;
    /* Win 3.x */
    бцел    стиль;
    ОКОНПРОЦ  оконПроц;
    цел     упрэлтыЭкстра;
    цел     окнаЭкстра;
    экз  	экземпляр;
    УИконка      пиктограмма;
    УКурсор    	курсор;
    УКисть      фон;
    шткст0   имяМеню;
    шткст0   имяКласса;
    УИконка  пиктограммаМал;
}
alias  КЛАССОКДОП WNDCLASSEXW;
alias WNDCLASSEXW* LPWNDCLASSEXW, PWNDCLASSEXW;
//////////////////////////////////////////
struct КЛАССОК_А //WNDCLASSA
{
    бцел        стиль;
    ОКОНПРОЦ    оконПроц;
    цел         упрэлтыЭкстра;
    цел         окЭкстра;
    экз  		экземпляр;
    УИконка      	пиктограмма;
    УКурсор    		курсор;
    УКисть      	фон;
    ткст0       имяМеню;
    ткст0       имяКласса;
}
	alias КЛАССОК_А WNDCLASSA;
	alias WNDCLASSA* LPWNDCLASSA, PWNDCLASSA;
///////////////////////////////////////
struct КЛАССОК //WNDCLASSW
{
    бцел        стиль;
    ОКОНПРОЦ    оконПроц;
    цел         упрэлтыЭкстра;
    цел         окЭкстра;
    экз  		экземпляр;
    УИконка      	пиктограмма;
    УКурсор    		курсор;
    УКисть      	фон;
    шткст0       имяМеню;
    шткст0       имяКласса;
}
	alias КЛАССОК WNDCLASSW;
	alias WNDCLASSW* LPWNDCLASSW, PWNDCLASSW;
////////////////////////////////////////////
struct СООБ //MSG
{
    ук      окноПолучатель;
    бцел    сообщение;
    бцел    вПарам;
    цел     лПарам;
    бцел    время;
    ТОЧКА   тчк;
}
	alias СООБ MSG;
	alias MSG* PMSG, NPMSG, LPMSG;
/////////////////////////////////////////////////
struct МЕТРИКА_ТЕКСТА //TEXTMETRICA
{
    цел        высота;
    цел        подъём;
    цел        спуск;
    цел        внутрВступ;
    цел        внешнийВступ;
    цел        среднШирСим;
    цел        максШирСим;
    цел        вес;
    цел        перевес;
    цел        оцифрАспектШ;
    цел        оцифрАспектВ;
    ббайт        первСим;
    ббайт        последнСим;
    ббайт        дефолтнСим;
    ббайт        брейкСим;
    ббайт        курсив;
    ббайт        подчерк;
    ббайт        струкАут;
    ббайт        питчИСемейство;
    ббайт        гарнитура;
}
alias МЕТРИКА_ТЕКСТА ТЕКСТМЕТР;
////////////////////////////////////////////////////////
alias ОТКРФЛХУКПРОЦ LPOFNHOOKPROC;
////////////////////////////////////
struct ОТКРФАЙЛ_А
{
    бцел        размерСтрукт;
    ук         окХозяин;
    экз    		экземпляр;
    ткст0       фильтр;
    ткст0        фильтрАдапт;
    бцел        максЧлоАдаптФильтров;
    бцел        индексФильтра;
    ткст0        файл;
    бцел        максЧлоФайлов;
    ткст0        титулФ;
    бцел        максЧлоФТитулов;
    ткст0       исхПапка;
    ткст0       титул;
    бцел        Флаги;
    бкрат         фСмещен;
    бкрат         члоФРасш;
    ткст0       дефРасш;
    цел       допДанные;
    ОТКРФЛХУКПРОЦ офХук;
    ткст0       имяШаблона;
}
	alias ОТКРФАЙЛ_А OPENFILENAMEA;
	alias OPENFILENAMEA *LPOPENFILENAMEA;
//////////////////////////////////////////////////
	struct ОТКРФАЙЛ
	 {
	   бцел        размерСтрукт;
	   ук         окХозяин;
	   экз    экземпляр;
	   шткст0      фильтр;
	   шткст0       фильтрАдапт;
	   бцел        максЧлоАдаптФильтров;
	   бцел        индексФильтра;
	   шткст0       файл;
	   бцел        максЧлоФайлов;
	   шткст0       титулФ;
	   бцел        максЧлоФТитулов;
	   шткст0      исхПапка;
	   шткст0      титул;
	   бцел        Флаги;
	   бкрат         фСмещен;
	   бкрат         члоФРасш;
	   шткст0      дефРасш;
	   цел       допДанные;
	   ОТКРФЛХУКПРОЦ офХук;
	   шткст0      имяШаблона;
	}
	alias ОТКРФАЙЛ OPENFILENAMEW;
	alias OPENFILENAMEW *LPOPENFILENAMEW;
////////////////////////////////////////
/* Bitmap Header Definition */

struct БИТМАП //BITMAP
{
    цел        тип;
    цел        ширина;
    цел        высота;
    цел        байтыШирины;
    бкрат      плоскости;
    бкрат      пиксельБит;
    ук         биты;
}
	alias БИТМАП BITMAP;
	alias BITMAP* PBITMAP, NPBITMAP, LPBITMAP;
///////////////////////////////////////////////////////
	struct ЛОГ_ШРИФТА //LOGFONTA
	{
		цел      высота;
		цел      ширина;
		цел      lfEscapement;
		цел      ориентация;
		цел      вес;
		ббайт      курсив;
		ббайт      подчерк;
		ббайт      перечерк;
		ббайт      гарнитура;
		ббайт      выхТочность;
		ббайт      обрезТочность;
		ббайт      качество;
		ббайт      питчИСемейство;
		сим[32]       имяКегля;
	}
	alias ЛОГ_ШРИФТА ШРИФТЛОГ_А, LOGFONTA;
	alias LOGFONTA* PLOGFONTA, NPLOGFONTA, LPLOGFONTA;
////////////////////////////////////
		struct ЛОГ_ШРИФТ //LOGFONTW
	{
		цел      высота;
		цел      ширина;
		цел      lfEscapement;
		цел      ориентация;
		цел      вес;
		ббайт      курсив;
		ббайт      подчерк;
		ббайт      перечерк;
		ббайт      гарнитура;
		ббайт      выхТочность;
		ббайт      обрезТочность;
		ббайт      качество;
		ббайт      питчИСемейство;
		шим[32]       имяКегля;
	}
	alias ЛОГ_ШРИФТ ШРИФТЛОГ, LOGFONTW;
	alias LOGFONTW* PLOGFONTW, NPLOGFONTW, LPLOGFONTW;
////////////////////////////////////////////////////////////
	/+
struct EXTLOGFONTA {
	LOGFONTA              elfLogFont;
	BYTE[LF_FULLFACESIZE] elfFullName;
	BYTE[LF_FACESIZE]     elfStyle;
	DWORD                 elfVersion;
	DWORD                 elfStyleSize;
	DWORD                 elfMatch;
	DWORD                 elfReserved;
	BYTE[ELF_VENDOR_SIZE] elfVendorId;
	DWORD                 elfCulture;
	PANOSE                elfPanose;
}
alias EXTLOGFONTA* PEXTLOGFONTA, NPEXTLOGFONTA, LPEXTLOGFONTA;
////////////////////////////////////////////////////
struct EXTLOGFONTW {
	LOGFONTW               elfLogFont;
	WCHAR[LF_FULLFACESIZE] elfFullName;
	WCHAR[LF_FACESIZE]     elfStyle;
	DWORD                  elfVersion;
	DWORD                  elfStyleSize;
	DWORD                  elfMatch;
	DWORD                  elfReserved;
	BYTE[ELF_VENDOR_SIZE]  elfVendorId;
	DWORD                  elfCulture;
	PANOSE                 elfPanose;
}
alias EXTLOGFONTW* PEXTLOGFONTW, NPEXTLOGFONTW, LPEXTLOGFONTW;
+/
////////////////////////////////////////////////////////
	align (2) struct ШАБЛОНДЛГ//DLGTEMPLATE
	 {
		бцел стиль;
		бцел расширеннСтиль;
		бкрат cdit;
		крат x; alias x ш;
		крат y; alias y в;
		крат cx; alias cx дш;
		крат cy; alias cy дв;
	}
alias ШАБЛОНДЛГ DLGTEMPLATE;
alias DLGTEMPLATE *LPDLGTEMPLATEA;
alias DLGTEMPLATE *LPDLGTEMPLATEW;
alias LPDLGTEMPLATEA LPDLGTEMPLATE;
alias  DLGTEMPLATE *LPCDLGTEMPLATEA;
alias  DLGTEMPLATE *LPCDLGTEMPLATEW;
alias LPCDLGTEMPLATEA LPCDLGTEMPLATE;
////////////////////////////////////////////////////////

struct ЛОГ_ПЕРА //LOGPEN
{
    бцел        Стиль;
    ТОЧКА       Ширина;
    ЦВЕТ       Цвет;
}
	alias ЛОГ_ПЕРА ПЕРЛОГ, LOGPEN;
alias LOGPEN* PLOGPEN, NPLOGPEN, LPLOGPEN;
//////////////////////////////////////////////////
	struct КООРД //COORD
	 {
		крат X; alias X Ш;
		крат Y; alias Y В;
	}
	alias КООРД COORD;
	alias COORD *PCOORD;
/////////////////////////////////////////////////////

struct МПРЯМ //SMALL_RECT
{
    крат лево;
    крат верх;
    крат право;
    крат низ;
}
	alias МПРЯМ SMALL_RECT;
	alias SMALL_RECT *PSMALL_RECT;
/////////////////////////////////////////////
	struct ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ //KEY_EVENT_RECORD
{
    бул 	клВнизу;
    бкрат 	счётПовторов;
    бкрат 	кодВиртКл;
    бкрат 	кодВиртСкан;
    union
    {
        шим симЮникода;
        сим   симАски;
    }
    бцел состКлУпр;
}
	alias ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ ЗАПСОБКЛ, KEY_EVENT_RECORD;
	alias KEY_EVENT_RECORD *PKEY_EVENT_RECORD;
///////////////////////////////////////////////
	struct ЗАПИСЬ_СОБЫТИЯ_МЫШИ //MOUSE_EVENT_RECORD
{
    КООРД позМыши;
    ПСостКнопкиМыши состКнопки;
    ПСостКлУпр состКлУпр;
    ПТипСобМыши флагиСобытия;
}
	alias ЗАПИСЬ_СОБЫТИЯ_МЫШИ ЗАПСОБМЫШ, MOUSE_EVENT_RECORD;
	alias MOUSE_EVENT_RECORD *PMOUSE_EVENT_RECORD;
//////////////////////////////////////////////////////////
	struct ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА//WINDOW_BUFFER_SIZE_RECORD
	 {
		КООРД размер;
	 }
	alias ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА ЗАПРАЗМБУФОК, WINDOW_BUFFER_SIZE_RECORD;
	alias WINDOW_BUFFER_SIZE_RECORD *PWINDOW_BUFFER_SIZE_RECORD;
////////////////////////////////////////////////
	struct ЗАПИСЬ_СОБЫТИЯ_МЕНЮ //MENU_EVENT_RECORD
	 {
		бцел идКоманды;
	 }
	alias ЗАПИСЬ_СОБЫТИЯ_МЕНЮ ЗАПСОБМЕНЮ, MENU_EVENT_RECORD;
	alias MENU_EVENT_RECORD *PMENU_EVENT_RECORD;
/////////////////////////////////////////////////
	struct ЗАПИСЬ_СОБЫТИЯ_ФОКУСА//FOCUS_EVENT_RECORD
	 {
		бул установитьФокус;
	}
	alias ЗАПИСЬ_СОБЫТИЯ_ФОКУСА ЗАПСОБФОК, FOCUS_EVENT_RECORD;
	alias FOCUS_EVENT_RECORD *PFOCUS_EVENT_RECORD;
//////////////////////////////////////////////////
	struct ЗАПИСЬ_ВВОДА//INPUT_RECORD
{
    бкрат типСобытия;
    union
    {
        ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ собКлав;
        ЗАПИСЬ_СОБЫТИЯ_МЫШИ 	собМыши;
        ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА собРазмБуфОк;
        ЗАПИСЬ_СОБЫТИЯ_МЕНЮ собМеню;
        ЗАПИСЬ_СОБЫТИЯ_ФОКУСА собФок;
    }
}
	alias ЗАПИСЬ_ВВОДА ЗАПВВОДА, INPUT_RECORD;
	alias INPUT_RECORD *PINPUT_RECORD;
///////////////////////////////////
struct ИНФОСИМ//CHAR_INFO
{
    union
    {
        шим симЮникода;
        сим   симАски;
    }
    ПАтрыИнфосим атрибуты;
}
	alias ИНФОСИМ CHAR_INFO;
	alias CHAR_INFO *PCHAR_INFO;
/////////////////////////////
	struct ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ //CONSOLE_SCREEN_BUFFER_INFO
	{
		КООРД размер;
		КООРД позКурсора;
		ПТекстКонсоли  атрибуты;
		МПРЯМ окно;
		КООРД максРазмОкна;
	}
	alias ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ ИНФОКОНСЭКРБУФ, CONSOLE_SCREEN_BUFFER_INFO;
	alias CONSOLE_SCREEN_BUFFER_INFO *PCONSOLE_SCREEN_BUFFER_INFO;
////////////////////////////////////////////////////////////////

	struct ИНФ_О_КУРСОРЕ_КОНСОЛИ //CONSOLE_CURSOR_INFO
	{
		бцел  размер;
		бул   видимый;
	}
	alias ИНФ_О_КУРСОРЕ_КОНСОЛИ ИНФОКОНСКУРСОР, CONSOLE_CURSOR_INFO;
	alias CONSOLE_CURSOR_INFO *PCONSOLE_CURSOR_INFO;
////////////////////////////////////////////////////
struct ВИНСОКБУФ //WSABUF
{
    бцел    длина;
    ук   буф;
}
alias ВИНСОКБУФ WSABUF;
//////////////////////////////
	struct ВИНСОКДАН //WSADATA
	{
		бкрат версия;
		бкрат хВерсия;
		сим[cast(цел) ДЛИНА_ВСАОПИСАНИЯ + 1] описание;
		сим[cast(цел) ДЛИНА_ВСАСИС_СТАТУСА + 1] сисСтатус;
		бкрат максЧлоСок;
		бкрат максДгПпд;//iMaxUdpDg;
		ткст0 инфОПроизв;//lpVendorInfo;
	}
	alias ВИНСОКДАН WSADATA;
	alias WSADATA* LPWSADATA;
/////////////////////////////////////////////////////
struct ВавЗаг
{
    сим[4] рифф = "RIFF";
    бцел размер;
    сим[4] фмт = "WAVE";

    сим[4] идЦилиндраФмт = "fmt ";
    бцел размерЦилиндраФмт;
    бкрат аудиоФормат;
    бкрат члоКаналов;
    бцел семплРейт;
    бцел байтРейт;
    бкрат раскладкаБлока;
    бкрат битНаСемпл;

    сим[4] идЦилиндраДанных = "data";
    бцел размерЦилиндраДанных;
    // data follows
}
////////////////////////////////////////////////
struct ИНФОСТАРТА //STARTUPINFO
{
    бцел размер;//этой стр-ры
    шим *резерв;//пусто
    шим *рабСтол;//название процесса на раб.ст.
    шим *титул;//если пусто, то отображается просто имя программы
    бцел ш;//смещение по ширине от левого верхнего угла
    бцел в;//то же по высоте
    бцел шразм;//ширина окна
    бцел вразм;//высота окна
    бцел школвосим;//ширина экранного буфера
    бцел вколвосим;//высота экранного буфера
    бцел запатр;//начальные цвета текста и фона
    бцел флаги; //Перечень флагов
    бкрат показОкна;
    бкрат резерв2;
    ббайт *резерв2Ук;
    ук стдвво;
    ук стдвыв;
    ук стдош;
}
	alias ИНФОСТАРТА STARTUPINFO;
	alias STARTUPINFO* LPSTARTUPINFO;
	alias STARTUPINFO _STARTUPINFO;
///////////////////////////////////////////////////////
struct ИНФОПРОЦ //PROCESS_INFO
{
    ук процесс;
    ук нить;
    бцел идПроцесса;
    бцел идНити;
}
alias ИНФОПРОЦ PROCESS_INFO, PROCESS_INFORMATION;
alias PROCESS_INFORMATION* LPPROCESS_INFORMATION;
alias PROCESS_INFORMATION _PROCESS_INFORMATION;
alias PROCESS_INFORMATION TPROCESSINFORMATION;
alias PROCESS_INFORMATION* PPROCESSINFORMATION;
/////////////////////////////////////////////////////////
struct ГРАНБЕЗОПМАСА
{
    бцел члоЭлтов;
    цел нижГран;
}
////////////////////////////////////////
struct КОСЕРВЕРИНФО //COSERVERINFO
{
    бцел резерв1;
    шткст0 имяОбъ;  
    КОАУТИНФО* аутИнф;
    бцел резерв2;
}
//////////////////////////////////////////////
	struct КОАУТИДЕНТИЧНОСТЬ //COAUTHIDENTITY
	{
	  шткст0 Пользователь;
	  бцел ПользовательДлина;
	  шткст0 Домен;
	  бцел ДоменДлина;
	  шткст0 Пароль;
	  бцел ПарольДлина;
	  бцел Флаги;
	}
/////////////////////////////////
	struct КОАУТИНФО //COAUTHINFO
	{
	  бцел службаАутн;
	  бцел службаАутз;
	  шткст0 имяПринкСервера;
	  бцел уровеньАутн;
	  бцел уровеньИмперсонации;
	  КОАУТИДЕНТИЧНОСТЬ* данныеАутИдент;
	  бцел способности;
	}
/////////////////////////////
	struct ОТКРПМБ //STATSTG
	 {
	  шткст0 укНаШ0Имя;
	  бцел тип;
	  бдол бРазм;
	  ФВРЕМЯ ивремя;
	  ФВРЕМЯ свремя;
	  ФВРЕМЯ двремя;
	  бцел послРежДост;
	  бцел поддержТипыБлокРгна;
	  ГУИД клсид;
	  бцел битыТекСостХр;
	  бцел резерв;
	}
///////////////////////////////
	struct ОПЦИИХР //STGOPTIONS
	 {
	  бкрат испВерсия;
	  бкрат резерв;
	  бцел бдРазмСектора;
	  шткст0 укНаШ0ФайлШаблона;
	}
///////////////////////
struct СВЯЗОПЦИИ //
{
    бцел бСтрукт = СВЯЗОПЦИИ.sizeof;
    бцел мсоФлаги;
    бцел послРежДост;
    бцел бцПредельнСрокТик;
}
//////////////////////
struct СВЯЗОПЦИИ2
{
    бцел бСтрукт = СВЯЗОПЦИИ2.sizeof;
    бцел мсоФлаги;
    бцел послРежДост;
    бцел бцПредельнСрокТик;
    бцел бцТрэкФлаги;
    бцел бцКонтекстКласса;
    бцел локаль;
    КОСЕРВЕРИНФО* укНаСерверИнфо;
}
///////////////////////////
struct МУЛЬТИ_ОИ //MULTI_QI
{
    ГУИД* укНаИИд;
    Инкогнито укНаИз;
    цел хрез;
}
///////////////////////////////
struct ЦУСТРОЙСТВО //DVTARGETDEVICE
{
    бцел цуРазм;
    бкрат цуСмещКИмениДрайвера;
    бкрат цуСмещКИмениУстрва;
    бкрат цуСмещКИмениПорта;
    бкрат цуСмещКДопУстрреж;
    ббайт* цуДанные;
}
///////////////////////////////
struct ФОРМАТИТД //FORMATETC
{
    бкрат формат;
    ЦУСТРОЙСТВО* укнад;
    бцел аспект;
    цел индекс;
    бцел тимед;
}
//////////////////////////////////
	struct НОСИТЕЛЬПАМ //STGMEDIUM
	{
	  бцел тимед;
	  union {
		ук битмап;
		ук метаФайлПикт;
		ук усМетаФайл;
		ук глоб;
		шткст0 имяф;
		ИПоток птк;
		ИХранилище хран;
	  }
	  Инкогнито инкДляВысвобожд;
	}
////////////////////////////
	struct ОЛЕВЕРБ //OLEVERB
	 {
	  цел верб;
	  шткст0 имяВерба;
	  бцел флаги;
	  бцел грфАтры;
	}
///////////////////////////////
struct СТАТДАННЫЕ //STATDATA
{
    ФОРМАТИТД форматетц;
    бцел адвф;
    IAdviseSink адвСинк;
    бцел соединение;
}
//////////////////////////////////
struct ДИСППАРАМЫ //DISPPARAMS
{
    ВАРИАНТ* ргварг;
    цел* ргдиспидИменованыеАрги;
    бцел арги;
    бцел именованыеАрги;
}
///////////////////////////////
	struct ИСКЛИНФО //EXCEPINFO
	 {
	  бкрат код;
	  бкрат резерв1;
	  шткст0 исток;
	  шткст0 описание;
	  шткст0 файлСправки;
	  бцел контекстСправки;
	  ук   резерв2;
	  цел function(ИСКЛИНФО*) измененЗаполнение;
	  цел скод;
	}
/////////////////////////////
struct ТИПДЕСКР //TYPEDESC
{
    union
    {
        ТИПДЕСКР* деск;
        МАССДЕСКР* адеск;
        бцел ссылтип;
    }
    бкрат вт;
}
/////////////////////////////
struct МАССДЕСКР//ARRAYDESC
{
    ТИПДЕСКР элемДеск;
    бкрат меры;
    ГРАНБЕЗОПМАСА[1] ргграни;
}
/////////////////////////////////////
struct ПАРАМДЕСКРДОП //PARAMDESCEX
{
    бцел байты;
    ВАРИАНТ дефЗнач;
}
/////////////////////////////////
struct ПАРАМДЕСКР //PARAMDESC
{
    ПАРАМДЕСКРДОП* ппарамдесцекс;
    бкрат флагиПарам;
}
//////////////////////////////
struct ИДЛДЕСКР //IDLDESC
{
    бцел резерв;
    бкрат флпгиИДЛ;
}
///////////////////////////////
struct ЭЛЕМДЕСКР //ELEMDESC
{
    ТИПДЕСКР дескт;
    union
    {
        ИДЛДЕСКР дескИДЛ;
        ПАРАМДЕСКР дескпарам;
    }
}
////////////////////////////
	struct ТИПАТР//TYPEATTR
	 {
	  ГУИД гуид;
	  бцел лкид;
	  бцел резерв;
	  цел конструкторЧленИД;
	  цел деструкторЧленИД;
	  шткст0 схема;
	  бцел размерЭкземпляра;
	  ПВидТипа типвид;
	  бкрат функи;
	  бкрат пермы;
	  бкрат имплТипы;//cImplTypes
	  бкрат размерВфт;
	  бкрат раскладка;
	  бкрат флагиТипов;
	  бкрат номСтаршВерс;
	  бкрат номМладшВерс;
	  ТИПДЕСКР алиасДеск;
	  ИДЛДЕСКР типДескИДЛ;
	}
///////////////////////////////
alias цел ИДДИСП;
alias ИДДИСП ИДЧЛЕНА;
alias бцел ТИПГССЫЛ;

	struct ФУНКЦДЕСКР//FUNCDESC
	{
	  ИДЧЛЕНА идЧлена;//memid
	  цел* ргскод;
	  ЭЛЕМДЕСКР* парамРгэлемдеск;
	  ПВидФунк видфунк;
	  ПВидВызова типвыз;
	  ПКонвВызова конввыз;
	  крат парамы;
	  крат опцПарамов;
	  крат ВфтО;
	  крат скоды;
	  ЭЛЕМДЕСКР функЭлемдеск;
	  бкрат флагиФунк;
	}
//////////////////////////////
struct ПЕРЕМДЕСКР //VARDESC
	{
	  цел идпам;
	  шткст0 схема;
	  union {
		бцел экзО;
		ВАРИАНТ* значПерем;
	  }
	  ЭЛЕМДЕСКР перемДескЭлем;
	  бкрат флагиПерем;
	  ПВидПерем типперем;
	}
////////////////////////////
	struct УКПРИВЯЗ//BINDPTR
	 {
	  ФУНКЦДЕСКР* функдескр;
	  ПЕРЕМДЕСКР* вардескр;
	  ITypeComp ткомп;
	}
//////////////////////////////////
	struct ОСОБЭЛДАН//CUSTDATAITEM 
	{
	  ГУИД гуид;
	  ВАРИАНТ значВар;
	}
////////////////////////////
	struct ОСОБДАН //CUSTDATA
	 {
	  бцел особДанные;
	  ОСОБЭЛДАН* осДан;
	}
//////////////////////////////////////
	struct ИНФ_О_КАТЕГОРИИ//CATEGORYINFO
	 {
	  ГУИД идКат;
	  бцел лкид;
	  шим[128] описание;
	}
	alias ИНФ_О_КАТЕГОРИИ ИНФОКАТ;
//////////////////////////////////
	struct АТРТБИБ //TLIBATTR
	 {
	  ГУИД гуид;
	  бцел лкид;
	  ПВидСистемы видсис;
	  бкрат старшНомВер;
	  бкрат младНомВер;
	  бкрат флагиБиб;
	}
///////////////////////////////
struct РИСДЕСКР//PICTDESC
{
    бцел размер = РИСДЕСКР.sizeof;
    бцел типРис;
    ук укз;
}
//////////////////////////////////
struct СОЕДДАН //CONNECTDATA
{
    Инкогнито инк;
    бцел куки;
}
/////////////////////////////
struct ИНФОЛИЦ //LICINFO
{
    цел инфолиц = ИНФОЛИЦ.sizeof;
    цел доступнРантаймКлюч;
    цел лицВерифицирована;
}
alias ИНФОЛИЦ LICINFO;
alias LICINFO* LPLICINFO;
//////////////////////////////////////////////
struct МЕТРИКА_ОЛЕ_ТЕКСТА //TEXTMETRICOLE
{
    цел высота;
    цел подъём;
    цел спуск;
    цел внутреннийВвод;
    цел внешнийВвод;
    цел средШирСим;
    цел максШирСим;
    цел вес;
    цел свис;
    цел оцифрАспектШ;
    цел оцифрАспектВ;
    шим первСим;
    шим последнСим;
    шим дефСим;
    шим брейкСим;
    ббайт курсив;
    ббайт подчерк;
    ббайт tmStruckOut;
    ббайт tmPitchAndFamily;
    ббайт гарнитура;
}
alias МЕТРИКА_ОЛЕ_ТЕКСТА ОЛЕТЕКСТМЕТР;
///////////////////////////////////////////////////
struct ЗАПИСЬ_КУЧИ_ПРОЦЕССА //PROCESS_HEAPENTRY
{
    ук данук;
    бцел данные;
    ббайт излишек;
    ббайт индексРегиона;
    бкрат флаги;
    union
    {
        struct Блок
        {
            ук пам;
            бцел[3] резерв;
        }

        struct Регион
        {
            бцел переданныйРазм;
            бцел непереданныйРазм;
            ук первБлок;
            ук последнБлок;
        }
    }
}
alias ЗАПИСЬ_КУЧИ_ПРОЦЕССА ЗАППРОЦКУЧ;

//////////////////////////////////////////
	union БОЛЬШЕЦЕЛ //LARGE_INTEGER
	 {
		struct {
			бцел младшЧасть;
			цел старшЧасть;
		}
		дол квадрЧасть;
	}
alias БОЛЬШЕЦЕЛ ЛУИД, LARGE_INTEGER;
alias LARGE_INTEGER* PLARGE_INTEGER;
alias LARGE_INTEGER LUID;
alias LUID* PLUID;
///////////////////////////
	union ББОЛЬШЕЦЕЛ //ULARGE_INTEGER
	 {
		struct {
			бцел младшЧасть;
			бцел старшЧасть;
		}
		бдол квадрЧасть;
	}
alias ББОЛЬШЕЦЕЛ ULARGE_INTEGER;
	alias ULARGE_INTEGER* PULARGE_INTEGER;
//////////////////////////////
align(4) struct ЛУИД_И_АТРЫ//LUID_AND_ATTRIBUTES
	{
	ЛУИД луид;
	бцел атры;
	}
alias ЛУИД_И_АТРЫ LUID_AND_ATTRIBUTES;
alias LUID_AND_ATTRIBUTES* PLUID_AND_ATTRIBUTES;
/////////////////////////////////
	struct НАБОР_ПРИВИЛЕГИЙ//PRIVILEGE_SET
	{
	бцел члоПрив;
	бцел упр;
	ЛУИД_И_АТРЫ _Привилегия;

	ЛУИД_И_АТРЫ* Привилегия() { return &_Привилегия; }
	}
alias НАБОР_ПРИВИЛЕГИЙ PRIVILEGE_SET;
alias PRIVILEGE_SET* PPRIVILEGE_SET;
///////////////////////////////////////////
enum SECURITY_IMPERSONATION_LEVEL {
	SecurityAnonymous,
	SecurityIdentification,
	SecurityImpersonation,
	SecurityDelegation
}

alias BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
alias BOOLEAN* PSECURITY_CONTEXT_TRACKING_MODE;
//////////////////////////////////////////////////////////////////
	struct КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ//SECURITY_QUALITY_OF_SERVICE 
	{
	бцел длина;
	ПУровеньИмперсонацииБезопасности   уровеньИмп;
	РЕЖИМ_ОТСЛЕЖИВАНИЯ_КОНТЕКСТА_БЕЗОПАСНОСТИ режимОтслежКонтекста;
	бул толькоДейств;
	}
	alias КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ КАЧБЕЗОПСЛУЖБ, SECURITY_QUALITY_OF_SERVICE;
	alias SECURITY_QUALITY_OF_SERVICE* PSECURITY_QUALITY_OF_SERVICE;
//////////////////////////////////////////////////////////////
alias PVOID PACCESS_TOKEN;
//////////////////////////////////////////////////
struct БЕЗОПИМПЕРССОСТ//SE_IMPERSONATION_STATE
{
    УкТОКЕН_ДОСТУПА 				 токен;
    бул 							 копироватьПриОткр;
    бул								 толькоДейств;
    ПУровеньИмперсонацииБезопасности уровень;
}
alias БЕЗОПИМПЕРССОСТ SE_IMPERSONATION_STATE;
alias SE_IMPERSONATION_STATE* PSE_IMPERSONATION_STATE;
////////////////////////////////////////////////////////
struct БИДИДЕНТАВТОРИТ//SID_IDENTIFIER_AUTHORITY
	{
	ббайт[6] знач;
	}
alias БИДИДЕНТАВТОРИТ SID_IDENTIFIER_AUTHORITY;
alias SID_IDENTIFIER_AUTHORITY* PSID_IDENTIFIER_AUTHORITY, LPSID_IDENTIFIER_AUTHORITY;
///////////////////////////////////

alias PVOID PSID;
///////////////////////
struct БИД//SID
{
    ббайт			ревизия;
    ббайт 			члоСубАвторитов;
    БИДИДЕНТАВТОРИТ идентАвторит;
    бцел 			_ПодАвторит;

	бцел* ПодАвторит() { return &_ПодАвторит; }
}
	alias БИД SID;
	alias SID* PISID;
///////////////////////////////////////////////

struct БИД_И_АТРЫ//SID_AND_ATTRIBUTES
{
    УкБИД бид;
    бцел атры;
}
alias БИД_И_АТРЫ SID_AND_ATTRIBUTES;
alias SID_AND_ATTRIBUTES* PSID_AND_ATTRIBUTES;
/////////////////////////////////////////

const size_t TOKEN_SOURCE_LENGTH = 8;
alias TOKEN_SOURCE_LENGTH ДЛИНА_ИСТОКА_ТОКЕНА;

	struct ИСТОК_ТОКЕНА //TOKEN_SOURCE
{
    сим[ДЛИНА_ИСТОКА_ТОКЕНА] имяИстока;
    ЛУИД идИстока;
}
	alias ИСТОК_ТОКЕНА ТОКИСТ, TOKEN_SOURCE;
	alias TOKEN_SOURCE* PTOKEN_SOURCE;
//////////////////////////////////////////////
struct ТОКЕНУПР//TOKEN_CONTROL
{
    ЛУИД         идТокена;
    ЛУИД         идАутентик;
    ЛУИД         идИзмененный;
    ТОКИСТ		 токИст;
}
alias ТОКЕНУПР TOKEN_CONTROL;
alias TOKEN_CONTROL* PTOKEN_CONTROL;
////////////////////////////////////////////////////

	struct ДЕФОЛТ_ДСКД_ТОКЕН//TOKEN_DEFAULT_DACL 
	{
	СКД* дефолтДскд;
	}
alias ДЕФОЛТ_ДСКД_ТОКЕН ДЕФДСКДТОК, TOKEN_DEFAULT_DACL;
alias TOKEN_DEFAULT_DACL* PTOKEN_DEFAULT_DACL;
////////////////////////////////////////////
	struct ГРУППЫ_ТОКЕНОВ//TOKEN_GROUPS
	{
	бцел 		члоГрупп;
	БИД_И_АТРЫ	 _Группы;

	БИД_И_АТРЫ* Группы() { return &_Группы; }
	}
	alias ГРУППЫ_ТОКЕНОВ ТОКЕНГРУП, TOKEN_GROUPS;
	alias TOKEN_GROUPS* PTOKEN_GROUPS, LPTOKEN_GROUPS;
/////////////////////////////////////////////
	struct ВЛАДЕЛЕЦ_ТОКЕНА //TOKEN_OWNER 
	{
	УкБИД владелец;
	}
alias ВЛАДЕЛЕЦ_ТОКЕНА TOKEN_OWNER;
alias TOKEN_OWNER* PTOKEN_OWNER;
////////////////////////////////////////////////////////
	struct ПЕРВИЧН_ГРУППА_ТОКЕНОВ//TOKEN_PRIMARY_GROUP 
	{
	УкБИД первичнГруппа;
	}
alias  ПЕРВИЧН_ГРУППА_ТОКЕНОВ TOKEN_PRIMARY_GROUP;
alias TOKEN_PRIMARY_GROUP* PTOKEN_PRIMARY_GROUP;
/////////////////////////////////////////////////////
	struct ПРИВИЛЕГИИ_ТОКЕНОВ//TOKEN_PRIVILEGES
	{
	бцел 		члоПривилегий;
	ЛУИД_И_АТРЫ _Привилегии;

	ЛУИД_И_АТРЫ* Привилегии() { return &_Привилегии; }
	}
alias ПРИВИЛЕГИИ_ТОКЕНОВ TOKEN_PRIVILEGES;
alias TOKEN_PRIVILEGES* PTOKEN_PRIVILEGES, LPTOKEN_PRIVILEGES;
////////////////////////////////////////

enum TOKEN_TYPE {
	TokenPrimary = 1,
	TokenImpersonation
}
alias TOKEN_TYPE* PTOKEN_TYPE;
////////////////////////////////////
struct ТОКЕНСТАТ //TOKEN_STATISTICS
{
    ЛУИД         					 идТокена;
    ЛУИД         					 идАутентификации;
    БОЛЬШЕЦЕЛ 						 времяУстаревания;
    ПТипТокена  					 типТокена;
    ПУровеньИмперсонацииБезопасности уровеньИмп;
    бцел        					 динамичПрисв;
    бцел       						 динамичДоступ;
    бцел      						 члоГрупп;
    бцел     						 члоПривилегий;
    ЛУИД      						 идИзменённый;
}
alias  ТОКЕНСТАТ TOKEN_STATISTICS;
alias TOKEN_STATISTICS* PTOKEN_STATISTICS;
//////////////////////////////////////////////////////
struct ПОЛЬЗОВАТЕЛЬ_ТОКЕНА//TOKEN_USER
{
    БИД_И_АТРЫ пользователь;
}
alias ПОЛЬЗОВАТЕЛЬ_ТОКЕНА TOKEN_USER;
alias TOKEN_USER* PTOKEN_USER;
/////////////////////////////////////////////	
struct ПРЕДЕЛЫ_КВОТ//QUOTA_LIMITS
{
    т_мера пределПулаСтр;
    т_мера пределПулаБезСтр;
    т_мера минРазмРабНабора;
    т_мера максРазмРабНабора;
    т_мера пределПейджфайла;
    БОЛЬШЕЦЕЛ пределВремени;
}
alias ПРЕДЕЛЫ_КВОТ QUOTA_LIMITS;
///////////////////////////////////
align(4):
    struct ФАЙЛЗАГ_ОБРАЗА//IMAGE_FILE_HEADER
{
    бкрат    Машина;
    бкрат    ЧлоСекций;
    бцел      ШтампВремени;
    бцел      УкНаСимТаб;
    бцел      ЧлоСим;
    бкрат    РазмОпцЗаг;
    бкрат    Характеристики;
}
alias ФАЙЛЗАГ_ОБРАЗА ФЗАГОБР;
////////////////////////////////////

struct ПАПКА_ДАННЫХ_ОБРАЗА //IMAGE_DATA_DIRECTORY
{
    бцел ВиртАдрес;
    бцел Размер;
}
alias ПАПКА_ДАННЫХ_ОБРАЗА ПАПДАНОБР;
/////////////////////////////////////////////////////

struct ОПЦЗАГ_ОБРАЗА //IMAGE_OPTIONAL_HEADER32
{
    //
    // Стандартные поля.
    //
    бкрат  Маг;
    ббайт  СтаршВерсКомпоновщика;
    ббайт   МладшВерсКомпоновщика;
    бцел   РазмерКода;
    бцел   РазмерИнициализДанных;
    бцел   РазмерНеинициализДанных;
    бцел   АдресТочкиВхода;
    бцел   ОваКода;
    бцел   ОваДанных;
    //
    // дополнительные поля НТ.
    //
    бцел   ОваОбраза;
    бцел   РаскладСекц;
    бцел   РаскладФайла;
    бкрат  СтаршВерсОС;
    бкрат  МладшВерсОС;
    бкрат  СтаршВерсОбр;
    бкрат  МладшВерсОбр;
    бкрат  СтаршВерсПодсист;
    бкрат  МладшВерсПодсист;
    бцел   ЗначВерсВин32;
    бцел   РазмерОбраза;
    бцел   РазмерЗагов;
    бцел   КСумма;
    бкрат  Подсистема;
    бкрат  ХарактеристикиДЛЛ;
    бцел   РазмерСтэкРезерва;
    бцел   РазмерСтэкКоммит;
    бцел   РазмерРезерваКучи;
    бцел   РазмерКоммитКучи;
    бцел   ФлагиЗагрузчика;
    бцел   ЧлоОВАиРазмеры;

    ПАПДАНОБР[16] ПапкаДанных;
}
alias ОПЦЗАГ_ОБРАЗА ОПЦЗАГОБР;
////////////////////////////////////////////////
struct ОПЦЗАГ_ОБРАЗА_РОМ {
	бкрат     Маг;
	ббайт     СтаршВерсКомпоновщика;
	ббайт     МладшВерсКомпоновщика;
	бцел    РазмерКода;
	бцел    РазмерИнициализДанных;
	бцел    РазмерНеинициализДанных;
	бцел    АдресТочкиВхода;
	бцел    ОваКода;
	бцел    ОваДанных;
	бцел    ОваБсс;
	бцел    МаскаГпр;
	бцел[4] МаскаЦпр;
	бцел    ЗначениеГп;
}
alias ОПЦЗАГ_ОБРАЗА_РОМ ОПЦЗАГОБРРОМ, IMAGE_ROM_OPTIONAL_HEADER;
alias IMAGE_ROM_OPTIONAL_HEADER* PIMAGE_ROM_OPTIONAL_HEADER;
///////////////////////////////////////////////////////////////////


align(2):
    struct ЗАГОЛОВОК_ОБРАЗА_ДОС //IMAGE_DOS_HEADER
{
    бкрат     маг;
    бкрат     члобайтпослстр;//число байтов последней страницы
    бкрат     члопар; //число страниц в файле
    бкрат     релок;//релокации
    бкрат     члопарвзаг;//число параграфов в заголовке
    бкрат     минтребдоппараг;//минимальное необходимое число дополнительных параграфов
    бкрат     макстребдоппараг;//максимальное число необходимых доп. параграфов
    бкрат     сс;//Начальное (относительное) значение SS
    бкрат     сп;//Начальное значение SP
    бкрат     кс;//контрольная сумма
    бкрат     ип;//Начальное значение IP
    бкрат     цс;//Начальное значение CS
    бкрат     фадртабрелок;//Файловый адрес таблицы релокаций
    бкрат     номовер;//Номер оверлея
    бкрат[4]  резерв;//Резервированные слова
    бкрат     оемид;//Идентификатор OEM
    бкрат     оеминфо;//Информация OEM
    бкрат[10]  резерв2;//Резервированные слова
    LONG      фадрновэкезаг;//Файловый адрес нового заголовка экзэ
}

alias ЗАГОЛОВОК_ОБРАЗА_ДОС ЗАГОБРДОС, IMAGE_DOS_HEADER;
////////////////////////////////////////

struct ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА //IMAGE_SECTION_HEADER
{
    ббайт[8] Имя;//ПРазмОбраза.РазмКратИмени
    union _Разное
    {
        бцел ФизичАдрес;
        бцел ВиртРазмер;
    }
    _Разное Разное;
    бцел ВиртАдрес;
    бцел РазмерНеобрДанных;
    бцел УкНаНеобрДанные;
    бцел УкНаРелокации;
    бцел УкНаНомераСтрок;
    бкрат  ЧлоРелокаций;
    бкрат  ЧлоНОмеровСтрок;
    бцел Характеристики;
}
alias ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА ЗАГСЕКЦОБР, IMAGE_SECTION_HEADER;
alias IMAGE_SECTION_HEADER* PIMAGE_SECTION_HEADER;

//////////////////////////////////////
////////////////////////////////////////////
struct ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА //IMAGE_SEPARATE_DEBUG_HEADER
 {
    бкрат        Сигнатура;
    бкрат        Флаги;
    бкрат        Машина;
    бкрат        Characteristics;
    бцел       ШтампВремени;
    бцел       КСумма;
    бцел       ОваОбраза;
    бцел       РазмерОбраза;
    бцел       ЧлоСекций;
    бцел       РазмЭкпортИмён;
    бцел       РазмПапкиОтлад;
    бцел       РаскладСекц;
    бцел[2]      Резерв;
}
alias ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА ОТДЕЛЬНОТЛАДЗАГОБР, IMAGE_SEPARATE_DEBUG_HEADER;
alias IMAGE_SEPARATE_DEBUG_HEADER* PIMAGE_SEPARATE_DEBUG_HEADER;
///////////////////////////////////////
struct ЗАГОЛОВКИ_ОБРАЗА_НТ //IMAGE_NT_HEADERS
 {
    бцел Сигнатура;
    ФЗАГОБР ФайлЗаг;
    ОПЦЗАГОБР ОпцЗаг;
}
alias ЗАГОЛОВКИ_ОБРАЗА_НТ НТОБРЗАГИ, IMAGE_NT_HEADERS;
////////////////////////////////////////

struct ИНФ_О_СИМВОЛЕ
{
    бцел РазмерСтруктуры;
    бцел ИндексТипа;
    бдол[2] Резерв;
    бцел Индекс;
    бцел Размер;
    бдол ОваМод;
    бцел Флаги;
    бдол Значение;
    бдол Адрес;
    бцел Регистр;
    бцел Масштаб;
    бцел Тэг;
    бцел ДлинаИм;
    бцел МаксДлинаИм;
    сим[1] Имя;
}

//////////////////////////
struct СКУ //DCB
{
    бцел СКУразм = СКУ.sizeof;
    бцел бодрейт;
    /+
    бцел fBinary:1;              // Binary Mode (skip EOF check)
    бцел fParity:1;              // Enable parity checking
    бцел fOutxCtsFlow:1;         // CTS handshaking on output
    бцел fOutxDsrFlow:1;         // DSR handshaking on output
    бцел fDtrControl:2;          // DTR Flow control
    бцел fDsrSensitivity:1;      // DSR Sensitivity
    бцел fTXContinueOnXoff:1;    // Continue TX when Xoff sent
    бцел fOutX:1;                // Enable output X-ON/X-OFF
    бцел fInX:1;                 // Enable input X-ON/X-OFF
    бцел fErrorChar:1;           // Enable Err Replacement
    бцел fNull:1;                // Enable Null stripping
    бцел fRtsControl:2;          // Rts Flow control
    бцел fAbortOnError:1;        // Abort all reads and writes on Error
    бцел fDummy2:17;             // Reserved

    +/
	бцел _бф;
	бул фБинар(бул ф)           { _бф = (_бф & ~0x0001) | ф; return ф; }
	бул фПаритет(бул ф)           { _бф = (_бф & ~0x0002) | (ф<<1); return ф; }
	бул фСиТиЭс(бул ф)      { _бф = (_бф & ~0x0004) | (ф<<2); return ф; }
	бул фДиЭсАр(бул ф)      { _бф = (_бф & ~0x0008) | (ф<<3); return ф; }
	байт фДиТиАр(байт x)       { _бф = (_бф & ~0x0030) | (x<<4); return cast(байт)(x & 3); }
	бул фЧувствительностьДиЭсАр(бул ф)   { _бф = (_бф & ~0x0040) | (ф<<6); return ф; }
	бул фПродолжитьТиЭксПриЭксвыкл(бул ф) { _бф = (_бф & ~0x0080) | (ф<<7); return ф; }
	бул фВыхЭкс(бул ф)             { _бф = (_бф & ~0x0100) | (ф<<8); return ф; }
	бул фВхЭкс(бул ф)              { _бф = (_бф & ~0x0200) | (ф<<9); return ф; }
	бул фОшСим(бул ф)        { _бф = (_бф & ~0x0400) | (ф<<10); return ф; }
	бул фНулл(бул ф)             { _бф = (_бф & ~0x0800) | (ф<<11); return ф; }
	байт фАрТиЭс(байт x)       { _бф = (_бф & ~0x3000) | (x<<12); return cast(байт)(x & 3); }
	бул фАбортПриОш(бул ф)     { _бф = (_бф & ~0x4000) | (ф<<14); return ф; }

	бул фБинар()           { return cast(бул) (_бф & 1); }
	бул фПаритет()           { return cast(бул) (_бф & 2); }
	бул фСиТиЭс()      { return cast(бул) (_бф & 4); }
	бул фДиЭсАр()      { return cast(бул) (_бф & 8); }
	байт фДиТиАр()       { return cast(байт) ((_бф & (32+16))>>4); }
	бул фЧувствительностьДиЭсАр()   { return cast(бул) (_бф & 64); }
	бул фПродолжитьТиЭксПриЭквыкл() { return cast(бул) (_бф & 128); }
	бул фВыхЭкс()             { return cast(бул) (_бф & 256); }
	бул фВхЭкс()              { return cast(бул) (_бф & 512); }
	бул фОшСим()        { return cast(бул) (_бф & 1024); }
	бул фНулл()             { return cast(бул) (_бф & 2048); }
	байт фАрТиЭс()       { return cast(байт) ((_бф & (4096+8192))>>12); }
	бул фАбортПриОш()     { return cast(бул) (_бф & 16384); }

    

    бкрат резерв;
    бкрат эксвклЛим;
    бкрат эксвыклЛим;
    ббайт байтРазм;
    ббайт паритет;
    ббайт стопБиты;
    сим эксвклСим;
    сим эксвыклСим;
    сим ошСим;
    сим кфСим;
    сим собСим;
    бкрат резерв1;
}
alias СКУ СЕРИЙНЫЕ_КОММУНИКАЦИОННЫЕ_УСТРОЙСТВА, DCB;
alias DCB* LPDCB;
/////////////////////////////////////////////////////
struct КОММТАЙМАУТЫ//COMMTIMEOUTS
{
    бцел ТаймаутИнтервалаЧтения;
    бцел МультипликаторТаймаутаОбщегоЧтения;
    бцел КонстантаТаймаутаОбщегоЧтения;
    бцел МультипликаторТаймаутаОбщейЗаписи;
    бцел КонстантаТаймаутаОбщейЗаписи;
}
alias КОММТАЙМАУТЫ COMMTIMEOUTS;
alias COMMTIMEOUTS* LPCOMMTIMEOUTS;
////////////////////////////////////////////////
struct КОММСТАТ//COMSTAT
{
    /+
    DWORD fCtsHold:1;
    DWORD fDsrHold:1;
    DWORD fRlsdHold:1;
    DWORD fXoffHold:1;
    DWORD fXoffSent:1;
    DWORD fEof:1;
    DWORD fTxim:1;
    DWORD fReserved:25;
    +/
	бцел _бф;
    бул фОжиданиеСиТиЭс(бул ф)  { _бф = (_бф & ~1) | ф; return ф; }
	бул фОжиданиеДиЭсАр(бул ф)  { _бф = (_бф & ~2) | (ф<<1); return ф; }
	бул фОжиданиеАрЭлЭсДи(бул ф) { _бф = (_бф & ~4) | (ф<<2); return ф; }
	бул фОжиданиеЭксвыкл(бул ф) { _бф = (_бф & ~8) | (ф<<3); return ф; }
	бул фОтправленЭксвыкл(бул ф) { _бф = (_бф & ~16) | (ф<<4); return ф; }
	бул фКф(бул ф)      { _бф = (_бф & ~32) | (ф<<5); return ф; }
	бул фТиэксим(бул ф)     { _бф = (_бф & ~64) | (ф<<6); return ф; }

    бул фОжиданиеСиТиЭс()  { return cast(бул) (_бф & 1); }
	бул фОжиданиеДиЭсАр()  { return cast(бул) (_бф & 2); }
	бул фОжиданиеАрЭлЭсДи() { return cast(бул) (_бф & 4); }
	бул фОжиданиеЭксвыкл() { return cast(бул) (_бф & 8); }
	бул фОтправленЭксвыкл() { return cast(бул) (_бф & 16); }
	бул фКф()      { return cast(бул) (_бф & 32); }
	бул фТиэксим()     { return cast(бул) (_бф & 64); }
    

    бцел вхОч;
    бцел выхОч;
}
alias КОММСТАТ СТАТИСТИКА_КОММУНИКАЦИИ, COMSTAT;
alias COMSTAT* LPCOMSTAT;
//////////////////////////////////////////////
struct КОММКОНФИГ//COMMCONFIG
{
    бцел размер = КОММКОНФИГ.sizeof;
    бкрат  версия;
    бкрат  резерв;
    СКУ   ску;
    бцел подтипПровайдера;
    бцел СмещениеПровайдера;
    бцел размерПровайдера;
    шим _данныеОПровайдере;

	шткст0 данныеОПровайдере() { return &_данныеОПровайдере; }
}
alias КОММКОНФИГ КОНФИГУРАЦИЯ_КОММУНИКАЦИИ, COMMCONFIG;
alias COMMCONFIG* LPCOMMCONFIG;
/////////////////////////////
		struct АКТКТКСА//ACTCTXA
{
    бцел размер = this.sizeof;
    бцел флаги;
    ткст0 исток;
    бкрат архПроцессора;
    ИДЯз идЯзыка;
    ткст0 папкаСборки;
    ткст0 имяРесурса;
    ткст0 имяПриложения;
    ук модуль;
}
	alias АКТКТКСА КОНТЕКСТ_АКТИВАЦИИ_А, ACTCTXA;
	alias ACTCTXA* PACTCTXA, PCACTCTXA;
//////////////////////////////////////////////
struct АКТКТКС //ACTCTXW
{
    бцел размер = this.sizeof;
    бцел флаги;
    ткст0 исток;
    бкрат архПроцессора;
    ИДЯз идЯзыка;
    шткст *папкаСборки;
    шткст *имяРесурса;
    шткст *имяПриложения;
    ук модуль;
}
	alias АКТКТКС КОНТЕКСТ_АКТИВАЦИИ, ACTCTXW;
	alias ACTCTXW* PACTCTXW, PCACTCTXW;
/////////////////////////////////////////////
struct АСИНХЗАП//_OVERLAPPED_ENTRY
 {
  ULONG_PTR    КлючЗаполнения;
  АСИНХРОН* Асинхрон;
  ULONG_PTR    Внутр;
  бцел        ЧлоПереданныхБайтов;
} 
alias АСИНХЗАП OVERLAPPED_ENTRY, _OVERLAPPED_ENTRY;
alias OVERLAPPED_ENTRY *LPOVERLAPPED_ENTRY;
//////////////////////////////////////////////////
struct СТАТУС_ПИТАНИЯ_СИСТЕМЫ//_SYSTEM_POWER_STATUS
{
	ббайт  СтатусПТЛинии;
	ббайт  ФлагБатареи;
	ббайт  ПроцентЗарядаБатареи;
	ббайт  ФлагСтатусаСистемы;
	бцел ВремяЖизниБатареи;
	бцел ПолноеВремяЖизниБатареи;
} 
alias СТАТУС_ПИТАНИЯ_СИСТЕМЫ _SYSTEM_POWER_STATUS, SYSTEM_POWER_STATUS;
alias SYSTEM_POWER_STATUS *LPSYSTEM_POWER_STATUS;
///////////////////////////////////////////////////////
struct ГЕНЕРНЫЙ_МАППИНГ//GENERIC_MAPPING
 {
    МАСКА_ДОСТУПА ГенЧтен;
    МАСКА_ДОСТУПА ГенЗап;
    МАСКА_ДОСТУПА ГенВып;
    МАСКА_ДОСТУПА ГенВсё;
}
alias ГЕНЕРНЫЙ_МАППИНГ ГЕНМАП, GENERIC_MAPPING;
alias GENERIC_MAPPING* PGENERIC_MAPPING;
//////////////////////////////////////////////////
struct ИНФОМОНИТОРЕ //MONITORINFO
{
    бцел Размер = this.sizeof;
    ПРЯМ Монитор;
    ПРЯМ Работа;
    бцел Флаги;
}
alias ИНФОМОНИТОРЕ MONITORINFO;
alias MONITORINFO* LPMONITORINFO;
/////////////////////////////////////
struct ХФОРМА//XFORM
 {
	плав eM11;
	плав eM12;
	плав eM21;
	плав eM22;
	плав eDx;
	плав eDy;
}
alias ХФОРМА XFORM;
alias ХФОРМА* PXFORM, LPXFORM;
/////////////////////////////////////
struct РАЗМЕЩЕНИЕ_ОКНА //WINDOWPLACEMENT
{
	бцел Длина;
	бцел Флаги;
	бцел КмдПоказать;
	ТОЧКА МинПозТчк;
	ТОЧКА МаксПозТчк;
	ПРЯМ НормПоз;
}
alias РАЗМЕЩЕНИЕ_ОКНА WINDOWPLACEMENT;
alias РАЗМЕЩЕНИЕ_ОКНА* LPWINDOWPLACEMENT, PWINDOWPLACEMENT;
///////////////////////////////////////////////////////////
struct СПИС_ВА
{
}
////////////////////////////////////////////
struct ИНФОБОК//WINDOWINFO
 {
	бцел Размер = ИНФОБОК.sizeof;
	ПРЯМ  Окно;
	ПРЯМ  Клиент;
	бцел Стиль;
	бцел ДопСтиль;
	бцел СтатусОкна;
	бцел  ГраницыШОкна;
	бцел  ГрвницыВОкна;
	АТОМ  ТипАтомаОкна;
	бкрат  ВерсияСоздателя;
}
alias ИНФОБОК WINDOWINFO;
alias ИНФОБОК* PWINDOWINFO, LPWINDOWINFO;
/////////////////////////////////////////////
struct ФМТЧИСЛА_А //NUMBERFMTA
{
	бцел  ЧисЦифры;
	бцел  ВводныйНоль;
	бцел  Группировка;
	ткст0 РаздДесятков;
	ткст0 РаздТысяч;
	бцел  ОтрицПорядок;
}
alias ФМТЧИСЛА_А NUMBERFMTA;
alias ФМТЧИСЛА_А* LPNUMBERFMTA;
////////////////////////////////////////////
struct ФМТЧИСЛА//NUMBERFMTW
 {
	бцел   ЧисЦифры;
	бцел   ВводныйНоль;
	бцел   Группировка;
	шткст0 РаздДесятков;
	шткст0 РаздТысяч;
	бцел   ОтрицПорядок;
}
alias ФМТЧИСЛА NUMBERFMTW;
alias ФМТЧИСЛА* LPNUMBERFMTW;
////////////////////////////////////////////
struct ФМТВАЛЮТЫ_А //CURRENCYFMTA
{
	бцел  ЧисЦифры;
	бцел  ВводныйНоль;
	бцел  Группировка;
	ткст0 РаздДесятков;
	ткст0 РаздТысяч;
	бцел  ОтрицПорядок;
	бцел  ПоложитПорядок;
	ткст0 СимволВалюты;
}
alias ФМТВАЛЮТЫ_А CURRENCYFMTA;
alias ФМТВАЛЮТЫ_А* LPCURRENCYFMTA;
///////////////////////////////////////////////
struct ФМТВАЛЮТЫ//CURRENCYFMTW
 {
	бцел   ЧисЦифры;
	бцел   ВводныйНоль;
	бцел   Группировка;
	шткст0 РаздДесятков;
	шткст0 РаздТысяч;
	бцел   ОтрицПорядок;
	бцел   ПоложитПорядок;
	шткст0 СимволВалюты;
}
alias ФМТВАЛЮТЫ CURRENCYFMTW;
alias ФМТВАЛЮТЫ* LPCURRENCYFMTW;
/////////////////////////////////////////////////

////////////////////////////////////////////////