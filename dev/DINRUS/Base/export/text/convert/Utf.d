/*******************************************************************************

        Быстрые транскодеры Юникода. Они очень чувствительны к небольшим
        изменениям на 32-битных x86 устройствах, так как у них небольшой
		набор регистров. Опасайтесь субтильных изменений, которые могут
        увеличить период выполнения, вплоть до 200%. Из-за этого три из
        шести этих транскодеров могут читать за край ввода на один,
        два или три байта, прежде, чем остановятся. Напомним, что поддержка
        поточности добавляет 15% перегрузку при преобразовании дим => сим,
        но мало влияет на прочее.

        Эти процедуры были настроены под Intel P4; с другими устройствами
		могут работать ещё эффективней, слегка с иным подходом, но, кажется,
        они вполне себе оптимальны на процессорах AMD x86. Эти алгоритмы
        во многом выигрывают из-за дополнительных регистров на AMD64.
        На 3ГГц P4, преобразование дим/сим занимают около 2500нс на
		обработку массива из 1000 ASCII элементов. Вызов менеджера
        памяти удваивает этот период, и учетверяет время для
        массивов из 100 элементов. Размещение памяти может заметно
		замедлиться во многопоточной среде,- по возможности этого
		следует избегать.

        При транскодировании между utf16 и utf8 суррогатные пары обрабатываются
		не очень оптимально. Такие случаи считаются пограничными условиям
		для данного модуля.

        Есть три общих случая, в которых ввод может оказаться незавершённым,
        включая каждый случай 'расширения' : utf8 => utf16, utf8 => utf32
        и utf16 => utf32. Крайний случае - это utf16 => utf8, если имеется
        суррогатная пара. В таких случаях выводится исключение, если
        поточный режим отключен ~ в последнем режиме возвращается
        дополнительное целое, указывающее на количество потреблённых элементов
		ввода. Во всех случаях возвращается корректный срез вывода.

        Подробности об обработке Юникода см. здесь:
        $(UL $(LINK http://www.utf-8.com/))
        $(UL $(LINK http://www.hackcraft.net/xmlUnicode/))
        $(UL $(LINK http://www.azillionmonkeys.com/qed/unicode.html/))
        $(UL $(LINK http://icu.sourceforge.net/docs/papers/forms_of_unicode/))

*******************************************************************************/

module text.convert.Utf;

/*******************************************************************************

        Симметричные вызовы для эквивалентных типов; возвращается предоставленный
        ввод без преобразования.

*******************************************************************************/

extern(D) ткст  вТкст (ткст ист, ткст приёмн, бцел* взято=пусто);
extern(D) шим[] вТкст (шим[] ист, шим[] приёмн, бцел* взято=пусто);
extern(D) дим[] вТкст (дим[] ист, дим[] приёмн, бцел* взято=пусто);

/*******************************************************************************

        Кодирует Utf8 максимум до 4 байт длиной (пяти- и шести-байтные
        вариации не поддерживаются).

        Если вывод предоставлен вне стэка, он должен быть достаточно
        велик, чтобы вобрать в себя весь транскодинг; если этого
        не сделано, то вывод будет отправлен на кучу, а не в стэк.

        Возвращает срез буфера вывода, соответствующий  преобразованым
		символам. Для оптимальной производительности, возвращаемый
        буфер следует назначать как 'вывод' при последующих вызовах.
        Например:

        ---
        ткст вывод;

        ткст результат = вТкст (ввод, вывод);

        // сбросим вывод после реаллокации
        if (результат.length > вывод.length)
            вывод = результат;
        ---

        Если указано 'взято', оно устанавливается в число потреблённых из
        ввода элементов, а буфер вывода не меняется в размере
		(и не реаллоцируется). Этим представляется поточный режим,
        когда срезы ввода одрабатываются последовательно, а не все
		одновременно ( 'взято' используется как индекс
		для преобразования среза в непотреблённый ввод).

*******************************************************************************/

extern(D) ткст вТкст (шим[] ввод, ткст вывод=пусто, бцел* взято=пусто);

/*******************************************************************************

        Раскодирует Utf8, произведённый выше расположенным методом вТкст().

        Если вывод предоставлен вне стэка, он должен быть достаточно
        велик, чтобы вобрать в себя весь транскодинг; если этого
        не сделано, то вывод будет отправлен на кучу, а не в стэк.

        Возвращает срез буфера вывода, соответствующий  преобразованым
		символам. Для оптимальной производительности, возвращаемый
        буфер следует назначать как 'вывод' при последующих вызовах.

        Если указано 'взято', оно устанавливается в число потреблённых из
        ввода элементов, а буфер вывода не меняется в размере
		(и не реаллоцируется). Этим представляется поточный режим,
        когда срезы ввода одрабатываются последовательно, а не все
		одновременно ( 'взято' используется как индекс
		для преобразования среза в непотреблённый ввод).

*******************************************************************************/

extern(D) шим[] вТкст16 (ткст ввод, шим[] вывод=пусто, бцел* взято=пусто);


/*******************************************************************************

        Кодирует Utf8 максимум до 4 байт длиной (пяти- и шести-байтные
        вариации не поддерживаются).Выводит исключение, когда вводимый
        дим больше чем 0x10ffff.

        Если вывод предоставлен вне стэка, он должен быть достаточно
        велик, чтобы вобрать в себя весь транскодинг; если этого
        не сделано, то вывод будет отправлен на кучу, а не в стэк.

        Возвращает срез буфера вывода, соответствующий  преобразованым
		символам. Для оптимальной производительности, возвращаемый
        буфер следует назначать как 'вывод' при последующих вызовах.

        Если указано 'взято', оно устанавливается в число потреблённых из
        ввода элементов, а буфер вывода не меняется в размере
		(и не реаллоцируется). Этим представляется поточный режим,
        когда срезы ввода одрабатываются последовательно, а не все
		одновременно ( 'взято' используется как индекс
		для преобразования среза в непотреблённый ввод).

*******************************************************************************/

extern(D) ткст вТкст (дим[] ввод, ткст вывод=пусто, бцел* взято=пусто);


/*******************************************************************************

        Раскодирует Utf8, произведённый выше расположенным методом вТкст().

        Если вывод предоставлен вне стэка, он должен быть достаточно
        велик, чтобы вобрать в себя весь транскодинг; если этого
        не сделано, то вывод будет отправлен на кучу, а не в стэк.

        Возвращает срез буфера вывода, соответствующий  преобразованым
		символам. Для оптимальной производительности, возвращаемый
        буфер следует назначать как 'вывод' при последующих вызовах.

        Если указано 'взято', оно устанавливается в число потреблённых из
        ввода элементов, а буфер вывода не меняется в размере
		(и не реаллоцируется). Этим представляется поточный режим,
        когда срезы ввода одрабатываются последовательно, а не все
		одновременно ( 'взято' используется как индекс
		для преобразования среза в непотреблённый ввод).

*******************************************************************************/

extern(D) дим[] вТкст32 (ткст ввод, дим[] вывод=пусто, бцел* взято=пусто);

/*******************************************************************************

        Кодирует Utf16 максимум до 2 байт длиной. Выводит исключение,
        когда вводимый дим больше чем 0x10ffff.

        Если вывод предоставлен вне стэка, он должен быть достаточно
        велик, чтобы вобрать в себя весь транскодинг; если этого
        не сделано, то вывод будет отправлен на кучу, а не в стэк.

        Возвращает срез буфера вывода, соответствующий  преобразованым
		символам. Для оптимальной производительности, возвращаемый
        буфер следует назначать как 'вывод' при последующих вызовах.

        Если указано 'взято', оно устанавливается в число потреблённых из
        ввода элементов, а буфер вывода не меняется в размере
		(и не реаллоцируется). Этим представляется поточный режим,
        когда срезы ввода одрабатываются последовательно, а не все
		одновременно ( 'взято' используется как индекс
		для преобразования среза в непотреблённый ввод).

*******************************************************************************/

extern(D) шим[] вТкст16 (дим[] ввод, шим[] вывод=пусто, бцел* взято=пусто);

/*******************************************************************************

        Раскодирует Utf16, произведённый выше расположенным методом вТкст16().

        Если вывод предоставлен вне стэка, он должен быть достаточно
        велик, чтобы вобрать в себя весь транскодинг; если этого
        не сделано, то вывод будет отправлен на кучу, а не в стэк.

        Возвращает срез буфера вывода, соответствующий  преобразованым
		символам. Для оптимальной производительности, возвращаемый
        буфер следует назначать как 'вывод' при последующих вызовах.

        Если указано 'взято', оно устанавливается в число потреблённых из
        ввода элементов, а буфер вывода не меняется в размере
		(и не реаллоцируется). Этим представляется поточный режим,
        когда срезы ввода одрабатываются последовательно, а не все
		одновременно ( 'взято' используется как индекс
		для преобразования среза в непотреблённый ввод).

*******************************************************************************/

extern(D) дим[] вТкст32 (шим[] ввод, дим[] вывод=пусто, бцел* взято=пусто);


/*******************************************************************************

        Декодирует единичный дим из заданного ист текста, и показывает,
        сколько симов потреблено из ист при этом.

*******************************************************************************/

extern(D) дим раскодируй (ткст ист, ref бцел взято);

/*******************************************************************************

        Декодирует единичный дим из заданного ист текста, и показывает,
        сколько шимов потреблено из ист при этом.

*******************************************************************************/

extern(D) дим раскодируй (шим[] ист, ref бцел взято);

/*******************************************************************************

        Кодирует дим, преобразуя в предоставленный приёмн массив, и возвращает
		его срез, представляющий кодировку.

*******************************************************************************/

extern(D) ткст кодируй (ткст приёмн, дим c);

/*******************************************************************************

        Кодирует дим, преобразуя в предоставленный приёмн массив, и возвращает
		его срез, представляющий кодировку.

*******************************************************************************/

extern(D) шим[] кодируй (шим[] приёмн, дим c);

/*******************************************************************************

        Действителен ли данный символ?

*******************************************************************************/

extern(D) бул действителен (дим c);

/*******************************************************************************

        Преобразует из ткст в предоставленный тип приёмн.

        Возвращает срез предоставленного приёмн, когда его либо вполне достаточно
		для размещения результата, либо иначе массив размещается на куче. Возвращает
        исходный ввод, когда не требуется никакого преобразования.

*******************************************************************************/

T[] изТкст8(T) (ткст s, T[] приёмн)
{
    static if (is (T == сим))
        return s;

    static if (is (T == шим))
        return .вТкст16 (s, приёмн);

    static if (is (T == дим))
        return .вТкст32 (s, приёмн);
}

/*******************************************************************************

       Преобразует из шткст в предоставленный тип приёмн.

        Возвращает срез предоставленного приёмн, когда его либо вполне достаточно
		для размещения результата, либо иначе массив размещается на куче. Возвращает
        исходный ввод, когда не требуется никакого преобразования.

*******************************************************************************/

T[] изТкст16(T) (шим[] s, T[] приёмн)
{
    static if (is (T == шим))
        return s;

    static if (is (T == сим))
        return .вТкст (s, приёмн);

    static if (is (T == дим))
        return .вТкст32 (s, приёмн);
}

/*******************************************************************************

        Преобразует из юткст в предоставленный тип приёмн.

        Возвращает срез предоставленного приёмн, когда его либо вполне достаточно
		для размещения результата, либо иначе массив размещается на куче. Возвращает
        исходный ввод, когда не требуется никакого преобразования.

*******************************************************************************/

T[] изТкст32(T) (дим[] s, T[] приёмн)
{
    static if (is (T == дим))
        return s;

    static if (is (T == сим))
        return .вТкст (s, приёмн);

    static if (is (T == шим))
        return .вТкст16 (s, приёмн);
}

/*******************************************************************************

        Настроить контент так, чтобы в левой части предоставленного текста
		не было никакой частичной кодировки.

        Возвращает срез ввода.

*******************************************************************************/

T[] отрежьЛево(T) (T[] s)
{
    static if (is (T == сим))
        for (цел i=0; i < s.length && (s[i] & 0x80); ++i)
            if ((s[i] & 0xc0) is 0xc0)
                return s [i..$];

    static if (is (T == шим))
        // пропусти if первый сим is a trailing surrogate
        if ((s[0] & 0xfffffc00) is 0xdc00)
            return s [1..$];

    return s;
}

/*******************************************************************************

        Настроить контент так, чтобы в правой части предоставленного текста
		не было никакой частичной кодировки.

        Возвращает срез ввода.

*******************************************************************************/

T[] отрежьПраво(T) (T[] s)
{
    if (s.length)
    {
        бцел i = s.length - 1;
        static if (is (T == сим))
            while (i && (s[i] & 0x80))
                if ((s[i] & 0xc0) is 0xc0)
                {
                    // лоцирован первый байт последовательности
                    ббайт b = s[i];
                    цел d = s.length - i;

                    // это 3 байтная последовательность?
                    if (b & 0x20)
                        --d;

                    // или четырёх байтная?
                    if (b & 0x10)
                        --d;

                    // последовательность завершена?
                    if (d is 2)
                        i = s.length;
                    return s [0..i];
                }
                else
                    --i;

        static if (is (T == шим))
            // пропустим, если последний сим это вводный суррогат
            if ((s[i] & 0xfffffc00) is 0xd800)
                return s [0..$-1];
    }
    return s;
}



/*******************************************************************************

*******************************************************************************/

debug (Utf)
{
    import io.Console;

    проц main()
    {
        auto s = "[\xc2\xa2\xc2\xa2\xc2\xa2]";
        Квывод (s).нс;

        Квывод (отрежьЛево(s[0..$])).нс;
        Квывод (отрежьЛево(s[1..$])).нс;
        Квывод (отрежьЛево(s[2..$])).нс;
        Квывод (отрежьЛево(s[3..$])).нс;
        Квывод (отрежьЛево(s[4..$])).нс;
        Квывод (отрежьЛево(s[5..$])).нс;

        Квывод (отрежьПраво(s[0..$])).нс;
        Квывод (отрежьПраво(s[0..$-1])).нс;
        Квывод (отрежьПраво(s[0..$-2])).нс;
        Квывод (отрежьПраво(s[0..$-3])).нс;
        Квывод (отрежьПраво(s[0..$-4])).нс;
        Квывод (отрежьПраво(s[0..$-5])).нс;
    }
}
