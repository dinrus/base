/*******************************************************************************
        Набор функций для преобразования между текстовым и целым 
        значениями. 

        Очень рекомендуется применять "import alias" механизм Ди к этому модулю,
        дабы предотвратить загрязнение пространства имён:
        ---
        import Целое = text.convert.Integer;

        auto i = Целое.разбор ("32767");
        ---
        
*******************************************************************************/

module text.convert.Integer;

private import exception;

/******************************************************************************

        Разбирает целое значение из предоставленного 'цифры' ткст. 

        Этот ткст проверяется на знак и опциональный префикс корня.
        Корень может предоставляться и как аргумент, 
        whereupon it must сверь the префикс (where present). Когда
        корень установлен в ноль, преобразование происходит по умолчанию в десяток.

        Выводит исключение: ИсклНелегальногоАргумента, когда вводный текст неразборчив
        целиком и полностью.

        See_also: низкоуровневые функции разбор() и преобразуй()

******************************************************************************/

цел вЦел(T, U=бцел) (T[] цифры, U корень=0)
{return вЦел!(T)(цифры, корень);}

цел вЦел(T) (T[] цифры, бцел корень=0)
{
        auto x = вДол (цифры, корень);
        if (x > цел.max)
            throw new ИсклНелегальногоАргумента ("Целое.вЦел :: целое перебор");
        return cast(цел) x;
}

/******************************************************************************

        Разбирает целое значение из предоставленного 'цифры' ткст. 

        Этот ткст проверяется на знак и опциональный префикс корня.
        Корень может предоставляться и как аргумент, 
        whereupon it must сверь the префикс (where present). Когда
        корень установлен в ноль, преобразование происходит по умолчанию в десяток.

        Выводит исключение: ИсклНелегальногоАргумента, когда вводный текст неразборчив
        целиком и полностью.

        See_also: низкоуровневые функции разбор() и преобразуй()

******************************************************************************/

дол вДол(T, U=бцел) (T[] цифры, U корень=0)
{return вДол!(T)(цифры, корень);}

дол вДол(T) (T[] цифры, бцел корень=0)
{
        бцел длин;

        auto x = разбор (цифры, корень, &длин);
        if (длин < цифры.length)
            throw new ИсклНелегальногоАргумента ("Целое.вДол :: непригодный литерал");
        return x;
}

/******************************************************************************

        Обёртка шаблона для упрощения работы. Возвращает текстовую версию
        предоставленного значения.

        Подробности см. в форматируй().

******************************************************************************/

extern(D) ткст вТкст (дол i, ткст фмт = пусто);
               
/******************************************************************************

        Обёртка шаблона для упрощения работы. Возвращает текстовую версию
        предоставленного значения.

        Подробности см. в форматируй().

******************************************************************************/

extern(D) шим[] вТкст16 (дол i, шим[] фмт = пусто);
               
/******************************************************************************

        Обёртка шаблона для упрощения работы. Возвращает текстовую версию
        предоставленного значения.

        Подробности см. в форматируй().

******************************************************************************/

extern(D) дим[] вТкст32 (дол i, дим[] фмт = пусто);
               
/*******************************************************************************

        Поддерживает спецификации формата через Массив, когда формат следует за
        приведённой ниже нотацией:
        ---
        тип ширина префикс
        ---

        Тип - это что-то одно из [d, g, u, b, x, o] или эквивалент в верхнем регистре, и
        он диктует корень преобразования или иную семантику.

        Ширина необязательна и указывает минимальную ширину для zero-паддинга,
        в то время как опциональный префикс - это что-то одно из ['#', ' ', '+'] и указывает,
        что разные префиксы следует поместить на вывод. Напр.,
        ---
        "d"     => целое
        "u"     => беззначное
        "o"     => восмеричное
        "b"     => двоичное
        "x"     => шестнадцатиричное
        "X"     => шестнадцатеричное верхнего регистра

        "d+"    => целое псеп_в_начале с "+"
        "b#"    => двоичный псеп_в_начале с "0b"
        "x#"    => 16-ричный псеп_в_начале с "0x"
        "X#"    => 16-ричный псеп_в_начале с "0X"

        "d8"    => десяток псеп_в_конце в_ 8 places as требуется
        "b8"    => двоичный псеп_в_конце в_ 8 places as требуется
        "b8#"   => двоичный псеп_в_конце в_ 8 places и псеп_в_начале с "0b"
        ---

        Заметьте, что указанная ширина относится исключительно к префиксу, хотя
        паддинг ширины будет сжат при необходимости с тем, чтобы запрошенный
        префикс мог быть вставлен в предоставленный вывод.

*******************************************************************************/

T[] форматируй(T, U=дол) (T[] приёмн, U i, T[] фмт = пусто)
{return форматируй!(T)(приёмн, cast(дол) i, фмт);}

T[] форматируй(T) (T[] приёмн, дол i, T[] фмт = пусто)
{
        сим    пре,
                тип;
        цел     ширина;

        раскодируй (фмт, тип, пре, ширина);
        return форматёр (приёмн, i, тип, пре, ширина);
} 

private проц раскодируй(T) (T[] фмт, ref сим тип, out сим пре, out цел ширина)
{
        if (фмт.length is 0)
            тип = 'd';
        else
           {
           тип = фмт[0];
           if (фмт.length > 1)
              {
              auto p = &фмт[1];
              for (цел j=1; j < фмт.length; ++j, ++p)
                   if (*p >= '0' && *p <= '9')
                       ширина = ширина * 10 + (*p - '0');
                   else
                      пре = *p;
              }
           }
} 


T[] форматёр(T, U=дол, X=сим, Y=сим) (T[] приёмн, U i, X тип, Y пре, цел ширина)
{return форматёр!(T)(приёмн, cast(дол) i, тип, пре, ширина);}


private struct ИнфоОФорматировщике(T)
{
		бцел    корень;
		T[]     префикс;
		T[]     числа;
}

T[] форматёр(T) (T[] приёмн, дол i, сим тип, сим пре, цел ширина)
{
        const T[] lower = "0123456789abcdef";
        const T[] upper = "0123456789ABCDEF";
        
        alias ИнфоОФорматировщике!(T) Инфо;

        const   Инфо[] форматы = 
                [
                {10, пусто, lower}, 
                {10, "-",  lower}, 
                {10, " ",  lower}, 
                {10, "+",  lower}, 
                { 2, "0b", lower}, 
                { 8, "0o", lower}, 
                {16, "0x", lower}, 
                {16, "0X", upper},
                ];

        ббайт индекс;
        цел   длин = приёмн.length;

        if (длин)
           {
           switch (тип)
                  {
                  case 'd':
                  case 'D':
                  case 'g':
                  case 'G':
                       if (i < 0)
                          {
                          индекс = 1;
                          i = -i;
                          }
                       else
                          if (пре is ' ')
                              индекс = 2;
                          else
                             if (пре is '+')
                                 индекс = 3;
                  case 'u':
                  case 'U':
                       пре = '#';
                       break;

                  case 'b':
                  case 'B':
                       индекс = 4;
                       break;

                  case 'o':
                  case 'O':
                       индекс = 5;
                       break;

                  case 'x':
                       индекс = 6;
                       break;

                  case 'X':
                       индекс = 7;
                       break;

                  default:
                        return cast(T[])"{неизвестный формат '"~cast(T)тип~"'}";
                  }

           auto инфо = &форматы[индекс];
           auto числа = инфо.числа;
           auto корень = инфо.корень;

           // преобразуй число в_ текст
           auto p = приёмн.ptr + длин;
           if (бцел.max >= cast(бдол) i)
              {
              auto знач = cast (бцел) i;
              do {
                 *--p = числа [знач % корень];
                 } while ((знач /= корень) && --длин);
              }
           else
              {
              auto знач = cast (бдол) i;
              do {
                 *--p = числа [cast(бцел) (знач % корень)];
                 } while ((знач /= корень) && --длин);
              }
        
           auto префикс = (пре is '#') ? инфо.префикс : пусто;
           if (длин > префикс.length)
              {
              длин -= префикс.length + 1;

              // префикс число with zeros? 
              if (ширина)
                 {
                 ширина = приёмн.length - ширина - префикс.length;
                 while (длин > ширина && длин > 0)
                       {
                       *--p = '0';
                       --длин;
                       }
                 }
              // пиши optional префикс ткст ...
              приёмн [длин .. длин + префикс.length] = префикс;

              // return срез of предоставленный буфер вывода
              return приёмн [длин .. $];                               
              }
           }
        
        return "{слишком малая ширина вывода}";
} 


/******************************************************************************

        Разбирает целое значение из предоставленного 'цифры' ткст. 

        Этот ткст проверяется на знак и опциональный префикс кореня. 
        Корень может предоставляться как аргумент, 
        whereupon it must сверь the префикс (where present). Когда
        корень установлен в ноль, преодразование по умрлчанию в десяток.

        Не-пустое 'взято' вернёт число символов, использованных
        для построения возвратного значения.

        Выводит исключение: Неук. Параметр 'взято' должен 
		проверяться на действительный ввод.

******************************************************************************/

дол разбор(T, U=бцел) (T[] цифры, U корень=0, бцел* взято=пусто)
{return разбор!(T)(цифры, корень, взято);}

дол разбор(T) (T[] цифры, бцел корень=0, бцел* взято=пусто)
{
        бул знак;

        auto eaten = убери (цифры, знак, корень);
        auto значение = преобразуй (цифры[eaten..$], корень, взято);

        // проверь *взято > 0 в_ сделай sure we don't разбор "-" as 0.
        if (взято && *взято > 0)
            *взято += eaten;

        return cast(дол) (знак ? -значение : значение);
}

/******************************************************************************

        Преоьразует предоставленный 'цифры'_в  целое значение,
        не проверяя на знак или корень. Корень по дефолту
        в десяток (10).

        Возвращает значение и обновляет 'взято' на число
        потреблённых символов.

        Выводит исключение: Неук. Параметр 'взято' должен 
		проверяться на действительный ввод.

******************************************************************************/

бдол преобразуй(T, U=бцел) (T[] цифры, U корень=10, бцел* взято=пусто)
{return преобразуй!(T)(цифры, корень, взято);}

бдол преобразуй(T) (T[] цифры, бцел корень=10, бцел* взято=пусто)
{
        бцел  eaten;
        бдол значение;

        foreach (c; цифры)
                {
                if (c >= '0' && c <= '9')
                   {}
                else
                   if (c >= 'a' && c <= 'z')
                       c -= 39;
                   else
                      if (c >= 'A' && c <= 'Z')
                          c -= 7;
                      else
                         break;

                if ((c -= '0') < корень)
                   {
                   значение = значение * корень + c;
                   ++eaten;
                   }
                else
                   break;
                }

        if (взято)
            *взято = eaten;

        return значение;
}


/******************************************************************************

        Убирает пробел в начале, выкидывая опционально +/- знак,
        и префикс корня. Если значение корня совпадает с
        опцинальным префиксом, либо корень равен нулю, префикс
        потребляется и назначается. Когда корень не ноль и
        не совпадает с явным префиксом, последний остаётся 
        не использованным. Иначе, корень по умолчанию в 10.

        Возвращает число использованных символов.

******************************************************************************/

бцел убери(T, U=бцел) (T[] цифры, ref бул знак, ref U корень)
{return убери!(T)(цифры, знак, корень);}

бцел убери(T) (T[] цифры, ref бул знак, ref бцел корень)
{
        T       c;
        T*      p = цифры.ptr;
        цел     длин = цифры.length;

        if (длин)
           {
           // откинь off пробел и знак characters
           for (c = *p; длин; c = *++p, --длин)
                if (c is ' ' || c is '\t')
                   {}
                else
                   if (c is '-')
                       знак = да;
                   else
                      if (c is '+')
                          знак = нет;
                   else
                      break;

           // откинь off a корень определитель also?
           auto r = корень;
           if (c is '0' && длин > 1)
               switch (*++p)
                      {
                      case 'x':
                      case 'X':
                           ++p;
                           r = 16;
                           break;
 
                      case 'b':
                      case 'B':
                           ++p;
                           r = 2;
                           break;
 
                      case 'o':
                      case 'O':
                           ++p;
                           r = 8;
                           break;
 
                      default: 
                            --p;
                           break;
                      } 

           // default the корень в_ 10
           if (r is 0)
               корень = 10;
           else
              // явный корень must сверь (optional) префикс
              if (корень != r)
                  if (корень)
                      p -= 2;
                  else
                     корень = r;
           }

        // return число of characters eaten
        return (p - цифры.ptr);
}


/******************************************************************************

        Бысрый конвертер текста в бцел. Используется только при известном
        контенте, либо вместо него применяются разбор() или преобразуй().

        Возвращает разобранный бцел.
        
******************************************************************************/

бцел atoi(T) (T[] s, цел корень = 10)
{
        бцел значение;

        foreach (c; s)
                 if (c >= '0' && c <= '9')
                     значение = значение * корень + (c - '0');
                 else
                    break;
        return значение;
}


/******************************************************************************

        Быстрый конвертер бцел в текст, где предоставленный вывод
        должен вмещать результат (10 цифр в большинстве случаев).
        Для мейнстримного применения больше подойдёт форматируй().

        Возвращает наполненный срез предоставленного вывода.
        
******************************************************************************/

T[] itoa(T, U=бцел) (T[] вывод, U значение, цел корень = 10)
{return itoa!(T)(вывод, значение, корень);}

T[] itoa(T) (T[] вывод, бцел значение, цел корень = 10)
{
        T* p = вывод.ptr + вывод.length;

        do {
           *--p = cast(T)(значение % корень + '0');
           } while (значение /= корень);
        return вывод[p-вывод.ptr .. $];
}


/******************************************************************************

        Потребляет число из ввода не преобразуя. Аргумент
        'fp' включает потребление с плавающей точкой. Поддерживает hex-ввод
        чисел, с соответствующими псеп_в_начале.

        Since version 0.99.9

******************************************************************************/

T[] используй(T) (T[] ист, бул fp=нет)
{
        T       c;
        бул    знак;
        бцел    корень;

        // удали leading пространство, и знак
        auto e = ист.ptr + ист.length;
        auto p = ист.ptr + убери (ист, знак, корень);
        auto b = p;

        // bail out if the ткст is пустой
        if (ист.length is 0 || p > &ист[$-1])
            return пусто;

        // читай leading цифры
        for (c=*p; p < e && ((c >= '0' && c <= '9') || 
            (корень is 16 && ((c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))));)
             c = *++p;

        if (fp)
           {
           // gobble up a точка
           if (c is '.' && p < e)
               c = *++p;

           // читай fractional цифры
           while (c >= '0' && c <= '9' && p < e)
                  c = *++p;

           // dопр we используй anything?
           if (p > b)
              {
              // используй exponent?
              if ((c is 'e' || c is 'Е') && p < e )
                 {
                 c = *++p;
                 if (c is '+' || c is '-')
                     c = *++p;
                 while (c >= '0' && c <= '9' && p < e)
                        c = *++p;
                 }
              }
           }
        return ист [0 .. p-ист.ptr];
}