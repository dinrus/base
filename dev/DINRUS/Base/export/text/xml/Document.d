module text.xml.Document;

package import text.xml.PullParser;

version(Clear)
extern (C) ук memset(ук s, цел c, т_мера n);

version=discrete;

/*******************************************************************************

        Реализует DOM поверх парсера XML, поддерживая разбор документа,
        обход дерева и ad-hoc манипуляции с деревом.

        Этот DOM API non-conformant, но простой и функциональный по
        стилю - выявляем положение интересующего узла дерева и
		работаем с ним, или вокруг да около него!
		Во всяком случае для начала нужно иметь экзеппляр
		документа, после чего его можно наполнить либо парсингом существующего
		документа, либо посредством манипуляция с API.

        Этот частичный DOM использует простой фрилист, где размещается
		каждый узел дерева, что делает разбор документов XML весьма
		эффективным. Неудобство такой схемы состоит в том, что для
		копирования узлов из одного документа в другой требует
	    дополнительного беспокойства. Но мы чувствовали, что это
		терпимое неудобство, если противопоставить the throughput gains 
		vs относительной редкости of grafting operations. Для графтинга
		внутри или между документами, пожалуйста, используйте
		методы перемести() и копируй().

        Другое упрощение относится к транкодированию сущности. Это
        выполняется не внутренне, а лежит на ответственности клиента.
        То есть клиент - при необходимости - должен выполнять соответствующее
		транскодирование сущности. Не кажется очень уж приемлемым
		 платить (высокую) цену за транскодинг всех документов.

        Пример разбора
        ---
        auto док = new Документ!(сим);
        док.разбор (контент);

        auto выведи = new ДокПринтер!(сим);
        Стдвыв(выведи(док)).нс;
        ---

        Пример API
        ---
        auto док = new Документ!(сим);

        // прикрепим заголовок xml
        док.заголовок;

        // прикрепим элемент с какими-нибудь атрибутами, плюс
        // элемент-ветвь с прикреплённым значением данных
        док.дерево.элемент   (пусто, "элемент")
                .атрибут (пусто, "атриб1", "значение")
                .атрибут (пусто, "атриб2")
                .элемент   (пусто, "ветвь", "значение");

        auto выведи = new ДокПринтер!(сим);
        Стдвыв(выведи(док)).нс;
        ---

        Заметьте, что дерево() документов включает все узлы в этом дереве,
        а не только элементы. Для адресации к самому верхнему элементу
		вместо неё используется док.элементы. Например, добавим внутренний
		пасынок к предыдущей иллюстрации:
        ---
        док.элементы.элемент (пусто, "пасынок");
        ---

        Выводим имя самого верхнего (корневого) элемента:
        ---
        Стдвыв.форматнс ("первый элемент - это '{}'", док.элементы.имя);
        ---

        Примеры XPath:
        ---
        auto док = new Документ!(сим);

        // прикрепим элемент с какими-нибудь атрибутами, плюс
        // элемент-ветвь с прикреплённым значением данных
        док.дерево.элемент   (пусто, "элемент")
                .атрибут (пусто, "атриб1", "значение")
                .атрибут (пусто, "атриб2")
                .элемент   (пусто, "ветвь", "значение");

        // выбираем именованные элементы
        auto набор = док.запрос["элемент"]["ветвь"];

        // выбираем все атрибуты с именем "атриб1"
        набор = док.запрос.потомок.атрибут("атриб1");

        // выбираем элементы с одним родителем и совпадающими текстовыми значениеми
        набор = док.запрос[].фильтр((док.Узел n) {return n.ветви.естьДанные("значение");});
        ---

        Заметьте, что запросы пути временные - контент запросов не сохраняется.
        То есть жизненный цикл итога запроса ограничен. Его можно лишь явно скопировать.
	    Например, такая операция не удастся:
        ---
        auto элементы = док.запрос["элемент"];
        auto ветви = элементы["ветвь"];
        ---

        Выше будут потеряны элементы, так как ассоциированный документ повторно
		использует пространство узла для последующих запросов. Чтобы удержать
		результаты, выполняем следующее:
        ---
        auto элементы = док.запрос["элемент"].dup;
        auto ветви = элементы["ветвь"];
        ---

        Выше упомянутый .dup, как правило, очень мал (набор из одних указателей).
		С другой стороны, полностью поддерживаются рекурсивные запросы.
        ---
        набор = док.запрос[].фильтр((док.Узел n) {return n.запрос[].счёт > 1;});
        ---

        Типичное применение придерживается следующего образца, в котором результат
		каждого запроса обрабатывается перед инициацией другого:
        ---
        foreach (узел; док.запрос.ветвь("элемент"))
                {
                // делаем что-либо с каждым узлом
                }
        ---

        Заметьте, что парсер шаблонизирован под сим, шим или дим.

*******************************************************************************/

class Документ(T) : package PullParser!(T)
{
    public alias УзелРеализ*  Узел;

    private Узел            корень;
    private УзелРеализ[]      список;
    private УзелРеализ[][]    списки;
    private цел             индекс,
            чанки,
            фрисписки;
    private ПутьРЯР!(T)     хпуть;

    /***********************************************************************

            Конструирует экземпляр DOM. Опциональный параметр указывает
            начальное число узлов, назначенных в фрилист.

    ***********************************************************************/

    this (бцел узлы = 1000)
    {
        assert (узлы > 50);
        super (пусто);
        хпуть = new ПутьРЯР!(T);

        чанки = узлы;
        новый_список;
        корень = размести;
        корень.ид = ПТипУзлаРЯР.Документ;
    }

    /***********************************************************************

            Возвращает хпуть укз для запроса этого документа. Начинается
            от корня документа.

            Смотрите также Узел.запрос

    ***********************************************************************/

    final ПутьРЯР!(T).НаборУзлов запрос ()
    {
        return хпуть.старт (корень);
    }

    /***********************************************************************

            Возвращает корневой узел документа, от которого исходят
			все прочие узлы.

            Возвращает пусто, когда узлов в документе больше нет.

    ***********************************************************************/

    final Узел дерево ()
    {
        return корень;
    }

    /***********************************************************************

            Возвращает самый верхний узел элементов, как правило, являющийся
            корнем дерева элементов.

            Возвращает пусто, когда вершинные узлы отсутствуют.

    ***********************************************************************/

    final Узел элементы ()
    {
        if (корень)
        {
            auto узел = корень.последнОтпрыск;
            while (узел)
                if (узел.ид is ПТипУзлаРЯР.Элемент)
                    return узел;
                else
                    узел = узел.предш;
        }
        return пусто;
    }

    /***********************************************************************

            Сбросить фрилист. При последующем размещении узлов документа
            будут переписываться предыдущие экземпляры.

    ***********************************************************************/

    final Документ сбрось ()
    {
        корень.последнОтпрыск = корень.первОтпрыск = пусто;
        version(Clear)
        {
            while (фрисписки)
            {
                auto список = списки[--фрисписки];
                memset (список.ptr, 0, УзелРеализ.sizeof * список.length);
            }
        }
        else
        {
            фрисписки = 0;
        }
        новый_список;
        индекс = 1;
        version(d)
        {
            фрисписки = 0;          // needed to align the codegen!
        }
        return this;
    }

    /***********************************************************************

           Приставить заголовок XML к дереву документа.
 
    ***********************************************************************/

    final Документ заголовок (T[] кодировка = пусто)
    {
        if (кодировка.length)
            кодировка = `xml version="1.0" encoding="`~кодировка~`"`;
        else
            кодировка = `xml version="1.0" encoding="UTF-8"`;

        корень.приставь (корень.создай(ПТипУзлаРЯР.ПИ, кодировка));
        return this;
    }

    /***********************************************************************

            Разобрать данный контент xml, который будет повторно использовать
			любой существующий узел внутри этого документа. Итоговое дерево
			можно получить с помощью атрибута документа 'дерево'.

    ***********************************************************************/

    final проц разбор(T[] xml)
    {
        assert (xml);
        сбрось;
        super.сбрось (xml);
        auto тек = корень;
        бцел defNamespace;

        while (да)
        {
            auto p = текст.точка;
            switch (super.следщ)
            {
            case ПТипТокенаРЯР.КонечныйЭлемент:
            case ПТипТокенаРЯР.ПустойКонечныйЭлемент:
                assert (тек.хост);
                тек.конец = текст.точка;
                тек = тек.хост;
                break;

            case ПТипТокенаРЯР.Данные:
                version (discrete)
                {
                    auto узел = размести;
                    узел.НеобрЗначение = super.НеобрЗначение;
                    узел.ид = ПТипУзлаРЯР.Данные;
                    тек.добавь (узел);
                }
                else
                {
                    if (тек.НеобрЗначение.length is 0)
                        тек.НеобрЗначение = super.НеобрЗначение;
                    else
                        // несколько секций с данными
                        тек.данные (super.НеобрЗначение);
                }
                break;

            case ПТипТокенаРЯР.НачальныйЭлемент:
                auto узел = размести;
                узел.хост = тек;
                узел.псеп_в_начале = super.префикс;
                узел.ид = ПТипУзлаРЯР.Элемент;
                узел.локалИмя = super.локалИмя;
                узел.старт = p;

                // инлайн добавь
                if (тек.последнОтпрыск)
                {
                    тек.последнОтпрыск.следщПасынок = узел;
                    узел.предшПасынок = тек.последнОтпрыск;
                    тек.последнОтпрыск = узел;
                }
                else
                {
                    тек.первОтпрыск = узел;
                    тек.последнОтпрыск = узел;
                }
                тек = узел;
                break;

            case ПТипТокенаРЯР.Атрибут:
                auto атр = размести;
                атр.псеп_в_начале = super.префикс;
                атр.НеобрЗначение = super.НеобрЗначение;
                атр.локалИмя = super.локалИмя;
                атр.ид = ПТипУзлаРЯР.Атрибут;
                тек.атриб (атр);
                break;

            case ПТипТокенаРЯР.ПИ:
                тек.пи_ (super.НеобрЗначение, p[0..текст.точка-p]);
                break;

            case ПТипТокенаРЯР.Комментарий:
                тек.коммент_ (super.НеобрЗначение);
                break;

            case ПТипТокенаРЯР.СиДанные:
                тек.сиданные_ (super.НеобрЗначение);
                break;

            case ПТипТокенаРЯР.Доктип:
                тек.доктип_ (super.НеобрЗначение);
                break;

            case ПТипТокенаРЯР.Готово:
                return;

            default:
                break;
            }
        }
    }

    /***********************************************************************

            Размещает узел из этого фрилиста.

    ***********************************************************************/

    private final Узел размести ()
    {
        if (индекс >= список.length)
            новый_список;

        auto p = &список[индекс++];
        p.док = this;
        version(Clear) {}
        else
        {
            p.старт = p.конец = пусто;
            p.хост =
                p.предшПасынок =
                    p.следщПасынок =
                        p.первОтпрыск =
                            p.последнОтпрыск =
                                p.первАтр =
                                    p.последнАтр = пусто;
            p.НеобрЗначение =
                p.локалИмя =
                    p.псеп_в_начале = пусто;
        }
        return p;
    }

    /***********************************************************************

            Размещает узел из этого фрилиста.

    ***********************************************************************/

    private final проц новый_список ()
    {
        индекс = 0;
        if (фрисписки >= списки.length)
        {
            списки.length = списки.length + 1;
            списки[$-1] = new УзелРеализ [чанки];
        }
        список = списки[фрисписки++];
    }

    /***********************************************************************

            Поддержка foreach для записи и выбора узлов.

            Низкоуровневый механизм для захвата контекста,
            относящегося к opApply, и используемый здесь для
			сметания узлов при тестировании различных
			отношений.

            See Узел.атрибуты и Узел.ветви

    ***********************************************************************/

    private struct Визитор
    {
        private Узел узел;

        public alias значение      данные;
        public alias естьЗначение   естьДанные;

        /***************************************************************

                Есть тут, что можно посетить?

                Временная ёмкость: O(1)

        ***************************************************************/

        бул есть_ли ()
        {
            return узел != пусто;
        }

        /***************************************************************

                Траверсирует по узлам-пасынкам.

        ***************************************************************/

        цел opApply (цел delegate(ref Узел) дг)
        {
            цел возвр;

            for (auto n=узел; n; n = n.следщПасынок)
                if ((возвр = дг(n)) != 0)
                    break;
            return возвр;
        }

        /***************************************************************

                Лоцирует узел с совпадающими имя и/или префикс,
                которые проходят через опциональный фильтр. Каждый
                аргумент ингнорируется, если он = пусто.

                Временная ёмкость: O(n)

        ***************************************************************/

        Узел имя (T[] префикс, T[] локал, бул delegate(Узел) дг=пусто)
        {
            for (auto n=узел; n; n = n.следщПасынок)
            {
                if (локал.ptr && локал != n.локалИмя)
                    continue;

                if (префикс.ptr && префикс != n.псеп_в_начале)
                    continue;

                if (дг.ptr && дг(n) is нет)
                    continue;

                return n;
            }
            return пусто;
        }

        /***************************************************************

                Сканирует узлы на совпадающие имя и/или префикс. Каждый
                аргумент ингнорируется, если он = пусто.

                Временная ёмкость: O(n)

        ***************************************************************/

        бул естьИмя (T[] префикс, T[] локал)
        {
            return имя (префикс, локал) != пусто;
        }

        /***************************************************************

                Лоцирует узел с совпадающими имя и/или префикс. Каждый
                аргумент ингнорируется, если он = пусто.
				
                Временная ёмкость: O(n)

        ***************************************************************/
        version (Фильтр)
        {
            Узел значение (T[] префикс, T[] локал, T[] значение)
            {
                if (значение.ptr)
                    return имя (префикс, локал, (Узел n)
                {
                    return значение == n.НеобрЗначение;
                });
                return имя (префикс, локал);
            }
        }
        /***************************************************************

                Сметает узлы в поисках свера, и возвращает либо
                узел, либо пусто. Смотрите значение(x,y,z) или имя(x,y,z)
				для дополнительной фильтрации.

                Временная ёмкость: O(n)

        ***************************************************************/

        Узел значение (T[] свер)
        {
            if (свер.ptr)
                for (auto n=узел; n; n = n.следщПасынок)
                    if (свер == n.НеобрЗначение)
                        return n;
            return пусто;
        }

        /***************************************************************

                Сметает узлы в поисках значения свер. Возвращает
                да, если найдено. Смотрите значение(x,y,z) или имя(x,y,z)
				для дополнительной фильтрации.

                Временная ёмкость: O(n)

        ***************************************************************/

        бул естьЗначение (T[] свер)
        {
            return значение(свер) != пусто;
        }
    }


    /***********************************************************************

            Реализация узла

    ***********************************************************************/

    private struct УзелРеализ
    {
        public ук            пользователь;           /// окрыт для использования
        package Документ        док;            // владеющий документ
        package ПТипУзлаРЯР     ид;             // тип узла
        package T[]             псеп_в_начале;       // пространство имён
        package T[]             локалИмя;      // имя
        package T[]             НеобрЗначение;       // данные значение

        package Узел            хост,           // родитель узел
                предшПасынок,    // приор
                следщПасынок,    // следщ
                первОтпрыск,     // голова
                последнОтпрыск,      // хвост
                первАтр,      // голова
                последнАтр;       // хвост

        package T*              конец,            // срез из  ...
                старт;          // оригинальный текст xml

        /***************************************************************

                Возвращает хостирующий документ.

        ***************************************************************/

        Документ документ ()
        {
            return док;
        }

        /***************************************************************

                Возвращает ид типа узла.

        ***************************************************************/

        ПТипУзлаРЯР тип ()
        {
            return ид;
        }

        /***************************************************************

                Возвращает родитель, который может быть пусто.

        ***************************************************************/

        Узел родитель ()
        {
            return хост;
        }

        /***************************************************************

                Возвращает первую ветвь, которая может быть пусто.

        ***************************************************************/

        Узел ветвь ()
        {
            return первОтпрыск;
        }

        /***************************************************************

                Возвращает последнюю ветвь, которая может быть пусто.

                Deprecated: exposes too much implementation detail.
                            Please file a ticket if you really need
                            this functionality

        ***************************************************************/

        deprecated Узел хвостОтпрыск ()
        {
            return последнОтпрыск;
        }

        /***************************************************************

                Возвращает предыдущий пасынок, который может быть пусто.

        ***************************************************************/

        Узел предш ()
        {
            return предшПасынок;
        }

        /***************************************************************

                Возвращает следующий пасынок, который может быть пусто.

        ***************************************************************/

        Узел следщ ()
        {
            return следщПасынок;
        }

        /***************************************************************

                Возвращает префикс пространства имён этого узла (может быть пусто).

        ***************************************************************/

        T[] префикс ()
        {
            return псеп_в_начале;
        }

        /***************************************************************

                Устанавливает префикс пространства имён этого узла (может быть пусто).

        ***************************************************************/

        Узел префикс (T[] замени)
        {
            псеп_в_начале = замени;
            return this;
        }

        /***************************************************************

                Возвращает имя узла (без префикса).

        ***************************************************************/

        T[] имя ()
        {
            return локалИмя;
        }

        /***************************************************************

                Устанавливает имя узла (без префикса).

        ***************************************************************/

        Узел имя (T[] замени)
        {
            локалИмя = замени;
            return this;
        }

        /***************************************************************

                Возвращает контент с данными, который может быть пусто.

        ***************************************************************/

        T[] значение ()
        {
            version(discrete)
            {
                if (тип is ПТипУзлаРЯР.Элемент)
                    foreach (ветвь; ветви)
                    if (ветвь.ид is ПТипУзлаРЯР.Данные ||
                            ветвь.ид is ПТипУзлаРЯР.СиДанные)
                        return ветвь.НеобрЗначение;
            }
            return НеобрЗначение;
        }

        /***************************************************************

                Устанавливает контент с необр данными, который может быть пусто.

        ***************************************************************/

        проц значение (T[] знач)
        {
            version(discrete)
            {
                if (тип is ПТипУзлаРЯР.Элемент)
                    foreach (ветвь; ветви)
                    if (ветвь.ид is ПТипУзлаРЯР.Данные)
                        return ветвь.значение (знач);
            }
            НеобрЗначение = знач;
            измени;
        }

        /***************************************************************

                Возвращает полное имя узла, являющееся комбинацией
                префикса & локал имён. Узлы без префикса
                возвращают только локал-имя.

        ***************************************************************/

        T[] вТкст (T[] вывод = пусто)
        {
            if (псеп_в_начале.length)
            {
                auto длин = псеп_в_начале.length + локалИмя.length + 1;

                // прикреплён ли уже этот префикс к имя?
                if (псеп_в_начале.ptr + псеп_в_начале.length + 1 is локалИмя.ptr &&
                        ':' is *(локалИмя.ptr-1))
                    return псеп_в_начале.ptr [0 .. длин];

                // копируем дискретные  сегменты в вывод
                if (вывод.length < длин)
                    вывод.length = длин;
                вывод[0..псеп_в_начале.length] = псеп_в_начале;
                вывод[псеп_в_начале.length] = ':';
                вывод[псеп_в_начале.length+1 .. длин] = локалИмя;
                return вывод[0..длин];
            }

            return локалИмя;
        }

        /***************************************************************

                Возвращает индекс этого узла, либо количество
                предщестующих пасынков в нём.

                Временная ёмкость: O(n)

        ***************************************************************/

        бцел позиция ()
        {
            auto счёт = 0;
            auto приор = предшПасынок;
            while (приор)
                ++счёт, приор = приор.предшПасынок;
            return счёт;
        }

        /***************************************************************

                Открепляет этот узел лт его родителя и пасынков.

        ***************************************************************/

        Узел открепи ()
        {
            return удали;
        }

        /***************************************************************

                Возвращает хпуть укз, для запроса этого узла.

                Смотрите также Документ.запрос

        ***************************************************************/

        final ПутьРЯР!(T).НаборУзлов запрос ()
        {
            return док.хпуть.старт (this);
        }

        /***************************************************************

                Возвращает foreach обходчик для ветвей узла.

        ***************************************************************/

        Визитор ветви ()
        {
            Визитор знач = {первОтпрыск};
            return знач;
        }

        /***************************************************************

                Возвращает foreach обходчик для атрибутов узла.

        ***************************************************************/

        Визитор атрибуты ()
        {
            Визитор знач = {первАтр};
            return знач;
        }

        /***************************************************************

                Возвращает есть ли атрибуты.

            Deprecated: вместо него используется узел.атрибуты.есть_ли

        ***************************************************************/

        deprecated бул естьАтрибуты ()
        {
            return первАтр !is пусто;
        }

        /***************************************************************

                Возвращает есть ли ветви.

        Deprecated: вместо него используйте узел.ветвь или узел.ветви.есть_ли
				
        ***************************************************************/

        deprecated бул естьОтпрыски ()
        {
            return первОтпрыск !is пусто;
        }

        /***************************************************************

                Дублирует данное поддерево как ветвь
                этого узла.

                Возвращает ссылку на поддерево.

        ***************************************************************/

        Узел копируй (Узел дерево)
        {
            assert (дерево);
            дерево = дерево.клонируй;
            дерево.мигрируй (документ);

            if (дерево.ид is ПТипУзлаРЯР.Атрибут)
                атриб (дерево);
            else
                добавь (дерево);
            return дерево;
        }

        /***************************************************************

                Релоцирует данное поддерево как ветвь
                этого узла.

                Возвращает ссылку на поддерево.

        ***************************************************************/

        Узел перемести (Узел дерево)
        {
            дерево.открепи;
            if (дерево.док is док)
            {
                if (дерево.ид is ПТипУзлаРЯР.Атрибут)
                    атриб (дерево);
                else
                    добавь (дерево);
            }
            else
                дерево = копируй (дерево);
            return дерево;
        }

        /***************************************************************

                Приставляет новый элемент (ветвь) и возвращает ссылку на
                него.

        ***************************************************************/

        Узел элемент (T[] префикс, T[] локал, T[] значение = пусто)
        {
            return элемент_ (префикс, локал, значение).измени;
        }

        /***************************************************************

                Прикрепляет атрибут и возвращает this, его хост.

        ***************************************************************/

        Узел атрибут (T[] префикс, T[] локал, T[] значение = пусто)
        {
            return атрибут_ (префикс, локал, значение).измени;
        }

        /***************************************************************

                Прикрепляет узел данных и возвращает this, его хост.

        ***************************************************************/

        Узел данные (T[] данные)
        {
            return данные_ (данные).измени;
        }

        /***************************************************************

                Прикрепляет узел СиДанные и возвращает this, его хост.

        ***************************************************************/

        Узел сиданные (T[] сиданные)
        {
            return сиданные_ (сиданные).измени;
        }

        /***************************************************************

                Прикрепляет узел комментария и возвращает this, его хост.

        ***************************************************************/

        Узел коммент (T[] коммент)
        {
            return коммент_ (коммент).измени;
        }

        /***************************************************************

                Прикрепляет узел Доктип и возвращает this, его хост.

        ***************************************************************/

        Узел доктип (T[] доктип)
        {
            return доктип_ (доктип).измени;
        }

        /***************************************************************

                Прикрепляет узел ПИ и возвращает this, его хост.

        ***************************************************************/

        Узел пи (T[] пи)
        {
            return пи_ (пи, пусто).измени;
        }

        /***************************************************************

                Прикрепляет ветвь Элемент, и возвращает ссылку на
                эту ветвь.

        ***************************************************************/

        private Узел элемент_ (T[] префикс, T[] локал, T[] значение = пусто)
        {
            auto узел = создай (ПТипУзлаРЯР.Элемент, пусто);
            добавь (узел.установи (префикс, локал));
            version(discrete)
            {
                if (значение.length)
                    узел.данные_ (значение);
            }
            else
            {
                узел.НеобрЗначение = значение;
            }
            return узел;
        }

        /***************************************************************

                Прикрепляет атрибут, и возвращает этот хост.

        ***************************************************************/

        private Узел атрибут_ (T[] префикс, T[] локал, T[] значение = пусто)
        {
            auto узел = создай (ПТипУзлаРЯР.Атрибут, значение);
            атриб (узел.установи (префикс, локал));
            return this;
        }

        /***************************************************************

                Прикрепляет узел Данные, и возвращает этот хост.

        ***************************************************************/

        private Узел данные_ (T[] данные)
        {
            добавь (создай (ПТипУзлаРЯР.Данные, данные));
            return this;
        }

        /***************************************************************

                Прикрепляет узел СиДанные, и возвращает этот хост.

        ***************************************************************/

        private Узел сиданные_ (T[] сиданные)
        {
            добавь (создай (ПТипУзлаРЯР.СиДанные, сиданные));
            return this;
        }

        /***************************************************************

                Прикрепляет узел Комментарий, и возвращает этот хост.

        ***************************************************************/

        private Узел коммент_ (T[] коммент)
        {
            добавь (создай (ПТипУзлаРЯР.Комментарий, коммент));
            return this;
        }

        /***************************************************************

                Прикрепляет узел ПИ, и возвращает этот хост.

        ***************************************************************/

        private Узел пи_ (T[] пи, T[] патч)
        {
            добавь (создай(ПТипУзлаРЯР.ПИ, пи).патч(патч));
            return this;
        }

        /***************************************************************

                Прикрепляет узел Доктип, и возвращает этот хост.

        ***************************************************************/

        private Узел доктип_ (T[] доктип)
        {
            добавь (создай (ПТипУзлаРЯР.Доктип, доктип));
            return this;
        }

        /***************************************************************

                Добавляет атрибут к этому узлу; у заданного атрибута
                не может существовать родитель.

        ***************************************************************/

        private проц атриб (Узел узел)
        {
            assert (узел.родитель is пусто);
            узел.хост = this;
            if (последнАтр)
            {
                последнАтр.следщПасынок = узел;
                узел.предшПасынок = последнАтр;
                последнАтр = узел;
            }
            else
                первАтр = последнАтр = узел;
        }

        /***************************************************************

                Добавляет узел к этому узлу. Данный узел не
                может иметь существующего родителя.

        ***************************************************************/

        private проц добавь (Узел узел)
        {
            assert (узел.родитель is пусто);
            узел.хост = this;
            if (последнОтпрыск)
            {
                последнОтпрыск.следщПасынок = узел;
                узел.предшПасынок = последнОтпрыск;
                последнОтпрыск = узел;
            }
            else
                первОтпрыск = последнОтпрыск = узел;
        }

        /***************************************************************

                Приставляет (впереди) узел к этому узлу. У данного узла
                не может существовать родителя.

        ***************************************************************/

        private проц приставь (Узел узел)
        {
            assert (узел.родитель is пусто);
            узел.хост = this;
            if (первОтпрыск)
            {
                первОтпрыск.предшПасынок = узел;
                узел.следщПасынок = первОтпрыск;
                первОтпрыск = узел;
            }
            else
                первОтпрыск = последнОтпрыск = узел;
        }

        /***************************************************************

                Конфигурирует значения узла.

        ***************************************************************/

        private Узел установи (T[] префикс, T[] локал)
        {
            this.локалИмя = локал;
            this.псеп_в_начале = префикс;
            return this;
        }

        /***************************************************************

                Создаёт и возвращает узел элемента ветви.

        ***************************************************************/

        private Узел создай (ПТипУзлаРЯР тип, T[] значение)
        {
            auto узел = документ.размести;
            узел.НеобрЗначение = значение;
            узел.ид = тип;
            return узел;
        }

        /***************************************************************

                Открепляет этот узел от его родителя и пасынков.

        ***************************************************************/

        private Узел удали()
        {
            if (! хост)
                return this;

            измени;
            if (предшПасынок && следщПасынок)
            {
                предшПасынок.следщПасынок = следщПасынок;
                следщПасынок.предшПасынок = предшПасынок;
                предшПасынок = пусто;
                следщПасынок = пусто;
                хост = пусто;
            }
            else if (следщПасынок)
            {
                debug assert(хост.первОтпрыск == this);
                родитель.первОтпрыск = следщПасынок;
                следщПасынок.предшПасынок = пусто;
                следщПасынок = пусто;
                хост = пусто;
            }
            else if (тип != ПТипУзлаРЯР.Атрибут)
            {
                if (предшПасынок)
                {
                    debug assert(хост.последнОтпрыск == this);
                    хост.последнОтпрыск = предшПасынок;
                    предшПасынок.следщПасынок = пусто;
                    предшПасынок = пусто;
                    хост = пусто;
                }
                else
                {
                    debug assert(хост.первОтпрыск == this);
                    debug assert(хост.последнОтпрыск == this);
                    хост.первОтпрыск = пусто;
                    хост.последнОтпрыск = пусто;
                    хост = пусто;
                }
            }
            else
            {
                if (предшПасынок)
                {
                    debug assert(хост.последнАтр == this);
                    хост.последнАтр = предшПасынок;
                    предшПасынок.следщПасынок = пусто;
                    предшПасынок = пусто;
                    хост = пусто;
                }
                else
                {
                    debug assert(хост.первАтр == this);
                    debug assert(хост.последнАтр == this);
                    хост.первАтр = пусто;
                    хост.последнАтр = пусто;
                    хост = пусто;
                }
            }

            return this;
        }

        /***************************************************************

                Патчит текст сериализации, заставляя ДокПринтер
                игнорировать поддерево этого узла, и изливать
                предоставленный текст как необработанный вывод XML.

                Предупреждение: эта функция *не* копирует предоставленный
                текст, и может быть удалена в дальнейших ревизиях.

        ***************************************************************/

        private Узел патч (T[] текст)
        {
            конец = текст.ptr + текст.length;
            старт = текст.ptr;
            return this;
        }

        /***************************************************************

                Зануляет кэш сериализации этого узла и его
                предков.

        ***************************************************************/

        private Узел измени ()
        {
            auto узел = this;
            do
            {
                узел.конец = пусто;
            }
            while ((узел = узел.хост) !is пусто);

            return this;
        }

        /***************************************************************

                Дублирует единичный узел.

        ***************************************************************/

        private Узел dup ()
        {
            return создай(тип, НеобрЗначение.dup).установи(псеп_в_начале.dup, локалИмя.dup);
        }

        /***************************************************************

                Дублирует поддерево.

        ***************************************************************/

        private Узел клонируй ()
        {
            auto p = dup;

            foreach (атр; атрибуты)
            p.атриб (атр.dup);
            foreach (ветвь; ветви)
            p.добавь (ветвь.клонируй);
            return p;
        }

        /***************************************************************

                Сбросить хост документа для этого поддерева.

        ***************************************************************/

        private проц мигрируй (Документ хост)
        {
            this.док = хост;
            foreach (атр; атрибуты)
            атр.мигрируй (хост);
            foreach (ветвь; ветви)
            ветвь.мигрируй (хост);
        }
    }
}


/*******************************************************************************

        Поддержка XPath

        Предоставляет поддержку общим осевым и филтрационным функциям XPath,
        через исконный-D интерфейс вместо типичной интерпретированной нотации.

        Основная идея здесь - генерировать НаборУзлов, состоящий из тех
        узлов дерева, которые удовлетворяют функцию фильтрации. Направление, или
        оси, обхода дерева управляемо одной из нескольких предопределённых
        операций. Все методы облегчают связывание цепочки вызовов, где каждый шаг
        возвращает новый экземпляр НаборУзлов, над которым проводится оперирование.

        Сам набор узлов собран в фрилист, что избавляет от кучевой активности
        и добавляет полезное использование собственных средств работы
		со срезами массивов, имеющимися у Динруса (полученных от языка D).

        Примеры XPath
        ---
        auto док = new Документ!(сим);

        // прикрепим элемент с некоторыми атрибутами, плюс
        //  элемент ветви с закреплённым значением данных.
        док.дерево.элемент (пусто, "элемент")
                .атрибут (пусто, "атриб1", "значение")
                .атрибут (пусто, "атриб2")
                .элемент   (пусто, "ветвь", "значение");

        // выберем именованные элементы
        auto набор = док.запрос["элемент"]["ветвь"];

        // выберем все атрибуты с именем "атриб1"
        набор = док.запрос.потомок.атрибут("атриб1");

        // выбери элементы with one родитель и a совпадают текст значение
        набор = док.запрос[].фильтр((док.Узел n) {return n.ветви.естьДанные("значение");});
        ---

        Заметьте, что запросы пути временные - контент запросов не сохраняется.
        То есть жизненный цикл итога запроса ограничен. Его можно лишь явно скопировать.
	    Например, такая операция не удастся:
        ---
        auto элементы = док.запрос["элемент"];
        auto ветви = элементы["ветвь"];
        ---

        Выше будут потеряны элементы, так как ассоциированный документ повторно
		использует пространство узла для последующих запросов. Чтобы удержать
		результаты, выполняем следующее:
        ---
        auto элементы = док.запрос["элемент"].dup;
        auto ветви = элементы["ветвь"];
        ---

        Выше упомянутый .dup, как правило, очень мал (набор из одних указателей).
		С другой стороны, полностью поддерживаются рекурсивные запросы.
        ---
        набор = док.запрос[].фильтр((док.Узел n) {return n.запрос[].счёт > 1;});
        ---

        Типичное применение придерживается следующего образца, в котором результат
		каждого запроса обрабатывается перед инициацией другого:
        ---
        foreach (узел; док.запрос.ветвь("элемент"))
                {
                // делаем что-либо с каждым узлом
                }
        ---

        В поддерживаемые оси входят:
        ---
        .ветвь                  непосредственные ветви
        .родитель                 непосредственный родитель
        .следщ                   следующие пасынки
        .предш                   предыдущие пасынки
        .предок               все родители
        .потомок             все потомки
        .данные                   текст ветви
        .сиданные                  сиданные ветви
        .атрибут              атрибут ветви
        ---

        Каждая из упомянутых осей принимает опциональный ткст, который
		используется специфичным для оси способом для фильтрации узлов.
		Например, .ветвь("food") отфильтрует элементы <food> ветви.
		Эти варианты - краткие команды для применения  фильтра, чтобы
		провести пост-обработку результата. Каждая из осей также имеет
        варианты, которые принимают делегата.

        В целом, проводится обход оси и оперирование над результатами.
        В ходе оперирования может вестись обход другой оси, либо 
        шаг фильтрации. Все шаги могут быть, и, как правило, сцепляются
		вместе.

		Фильтры реализуются посредством механизма делегации,
        ---
        .фильтр (бул delegate(Узел))
        ---

        где делегат возвращает да, если узел обходит фильтр.
        Примером может быть выделение всех узлов специфичным атрибутом:
        ---
        auto набор = док.запрос.потомок.фильтр (
                    (док.Узел n){return n.атрибуты.естьИмя (пусто, "тест");}
                   );
        ---

        Явно это не так чисто, как в случае с истиной нотацией XPath, но
        её можно обернуть поверх этого API. Полезность здесь заключена в
        необрабатываемом сквозном протоке (throughput), что важно для
		некоторых приложений.

        Заметьте, что каждвя операция возвращает отдельный результат. Методы первый()
        и последний() такде возвращают набор из одного или нескольких элементов.
		Некоторые специфичные для языка расширения предоставлены тоже:
        ---
        * .ветвь() может быть заменена нотацией []

        * нотация[] может использоваться для индексирования определённого элемента,
		как .н_ый()

        * атрибут .узлы выставляет низлежащий Узел[], с которого можно снять
          срез или обойти в обычной для Динруса манере.
        ---

       В прочие утилитные методы (результата щапроса) входят:
       ---
       .dup
       .первый
       .последний
       .opIndex
       .н_ый
       .счёт
       .opApply
       ---

       ПутьРЯР сам должен быть классом, чтобы избежать проблем форвард-реферинга
	   (ссылки на ещё не написанный класс).

*******************************************************************************/

private class ПутьРЯР(T)
{
    public alias Документ!(T) Док;          /// типированный документ
    public alias Док.Узел     Узел;         /// генерный узел документа

    private Узел[]          фрилист;
    private бцел            фриИндекс,
            маркИндекс;
    private бцел            рекурсия;

    /***********************************************************************

            Применить запрос.

            Возвращает НаборУзлов, содержащий только данный узел, который
            затем моно использовать для каскадного преобразования
			в последующие экземпляры НаборУзлов.

    ***********************************************************************/

    final НаборУзлов старт (Узел корень)
    {
        // нужно поддерживать рекурсию, которая происходит внутри
        // обратного вызова фильтра
        if (рекурсия is 0)
        {
            if (фрилист.length is 0)
                фрилист.length = 256;
            фриИндекс = 0;
        }

        НаборУзлов установи = {this};
        auto метка = фриИндекс;
        размести(корень);
        return установи.присвой (метка);
    }

    /***********************************************************************

            Плоть поддержки XPath. Все операторы НаборУзлов
            имеются здесь, чтобы активировать сцепку вызовов.

            Заметьте, что некоторые оси выполняют двойную службу,
			в качестве фильтр дополнительно. Это лишь удобный
			фактор, не меняющий низлежащего механизма.

    ***********************************************************************/

    struct НаборУзлов
    {
        private ПутьРЯР хост;
        public  Узел[]  узлы;  /// Массив выбранных узлов

        /***************************************************************

                Возвращает дубликат НаборУзлов.

        ***************************************************************/

        НаборУзлов dup ()
        {
            НаборУзлов копируй = {хост};
            копируй.узлы = узлы.dup;
            return копируй;
        }

        /***************************************************************

                Возвращает число выбранных узлов в этом наборе.

        ***************************************************************/

        бцел счёт ()
        {
            return узлы.length;
        }

        /***************************************************************

                Возвращает набор, содержащий только первый узел
                текущего набора.

        ***************************************************************/

        НаборУзлов первый ()
        {
            return н_ый (0);
        }

        /***************************************************************

                Возвращает набор, содержащий только последний узел
                текущего набора.

        ***************************************************************/

        НаборУзлов последний ()
        {
            auto i = узлы.length;
            if (i > 0)
                --i;
            return н_ый (i);
        }

        /***************************************************************

                Возвращает набор, содержащий только н_ый узел
                текущего набора.

        ***************************************************************/

        НаборУзлов opIndex (бцел i)
        {
            return н_ый (i);
        }

        /***************************************************************

                Возвращает набор, содержащий только н_ый узел
                текущего набора.

        ***************************************************************/

        НаборУзлов н_ый (бцел индекс)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;
            if (индекс < узлы.length)
                хост.размести (узлы [индекс]);
            return установи.присвой (метка);
        }

        /***************************************************************

              Возвращает набор, содержащий все элементы ветви
                узлов внутри этого набора.

        ***************************************************************/

        НаборУзлов opSlice ()
        {
            return ветвь();
        }

        /***************************************************************

                Возвращает набор, содержащий все элементы ветви из
                узлов внутри этого набора, проводя свер данного имя.

        ***************************************************************/

        НаборУзлов opIndex (T[] имя)
        {
            return ветвь (имя);
        }

        /***************************************************************

                Возвращает набор, содержащий все родительские элементы из
                узлов внутри этого набора, проводя свер опционального имени.

        ***************************************************************/

        НаборУзлов родитель (T[] имя = пусто)
        {
            if (имя.ptr)
                return родитель ((Узел узел)
            {
                return узел.имя == имя;
            });
            return родитель (&всегда);
        }

        /***************************************************************

                Возвращает набор, содержащий все узлы данных, из
                узлов внутри этого набора, сверяя - опционально -
                значение.

        ***************************************************************/

        НаборУзлов данные (T[] значение = пусто)
        {
            if (значение.ptr)
                return ветвь ((Узел узел)
            {
                return узел.значение == значение;
            },
            ПТипУзлаРЯР.Данные);
            return ветвь (&всегда, ПТипУзлаРЯР.Данные);
        }

        /***************************************************************

                Возвращает набор, содержащий все узлы сиданные
                узлов внутри этого набора, сверяя - опционально -
                значение.

        ***************************************************************/

        НаборУзлов сиданные (T[] значение = пусто)
        {
            if (значение.ptr)
                return ветвь ((Узел узел)
            {
                return узел.значение == значение;
            },
            ПТипУзлаРЯР.СиДанные);
            return ветвь (&всегда, ПТипУзлаРЯР.СиДанные);
        }

        /***************************************************************

                Возвращает набор, содержащий все атрибуты из
                узлов внутри этого набора, сверяя - опциональное- имя.

        ***************************************************************/

        НаборУзлов атрибут (T[] имя = пусто)
        {
            if (имя.ptr)
                return атрибут ((Узел узел)
            {
                return узел.имя == имя;
            });
            return атрибут (&всегда);
        }

        /***************************************************************

                Возвращает набор, содержащий все потомок элементы из
                узлыов внутри этого набора, сверяя заданное имя.

        ***************************************************************/

        НаборУзлов потомок (T[] имя = пусто)
        {
            if (имя.ptr)
                return потомок ((Узел узел)
            {
                return узел.имя == имя;
            });
            return потомок (&всегда);
        }

        /***************************************************************

                Возвращает набор, содержащий все элементы-ветви
                узлов внутри этого набора, сверяя - опционально - имя.

        ***************************************************************/

        НаборУзлов ветвь (T[] имя = пусто)
        {
            if (имя.ptr)
                return ветвь ((Узел узел)
            {
                return узел.имя == имя;
            });
            return  ветвь (&всегда);
        }

        /***************************************************************

                Возвращает набор, содержащий все элементы-предки
                узлов внутри этого набора, сверяя необязательное
                имя.

        ***************************************************************/

        НаборУзлов предок (T[] имя = пусто)
        {
            if (имя.ptr)
                return предок ((Узел узел)
            {
                return узел.имя == имя;
            });
            return предок (&всегда);
        }

        /***************************************************************

                Возвращает набор, содержащий все предыдущие элементы-пасынки
                узлов, находящихся внутри этого набора,  имя - необязательно -
				проверяется.

        ***************************************************************/

        НаборУзлов предш (T[] имя = пусто)
        {
            if (имя.ptr)
                return предш ((Узел узел)
            {
                return узел.имя == имя;
            });
            return предш (&всегда);
        }

        /***************************************************************

                Возвращает набор, содержащий все последующие
                элементы-пасынки узлов внутри этого набора,
                сверяя - опционально -имя.

        ***************************************************************/

        НаборУзлов следщ (T[] имя = пусто)
        {
            if (имя.ptr)
                return следщ ((Узел узел)
            {
                return узел.имя == имя;
            });
            return следщ (&всегда);
        }

        /***************************************************************

                Возвращает набор, содержащий все узлы внутри этого набора,
                пароль которого проверяется тестом.

        ***************************************************************/

        НаборУзлов фильтр (бул delegate(Узел) фильтр)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            foreach (узел; узлы)
            тест (фильтр, узел);
            return установи.присвой (метка);
        }

        /***************************************************************

                Возвращает набор, содержащий все узлы-ветви
                узлов внутри этого набора.

        ***************************************************************/

        НаборУзлов ветвь (бул delegate(Узел) фильтр,
                            ПТипУзлаРЯР тип = ПТипУзлаРЯР.Элемент)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            foreach (родитель; узлы)
            foreach (ветвь; родитель.ветви)
            if (ветвь.ид is тип)
                тест (фильтр, ветвь);
            return установи.присвой (метка);
        }

        /***************************************************************

                Возвращает набор, содержащий все атрибут узлы 
                узлов внутри этого набора.

        ***************************************************************/

        НаборУзлов атрибут (бул delegate(Узел) фильтр)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            foreach (узел; узлы)
            foreach (атр; узел.атрибуты)
            тест (фильтр, атр);
            return установи.присвой (метка);
        }

        /***************************************************************

                Возвращает набор, содержащий все потомок узлы
                узлов внутри этого набора.

        ***************************************************************/

        НаборУзлов потомок (бул delegate(Узел) фильтр,
                            ПТипУзлаРЯР тип = ПТипУзлаРЯР.Элемент)
        {
            проц traverse (Узел родитель)
            {
                foreach (ветвь; родитель.ветви)
                {
                    if (ветвь.ид is тип)
                        тест (фильтр, ветвь);
                    if (ветвь.первОтпрыск)
                        traverse (ветвь);
                }
            }

            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            foreach (узел; узлы)
            traverse (узел);
            return установи.присвой (метка);
        }

        /***************************************************************

                Возвращает набор, содержащий все родитель узлы
                узлов внутри этого набора.

        ***************************************************************/

        НаборУзлов родитель (бул delegate(Узел) фильтр)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            foreach (узел; узлы)
            {
                auto p = узел.родитель;
                if (p && p.ид != ПТипУзлаРЯР.Документ && !установи.имеется(p))
                {
                    тест (фильтр, p);
                    // continually обнови our установи of узлы, so
                    // that установи.имеется() can see a приор Запись.
                    // Ideally we'd avoопр invoking тест() on
                    // приор узлы, but I don't feel the добавьed
                    // complexity is warranted
                    установи.узлы = хост.срез (метка);
                }
            }
            return установи.присвой (метка);
        }

        /***************************************************************

                Возвращает набор, содержащий все предок узлы of
                the узлы внутри этого набора, which пароль the given
                filtering тест

        ***************************************************************/

        НаборУзлов предок (бул delegate(Узел) фильтр)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            проц traverse (Узел ветвь)
            {
                auto p = ветвь.хост;
                if (p && p.ид != ПТипУзлаРЯР.Документ && !установи.имеется(p))
                {
                    тест (фильтр, p);
                    // continually обнови our установи of узлы, so
                    // that установи.имеется() can see a приор Запись.
                    // Ideally we'd avoопр invoking тест() on
                    // приор узлы, but I don't feel the добавьed
                    // complexity is warranted
                    установи.узлы = хост.срез (метка);
                    traverse (p);
                }
            }

            foreach (узел; узлы)
            traverse (узел);
            return установи.присвой (метка);
        }

        /***************************************************************

                Возвращает набор, содержащий все последующие пасынки
                тех, которые внутри этого набора.

        ***************************************************************/

        НаборУзлов следщ (бул delegate(Узел) фильтр,
                            ПТипУзлаРЯР тип = ПТипУзлаРЯР.Элемент)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            foreach (узел; узлы)
            {
                auto p = узел.следщПасынок;
                while (p)
                {
                    if (p.ид is тип)
                        тест (фильтр, p);
                    p = p.следщПасынок;
                }
            }
            return установи.присвой (метка);
        }

        /***************************************************************

                Возвращает набор, содержащий все приор узлы-пасынки
                тех узлов, которые внутри этого набора.

        ***************************************************************/

        НаборУзлов предш (бул delegate(Узел) фильтр,
                            ПТипУзлаРЯР тип = ПТипУзлаРЯР.Элемент)
        {
            НаборУзлов установи = {хост};
            auto метка = хост.метка;

            foreach (узел; узлы)
            {
                auto p = узел.предшПасынок;
                while (p)
                {
                    if (p.ид is тип)
                        тест (фильтр, p);
                    p = p.предшПасынок;
                }
            }
            return установи.присвой (метка);
        }

        /***************************************************************

                Траверсирует по узлам этого набора.

        ***************************************************************/

        цел opApply (цел delegate(ref Узел) дг)
        {
            цел возвр;

            foreach (узел; узлы)
            if ((возвр = дг (узел)) != 0)
                break;
            return возвр;
        }

        /***************************************************************

                Общий предикат

        ***************************************************************/

        private бул всегда (Узел узел)
        {
            return да;
        }

        /***************************************************************

                Присваивает срез фрилиста этому НаборУзлов.

        ***************************************************************/

        private НаборУзлов присвой (бцел метка)
        {
            узлы = хост.срез (метка);
            return *this;
        }

        /***************************************************************

                Выполняет фильтр на данном узле. Дело касается
                потенциальной рекурсии запросов, поэтому
                устанавливает всяческие уловки, 
				чтобы восстановиться из этого.

        ***************************************************************/

        private проц тест (бул delegate(Узел) фильтр, Узел узел)
        {
            auto вынь = хост.сунь;
            auto добавь = фильтр (узел);
            хост.вынь (вынь);
            if (добавь)
                хост.размести (узел);
        }

        /***************************************************************

                Как правило, приходится фильтровать предков по порядку,
                чтобы избежать дубликатов, - это предназначено
				для данной цели.

        ***************************************************************/

        private бул имеется (Узел p)
        {
            foreach (узел; узлы)
            if (узел is p)
                return да;
            return нет;
        }
    }

    /***********************************************************************

            Возвращает текущий индекс фрилиста.

    ***********************************************************************/

    private бцел метка ()
    {
        return фриИндекс;
    }

    /***********************************************************************

            Рекурсирует и сохраняет текущее состояние.

    ***********************************************************************/

    private бцел сунь ()
    {
        ++рекурсия;
        return фриИндекс;
    }

    /***********************************************************************

            Восстанавливает предшествующее состояние.

    ***********************************************************************/

    private проц вынь (бцел приор)
    {
        фриИндекс = приор;
        --рекурсия;
    }

    /***********************************************************************

            Возвращает срез фрилиста.

    ***********************************************************************/

    private Узел[] срез (бцел метка)
    {
        assert (метка <= фриИндекс);
        return фрилист [метка .. фриИндекс];
    }

    /***********************************************************************

            Размещает запись в фрилист, разворачивая, при необходимости.

    ***********************************************************************/

    private бцел размести (Узел узел)
    {
        if (фриИндекс >= фрилист.length)
            фрилист.length = фрилист.length + фрилист.length / 2;

        фрилист[фриИндекс] = узел;
        return ++фриИндекс;
    }
}


version (Old)
{
    /*******************************************************************************

            Спецификация сериализатора XML

    *******************************************************************************/

    interface IXmlPrinter(T)
    {
        public alias Документ!(T) Док;          /// типированный документ
        public alias Док.Узел Узел;             /// узел генерного документа
        public alias выведи opCall;              /// алиас метода выведи

        /***********************************************************************

                Генерирует текст представление дерева документа.

        ***********************************************************************/

        T[] выведи (Док док);

        /***********************************************************************

                Генерирует представление поддерева данного узла.

        ***********************************************************************/

        проц выведи (Узел корень, проц delegate(T[][]...) излей);
    }
}



/*******************************************************************************

*******************************************************************************/

debug (Документ)
{
    import io.Stdout;
    import text.xml.DocPrinter;

    проц main()
    {
        auto док = new Документ!(сим);

        // прикрепи an xml заголовок
        док.заголовок;

        // прикрепи an элемент with some атрибуты, plus
        // a ветвь элемент with an attached данные значение
        док.дерево.элемент   (пусто, "root")
        .атрибут (пусто, "attrib1", "value")
        .атрибут (пусто, "attrib2", "other")
        .элемент   (пусто, "ветвь")
        .сиданные     ("some text");

        // прикрепи a sibling в_ the interior элементы
        док.элементы.элемент (пусто, "sibling");

        бул foo (док.Узел узел)
        {
            узел = узел.атрибуты.имя(пусто, "attrib1");
            return узел && "значение" == узел.значение;
        }

        foreach (узел; док.запрос.потомок("корень").фильтр(&foo).ветвь)
        Стдвыв.форматнс(">> {}", узел.имя);

        foreach (узел; док.элементы.атрибуты)
        Стдвыв.форматнс("<< {}", узел.имя);

        foreach (узел; док.элементы.ветви)
        Стдвыв.форматнс("<< {}", узел.имя);

        foreach (узел; док.запрос.потомок.сиданные)
        Стдвыв.форматнс ("{}: {}", узел.родитель.имя, узел.значение);

        // излей the результат
        auto printer = new ДокПринтер!(сим);
        printer.выведи (док, стдвыв);
        док.сбрось;
    }
}
