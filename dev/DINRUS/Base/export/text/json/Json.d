module text.json.Json;

private import tpl.args;
private import io.model;
private import text.json.JsonEscape;
private import text.json.JsonParser;
private import Плав = text.convert.Float;

/*******************************************************************************

        Разборка текста на джейсон пребразуется в набор взаимосвязанных структур.
		Как правило, используются они следующим образом:
        ---
        auto джейсон = new Джейсон!(сим);
        джейсон.разбор (`{"t": true, "n":null, "array":["world", [4, 5]]}`);    
        ---   

        Для обратного преобразования в текстовый формаи используется делегат.
		Вот так документ выводится в консоль:
        ---
        джейсон.выведи ((ткст s) {Стдвыв(s);}); 
        ---

        Конструирование джейсон внутри кода облегчается наличием ряда фабрик 
        внутри экземпляра документа. В этом примере документ создаётся из 
        массива значений:
        ---
        auto джейсон = new Джейсон!(сим);

        // [да, нет, пусто, "текст"]
        with (джейсон)
              значение = Массив (да, нет, пусто, "текст");
        ---

        Установка документа на единичный объект:
        ---
        // {"a" : 10}
        with (джейсон)
              значение = объект (пара("a", значение(10)));
        ---

        Объекты можно строить с несколькими парами атрибутов:
        ---
        // {"a" : 10, "b" : да}
        with (джейсон)
              значение = объект (пара("a", значение(10)), пара("b", значение(да)));
        ---

        Подстановка массивов, либо других объектов в качетстве значений:
        ---
        // {"a" : [10, да, {"b" : пусто}]}
        with (джейсон)
              значение = объект (пара("a", Массив(10, да, объект(пара("b")))));
        ---

*******************************************************************************/

class Джейсон(T) : private ПарсерДжейсон!(T)
{
                     /// эти типы используются для внешнего обращения
        public alias ЗначениеДжейсон*  Значение;
        public alias ИмяЗначение*  Атрибут;
        public alias ОбъектДжейсон* Композит;

                    /// перечисляет семь принимаемых типов значений JSON
        public enum Тип {Пусто, Строка, НеобрСтрока, Число, Объект, Массив, Да, Нет};

        private Значение корень;

        /***********************************************************************
        
                Конструирует экземпляр джейсон, с дефолтным значением пусто.

        ***********************************************************************/
        
        this ()
        {
                массивы.length = 16;
                разбор (пусто);
        }

        /***********************************************************************
        
                Разбирает данный текст и возвращает результирующий тип значения.
                Также устанавливает значение документа. 

        ***********************************************************************/
        
        final Значение разбор (T[] джейсон)
        {
                гнездование = 0;
                атриб.сбрось;
                значения.сбрось;
                объекты.сбрось;
                foreach (ref p; массивы)
                         p.индекс = 0;

                корень = создайЗначение;
                if (super.сбрось (джейсон))
                    if (текТип is Токен.НачниОбъект)
                        корень.установи (разбериОбъект);
                    else
                       if (текТип is Токен.НачниМассив)
                           корень.установи (разбериМассив);
                       else
                          исключение ("непригодный документ джейсон");

                return корень;
        }

        /***********************************************************************
        
                Возвращает текстовое представление этого документа.

        ***********************************************************************/

        final T[] вТкст (T[] разделитель = пусто)
        {
                return корень.выведи (разделитель);
        }

        /***********************************************************************
        
                Возвращает значение корня этого документа.

        ***********************************************************************/
        
        final Значение значение ()
        {
                return корень;
        }

        /***********************************************************************
        
                Устанавливает значение корня этого документа.

        ***********************************************************************/
        
        final Значение значение (Значение знач)
        {
                return корень = знач;
        }

        /***********************************************************************
        
                Создаёт текстовое значение.

        ***********************************************************************/
        
        final Значение значение (T[] знач)
        {
                return создайЗначение.установи (знач);
        }

        /***********************************************************************
        
                Создаёт булево значение.

        ***********************************************************************/
        
        final Значение значение (бул знач)
        {
                return создайЗначение.установи (знач);
        }

        /***********************************************************************
        
                Создаёт числовое значение.

        ***********************************************************************/
        
        final Значение значение (дво знач)
        {
                return создайЗначение.установи (знач);
        }

         /***********************************************************************
         
                 Создаёт единичное значение из массива значений.

         ***********************************************************************/

         final Значение значение (Значение[] значч)
         {
                 return создайЗначение.установи (значч);
         }

        /***********************************************************************
        
                Создаёт массив значений.

        ***********************************************************************/

        final Значение массив (...)
        {
                return создайЗначение.установи (this, _arguments, _argptr);
        }

        /***********************************************************************
        
                Создаёт пару атрибут/значение, где дефолты значений установлены в 
                пусто.

        ***********************************************************************/
        
        Атрибут пара (T[] имя, Значение значение = пусто)
        {
                if (значение is пусто)
                    значение = создайЗначение;
                return создайАтрибут.установи (имя, значение);
        }

        /***********************************************************************
        
                Создаёт композит из ноль и более пар, и возвращает его как 
                значение.

        ***********************************************************************/
        
        final Значение объект (Атрибут установи[]...)
        {
                return создайЗначение.установи (создайОбъект.добавь (установи));
        }

        /***********************************************************************
        
                Внутренняя фабрика для создания значений.

        ***********************************************************************/
        
        private Значение создайЗначение ()
        {
                return значения.размести.сбрось;
        }

        /***********************************************************************
        
                Внутренняя фабрика для создания композитов.

        ***********************************************************************/
        
        private Композит создайОбъект ()
        {
                return объекты.размести.сбрось;
        }

        /***********************************************************************
        
                Внутренняя фабрика для создания атрибутов.

        ***********************************************************************/
       
        private Атрибут создайАтрибут ()
        {
                return атриб.размести;
        }

        /***********************************************************************
        
                Выводит генерное исключение.

        ***********************************************************************/
        
        private проц исключение (ткст сооб)
        {
                throw new Исключение (сооб);
        }

        /***********************************************************************
        
                Парсирует экземпляр значения.

        ***********************************************************************/
        
        private Значение разбериЗначение ()
        {
                auto знач = значения.размести;

                switch (super.текТип)
                       {
                       case Токен.Да:
                            знач.установи (Тип.Да);
                            break;

                       case Токен.Нет:
                            знач.установи (Тип.Нет);
                            break;

                       case Токен.Пусто:
                            знач.установи (Тип.Пусто);
                            break;

                       case Токен.НачниОбъект:
                            знач.установи (разбериОбъект);
                            break;

                       case Токен.НачниМассив:
                            знач.установи (разбериМассив);
                            break;

                       case Токен.Строка:
                            знач.установи (super.значение, да);
                            break;

                       case Токен.Число:
                            знач.установи (Плав.разбор (super.значение));
                            break;

                       default:
                            знач.установи (Тип.Пусто);
                            break;
                       }

                return знач;
        }

        /***********************************************************************
        
                Парсирует декларацию объекта.

        ***********************************************************************/
        
        private Композит разбериОбъект ()
        {
                auto o = объекты.размести.сбрось;

                while (super.следщ) 
                      {
                      if (super.текТип is Токен.ЗавершиОбъект)
                          return o;

                      if (super.текТип != Токен.Имя)
                          super.ожидалось ("имя атрибута", super.стр.ptr);
                        
                      auto имя = super.значение;
                        
                      if (! super.следщ)
                            super.ожидалось ("значение атрибута", super.стр.ptr);
                        
                      o.добавь (атриб.размести.установи (имя, разбериЗначение));
                      }

                return o;
        }
        
        /***********************************************************************
        
                Парсирует декларацию массива.

        ***********************************************************************/
        
        private Значение[] разбериМассив ()
        {
                if (гнездование >= массивы.length)
                    исключение ("массив внедрён слишком глубоко в документ");

                auto массив = &массивы[гнездование++];
                auto старт = массив.индекс;

                while (super.следщ && super.текТип != Токен.ЗавершиМассив) 
                      {
                      if (массив.индекс >= массив.контент.length)
                          массив.контент.length = массив.контент.length + 300;

                      массив.контент [массив.индекс++] = разбериЗначение;
                      }

                if (super.текТип != Токен.ЗавершиМассив)
                    исключение ("массив неправильной формы");

                --гнездование;
                return массив.контент [старт .. массив.индекс];
        }

        /***********************************************************************
        
                Представляет пару атрибут/значение.

        ***********************************************************************/
        
        struct ИмяЗначение
        {
                private Атрибут       следщ;
                public  T[]             имя;
                public  Значение           значение;

                /***************************************************************
        
                        Устанавливает имя и значение для этого атрибута.

                        Возвращает себя, для использования с Композит.добавь()

                ***************************************************************/
        
                Атрибут установи (T[] ключ, Значение знач)
                {
                        имя = ключ;
                        значение = знач;
                        return this;
                }
        }

        /***********************************************************************

                Представляет единичный объект джейсон (композит из именованной 
                пары атрибут/значение).
                
        ***********************************************************************/
        
        struct ОбъектДжейсон
        {
                private Атрибут голова,
                                  хвост;
                
                /***************************************************************
        
                ***************************************************************/
        
                Композит сбрось ()
                {
                        голова = хвост = пусто;
                        return this;
                }

                /***************************************************************
        
                        Добавляет пару атрибут/значение.

                ***************************************************************/
        
                Композит добавь (Атрибут a)
                {
                        if (хвост)
                            хвост.следщ = a, хвост = a;
                        else
                           голова = хвост = a;
                        return this;
                }

                /***************************************************************
        
                        Добавляет набор пар атрибут/значение.

                ***************************************************************/
        
                Композит добавь (Атрибут[] установи...)
                {
                        foreach (атр; установи)
                                 добавь (атр);
                        return this;
                }

                /***************************************************************
                        
                        Конструирует и возвращает хэшкарту атрибутов объекта.
                        This will be a fairly costly operation, so consider 
                        alternatives where appropriate

                ***************************************************************/
        
                Значение[T[]] хэшкарта ()
                {
                        Значение[T[]] члены;

                        auto a = голова;
                        while (a)
                              {
                              члены[a.имя] = a.значение;
                              a = a.следщ;
                              }

                        return члены;
                }
        
                /***************************************************************
        
                        Возвращает соответствующее значение для заданного имени 
                        атрибута. Выполняет линейный поиск по набору атрибутов.

                ***************************************************************/
        
                Значение значение (T[] имя)
                {
                        auto a = голова;
                        while (a)
                               if (имя == a.имя)
                                   return a.значение;
                               else
                                  a = a.следщ;

                        return пусто;
                }
        
                /***************************************************************
        
                        Итерирует по именам и значениям наших атрибутов.

                ***************************************************************/
        
                Обходчик атрибуты ()
                {
                        Обходчик i = {голова};
                        return i;
                }

                /***************************************************************
        
                        Итерирует по именам нашего атрибута. 
						
                ***************************************************************/
        
                static struct Обходчик
                {
                        private Атрибут голова;
        
                        цел opApply (цел delegate(ref T[] ключ, ref Значение знач) дг)
                        {
                                цел рез;
        
                                auto a = голова;
                                while (a)
                                      {
                                      if ((рез = дг (a.имя, a.значение)) != 0) 
                                           break;
                                      a = a.следщ;
                                      }
                               return рез;
                        }
                }
        }
        
        /***********************************************************************
        
                Представляет джейсон значение, одного из семи типов, 
                определённых в перчне Джейсон.Тип 

        ***********************************************************************/
        
        struct ЗначениеДжейсон
        {
                private union
                {
                        Значение[]         Массив;
                        реал            число;
                        T[]             ткст;
                        Композит       объект;
                }
        
                public Тип тип;               /// тип этого узла
                alias сбрось установи;                /// альтернативное имя для сбрось

                /***************************************************************
        
                        Возвращает да, если этот узел указанного типа.

                ***************************************************************/
        
                бул opEquals (Тип t) 
                {
                        return тип is t;
                }
                
                /***************************************************************
        
                        Возвращает да, если это значение представляет Да.

                ***************************************************************/
        
                бул вБул ()
                {
                        return (тип is Тип.Да);
                }

                /***************************************************************
                        
                        Возвращает ткст контент. Возвращает пусто, если это
                        значение не ткст.

                        приёмн при необходимости используется для преобразования искейпа.

                ***************************************************************/
        
                T[] вТкст (T[] приёмн = пусто)
                {
                        if (тип is Тип.НеобрСтрока)
                            return ткст;

                        if (тип is Тип.Строка)
                            return убериИскейп (ткст, приёмн);

                        return пусто;
                }
                
                /***************************************************************
        
                        Эмитировать ткст контент заданному делегату, с
                        преобразованием искейпа по необходимости.

                        Возвращает нет, если это не строковое значение.
                      
                ***************************************************************/
        
                бул вТкст (проц delegate(T[]) дг)
                {
                        if (тип is Тип.НеобрСтрока)
                            дг(ткст);
                        else
                           if (тип is Тип.Строка)
                               убериИскейп (ткст, дг);
                           else
                              return нет;
                        return да;
                }

                /***************************************************************
        
                        Возвращает контент как Композит/Объект. Возвращает пусто,
                        если это значение не Композит.

                ***************************************************************/
        
                Композит вОбъект ()
                {
                        return тип is Тип.Объект ? объект : пусто;
                }
                
                /***************************************************************
        
                        Возвращает контент как дво. Возвращает нч, где
                        значение не является числовым.

                ***************************************************************/
        
                реал вЧисло ()
                {
                        return тип is Тип.Число ? число : реал.nan;
                }
                
                /***************************************************************
        
                        Возвращает контент как Массив. Возвращает пусто, когда
                        значение не является массивом.

                ***************************************************************/
        
                Значение[] вМассив ()
                {
                        return (тип is Тип.Массив) ? Массив : пусто;
                }
                
                /***************************************************************
        
                        Устанавливает это значение для представления ткста. Если
						установлено 'эскапирован', полагается, что этот ткст 
						имеет пред-преобразованый искейпинг зарезервированных
						символов (таких как \t).

                ***************************************************************/
        
                Значение установи (T[] стр, бул эскапирован = нет)
                {
                        тип = эскапирован ? Тип.Строка : Тип.НеобрСтрока;
                        ткст = стр;
                        return this;
                }
                
                /***************************************************************
        
                        Устанавливает это значение для представления объекта.

                ***************************************************************/
        
                Значение установи (Композит об)
                {
                        тип = Тип.Объект;
                        объект = об;
                        return this;
                }
                
                /***************************************************************
        
                        Устанавливает это значение для представления числа.

                ***************************************************************/
        
                Значение установи (реал чис)
                {
                        тип = Тип.Число;
                        число = чис;
                        return this;
                }
                
                /***************************************************************
        
                        Устанавливает это значение для представления булево.

                ***************************************************************/
        
                Значение установи (бул b)
                {
                        тип = b ? Тип.Да : Тип.Нет;             
                        return this;
                }
                
                /***************************************************************
        
                        Устанавливает это значение для представления массива значений.

                ***************************************************************/
        
                Значение установи (Значение[] a)
                {
                        тип = Тип.Массив;
                        Массив = a;
                        return this;
                }
                
                /***************************************************************
        
                        Устанавливает это значение для представления пусто.

                ***************************************************************/
        
                Значение сбрось ()
                {
                        тип = Тип.Пусто;
                        return this;
                }
                
                /***************************************************************
        
                        Возвращает текст представление этого значения

                ***************************************************************/

                T[] выведи (T[] разделитель = пусто)
                {
                        T[] врем;
                        проц добавь (T[] s) {врем ~= s;}
                        выведи (&добавь, разделитель);
                        return врем;
                }

                /***************************************************************
        
                        Эмитировать текстовое представление этого значения в 
                        заданный ИПотокВывода.

                ***************************************************************/

                Значение выведи (ИПотокВывода s, T[] разделитель = пусто)
                {
                        return выведи ((T[] t){s.пиши(t);}, разделитель);
                }

                /***************************************************************
                        
                        Эмитировать текстовое представление этого значения в 
                        заданный делегат.

                ***************************************************************/
                
                Значение выведи (проц delegate(T[]) добавь, T[] разделитель = пусто)
                {
                        auto indent = 0;
        
                        проц нс ()
                        {
                                if (разделитель.length)
                                   {
                                   добавь ("\n");
                                   for (auto i=0; i < indent; i++)
                                        добавь (разделитель);
                                   }
                        }
        
                        проц printValue (Значение знач)
                        {
                                проц printObject (Композит об)
                                {
                                        if (об is пусто) 
                                            return;
                                        
                                        бул первый = да;
                                        добавь ("{");
                                        indent++;
        
                                        foreach (ключ, знач; об.атрибуты)
                                                {
                                                if (!первый)  
                                                     добавь (",");
                                                нс;
                                                добавь (`"`), добавь(ключ), добавь(`":`);
                                                printValue (знач);
                                                первый = нет;
                                                }
                                        indent--;
                                        нс;
                                        добавь ("}");
                                }
                                
                                проц printArray (Значение[] масс)
                                {
                                        бул первый = да;
                                        добавь ("[");
                                        indent++;
                                        foreach (знач; масс)
                                                {
                                                if (!первый) 
                                                     добавь (", ");
                                                нс;
                                                printValue (знач);
                                                первый = нет;
                                                }
                                        indent--;
                                        нс;
                                        добавь ("]");
                                }
        
        
                                if (знач is пусто) 
                                    return;
                                
                                switch (знач.тип)
                                       {
                                       T[64] врем =void;
        
                                       case Тип.Строка:
                                            добавь (`"`), добавь(знач.ткст), добавь(`"`);
                                            break;
        
                                       case Тип.НеобрСтрока:
                                            добавь (`"`), искейп(знач.ткст, добавь), добавь(`"`);
                                            break;
        
                                       case Тип.Число:
                                            добавь (Плав.форматируй (врем, знач.вЧисло));
                                            break;
        
                                       case Тип.Объект:
                                            auto об = знач.вОбъект;
                                            debug assert(об !is пусто);
                                            printObject (знач.вОбъект);
                                            break;
        
                                       case Тип.Массив:
                                            printArray (знач.вМассив);
                                            break;
        
                                       case Тип.Да:
                                            добавь ("true");
                                            break;
        
                                       case Тип.Нет:
                                            добавь ("false");
                                            break;
        
                                       default:
                                       case Тип.Пусто:
                                            добавь ("n");
                                            break;
                                       }
                        }
                        
                        printValue (this);
                        return this;
                }

                /***************************************************************
        
                        Устанавливает в указанный тип.

                ***************************************************************/
        
                private Значение установи (Тип тип)
                {
                        this.тип = тип;
                        return this;
                }

                /***************************************************************
        
                        Устанавливает различные значения в тип массив.

                ***************************************************************/
        
                private Значение установи (Джейсон хост, ИнфОТипе[] инфо, спис_ва арги)
                {
                        Значение[] список;

                        foreach (тип; инфо)
                                {
                                Значение знач;
                                if (тип is typeid(Значение))
                                    знач = ва_арг!(Значение)(арги);
                                else
                                   {
                                   знач = хост.создайЗначение;
                                   if (тип is typeid(дво))
                                       знач.установи (ва_арг!(дво)(арги));
                                   else
                                   if (тип is typeid(цел))
                                       знач.установи (ва_арг!(цел)(арги));
                                   else
                                   if (тип is typeid(бул))
                                       знач.установи (ва_арг!(бул)(арги));
                                   else
                                   if (тип is typeid(дол))
                                       знач.установи (ва_арг!(дол)(арги));
                                   else
                                   if (тип is typeid(Композит))
                                       знач.установи (ва_арг!(Композит)(арги));
                                   else
                                   if (тип is typeid(T[]))
                                       знач.установи (ва_арг!(T[])(арги));
                                   else
                                   if (тип is typeid(ук))
                                       ва_арг!(ук)(арги);
                                   else
                                      хост.исключение ("ЗначениеДжейсон.установи :: неожиданный тип: "~тип.вТкст);
                                   }
                                список ~= знач;
                                }
                        return установи (список);
                }
        }

        /***********************************************************************
        
                Внутренний механизм размещения

        ***********************************************************************/
        
        private struct Разместитель(T)
        {
                private T[]     список;
                private T[][]   списки;
                private цел     индекс,
                                блок;

                проц сбрось ()
                {
                        // discard since приор списки are not инициализован
                        списки.length = 0;       
                        блок = -1;
                        новый_список;
                }

                T* размести ()
                {
                        if (индекс >= список.length)
                            новый_список;
        
                        auto p = &список [индекс++];
                        return p;
                }
        
                private проц новый_список ()
                {
                        индекс = 0;
                        if (++блок >= списки.length)
                           {
                           списки.length = списки.length + 1;
                           списки[$-1] = new T[256];
                           }
                        список = списки [блок];
                }
        }

        /***********************************************************************
            
                Используется внутренне для парсинга значений массива.
                    
        ***********************************************************************/
        
        private struct Массив
        {
                бцел            индекс;
                Значение[]         контент;
        }

        /***********************************************************************
        
                Внутреннее представление документа.

        ***********************************************************************/
        
        private alias Разместитель!(ИмяЗначение)     Атриб;
        private alias Разместитель!(ЗначениеДжейсон)     Значения;
        private alias Разместитель!(ОбъектДжейсон)    Объекты;

        private Атриб                          атриб;
        private Значения                          значения;
        private Массив[]                         массивы;
        private Объекты                         объекты;
        private бцел                            гнездование;
}



/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{
        unittest
        {
        with (new Джейсон!(сим))
             {
             корень = объект
                  (
                  пара ("edgar", значение("friendly")),
                  пара ("счёт", значение(11.5)),
                  пара ("Массив", значение(массив(1, 2)))
                  );

             ткст значение = вТкст();
             assert (значение == `{"edgar":"friendly","счёт":11.5,"массив":[1, 2]}`, значение);
             }
        }
        
        unittest
        {
        // проверь with a разделитель of the tab character
        with (new Джейсон!(сим))
             {
             корень = объект
                  (
                  пара ("edgar", значение("friendly")),
                  пара ("счёт", значение(11.5)),
                  пара ("Массив", значение(Массив(1, 2)))
                  );

             ткст значение = вТкст ("\t");
             assert (значение == "{\n\t\"edgar\":\"friendly\",\n\t\"счёт\":11.5,\n\t\"Массив\":[\n\t\t1, \n\t\t2\n\t]\n}", значение);
             }
        }
        
        unittest
        {
        // проверь with a разделитель of five пробелы
        with (new Джейсон!(дим))
             {
             корень = объект
                  ( 
                  пара ("edgar", значение("friendly")),
                  пара ("счёт", значение(11.5)),
                  пара ("Массив", значение(массив(1, 2)))
                  );

             дим[] значение = вТкст ("     ");
             assert (значение == "{\n     \"edgar\":\"friendly\",\n     \"счёт\":11.5,\n     \"массив\":[\n          1, \n          2\n     ]\n}");
             }
        }
}
        
/*******************************************************************************

*******************************************************************************/

debug (Джейсон)
{
        import io.Stdout;
        import io.device.File;
        import time.StopWatch;
                
        проц main()
        {
                проц loop (ПарсерДжейсон!(сим) парсер, ткст джейсон, цел n)
                {
                        for (бцел i = 0; i < n; ++i)
                            {
                            парсер.сбрось (джейсон);
                            while (парсер.следщ) {}
                            }
                }
        
                проц тест (ткст имяф, ткст txt)
                {
                        бцел n = (300 * 1024 * 1024) / txt.length;
                        auto парсер = new ПарсерДжейсон!(сим);
                        
                        Секундомер watch;
                        watch.старт;
                        loop (парсер, txt, n);
                        auto t = watch.стоп;
                        auto mb = (txt.length * n) / (1024 * 1024);
                        Стдвыв.форматнс("{} {} итераций, {} сек: {} МБ/с", имяф, n, t, mb/t);
                }
        
                проц test1 (ткст имяф, ткст txt)
                {
                        бцел n = (200 * 1024 * 1024) / txt.length;
                        auto парсер = new Джейсон!(сим);
                        
                        Секундомер watch;
                        watch.старт;
                        for (бцел i = 0; i < n; ++i)
                             парсер.разбор (txt);
        
                        auto t = watch.стоп;
                        auto mb = (txt.length * n) / (1024 * 1024);
                        Стдвыв.форматнс("{} {} итераций, {} сек: {} МБ/с", имяф, n, t, mb/t);
                }
        
                ткст загрузи (ткст файл)
                {
                        return cast(ткст) Файл.получи(файл);
                }
        
                //тест("test1.джейсон", загрузи("test1.джейсон"));
                //тест("test2.джейсон", загрузи("test2.джейсон"));
                //тест("test3.джейсон", загрузи("test3.джейсон"));
                        
                //test1("test1.джейсон", загрузи("test1.джейсон"));
                //test1("test2.джейсон", загрузи("test2.джейсон"));
                //test1("test3.джейсон", загрузи("test3.джейсон"));
                
                auto p = new Джейсон!(сим);
                auto знач = p.разбор (`{"t": да, "f":нет, "n":пусто, "hi":["world", "big", 123, [4, 5, ["foo"]]]}`);       
                Стдвыв.форматнс ("{}", p.вТкст);
        
                with (p)
                      значение = объект(пара("a", массив(пусто, да, нет, 30, объект(пара("foo")))), пара("b", значение(10)));
        
                Стдвыв.форматнс ("{}", p.вТкст);

                p.разбор ("[-1]");
                Стдвыв.форматнс ("{}", p.вТкст);

                p.разбор(`["foo"]`);
                Стдвыв.форматнс ("{}", p.вТкст);

                p.разбор(`{"foo": {"ff" : "ffff"}`);
                Стдвыв.форматнс ("{}", p.вТкст);

                with (new Джейсон!(сим))
                     {
                     корень = объект(пара("массив", массив(пусто)));
                     Стдвыв.форматнс ("{}", вТкст());
                     }
        }
}



