module text.json.JsonEscape;

private import text.json.JsonParser;

private import Утил = text.convert.Float;

private import Утф = text.convert.Utf;

/******************************************************************************

        Преобразует 'эскапированные' символы в нормальные. Например: \\ => \

        Предоставленный буфер вывода должен, как минимум, быть не меньше
        вводимого ткст, либо же он будет размещён из кучи.

        Возвращает срез приёмн, когда контент требует преобразования,
        или иначе предоставленный ист.

******************************************************************************/

T[] убериИскейп(T) (T[] ист, T[] приёмн = пусто)
{
    т_мера контент;

    проц добавь (T[] s)
    {
        if (контент + s.length > приёмн.length)
            приёмн.length = приёмн.length + s.length + 1024;
        приёмн[контент .. контент+s.length] = s;
        контент += s.length;
    }

    убериИскейп (ист, &добавь);
    return приёмн [0 .. контент];
}


/******************************************************************************

        Преобразует зарезервированные символы в эскапированные. Например: \ => \\

        Возвращается либо срез из предоставленного буфера вывода, либо
        оригинальный контент, в зависимости от наличия зарезервированных символов.
		Буфер вывода при необходимости расширяется.

******************************************************************************/

T[] искейп(T) (T[] ист, T[] приёмн = пусто)
{
    т_мера контент;

    проц добавь (T[] s)
    {
        if (контент + s.length > приёмн.length)
            приёмн.length = приёмн.length + s.length + 1024;
        приёмн[контент .. контент+s.length] = s;
        контент += s.length;
    }

    искейп (ист, &добавь);
    return приёмн [0..контент];
}


/******************************************************************************

        Преобразует 'эскапированные' символы в нормальные. Например: \\ => \

        Этот вариант не требует an interim workspace, и вместо этого
        выводится прямо с помощью предоставленного делегата.
		
******************************************************************************/

проц убериИскейп(T) (T[] ист, проц delegate(T[]) излей)
{
    цел дельта;
    auto s = ист.ptr;
    auto длин = ист.length;
    enum:T {слэш = '\\'};

    // проверим первый на наличие чего-нибудь
    if ((дельта = Утил.индексУ (s, слэш, длин)) < длин)
    {
        // копируем сегменты, чанк за раз
        do
        {
            излей (s[0 .. дельта]);
            длин -= дельта;
            s += дельта;

            // bogus trailing '\'
            if (длин < 2)
            {
                излей ("\\");
                длин = 0;
                break;
            }

            // translate \c
            switch (s[1])
            {
            case '\\':
                излей ("\\");
                break;

            case '/':
                излей ("/");
                break;

            case '"':
                излей (`"`);
                            break;

                            case 'b':
                            излей ("\b");
                            break;

                            case 'f':
                            излей ("\f");
                            break;

                            case 'n':
                            излей ("\n");
                            break;

                            case 'r':
                            излей ("\r");
                            break;

                            case 't':
                            излей ("\t");
                            break;

                            case 'u':
                            if (длин < 6)
                            goto default;
                            else
                        {
                            дим знач = 0;
                            T[6]  t =void;

                            for (auto i=2; i < 6; ++i)
                        {
                            auto c = s[i];
                            if (c >= '0' && c <= '9')
                        {}
                            else
                            if (c >= 'a' && c <= 'f')
                            c -= 39;
                            else
                            if (c >= 'A' && c <= 'F')
                            c -= 7;
                            else
                            goto default;
                            знач = (знач << 4) + c - '0';
                        }

                            излей (Утф.изТкст32 ((&знач)[0..1], t));
                            длин -= 4;
                            s += 4;
                        }
                            break;

                            default:
                            throw new Исключение ("непригодный искейп");
                        }

                            s += 2;
                            длин -= 2;
                        } while ((дельта = Утил.индексУ (s, слэш, длин)) < длин);

                            // копируй хвост too
                            излей (s [0 .. длин]);
                        }
                            else
                            излей (ист);
                        }


                            /******************************************************************************

                            Преобразует зарезервированные символы в эскапированные. Например: \ => \\

							Этот вариант не требует an interim workspace, и вместо этого
							выводится прямо с помощью предоставленного делегата.

                            ******************************************************************************/

                            проц искейп(T) (T[] ист, проц delegate(T[]) излей)
                        {
                            T[2] патч = '\\';
                            auto s = ист.ptr;
                            auto t = s;
                            auto e = s + ист.length;

                            while (s < e)
                        {
                            switch (*s)
                        {
                            case '"':
                            case '/':
                            case '\\':
                            патч[1] = *s;
                            break;
                            case '\r':
                            патч[1] = 'r';
                            break;
                            case '\n':
                            патч[1] = 'n';
                            break;
                            case '\t':
                            патч[1] = 't';
                            break;
                            case '\b':
                            патч[1] = 'b';
                            break;
                            case '\f':
                            патч[1] = 'f';
                            break;
                            default:
                            ++s;
                            continue;
                        }
                            излей (t [0 .. s - t]);
                            излей (патч);
                            t = ++s;
                        }

                            // dопр we change anything? Copy хвост also
                            if (t is ист.ptr)
                            излей (ист);
                            else
                            излей (t [0 .. e - t]);
                        }


                            /******************************************************************************

                            ******************************************************************************/

                            debug (JsonEscape)
                        {
                            import io.Stdout;

                            проц main()
                        {
                            искейп ("abc");
                            assert (искейп ("abc") == "abc");
                            assert (искейп ("/abc") == `\/abc`, искейп ("/abc"));
                            assert (искейп ("ab\\c") == `ab\\c`, искейп ("ab\\c"));
                            assert (искейп ("abc\"") == `abc\"`);
                            assert (искейп ("abc/") == `abc\/`);
                            assert (искейп ("\n\t\r\b\f") == `\n\t\r\b\f`);

                            убериИскейп ("abc");
                            убериИскейп ("abc\\u0020x", (ткст p){Стдвыв(p);});
                            assert (убериИскейп ("abc") == "abc");
                            assert (убериИскейп ("abc\\") == "abc\\");
                            assert (убериИскейп ("abc\\t") == "abc\t");
                            assert (убериИскейп ("abc\\tc") == "abc\tc");
                            assert (убериИскейп ("\\t") == "\t");
                            assert (убериИскейп ("\\tx") == "\tx");
                            assert (убериИскейп ("\\r\\rx") == "\r\rx");
                            assert (убериИскейп ("abc\\t\\n\\bc") == "abc\t\n\bc");

                            assert (убериИскейп ("abc\"\\n\\bc") == "abc\"\n\bc");
                            assert (убериИскейп ("abc\\u002bx") == "abc+x");
                        }

                        }

