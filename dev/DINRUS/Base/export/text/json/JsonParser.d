module text.json.JsonParser;

private import col.Stack;

/*******************************************************************************

*******************************************************************************/

class ПарсерДжейсон(T)
{
        public enum Токен
               {
               Пустой, Имя, Строка, Число, НачниОбъект, ЗавершиОбъект, 
               НачниМассив, ЗавершиМассив, Да, Нет, Пусто
               }

        private enum Состояние {Объект, Массив};

        private struct Обходчик
        {
                T*      ptr;
                T*      конец;
                T[]     текст;

                проц сбрось (T[] текст)
                {
                        this.текст = текст;
                        this.ptr = текст.ptr;
                        this.конец = ptr + текст.length;
                }
        }

        protected Обходчик              стр;
        private Стэк!(Состояние, 16)       состояние;
        private T*                      текЛок;
        private цел                     текДлин;
        private Состояние                   текСост; 
        protected Токен                 текТип;
        
        /***********************************************************************
        
        ***********************************************************************/
        
        this (T[] текст = пусто)
        {
                сбрось (текст);
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        final бул следщ ()
        {
                auto п = стр.ptr;
                auto e = стр.конец;

                while (*п <= 32 && п < e) 
                       ++п; 

                if ((стр.ptr = п) >= e) 
                     return нет;

                if (текСост is Состояние.Массив) 
                    return разборЗначенияМассива;

                switch (текТип)
                       {
                       case Токен.Имя:
                            return разборЗначенияЧлена;

                       default:                
                            break;
                       }

                return разборИмениЧлена;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        final Токен тип ()
        {
                return текТип;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        final T[] значение ()
        {
                return текЛок [0 .. текДлин];
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        бул сбрось (T[] джейсон = пусто)
        {
                состояние.очисть;
                стр.сбрось (джейсон);
                текТип = Токен.Пустой;
                текСост = Состояние.Объект;

                if (джейсон.length)
                   {
                   auto п = стр.ptr;
                   auto e = стр.конец;

                   while (*п <= 32 && п < e) 
                          ++п; 
                   if (п < e)
                       return старт (*(стр.ptr = п));
                   }
                return нет;
        }

        /***********************************************************************
        
        ***********************************************************************/
        
        protected final проц ожидалось (ткст токен)
        {
                throw new Исключение ("ожидалось " ~ токен);
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        protected final проц ожидалось (ткст токен, T* точка)
        {
                static ткст itoa (ткст буф, цел i)
                {
                        auto п = буф.ptr+буф.length;
                        do {
                           *--п = '0' + i % 10;
                           } while (i /= 10);
                        return п[0..(буф.ptr+буф.length)-п];
                }
                сим[16] врем =void;
                ожидалось (токен ~ " @ввод[" ~ itoa(врем, точка-стр.текст.ptr)~"]");
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private проц неожиданныйКФ (ткст сооб)
        {
                throw new Исключение ("неожиданный конец ввода: " ~ сооб);
        }
                
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул старт (T c)
        {
                if (c is '{') 
                    return сунь (Токен.НачниОбъект, Состояние.Объект);

                if (c is '[') 
                    return сунь (Токен.НачниМассив, Состояние.Массив);

                ожидалось ("'{' или '[' в начале документа");
        }

        /***********************************************************************
        
        ***********************************************************************/
        
        private бул разборИмениЧлена ()
        {
                auto п = стр.ptr;
                auto e = стр.конец;

                if(*п is '}') 
                    return вынь (Токен.ЗавершиОбъект);
                
                if(*п is ',') 
                    ++п;
                
                while (*п <= 32) 
                       ++п;

                if (*п != '"')
                    if (*п == '}')
                        ожидалось ("имя атрибута после (потенциальный трейлинг) ','", п);
                    else
                       ожидалось ("'\"' перед именем атрибута", п);

                текЛок = п+1;
                текТип = Токен.Имя;

                while (++п < e) 
                       if (*п is '"' && !эскапирован(п))
                           break;

                if (п < e) 
                    текДлин = п - текЛок;
                else
                   неожиданныйКФ ("в имени атрибута");

                стр.ptr = п + 1;
                return да;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул разборЗначенияЧлена ()
        {
                auto п = стр.ptr;

                if(*п != ':') 
                   ожидалось ("':' перед значением атрибута", п);

                auto e = стр.конец;
                while (++п < e && *п <= 32) {}

                return разбериЗначение (*(стр.ptr = п));
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул разбериЗначение (T c)
        {                       
                switch (c)
                       {
                       case '{':
                            return сунь (Токен.НачниОбъект, Состояние.Объект);
         
                       case '[':
                            return сунь (Токен.НачниМассив, Состояние.Массив);
        
                       case '"':
                            return делайТкст;
        
                       case 'n':
                            if (сверь ("null", Токен.Пусто))
                                return да;
                            ожидалось ("'null'", стр.ptr);

                       case 't':
                            if (сверь ("true", Токен.Да))
                                return да;
                            ожидалось ("'true'", стр.ptr);

                       case 'f':
                            if (сверь ("false", Токен.Нет))
                                return да;
                            ожидалось ("'false'", стр.ptr);

                       default:
                            break;
                       }

                return parseNumber;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул делайТкст ()
        {
                auto п = стр.ptr;
                auto e = стр.конец;

                текЛок = п+1;
                текТип = Токен.Строка;
                
                while (++п < e) 
                       if (*п is '"' && !эскапирован(п))
                           break;

                if (п < e) 
                    текДлин = п - текЛок;
                else
                   неожиданныйКФ ("в ткст");

                стр.ptr = п + 1;
                return да;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул parseNumber ()
        {
                auto п = стр.ptr;
                auto e = стр.конец;
                auto c = *(текЛок = п);

                текТип = Токен.Число;

                if (c is '-' || c is '+')
                    c = *++п;

                while (c >= '0' && c <= '9') c = *++п;                 

                if (c is '.')
                    while (c = *++п, c >= '0' && c <= '9') {}                 

                if (c is 'e' || c is 'Е')
                    while (c = *++п, c >= '0' && c <= '9') {}

                if (п < e) 
                    текДлин = п - текЛок;
                else
                   неожиданныйКФ ("после числа");

                стр.ptr = п;
                return текДлин > 0;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул сверь (T[] имя, Токен токен)
        {
                auto i = имя.length;
                if (стр.ptr[0 .. i] == имя)
                   {
                   текЛок = стр.ptr;
                   текТип = токен;
                   стр.ptr += i;
                   текДлин = i;
                   return да;
                   }
                return нет;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул сунь (Токен токен, Состояние следщ)
        {
                текДлин = 0;
                текТип = токен;
                текЛок = стр.ptr++;
                состояние.сунь (текСост);
                текСост = следщ;
                return да;
        }
        
        /***********************************************************************
        
        ***********************************************************************/
        
        private бул вынь (Токен токен)
        {
                текДлин = 0;
                текТип = токен;
                текЛок = стр.ptr++;
                текСост = состояние.вынь;
                return да;
        }

        /***********************************************************************
        
        ***********************************************************************/
        
        private бул разборЗначенияМассива ()
        {
                auto п = стр.ptr;
                if (*п is ']') 
                    return вынь (Токен.ЗавершиМассив);
                
                if (*п is ',') 
                    ++п;

                auto e = стр.конец;
                while (п < e && *п <= 32) 
                       ++п;

                return разбериЗначение (*(стр.ptr = п));
        }

        /***********************************************************************
        
        ***********************************************************************/
        
        private цел эскапирован (T* п)
        {
                цел i;

                while (*--п is '\\')
                       ++i;
                return i & 1;
        }
}



debug(UnitTest)
{       
                const static ткст джейсон = 
                "{"
                        "\"glossary\": {"
                        "\"title\": \"example glossary\","
                                "\"GlossDiv\": {"
                                " 	\"title\": \"S\","
                                "	\"GlossList\": {"
                                "       \"GlossEntry\": {"
                                "           \"ID\": \"SGML\","
                                "			\"SortAs\": \"SGML\","
                                "			\"GlossTerm\": \"Standard Generalized Markup Language\","
                                "			\"Acronym\": \"SGML\","
                                "			\"Abbrev\": \"ISO 8879:1986\","
                                "			\"GlossDef\": {"
                        "                \"para\": \"A meta-markup language, used to create markup languages such as DocBook.\","
                                "				\"GlossSeeAlso\": [\"GML\", \"XML\"]"
                        "            },"
                                "			\"GlossSee\": \"markup\","
                                "			\"ANumber\": 12345.6e7"
                                "			\"True\": true"
                                "			\"False\": false"
                                "			\"Null\": null"
                        "        }"
                                "    }"
                        "}"
                    "}"
                "}";
       
unittest
{
        auto п = new ПарсерДжейсон!(сим)(джейсон);
        assert(п);
        assert(п.тип == п.Токен.НачниОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "glossary", п.значение);
        assert(п.следщ);
        assert(п.значение == "", п.значение);
        assert(п.тип == п.Токен.НачниОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "title", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "example glossary", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "GlossDiv", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.НачниОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "титул", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "S", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "GlossList", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.НачниОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "GlossEntry", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.НачниОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "ID", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "SGML", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "SortAs", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "SGML", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "GlossTerm", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "Standard Generalized Markup Language", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "Acronym", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "SGML", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "Abbrev", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "ISO 8879:1986", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "GlossDef", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.НачниОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "para", п.значение);
        assert(п.следщ);

        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "A meta-markup language, used to create markup languages such as DocBook.", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "GlossSeeAlso", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.НачниМассив);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "GML", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "XML", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.ЗавершиМассив);
        assert(п.следщ);
        assert(п.тип == п.Токен.ЗавершиОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "GlossSee", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Строка);
        assert(п.значение == "markup", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "ANumber", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Число);
        assert(п.значение == "12345.6e7", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "True", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Да);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "False", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Нет);
        assert(п.следщ);
        assert(п.тип == п.Токен.Имя);
        assert(п.значение == "Null", п.значение);
        assert(п.следщ);
        assert(п.тип == п.Токен.Пусто);
        assert(п.следщ);
        assert(п.тип == п.Токен.ЗавершиОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.ЗавершиОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.ЗавершиОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.ЗавершиОбъект);
        assert(п.следщ);
        assert(п.тип == п.Токен.ЗавершиОбъект);
        assert(!п.следщ);

        assert(п.состояние.размер == 0);

}

}


debug (ПарсерДжейсон)
{
        проц main()
        {
                auto джейсон = new ПарсерДжейсон!(сим);
        }
}

