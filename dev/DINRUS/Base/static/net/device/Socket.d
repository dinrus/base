
module net.device.Socket;

public import io.device.Conduit, net.device.Berkeley;
import exception;

/*******************************************************************************

        Обёртка Беркли API, реализующая абстракцию ИПровод 
        и добавляющая потокоспецифичную функциональность.

*******************************************************************************/

class Сокет : Провод, ИВыбираемый
{
        public alias исконный сокет;             // обратная совместимость

        private НаборСокетов pending;              // синхронные таймауты   
        private Беркли  беркли;             // обёртка беркли сокета


        /// см. super.таймаут(цел)
        deprecated проц установиТаймаут (дво t) 
        {
                таймаут = cast(бцел) (t * 1000);
        }

        deprecated бул былТаймаут ()
        {
                return нет;
        }

        /***********************************************************************
        
                Создать Стриминговый Интернет сокет.

        ***********************************************************************/

        this ()
        {
                this (ПСемействоАдресов.ИНЕТ, ПТипСок.Поток, ППротокол.ПУТ);
        }

		
		/***********************************************************************
        
                Создать Интернет сокет.

        ***********************************************************************/

        this (ПСемействоАдресов семейство, ПТипСок тип, ППротокол протокол)
        {
                беркли.открой (семейство, тип, протокол);
                version (Windows)
                         if (планировщик)
                             планировщик.открой (фукз, вТкст);
        }
		
        /***********************************************************************
        
                Создать Интернет Сокет с заданными характеристиками.

        ***********************************************************************/

        this (Адрес адр) 
        { 
                this (адр.семействоАдресов, ПТипСок.Поток, ППротокол.ПУТ); 
        }
                                


        /***********************************************************************

                Ворнуть имя данного устройства.

        ***********************************************************************/

        override ткст вТкст()
        {
                return "<сокет>";
        }

        /***********************************************************************

                Моделирует устройство, ориентированное на указатель. 

                TODO: выяснить как избежать выставления его в общих случаях.

        ***********************************************************************/

        Дескр фукз ()
        {
                return cast(Дескр) беркли.сок;
        }

        /***********************************************************************

                Возвращает обмотчик данного сокета.
                
        ***********************************************************************/

        Беркли* исконный ()
        {
                return &беркли;
        }

        /***********************************************************************

                Возвращает предпочитаемый размер для буферирующего провода I/O.

        ***********************************************************************/

        override т_мера размерБуфера ()
        {
                return 1024 * 8;
        }

        /***********************************************************************

                Подключиться к предоставленной конечной точке.
        
        ***********************************************************************/

        Сокет подключись (ткст адрес, бцел порт)
        {
                scope адр = new АдресИПв4 (адрес, порт);
                return подключись (адр);
        }

        /***********************************************************************

               Подключиться к предоставленной конечной точке.
        
        ***********************************************************************/

        Сокет подключись (Адрес адр)
        {
                if (планировщик)
                    асинхСвязь (адр);
                else
                   исконный.подключись (адр);
                return this;
        }

        /***********************************************************************

               Привязать данный сокет. Как правило, это делается для конфигурирования
                слушающего сокета (такого как сервер или мультикастный сокет).
                Заданный адрес должен описывать местный адаптер, или
                назначать отдельный порт (АДР_ЛЮБОЙ) , чтобы иметь адрес локального
                адаптера ОС.
        
        ***********************************************************************/

        Сокет вяжи (Адрес адрес)
        {
                беркли.вяжи (адрес);
                return this;
        }

        /***********************************************************************

                Информирует другой край о том, что подключенный сокет более не
                доступен. В общем, этот метод вызывается перед закрой()
        
                Функция "глуши" обрывает соединение сокета: 

                    -   останавливает приём данных с этого сокета. Если есть ещё данные,
                        они отвергаются.

                    -   останавливает попытку передачи данныех с этого сокета. Также
                        откидывает все данные, ждущие отправки. Перестаёт искать 
                        подтверждения уже отправленных даных; не переотправляет, 
                        если есть потерянные данные.

        ***********************************************************************/

        Сокет глуши ()
        {
                беркли.глуши (ПЭкстрЗакрытиеСокета.Всё);
                return this;
        }

        /***********************************************************************

                Освободить данный Сокет

                Заметьте, что следует всегда отключать Сокет в 
                нормальных условиях, и, как правило, вызывать глуши на всех 
                подключенных СОКЕТах до этого.

        ***********************************************************************/

        override проц открепи ()
        {
                беркли.открепи;
        }
        
       /***********************************************************************

                Читать контент из сокета. Заметьте, у операции может быть 
                таймаут (просрочка), если метод установиТаймаут() вызывался с 
                ненулевым значением.

                Возвращает число считанных из этого сокета байтов, или
                ИПровод.Кф , если контента больше нет.

        ***********************************************************************/

        override т_мера читай (проц[] приёмн)
        {
                if (планировщик)
                    return асинхЧтение (приёмн);

                auto x = Кф;
                if (жди (да))
                   {
                   x = исконный.принять (приёмн);
                   if (x <= 0)
                       x = Кф;
                   }
                return x;                        
        }
        
        /***********************************************************************

        ***********************************************************************/

        override т_мера пиши (проц[] ист)
        {
                if (планировщик)
                    return асинхЗапись (ист);

                auto x = Кф;
                if (жди (нет))
                   {
                   x = исконный.шли (ист);
                   if (x < 0)
                       x = Кф;
                   }
                return x;                        
        }

        /***********************************************************************

                Передать контент из другого провода в этот. Возвращает
                приёмн ИПотокВывода, или при неуспехе выводит ВВИскл.

                Трансферты оптимизированы. 

        ***********************************************************************/

        override ИПотокВывода копируй (ИПотокВвода ист, т_мера max = -1)
        {
                auto x = cast(ИВыбираемый) ист;

                if (планировщик && x)
                    асинхКопия (x.фукз);
                else
                   super.копируй (ист, max);
                return this;
        }

        /***********************************************************************
 
                Управление сокет IO при таймауте

        ***********************************************************************/

        package final бул жди (бул reading)
        {
                // активировал ли пользователь проверки таймаута?
                if (таймаут != -1)
                   {
                   НаборСокетов читай, пиши;

                   // да, проверим есть ли у нас НаборСокетов
                   if (pending is пусто)
                       pending = new НаборСокетов (1);
                   pending.сбрось.добавь (исконный.сок);

                   // ждём пока IO станет доступен, или таймаут хапнет
                   if (reading)
                       читай = pending;
                   else
                      пиши = pending;
                   цел i = pending.выбери (читай, пиши, пусто, таймаут * 1000);
                   if (i <= 0)
                      {
                      if (i is 0)
                          super.ошибка ("Сокет :: запрос таймаута");
                      return нет;
                      }
                   }       
                return да;
        }

        /***********************************************************************

                Ввести ВВИскл, отмечающий последнюю ошибку.
        
        ***********************************************************************/

        final проц ошибка ()
        {
                super.ошибка (this.вТкст ~ " :: " ~ СисОш.последнСооб);
        }

        /***********************************************************************
 
        ***********************************************************************/

        version (Win32)
        {
                private АСИНХРОН оверлап;
        
                /***************************************************************
        
                        Подключиться к предоставленной конечной точке.
                
                ***************************************************************/
        
                private проц асинхСвязь (Адрес адр)
                {
                        АдресИПв4.сокадр_ин local;
        
                        auto укз = беркли.сок;
                        net.device.Berkeley.свяжисок(cast(СОКЕТ) укз, cast(адрессок*)&local, local.sizeof);
        
                        ConnectEx (укз, адр.имя, адр.длинаИмени, пусто, 0, пусто, &оверлап);
                        жди (планировщик.Тип.Подключение);
                        патч (укз, SO_UPDATE_CONNECT_CONTEXT);
                }
        
                /***************************************************************
        
                ***************************************************************/
        
                private проц асинхКопия (Дескр укз)
                {
                        TransmitFile (беркли.сок, cast(HANDLE) укз, 
                                      0, 0, &оверлап, пусто, 0);
                        if (жди (планировщик.Тип.Трансфер) is Кф)
                            беркли.исключение ("Сокет.копируй :: ");
                }

                /***************************************************************

                        Читать чанк байтов из файла, преобразованный в указанный
                        Массив. Возвращает число считанных байтов, или Кф, когда 
                        данных больше нет.

                        Оперирует асинхронно, когда хостинговый поток (нить)
                        сконфигурирован в этой манере.

                ***************************************************************/

                private т_мера асинхЧтение (проц[] приёмн)
                {
                        бцел флаги;
                        бцел байты;
                        ВИНСОКБУФ буф = {приёмн.length, приёмн.ptr};

                        sys.WinFuncs.ВСАПрими (cast(HANDLE) беркли.сок, &буф, 1, &байты, &флаги, &оверлап, пусто);
                        if ((байты = жди (планировщик.Тип.Чтение, байты)) is Кф)
                             return Кф;

                        // читай of zero means Кф
                        if (байты is 0 && приёмн.length > 0)
                            return Кф;
                        return байты;
                }

                /***************************************************************

                        Записать чанк байтов в файл, из предоставленного
                        Массива. Возвращает число записанных байтов, или Кф, если 
                        вывод более недоступен.

                       Оперирует асинхронно, когда хостинговый поток (нить)
                       сконфигурирован в этой манере.

                ***************************************************************/

                private т_мера асинхЗапись (проц[] ист)
                {
                        бцел байты;
                        ВИНСОКБУФ буф = {ист.length, ист.ptr};

                        ВСАШли (cast(HANDLE) беркли.сок, &буф, 1, &байты, 0, &оверлап, пусто);
                        if ((байты = жди (планировщик.Тип.Запись, байты)) is Кф)
                             return Кф;
                        return байты;
                }

                /***************************************************************

                ***************************************************************/

                private т_мера жди (планировщик.Тип тип, бцел байты=0)
                {
                        while (да)
                              {
                              auto код = ВСАДайПоследнююОшибку;
                              if (код is ПОшибка.ОшибкаУкКонцаФайла ||
                                  код is ПОшибка.РазорванныйПайп)
                                  return Кф;

                              if (планировщик)
                                 {
                                 if (код is ПОшибка.Успех || 
                                     код is ПОшибка.ОжидаетсяВВ || 
                                     код is ПОшибка.НеполныйВВ)
                                    {
                                    бцел флаги;

                                    if (код is ПОшибка.НеполныйВВ)
                                        super.ошибка ("таймаут"); 

                                    auto укз = фукз;
                                    планировщик.ожидай (укз, тип, таймаут);
                                    if (ВСАДайАсинхрРезультат (укз, &оверлап, &байты, нет, &флаги))
                                        return байты;
                                    }
                                 else
                                    ошибка;
                                 }
                              else
                                 if (код is ПОшибка.Успех)
                                     return байты;
                                 else
                                    ошибка;
                              }
                        // should never получи here
                        assert (нет);
                }
        
                /***************************************************************
        
                ***************************************************************/
        
                private static проц патч (т_сокет приёмн, бцел как, т_сокет* ист=пусто)
                {
                        auto длин = ист ? ист.sizeof : 0;
                        if (net.device.Berkeley.установиопцсок (приёмн, ППротокол.СОКЕТ, как, ист, длин))
                            беркли.исключение ("патч :: ");
                }
        }


        /***********************************************************************
 
        ***********************************************************************/

        version (Posix)
        {
        
                private проц асинхСвязь (Адрес адр)
                {
                        assert (нет);
                }
        
      
                Сокет асинхКопия (Дескр файл)
                {
                        assert (нет);
                }

                private т_мера асинхЧтение (проц[] приёмн)
                {
                        assert (нет);
                }

                private т_мера асинхЗапись (проц[] ист)
                {
                        assert (нет);
                }
        }
}



/*******************************************************************************


*******************************************************************************/

class СерверСокет : Сокет
{      
        /***********************************************************************

        ***********************************************************************/

        this (бцел порт, цел backlog=32, бул reuse=нет)
        {
                scope адр = new АдресИПв4 (cast(бкрат) порт);
                this (адр, backlog, reuse);
        }

        /***********************************************************************

        ***********************************************************************/

        this (Адрес адр, цел backlog=32, бул reuse=нет)
        {
                super (адр);
                беркли.повторнИспАдреса(reuse).вяжи(адр).слушай(backlog);
        }

        /***********************************************************************

                Возвращает имя этого устройства.

        ***********************************************************************/

        override ткст вТкст()
        {
                return "<прими>";
        }

        /***********************************************************************

        ***********************************************************************/

        Сокет прими (Сокет реципиент = пусто)
        {
                if (реципиент is пусто)
                    реципиент = new Сокет;

                if (планировщик)
                    asyncAccept (реципиент);
                else              
                   беркли.прими (реципиент.беркли);
                
                реципиент.таймаут = таймаут;
                return реципиент;
        }

        /***********************************************************************

        ***********************************************************************/

        version (Windows)
        {
                /***************************************************************

                ***************************************************************/

                private проц asyncAccept (Сокет реципиент)
                {
                        байт[128]      врем;
                        бцел          байты;
                        бцел          флаги;

                        auto мишень = реципиент.беркли.сок;
                        AcceptEx (беркли.сок, мишень, врем.ptr, 0, 64, 64, &байты, &оверлап);
                        жди (планировщик.Тип.Приём);
                        патч (мишень, SO_UPDATE_ACCEPT_CONTEXT, &беркли.сок);
                }
        }

        /***********************************************************************

        ***********************************************************************/

        version (Posix)
        {
                /***************************************************************

                ***************************************************************/

                private проц asyncAccept (Сокет реципиент)
                {
                        assert (нет);
                }
        }
}