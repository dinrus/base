module net.device.Berkeley;

public import sys.common;
private import exception;
private import stringz;

version (Windows)
{
//import sys.win32.WsaSock;
struct Гуид
{
    бцел     g1;
    бкрат   g2,
             g3;
    ббайт[8] g4;
}

enum
{
    WSADESCRIPTION_LEN = 256,
    WSASYS_STATUS_LEN = 128,
    WSAEWOULDBLOCK =  10035,
    WSAEINTR =        10004,
}

enum
{
    SIO_GET_EXTENSION_FUNCTION_POINTER = 0x40000000 | 0x80000000 | 0x08000000 | 6,
    SO_UPDATE_CONNECT_CONTEXT = 0x7010,
    SO_UPDATE_ACCEPT_CONTEXT = 0x700B
}
//Эти функции руссифицированы и импортируются из Dinrus.Base.dll:
		 
	//цел ВСАСтарт(крат требВерсия, ВИНСОКДАН* всадан);
	//= int WSAStartup(WORD wVersionRequested, ВИНСОКДАН* lpWSAData);
	
	//цел ВСАЧистка();
	//= int WSACleanup();
	
	//цел ВСАДайПоследнююОшибку();
	//= int WSAGetLastError ();
	
//А эти требуется доработать и поместить в ДинрусБейс.
//Пока же мы их импортируем из вспомогательной статической либы (import.биб):

}

extern(C)
{
    т_мера длинтекс(in ткст0 текст);// strlen из модуля cidrus

	бкрат х8сбк(бкрат x);	//htons
	бцел х8сбц(бцел x);//htonl
	бкрат с8хбк(бкрат x);//ntohs
	бцел с8хбц(бцел x);//ntohl

	проц УД_УДАЛИ(СОКЕТ уд, набор_уд* набор);
	цел УД_УСТАНОВЛЕН(СОКЕТ уд, набор_уд* набор);
	проц УД_УСТАНОВИ(СОКЕТ уд, набор_уд* набор);
	проц УД_ОБНУЛИ(набор_уд* набор);
	
	СОКЕТ сокет(ПСемействоАдресов са, ПТипСок тип, ППротокол протокол);
	цел ввктлсок(СОКЕТ с, цел кмд, бцел* аргук);
	цел свяжисок(СОКЕТ с, адрессок* имя, цел длинаим);
	цел подключи(СОКЕТ с, адрессок* имя, цел длиннаим);		
	цел слушай(СОКЕТ с, цел бэклог);
	СОКЕТ пусти(СОКЕТ с, адрессок* адр, цел *длинадр);		
	цел закройсок(СОКЕТ с);	
	цел экстрзак(СОКЕТ с, ПЭкстрЗакрытиеСокета как);	
	цел дайимяпира(СОКЕТ с, адрессок* имя,  цел * длинаим);
	цел дайимясок(СОКЕТ с, адрессок* адр,  цел * длинаим);
	цел шли(СОКЕТ с, ук буф, цел длин, ПФлагиСокета флаги);
	цел шли_на(СОКЕТ с, ук буф, цел длин, ПФлагиСокета флаги, адрессок* кому, цел длинаприём);
	цел прими(СОКЕТ с, ук буф, цел длин, ПФлагиСокета флаги);
	цел прими_от(СОКЕТ с, ук буф, цел длин, ПФлагиСокета флаги, адрессок* от_кого,  цел* длинаистока);
	цел дайопцсок(СОКЕТ с, цел уровень, цел имяопц, ук значопц,  цел* длинаопц);
	цел установиопцсок(СОКЕТ с, цел уровень, цел имяопц, ук значопц, цел длинаопц);		
	бцел адр_инет(ткст т);	
	цел выбери(цел нуд, набор_уд* читнуд, набор_уд* запнуд, набор_уд* ошнуд, значврем* таймаут);
	ткст инетс8а(адрес_ин иа);	
	хостзап* дайхостпоимени(ткст имя);	
	хостзап* дайхостпоадресу(ук адр, цел длин, цел тип);		
	протзап* дайпротпоимени(ткст имя);	
	протзап* дайпротпономеру(цел номер);
	служзап* дайслужбупоимени(ткст имя, ткст протокол);
	служзап* дайслужбупопорту(цел порт, ткст протокол);		
	цел дайимяхоста(ткст имя, цел длинаим);	
	//цел дайадринфо(ткст имяузла, ткст имяслуж, адринфо* хинты, адринфо** рез);		
	//проц высвободиадринфо(адринфо* аи);	
	//цел дайинфобимени(адрессок* ас, т_длинсок длинсок, ткст хост, бцел длинхост, ткст серв, бцел длинсерв, ПИмИнфо флаги);
	
}

alias закройсок закрой;
alias выбери сделвыб;

 /**
* При указанных узле и службе, которые идентифицируют Интернет-хост 
* и любую службу, getAddrinfo() возвращает одну или более структуру ИнфОбАдре,
* каждая из которых содержит Интернет-адрес, который можно указать в вызове,
* для связи или подключения. 
* Функция getAddrinfo() комбинирует функционал, предоставленный функциями
* "дайслужбупоимени" и "дайслужбупопорту" в единый интерфейс, но, в отличие от них,
* getAddrinfo() реэнтрантна и позволяет программам обходить зависимости
* между  ИПv4 и ИПv6.
 */
 цел function(сим* узел, сим* служба, Адрес.ИнфОбАдре* хинты, Адрес.ИнфОбАдре** рез) getAddrinfo;
        
/**
* Функция freeAddrinfo() освобождает память, размещённую для динамически добавляемого
* в память линкованного списка результатов.
*/								
проц function(Адрес.ИнфОбАдре *рез) freeAddrinfo; 
								
/**
* Функция getnameinfo() инверсия getAddrinfo: она преобразует адрес сокета
* в соответствующие  хост и службу, в независимой от протокола манере.
*/
цел function(Адрес.адрессок* sa, цел salen, сим* хост, цел hostlen, сим* serv, цел servlen, цел флаги) getnameinfo; 
				
бул function (т_сокет, бцел, ук, DWORD, DWORD, DWORD, DWORD*, АСИНХРОН*) AcceptEx;
бул function (т_сокет, HANDLE, DWORD, DWORD, АСИНХРОН*, ук, DWORD) TransmitFile;
бул function (т_сокет, ук, цел, ук, DWORD, DWORD*, АСИНХРОН*) ConnectEx;
								
//сим* inet_ntop(цел af, проц *ист, сим *приёмн, цел длин);       

        private HMODULE биб;


        static this()
        {
                биб = ЗагрузиБиблиотекуА ("Ws2_32.dll");
                getnameinfo = cast(typeof(getnameinfo)) ДайАдресПроц(биб, "getnameinfo");
                if (!getnameinfo) 
                   { 
                   ОсвободиБиблиотеку (биб);
                   биб = ЗагрузиБиблиотекуА ("Wship6.dll");
                   } 
                getnameinfo = cast(typeof(getnameinfo)) ДайАдресПроц(биб, "getnameinfo"); 
	        getAddrinfo = cast(typeof(getAddrinfo)) ДайАдресПроц(биб, "getAddrinfo"); 
                freeAddrinfo = cast(typeof(freeAddrinfo)) ДайАдресПроц(биб, "freeAddrinfo"); 
                if (!getnameinfo) 
                   { 
                   ОсвободиБиблиотеку (биб);
                   биб = пусто;
                   } 

                ВИНСОКДАН wd =void;
                if (ВСАСтарт (0x0202, &wd))
                    throw new СокетИскл("версия библиотеки сокетов весьма устарела");

                DWORD результат;
                Гуид acceptG   = {0xb5367df1, 0xcbac, 0x11cf, [0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92]};
                Гуид connectG  = {0x25a207b9, 0xddf3, 0x4660, [0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e]};
                Гуид transmitG = {0xb5367df0, 0xcbac, 0x11cf, [0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92]};

                auto s = cast(HANDLE) сокет (ПСемействоАдресов.ИНЕТ, ПТипСок.Поток, ППротокол.ПУТ);
                assert (s != cast(HANDLE) -1);
								
                ВСАВВКонтрл (s, SIO_GET_EXTENSION_FUNCTION_POINTER, 
                          &connectG, connectG.sizeof, &ConnectEx, 
                          ConnectEx.sizeof, &результат, пусто, пусто);

                ВСАВВКонтрл (s, SIO_GET_EXTENSION_FUNCTION_POINTER, 
                          &acceptG, acceptG.sizeof, &AcceptEx, 
                          AcceptEx.sizeof, &результат, пусто, пусто);

                ВСАВВКонтрл (s, SIO_GET_EXTENSION_FUNCTION_POINTER, 
                          &transmitG, transmitG.sizeof, &TransmitFile, 
                          TransmitFile.sizeof, &результат, пусто, пусто);
                закройсок (cast(т_сокет) s);
        }

        static ~this()
        {
                if (биб)
                    ОсвободиБиблиотеку (биб);
                ВСАЧистка();
        }

/*******************************************************************************

*******************************************************************************/

public struct Беркли
{
        т_сокет        сок;
        ПТипСок      тип;
        ПСемействоАдресов   семейство;
        ППротокол    протокол;
version (Windows)
         бул           синхронно;

        enum : т_сокет 
        {
                НЕВЕРНСОК = т_сокет.init
        }
        
        enum 
        {
                Ошибка = -1
        }

        alias Ошибка        ОШИБКА;               // backward compatibility
        alias безЗаминки      установиБезЗаминки;          // backward compatibility
        alias повторнИспАдреса установиПовторнИспАдреса;     // backward compatibility
        

        /***********************************************************************

                Configure this экземпляр

        ***********************************************************************/

        проц открой (ПСемействоАдресов семейство, ПТипСок тип, ППротокол протокол, бул создай=да)
        {
                this.тип = тип;
                this.семейство = семейство;
                this.протокол = протокол;
                if (создай)
                    переоткрой;
        }

        /***********************************************************************

                Открыть/переоткрой a исконный сокет for this экземпляр

        ***********************************************************************/

        проц переоткрой (т_сокет сок = сок.init)
        {
                if (this.сок != сок.init)
                    this.открепи;

                if (сок is сок.init)
                   {
                   сок = cast(т_сокет) сокет (семейство, тип, протокол);
                   if (сок is сок.init)
                       исключение ("Не удалось создать сокет: ");
                   }

                this.сок = сок;
        }

        /***********************************************************************

                calling экстрзак() перед this is recommended for connection-
                oriented СОКЕТs

        ***********************************************************************/

        проц открепи ()
        {
                if (сок != сок.init)
                    .закрой (сок);
                сок = сок.init;
        }

        /***********************************************************************

                Return the underlying OS укз of this Провод

        ***********************************************************************/

        т_сокет укз ()
        {
                return сок;
        }

        /***********************************************************************

                Return сокет ошибка статус

        ***********************************************************************/

        цел ошибка ()
        {
                цел errcode;
                дайОпцию (ППротокол.СОКЕТ, ПОпцияСокета.Ошибка, (&errcode)[0..1]);
                return errcode;
        }

        /***********************************************************************

                Return the последний ошибка

        ***********************************************************************/

        static цел последнОшиб ()
        {
                version (Win32)
                         return ВСАДайПоследнююОшибку();
                   else
                      return errno;
        }

        /***********************************************************************

                Is this сокет still alive? A закрыт сокет is consопрered куда
                be dead, but a экстрзак сокет is still alive.

        ***********************************************************************/

        бул жив_ли ()
        {
                цел тип, разм_типа = тип.sizeof;
                return дайопцсок (сок, ППротокол.СОКЕТ,
                                   ПОпцияСокета.Тип, cast(сим*) &тип,
                                   &разм_типа) != Ошибка;
        }

        /***********************************************************************

        ***********************************************************************/

        ПСемействоАдресов семействоАдресов ()
        {
                return семейство;
        }

        /***********************************************************************

        ***********************************************************************/

        Беркли* вяжи (Адрес адр)
        {
                if(Ошибка == .свяжисок (cast(СОКЕТ) сок, cast(адрессок*) адр.имя, адр.длинаИмени))
                   исключение ("Не удалась привязка сокета: ");
                return this;
        }

        /***********************************************************************

        ***********************************************************************/

        Беркли* подключись (Адрес куда)
        {
                if (Ошибка == .подключи (cast(СОКЕТ) сок, cast(адрессок*) куда.имя, куда.длинаИмени))
                   {
                   if (! блокируется)
                      {
                      auto err = последнОшиб;
                      version (Windows)
                              {
                              if (err is WSAEWOULDBLOCK)
                                  return this;
                              }
                           else
                              {
                              if (err is EINPROGRESS)
                                  return this;
                              }
                      }
                   исключение ("Не удалось подключить сокет: ");
                   }
                return this;
        }

        /***********************************************************************

                need куда вяжи() первый

        ***********************************************************************/

        Беркли* слушай (цел backlog)
        {
                if (Ошибка == .слушай (сок, backlog))
                    исключение ("Не удалось прослушивание сокета: ");
                return this;
        }

        /***********************************************************************

                need куда вяжи() первый

        ***********************************************************************/

        проц прими (ref Беркли мишень)
        {
                auto newsock = .пусти (cast(СОКЕТ) сок, пусто, пусто); 
                if (т_сокет.init is newsock)
                    исключение ("Не удалось принять подключение к сокету: ");

                мишень.переоткрой (cast(т_сокет) newsock);
                мишень.протокол = протокол;            //same протокол
                мишень.семейство = семейство;                //same семейство
                мишень.тип = тип;                    //same тип
        }

        /***********************************************************************

                The экстрзак function shuts down the connection of the сокет.
                Depending on the аргумент значение, it will:

                    -   stop receiving данные for this сокет. If further данные
                        arrives, it is rejected.

                    -   stop trying куда transmit данные из_ this сокет. Also
                        discards any данные waiting куда be sent. Стоп looking for
                        acknowledgement of данные already sent; don't retransmit
                        if any данные is lost.

        ***********************************************************************/

        Беркли* глуши (ПЭкстрЗакрытиеСокета как)
        {
                .экстрзак (сок, как);
                return this;
        }

        /***********************************************************************

                установи заминка таймаут

        ***********************************************************************/

        Беркли* заминка (цел период)
        {
                version (Win32)
                         alias бкрат атр;
                   else
                       alias бцел атр;

                union заминка
                {
                        struct {
                               атр вкл;            // опция on/off
                               атр время;           // заминка время
                               };
                        атр[2] массив;                  // combined
                }

                заминка l;
                l.вкл = 1;                          // опция on/off
                l.время = cast(бкрат) период;       // заминка время

                return установиОпцию (ППротокол.СОКЕТ, ПОпцияСокета.Заминка, l.массив);
        }

        /***********************************************************************

                активируй/disable адрес reuse

        ***********************************************************************/

        Беркли* повторнИспАдреса (бул включен)
        {
                цел[1] x = включен;
                return установиОпцию (ППротокол.СОКЕТ, ПОпцияСокета.ПереиспАдр, x);
        }

        /***********************************************************************

                активируй/disable безЗаминки опция (nagle)

        ***********************************************************************/

        Беркли* безЗаминки (бул включен)
        {
                цел[1] x = включен;
                return установиОпцию (ППротокол.ПУТ, ПОпцияСокета.ПУТБезЗадержек, x);
        }

        /***********************************************************************

                Helper function куда укз the добавим и dropping of группа
                membershИП.

        ***********************************************************************/

        проц включиВГруппу (АдресИПв4 адрес, бул onOff)
        {
                assert (адрес, "Сокет.включиВГруппу :: пустой адрес непригоден");

                struct ИП_mreq
                {
                бцел  imr_multiAddr;  /* ИП multicast адрес of группа */
                бцел  imr_interface;  /* local ИП адрес of interface */
                };

                ИП_mreq mrq;

                auto опция = (onOff) ? ПОпцияСокета.ИПВГруппу : ПОпцияСокета.ИПИзГруппы;
                mrq.imr_interface = 0;
                mrq.imr_multiAddr = адрес.син.адрИС;

                if (.установиопцсок(сок, ППротокол.ИП, опция, &mrq, mrq.sizeof) == Ошибка)
                    исключение ("Не удалось выполнить мультикастное объединение: ");
        }

        /***********************************************************************

        ***********************************************************************/

        Адрес новОбъектСемейства ()
        {
                if (семейство is ПСемействоАдресов.ИНЕТ)
                   return new АдресИПв4;
                if (семейство is ПСемействоАдресов.ИНЕТ6)
		    return new АдресИПв6;
                return new НеизвестныйАдрес;
        }

        /***********************************************************************

                return the имя_хоста

        ***********************************************************************/

        static ткст имяХоста ()
        {
                сим[64] имя;

                if(Ошибка == .дайимяхоста (имя, имя.length))
                   исключение ("Не удаётся получить имя хоста: ");
                return имя [0 .. длинтекс(имя.ptr)].dup;
        }

        /***********************************************************************

                return the default хост адрес (ИПv4)

        ***********************************************************************/

        static бцел адресХоста ()
        {
                auto ih = new НетХост;
                ih.дайХостПоИмени (имяХоста);
                assert (ih.АдрСписок.length);
                return ih.АдрСписок[0];
        }

        /***********************************************************************

                return the remote адрес of the текущ connection (ИПv4)

        ***********************************************************************/

        Адрес удалённыйАдрес ()
        {
                auto адр = новОбъектСемейства;
                auto длинаИмени = адр.длинаИмени;
                if(Ошибка == .дайимяпира (cast(СОКЕТ) сок, cast(адрессок*) адр.имя, &длинаИмени))
                   исключение ("Не удаётся получить адрес удалённого сокета: ");
                assert (адр.семействоАдресов is семейство);
                return адр;
        }

        /***********************************************************************

                return the local адрес of the текущ connection (ИПv4)

        ***********************************************************************/

        Адрес локальныйАдрес ()
        {
                auto адр = новОбъектСемейства;
                auto длинаИмени = адр.длинаИмени;
                if(Ошибка == .дайимясок (cast(СОКЕТ) сок, cast(адрессок*) адр.имя, &длинаИмени))
                   исключение ("Не удаётся получить адрес локального сокета: ");
                assert (адр.семействоАдресов is семейство);
                return адр;
        }

        /***********************************************************************

                Отправка данные on the connection. Возвращает the число of байты 
                actually sent, либо ОШИБКА on failure. If the сокет is блокируется 
                и there is no буфер пространство лево, шли waits.

                Возвращает число of байты actually sent, либо -1 on ошибка

        ***********************************************************************/

        цел шли (проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {       
                if (буф.length is 0)
                    return 0;

                version (Posix)
                        {
                        auto возвр = .шли (сок, буф.ptr, буф.length, 
                                          ПФлагиСокета.БезСигнала + cast(ПФлагиСокета) флаги);
                        if (errno is EPIPE)
                            возвр = -1;
                        return возвр;
                        }
                     else
                        return .шли (cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета) флаги);
        }

        /***********************************************************************

                Отправка данные куда a specific приёмник адрес. If the 
                приёмник адрес is not specified, a connection 
                must have been made и that адрес is использован. If the 
                сокет is блокируется и there is no буфер пространство лево, 
                отправь_на waits.

        ***********************************************************************/

        цел отправь_на (проц[] буф, ПФлагиСокета флаги, Адрес куда)
        {
                return отправь_на (буф, cast(цел) флаги, куда.имя, куда.длинаИмени);
        }

        /***********************************************************************

                описано ранее

        ***********************************************************************/

        цел отправь_на (проц[] буф, Адрес куда)
        {
                return отправь_на (буф, ПФлагиСокета.Неук, куда);
        }

        /***********************************************************************

                описано ранее - assumes you подключись()ed

        ***********************************************************************/

        цел отправь_на (проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                return отправь_на (буф, cast(цел) флаги, пусто, 0);
        }

        /***********************************************************************

                Отправка данные куда a specific приёмник адрес. If the 
                приёмник адрес is not specified, a connection 
                must have been made и that адрес is использован. If the 
                сокет is блокируется и there is no буфер пространство лево, 
                отправь_на waits.

        ***********************************************************************/

        private цел отправь_на (проц[] буф, цел флаги, Адрес.адрессок* куда, цел длин)
        {
                if (буф.length is 0)
                    return 0;

                version (Posix)
                        {
                        auto возвр = .шли_на (cast(СОКЕТ) сок, буф.ptr, буф.length, 
                                            флаги | ПФлагиСокета.БезСигнала, cast(адрессок*) куда, длин);
                        if (errno is EPIPE)
                            возвр = -1;
                        return возвр;
                        }
                     else
                        return .шли_на (cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета) флаги, cast(адрессок*) куда, длин);
        }

        /***********************************************************************
                принять данные on the connection. Возвращает the число of 
                байты actually Приёмd, 0 if the remote sопрe имеется закрыт 
                the connection, либо ОШИБКА on failure. If the сокет is блокируется, 
                принять waits until there is данные куда be Приёмd.
                
                Возвращает число of байты actually Приёмd, 0 on connection 
                closure, либо -1 on ошибка

        ***********************************************************************/

        цел принять (проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять :: у целевого буфера нулевая длина");

                return .прими(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги);
        }

        /***********************************************************************

                принять данные и получи the remote endpoint адрес. Возвращает 
                the число of байты actually Приёмd, 0 if the remote sопрe 
                имеется закрыт the connection, либо ОШИБКА on failure. If the сокет 
                is блокируется, принять_от waits until there is данные куда be 
                Приёмd.

        ***********************************************************************/

        цел принять_от (проц[] буф, ПФлагиСокета флаги, Адрес из_)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять_от :: у целевого буфера нулевая длина");

                assert(из_.семействоАдресов() == семейство);
                цел длинаИмени = из_.длинаИмени();
                return .прими_от(cast(СОКЕТ)сок, буф.ptr, буф.length, cast(ПФлагиСокета) флаги, cast(адрессок*) из_.имя(), &длинаИмени);
        }

        /***********************************************************************

                описано ранее

        ***********************************************************************/

        цел принять_от (проц[] буф, Адрес из_)
        {
                return принять_от(буф, ПФлагиСокета.Неук, из_);
        }

        /***********************************************************************

                описано ранее - assumes you подключись()ed

        ***********************************************************************/

        цел принять_от (проц[] буф, ПФлагиСокета флаги = ПФлагиСокета.Неук)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять_от :: у целевого буфера нулевая длина");

                return .прими_от(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги, пусто, пусто);
        }

        /***********************************************************************

                returns the length, in байты, of the actual результат - very
                different из_ дайопцсок()

        ***********************************************************************/

        цел дайОпцию (ППротокол уровень, ПОпцияСокета опция, проц[] результат)
        {
                цел длин = результат.length;
                if(Ошибка == .дайопцсок (сок, cast(цел)уровень, cast(цел)опция, результат.ptr, &длин))
                   исключение ("Не удаётся получить опцию сокета: ");
                return длин;
        }

        /***********************************************************************

        ***********************************************************************/

        Беркли* установиОпцию (ППротокол уровень, ПОпцияСокета опция, проц[] значение)
        {
                if(Ошибка == .установиопцсок (сок, cast(цел)уровень, cast(цел)опция, значение.ptr, значение.length))
                   исключение ("Не удаётся установить опцию сокета: ");
                return this;
        }

        /***********************************************************************

                getter

        ***********************************************************************/

        бул блокируется()
        {
                version (Windows)
                         return синхронно;
                else
                   return !(fcntl(сок, F_GETFL, 0) & O_NONBLOCK);
        }

        /***********************************************************************

                setter

        ***********************************************************************/

        проц блокируется(бул да)
        {
                version (Windows)
                        {
                        бцел чис = !да;
                        if(ввктлсок(сок, ВВФСБВВ, &чис) is ОШИБКА)
                           исключение("Не удаётся установить блокировку сокета: ");
                        синхронно = да;
                        }
                     else 
                        {
                        цел x = fcntl(сок, F_GETFL, 0);
                        if(да)
                           x &= ~O_NONBLOCK;
                        else
                           x |= O_NONBLOCK;
                        if(fcntl(сок, F_SETFL, x) is ОШИБКА)
                           исключение("Не удаётся установить блокировку сокета: ");
                        }
                return; 
        }

        /***********************************************************************

        ***********************************************************************/

        static проц исключение (ткст сооб)
        {
                throw new СокетИскл (сооб ~ СисОш.найди(последнОшиб));
        }

        /***********************************************************************

        ***********************************************************************/

        protected static проц плохойАрг (ткст сооб)
        {
                throw new ИсклНелегальногоАргумента (сооб);
        }
}



/*******************************************************************************


*******************************************************************************/

public abstract class Адрес
{
        public struct адрессок
        {
                бкрат   семейство;
                сим[14] данные = 0;
        }

        struct ИнфОбАдре 
        { 
                цел       ai_flags; 
                цел       ai_family; 
                цел       ai_socktype; 
                цел       ai_protocol; 
                бцел      ai_Addrlen; 
                version (freebsd)
                        {
                        сим*     ai_canonname; 
                        адрессок* ai_Addr; 
                        }
                     else
                        {
                        адрессок* ai_Addr; 
                        сим*     ai_canonname; 
                        }
                ИнфОбАдре* ai_next; 
        } 

        abstract адрессок*      имя();
        abstract цел            длинаИмени();

        /***********************************************************************

                Internal usage

        ***********************************************************************/

        private static бкрат с8хбк (бкрат x)
        {
                return х8сбк(x);
        }

        /***********************************************************************

                Internal usage

        ***********************************************************************/

        private static бцел с8хбц (бцел x)
        {
                return х8сбц(x);
        }

        /***********************************************************************

                Internal usage

        ***********************************************************************/

        private static ткст преобразуй2Д (сим* s)
        {
                return s ? s[0 .. длинтекс(s)] : cast(ткст)пусто;
        }

        /***********************************************************************

                Internal usage

        ***********************************************************************/

        private static сим* преобразуй2Си (ткст ввод, ткст вывод)
        {
                вывод [0 .. ввод.length] = ввод;
                вывод [ввод.length] = 0;
                return вывод.ptr;
        }

        /***********************************************************************

                Internal usage

        ***********************************************************************/

        private static ткст изЦел (ткст врем, цел i)
        {
                цел j = врем.length;
                do {
                   врем[--j] = cast(сим)(i % 10 + '0');
                   } while (i /= 10);
                return врем [j .. $];
        }

        /***********************************************************************

                Internal usage

        ***********************************************************************/

        private static цел вЦел (ткст s)
        {
                бцел значение;

                foreach (c; s)
                         if (c >= '0' && c <= '9')
                             значение = значение * 10 + (c - '0');
                         else
                            break;
                return значение;
        }

        /***********************************************************************

                Dinrus: добавьed this common function

        ***********************************************************************/

        static проц исключение (ткст сооб)
        {
                throw new СокетИскл (сооб);
        }
				
        /***********************************************************************

                Адрес factory

        ***********************************************************************/

        static Адрес создай (адрессок* sa) 
        { 
                switch  (sa.семейство) 
                        { 
                        case ПСемействоАдресов.ИНЕТ: 
                             return new АдресИПв4(sa); 
                        case ПСемействоАдресов.ИНЕТ6: 
                             return new АдресИПв6(sa); 
                        default: 
                             return пусто; 
                        } 
        } 
				
        /*********************************************************************** 
  
        ***********************************************************************/ 
         
        static Адрес разреши (ткст хост, ткст служба = пусто, 
                                ПСемействоАдресов af = ПСемействоАдресов.НЕУК, 
                                ПФлагиАИ флаги = cast(ПФлагиАИ)0) 
        { 
                return разрешиВсе (хост, служба, af, флаги)[0]; 
        } 
         
        /*********************************************************************** 
  
        ***********************************************************************/ 
         
        static Адрес разреши (ткст хост, бкрат порт, 
                                ПСемействоАдресов af = ПСемействоАдресов.НЕУК, 
                                ПФлагиАИ флаги = cast(ПФлагиАИ)0) 
        { 
                return разрешиВсе (хост, порт, af, флаги)[0]; 
        } 
         
        /*********************************************************************** 
  
        ***********************************************************************/ 
         
        static Адрес[] разрешиВсе (ткст хост, ткст служба = пусто, 
                                     ПСемействоАдресов af = ПСемействоАдресов.НЕУК, 
                                     ПФлагиАИ флаги = cast(ПФлагиАИ)0) 
        { 
                Адрес[] retVal; 
                version (Win32) 
                        { 
                        if (!getAddrinfo) 
                           { // *old* windows, let's fall задний куда НетХост 
                           бцел порт = вЦел(служба); 
                           if (флаги & ПФлагиАИ.Пассив && хост is пусто) 
                               return [new АдресИПв4(0, порт)]; 

                           auto nh = new НетХост; 
                           if (!nh.дайХостПоИмени(хост)) 
                                throw new АдрИскл("не удалось разрешить " ~ хост); 

                           retVal.length = nh.АдрСписок.length; 
                           foreach (i, адр; nh.АдрСписок)
                                    retVal[i] = new АдресИПв4(адр, порт); 
                           return retVal; 
                           } 
                        } 

                ИнфОбАдре* инфо; 
                ИнфОбАдре хинты; 
                хинты.ai_flags = флаги; 
                хинты.ai_family = (флаги & ПФлагиАИ.Пассив && af == ПСемействоАдресов.НЕУК) ? ПСемействоАдресов.ИНЕТ6 : af; 
                хинты.ai_socktype = ПТипСок.Поток; 
                цел ошибка = getAddrinfo(stringz.вТкст0(хост), служба.length == 0 ? пусто : stringz.вТкст0(служба), &хинты, &инфо); 
                if (ошибка != 0)  
                    throw new АдрИскл("не удалось разрешить " ~ хост); 

                retVal.length = 16; 
                retVal.length = 0; 
                while (инфо) 
                      { 
                      if (auto адр = создай(инфо.ai_Addr)) 
                          retVal ~= адр; 
                      инфо = инфо.ai_next; 
                      } 
                freeAddrinfo (инфо); 
                return retVal; 
        } 
         
        /*********************************************************************** 
  
        ***********************************************************************/ 
         
        static Адрес[] разрешиВсе (сим хост[], бкрат порт, 
                                     ПСемействоАдресов af = ПСемействоАдресов.НЕУК, 
                                     ПФлагиАИ флаги = cast(ПФлагиАИ)0) 
        { 
                сим[16] буф; 
                return разрешиВсе (хост, изЦел(буф, порт), af, флаги); 
        } 
         
        /*********************************************************************** 
  
        ***********************************************************************/ 
         
        static Адрес пассивное (ткст служба, 
                                ПСемействоАдресов af = ПСемействоАдресов.НЕУК, 
                                ПФлагиАИ флаги = cast(ПФлагиАИ)0) 
        { 
                return разреши (пусто, служба, af, флаги | ПФлагиАИ.Пассив); 
        } 
         
        /*********************************************************************** 
 
         ***********************************************************************/ 
         
        static Адрес пассивное (бкрат порт, ПСемействоАдресов af = ПСемействоАдресов.НЕУК, 
                                ПФлагиАИ флаги = cast(ПФлагиАИ)0) 
        { 
                return разреши (пусто, порт, af, флаги | ПФлагиАИ.Пассив); 
        } 
         
        /*********************************************************************** 
  
        ***********************************************************************/ 
 
        ткст вТкстАдреса() 
        { 
                сим[1025] хост =void; 
                // Getting имя инфо. Don't look up имя_хоста, returns 
                // numeric имя. (ПФлагиУИ.НумерикХост)
                getnameinfo (имя, длинаИмени, хост.ptr, хост.length, пусто, 0, ПФлагиУИ.НумерикХост); 
                return изТкст0 (хост.ptr); 
        } 
 
        /*********************************************************************** 
 
         ***********************************************************************/ 
 
        ткст вТкстПорта() 
        { 
                сим[32] служба =void; 
                // Getting имя инфо. Возвращает порт число, not 
                // служба имя. (ПФлагиУИ.НумерикСлужба)
                getnameinfo (имя, длинаИмени, пусто, 0, служба.ptr, служба.length, ПФлагиУИ.НумерикСлужба); 
                foreach (i, c; служба)  
                         if (c == '\0')  
                             return служба[0..i].dup; 
                return пусто;
        } 
          
        /*********************************************************************** 
  
        ***********************************************************************/ 
 
        ткст вТкст() 
        { 
                return вТкстАдреса ~ ":" ~ вТкстПорта; 
        } 
                  
        /*********************************************************************** 
 
         ***********************************************************************/ 
 
        ПСемействоАдресов семействоАдресов() 
        { 
                return cast(ПСемействоАдресов)имя.семейство; 
        } 
}


/*******************************************************************************

*******************************************************************************/

public class НеизвестныйАдрес : Адрес
{
        адрессок sa;

        /***********************************************************************

        ***********************************************************************/

        адрессок* имя()
        {
                return &sa;
        }

        /***********************************************************************

        ***********************************************************************/

        цел длинаИмени()
        {
                return sa.sizeof;
        }

        /***********************************************************************

        ***********************************************************************/

        ПСемействоАдресов семействоАдресов()
        {
                return cast(ПСемействоАдресов) sa.семейство;
        }

        /***********************************************************************

        ***********************************************************************/

        ткст вТкст()
        {
                return "Неизвестно";
        }
}


/*******************************************************************************


*******************************************************************************/

public class АдресИПв4 : Адрес
{
        /***********************************************************************

        ***********************************************************************/

        enum 
        {
                АДР_ЛЮБОЙ = 0, 
                АДР_НЕУК = cast(бцел)-1, 
                ПОРТ_ЛЮБОЙ = 0
        }

        /***********************************************************************

        ***********************************************************************/

        struct сокадр_ин
        {
                version (freebsd)
                        {
                        ббайт sin_len;
                        ббайт семействоИС  = ПСемействоАдресов.ИНЕТ;
                        } 
                     else 
                        {
                        бкрат семействоИС = ПСемействоАдресов.ИНЕТ;
                        }
                бкрат портИС;
                бцел адрИС; //in_Addr
                сим[8] зероИС = 0;
        }

        static assert(сокадр_ин.sizeof is 16);

        private сокадр_ин син;

        /***********************************************************************

        ***********************************************************************/

        package this ()
        {
        }

        /***********************************************************************

        ***********************************************************************/

        this (бкрат порт)
        {
                син.адрИС = 0; //any, "0.0.0.0"
                син.портИС = х8сбк(порт);
        }

        /***********************************************************************

        ***********************************************************************/

        this (бцел адр, бкрат порт)
        {
                син.адрИС = х8сбц(адр);
                син.портИС = х8сбк(порт);
        }

        /***********************************************************************

                -порт- can be ПОРТ_ЛЮБОЙ
                -адр- is an ИП Адрес or хост имя

        ***********************************************************************/

        this (ткст адр, цел порт = ПОРТ_ЛЮБОЙ)
        {
                бцел uiAddr = разбор(адр);
                if (АДР_НЕУК == uiAddr)
                   {
                   auto ih = new НетХост;
                   if (!ih.дайХостПоИмени(адр))
                      {
                      сим[16] врем =void;
                      исключение ("Unable куда разреши "~адр~":"~изЦел(врем, порт));
                      }
                   uiAddr = ih.АдрСписок[0];
                   }
                син.адрИС = х8сбц(uiAddr);
                син.портИС = х8сбк(cast(бкрат) порт);
        }

        /***********************************************************************

        ***********************************************************************/

        this (адрессок* адр) 
        { 
                син = *(cast(сокадр_ин*)адр); 
        } 
				
        /***********************************************************************

        ***********************************************************************/
				
        адрессок* имя()
        {
                return cast(адрессок*)&син;
        }

        /***********************************************************************

        ***********************************************************************/

        цел длинаИмени()
        {
                return син.sizeof;
        }

        /***********************************************************************

        ***********************************************************************/

        ПСемействоАдресов семействоАдресов()
        {
                return ПСемействоАдресов.ИНЕТ;
        }

        /***********************************************************************

        ***********************************************************************/

        бкрат порт()
        {
                return с8хбк(син.портИС);
        }

        /***********************************************************************

        ***********************************************************************/

        бцел адр()
        {
                return с8хбц(син.адрИС);
        }

        /***********************************************************************

        ***********************************************************************/

        ткст вТкстАдреса()
        {
                сим[16] buff = 0;
                version (Windows)
				{
				адрес_ин адр;
				адр.с_адр = син.адрИС;
                         return инетс8а(адр).dup;
				}
                else
                   return преобразуй2Д(inet_ntop(ПСемействоАдресов.ИНЕТ, &син.адрИС, buff.ptr, 16)).dup;
        }

        /***********************************************************************

        ***********************************************************************/

        ткст вТкстПорта()
        {
                сим[8] _port;
                return изЦел (_port, порт()).dup;
        }

        /***********************************************************************

        ***********************************************************************/

        ткст вТкст()
        {
                return вТкстАдреса() ~ ":" ~ вТкстПорта();
        }

        /***********************************************************************

                Параметр адр является ИП Адресом в формате "a.b.c.d",
                при неуспехе возвращает АДР_НЕУКe

        ***********************************************************************/

        static бцел разбор(ткст адр)
        {
                сим[64] врем;

                synchronized (АдресИПв4.classinfo)
                              return с8хбц(адр_инет(адр));
        }
}

/*******************************************************************************

*******************************************************************************/

debug(UnitTest)
{
        unittest
        {
        АдресИПв4 ia = new АдресИПв4("63.105.9.61", 80);
        assert(ia.вТкст() == "63.105.9.61:80");
        }
}

/******************************************************************************* 
        
        ИПv6 is the следщ-generation Internet Protocol version
        designated as the потомок куда ИПv4, the первый
        implementation использован in the Internet that is still in
        dominant use currently.
	        			
        More information: http://ИПv6.com/
				
        ИПv6 supports 128-bit Адрес пространство as opposed куда 32-bit
        Адрес пространство of ИПv4.
				
        ИПv6 is записано as 8 блокs of 4 octal цифры (16 bit)
        separated by a colon (":"). Zero блок can be replaced by "::".
	        			
        For example: 
        ---
        0000:0000:0000:0000:0000:0000:0000:0001
        is equal
        ::0001
        is equal
        ::1
        is analogue ИПv4 127.0.0.1
				
        0000:0000:0000:0000:0000:0000:0000:0000
        is equal
        ::
        is analogue ИПv4 0.0.0.0
				
        2001:cdba:0000:0000:0000:0000:3257:9652 
        is equal
        2001:cdba::3257:9652
				
        ИПv4 Адрес can be submitted through ИПv6 as ::ffff:xx.xx.xx.xx,
        where xx.xx.xx.xx 32-bit ИПv4 адресes.
				
        ::ffff:51b0:ec6d
        is equal
        ::ffff:81.176.236.109
        is analogue ИПv4 81.176.236.109
				
        The URL for the ИПv6 Адрес will be of the form:
        http://[2001:cdba:0000:0000:0000:0000:3257:9652]/
				
        If needed куда specify a порт, it will be listed после the
        closing square bracket followed by a colon.
				
        http://[2001:cdba:0000:0000:0000:0000:3257:9652]:8080/
        Адрес: "2001:cdba:0000:0000:0000:0000:3257:9652"
        порт: 8080
				
        АдресИПв6 can be использован as well as АдресИПв4.
				
        scope адр = new АдресИПв6(8080); 
        Адрес: "::"
        порт: 8080
				
        scope Addr_2 = new АдресИПв6("::1", 8081); 
        Адрес: "::1"
        порт: 8081
				
        scope Addr_3 = new АдресИПв6("::1"); 
        Адрес: "::1"
        порт: ПОРТ_ЛЮБОЙ
				
        Also in the АдресИПв6 constructor can specify the служба имя
        or порт as ткст
				
        scope Addr_3 = new АдресИПв6("::", "ssh"); 
        Адрес: "::"
        порт: 22 (ssh служба порт)
				
        scope Addr_4 = new АдресИПв6("::", "8080"); 
        Адрес: "::"
        порт: 8080
				
*******************************************************************************/ 
				
class АдресИПв6 : Адрес 
{ 
protected:
        /*********************************************************************** 
         
        ***********************************************************************/ 
 
        struct sockAddr_in6 
        { 
                бкрат sin_family; 
                бкрат портИС; 
                 
                бцел sin6_flowinfo; 
                ббайт[16] sin6_Addr; 
                бцел sin6_scope_опр; 
        } 
         
        sockAddr_in6 син; 
 
        /*********************************************************************** 
 
         ***********************************************************************/ 
 
        this () 
        { 
        } 
 
        /***********************************************************************

        ***********************************************************************/

        this (адрессок* sa) 
        { 
                син = *cast(sockAddr_in6*)sa; 
        } 
         
        /*********************************************************************** 
 
        ***********************************************************************/ 
 
        адрессок* имя() 
        { 
                return cast(адрессок*)&син; 
        } 
 
        /*********************************************************************** 
 
        ***********************************************************************/ 
 
        цел длинаИмени() 
        { 
                return син.sizeof; 
        } 
 
 public: 

        /***********************************************************************

        ***********************************************************************/

        ПСемействоАдресов семействоАдресов()
        {
                return ПСемействоАдресов.ИНЕТ6;
        }

 
        const бкрат ПОРТ_ЛЮБОЙ = 0; 
  
        /*********************************************************************** 
 
         ***********************************************************************/ 
 
        бкрат порт() 
        { 
                return с8хбк(син.портИС); 
        } 
 				
        /*********************************************************************** 
 
                Созд АдресИПв6 with zero Адрес

        ***********************************************************************/ 
 				
        this (цел порт) 
        { 
          this ("::", порт);
        } 
				
        /*********************************************************************** 
 
                -порт- can be ПОРТ_ЛЮБОЙ 
                -адр- is an ИП Адрес or хост имя 
 
        ***********************************************************************/ 
				
        this (ткст адр, цел порт = ПОРТ_ЛЮБОЙ) 
        { 
                version (Win32) 
                        { 
                        if (!getAddrinfo) 
                             исключение ("Эта платформа не поддерживает ИПv6."); 
                        } 
                ИнфОбАдре* инфо; 
                ИнфОбАдре хинты; 
                хинты.ai_family = ПСемействоАдресов.ИНЕТ6; 
                цел ошибка = getAddrinfo((адр ~ '\0').ptr, пусто, &хинты, &инфо); 
                if (ошибка != 0)  
                    исключение("Неудачно был создан АдресИПв6: "); 
                 
                син = *cast(sockAddr_in6*)(инфо.ai_Addr); 
                син.портИС = х8сбк(порт); 
        } 
               
        /*********************************************************************** 
 
                -служба- can be a порт число or служба имя 
                -адр- is an ИП Адрес or хост имя 
 
        ***********************************************************************/ 
 
        this (ткст адр, ткст служба) 
        { 
                version (Win32) 
                        { 
                        if(! getAddrinfo) 
                             исключение ("Эта платформа не поддерживает ИПv6."); 
                        } 
                ИнфОбАдре* инфо; 
                ИнфОбАдре хинты; 
                хинты.ai_family = ПСемействоАдресов.ИНЕТ6; 
                цел ошибка = getAddrinfo((адр ~ '\0').ptr, (служба ~ '\0').ptr, &хинты, &инфо); 
                if (ошибка != 0)  
                    исключение ("Неудачно был создан АдресИПв6: "); 
                син = *cast(sockAddr_in6*)(инфо.ai_Addr); 
        } 
 
        /*********************************************************************** 
  
        ***********************************************************************/ 
 
        ббайт[] адр() 
        { 
                return син.sin6_Addr; 
        } 
 
        /*********************************************************************** 
  
        ***********************************************************************/ 
 
        version (Posix)
        ткст вТкстАдреса()
        {
				
                сим[100] buff = 0;
                return изТкст0(inet_ntop(ПСемействоАдресов.ИНЕТ6, &син.sin6_Addr, buff.ptr, 100)).dup;
        }

        /***********************************************************************

        ***********************************************************************/

        ткст вТкстПорта()
        {
                сим[8] _port;
                return изЦел (_port, порт()).dup;
        }
 
        /***********************************************************************

        ***********************************************************************/

        ткст вТкст() 
        { 
                return "[" ~ вТкстАдреса ~ "]:" ~ вТкстПорта; 
        } 
} 

/*******************************************************************************

*******************************************************************************/

debug(UnitTest)
{
        unittest
        {
        АдресИПв6 ia = new АдресИПв6("7628:0d18:11a3:09d7:1f34:8a2e:07a0:765d", 8080);
        //assert(ia.вТкст() == "[7628:d18:11a3:9d7:1f34:8a2e:7a0:765d]:8080");
        assert(ia.вТкст() == "[7628:0d18:11a3:09d7:1f34:8a2e:07a0:765d]:8080");
        }
}


/*******************************************************************************


*******************************************************************************/

public class НетХост
{
        ткст          имя;
        ткст[]        алиасы;
        бцел[]          АдрСписок;

        /***********************************************************************

        ***********************************************************************/

        struct хостзап
        {
                сим* имя;
                сим** алиасы;
                version (Win32)
                        {
                        крат типадр;
                        крат длина;
                        }
                     else 
                        {
                        цел типадр;
                        цел длина;
                        }
                сим** списадр;

                сим* адр()
                {
                        return списадр[0];
                }
        }

        /***********************************************************************

        ***********************************************************************/

        protected проц проверьХостзап(хостзап* he)
        {
                if (he.типадр != ПСемействоАдресов.ИНЕТ || he.длина != 4)
                    throw new СокетИскл("семейства адресов не совпадают.");
        }

        /***********************************************************************

        ***********************************************************************/

        проц наполни (хостзап* he)
        {
                цел i;
                сим* p;

                имя = Адрес.преобразуй2Д (he.имя);

                for (i = 0;; i++)
                    {
                    p = he.алиасы[i];
                    if(!p)
                        break;
                    }

                if (i)
                   {
                   алиасы = new ткст[i];
                   for (i = 0; i != алиасы.length; i++)
                        алиасы[i] = Адрес.преобразуй2Д(he.алиасы[i]);
                   }
                else
                   алиасы = пусто;

                for (i = 0;; i++)
                    {
                    p = he.списадр[i];
                    if(!p)
                        break;
                    }

                if (i)
                   {
                   АдрСписок = new бцел[i];
                   for (i = 0; i != АдрСписок.length; i++)
                        АдрСписок[i] = Адрес.с8хбц(*(cast(бцел*)he.списадр[i]));
                   }
                else
                   АдрСписок = пусто;
        }

        /***********************************************************************

        ***********************************************************************/

        бул дайХостПоИмени(ткст имя)
        {
                сим[1024] врем;

                synchronized (НетХост.classinfo)
                             {
                             auto he = дайхостпоимени(имя);
                             if(!he)
                                return нет;
                             проверьХостзап(cast(хостзап*) he);
                             наполни(cast(хостзап*) he);
                             }
                return да;
        }

        /***********************************************************************

        ***********************************************************************/

        бул дайХостПоАдресу(бцел адр)
        {
                бцел x = х8сбц(адр);
                synchronized (НетХост.classinfo)
                             {
                             auto he = дайхостпоадресу(&x, 4, cast(цел)ПСемействоАдресов.ИНЕТ);
                             if(!he)
                                 return нет;
                             проверьХостзап(cast(хостзап*) he);
                             наполни(cast(хостзап*) he);
                             }
                return да;
        }

        /***********************************************************************

        ***********************************************************************/

        //shortcut
        бул дайХостПоАдресу(ткст адр)
        {
                сим[64] врем;

                synchronized (НетХост.classinfo)
                             {
                             бцел x = адр_инет(адр);
                             auto he = дайхостпоадресу(&x, 4, cast(цел)ПСемействоАдресов.ИНЕТ);
                             if(!he)
                                 return нет;
                             проверьХостзап(cast(хостзап*) he);
                             наполни(cast(хостзап*) he);
                             }
                return да;
        }
}


/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{
        extern (C) цел printf(сим*, ...);
        unittest
        {
        НетХост ih = new НетХост;
        ih.дайХостПоИмени(Беркли.имяХоста());
        assert(ih.АдрСписок.length > 0);
        АдресИПв4 ia = new АдресИПв4(ih.АдрСписок[0], АдресИПв4.ПОРТ_ЛЮБОЙ);
        printf("ИП адрес = %.*s\nname = %.*s\n", ia.вТкстАдреса(), ih.имя);
        foreach(цел i, ткст s; ih.алиасы)
        {
                printf("алиасы[%d] = %.*s\n", i, s);
        }

        printf("---\n");

        assert(ih.дайХостПоАдресу(ih.АдрСписок[0]));
        printf("имя = %.*s\n", ih.имя);
        foreach(цел i, ткст s; ih.алиасы)
        {
                printf("алиасы[%d] = %.*s\n", i, s);
        }
        }
}


/*******************************************************************************

        Набор сокетов для Беркли.выбери()

*******************************************************************************/

public class НаборСокетов
{
     
        private бцел  члоБайт; //Win32: excludes бцел.размер "счёт"
        private байт* буф;

       
        version(Windows)
        {
                бцел счёт()
                {
                        return *(cast(бцел*)буф);
                }

                проц счёт(цел setter)
                {
                        *(cast(бцел*)буф) = setter;
                }


                т_сокет* первый()
                {
                        return cast(т_сокет*)(буф + бцел.sizeof);
                }
        }
        else version (Posix)
        {
                import core.BitManip;

                бцел nfdbits;
                т_сокет _maxfd = 0;

                бцел fdelt(т_сокет s)
                {
                        return cast(бцел)s / nfdbits;
                }


                бцел fdmask(т_сокет s)
                {
                        return 1 << cast(бцел)s % nfdbits;
                }


                бцел* первый()
                {
                        return cast(бцел*)буф;
                }

                public т_сокет максуд()
                {
                        return _maxfd;
                }
        }


        public:

        this (бцел макс)
        {
                version(Win32)
                {
                        члоБайт = макс * т_сокет.sizeof;
                        буф = (new байт[члоБайт + бцел.sizeof]).ptr;
                        счёт = 0;
                }
                else version (Posix)
                {
                        if (макс <= 32)
                            члоБайт = 32 * бцел.sizeof;
                        else
                           члоБайт = макс * бцел.sizeof;

                        буф = (new байт[члоБайт]).ptr;
                        nfdbits = члоБайт * 8;
                        //очисть(); //new initializes куда 0
                }
                else
                {
                        static assert(0);
                }
        }

        this (НаборСокетов o) 
        {
                члоБайт = o.члоБайт;
                auto размер = члоБайт;
                version (Win32) 
                         размер += бцел.sizeof;

                version (Posix) 
                        {
                        nfdbits = o.nfdbits;
                        _maxfd = o._maxfd;
                        }
                
                auto b = new байт[размер];
                b[] = o.буф[0..размер];
                буф = b.ptr;
        }

        this()
        {
                version(Win32)
                {
                        this(64);
                }
                else version (Posix)
                {
                        this(32);
                }
                else
                {
                        static assert(0);
                }
        }

        НаборСокетов dup() 
        {
                return new НаборСокетов (this);
        }
        
        НаборСокетов сбрось()
        {
                version(Win32)
                {
                        счёт = 0;
                }
                else version (Posix)
                {
                        буф[0 .. члоБайт] = 0;
                        _maxfd = 0;
                }
                else
                {
                        static assert(0);
                }
                return this;
        }

        проц добавь(т_сокет s)
        in
        {
                version(Win32)
                {
                        assert(счёт < макс); //добавьed too many СОКЕТs; specify a higher макс in the constructor
                }
        }
        body
        {
                version(Win32)
                {
                        бцел c = счёт;
                        первый[c] = s;
                        счёт = c + 1;
                }
                else version (Posix)
                {
                        if (s > _maxfd)
                                _maxfd = s;

                        bts(cast(бцел*)&первый[fdelt(s)], cast(бцел)s % nfdbits);
                }
                else
                {
                        static assert(0);
                }
        }

        проц добавь(Беркли* s)
        {
                добавь(s.укз);
        }

        проц удали(т_сокет s)
        {
                version(Win32)
                {
                        бцел c = счёт;
                        т_сокет* старт = первый;
                        т_сокет* stop = старт + c;

                        for(; старт != stop; старт++)
                        {
                                if(*старт == s)
                                        goto найдено;
                        }
                        return; //не найден

                        найдено:
                        for(++старт; старт != stop; старт++)
                        {
                                *(старт - 1) = *старт;
                        }

                        счёт = c - 1;
                }
                else version (Posix)
                {
                        btr(cast(бцел*)&первый[fdelt(s)], cast(бцел)s % nfdbits);

                        // If we're removing the biggest файл descrИПtor we've
                        // entered so far we need куда recalculate this значение
                        // for the сокет установи.
                        if (s == _maxfd)
                        {
                                while (--_maxfd >= 0)
                                {
                                        if (набор_ли(_maxfd))
                                        {
                                                break;
                                        }
                                }
                        }
                }
                else
                {
                        static assert(0);
                }
        }

        проц удали(Беркли* s)
        {
                удали(s.укз);
        }

        цел набор_ли(т_сокет s)
        {
                version(Win32)
                {
                        т_сокет* старт = первый;
                        т_сокет* stop = старт + счёт;

                        for(; старт != stop; старт++)
                        {
                                if(*старт == s)
                                        return да;
                        }
                        return нет;
                }
                else version (Posix)
                {
                        //return bt(cast(бцел*)&первый[fdelt(s)], cast(бцел)s % nfdbits);
                        цел индекс = cast(бцел)s % nfdbits;
                        return (cast(бцел*)&первый[fdelt(s)])[индекс / (бцел.sizeof*8)] & (1 << (индекс & ((бцел.sizeof*8) - 1)));
                }
                else
                {
                        static assert(0);
                }
        }

        цел набор_ли(Беркли* s)
        {
                return набор_ли(s.укз);
        }

        бцел макс()
        {
                return члоБайт / т_сокет.sizeof;
        }

        набор_уд* вНабор_УД()
        {
                return cast(набор_уд*)буф;
        }

        /***********************************************************************

                НаборСокетов's are updated куда include only those СОКЕТs which an
                событие occured.

                Возвращает the число of события, 0 on таймаут, либо -1 on ошибка

                for a подключись()ing сокет, writeability means подключен
                for a слушай()ing сокет, readability means listening

                Winsock: possibly internally limited куда 64 СОКЕТs per установи

        ***********************************************************************/

        static цел выбери (НаборСокетов проверьЧит, НаборСокетов проверьЗап, НаборСокетов проверьОш, значврем* tv)
        {
                набор_уд* fr, fw, fe;

                //сделай sure Неук of the НаборСокетов's are the same объект
                if (проверьЧит)
                   {
                   assert(проверьЧит !is проверьЗап);
                   assert(проверьЧит !is проверьОш);
                   }

                if (проверьЗап)
                    assert(проверьЗап !is проверьОш);

                version(Win32)
                {
                        //Windows имеется a problem with пустой набор_уд's that aren't пусто
                        fr = (проверьЧит && проверьЧит.счёт()) ? проверьЧит.вНабор_УД() : пусто;
                        fw = (проверьЗап && проверьЗап.счёт()) ? проверьЗап.вНабор_УД() : пусто;
                        fe = (проверьОш && проверьОш.счёт()) ? проверьОш.вНабор_УД() : пусто;
                }
                else
                {
                        fr = проверьЧит ? проверьЧит.вНабор_УД() : пусто;
                        fw = проверьЗап ? проверьЗап.вНабор_УД() : пусто;
                        fe = проверьОш ? проверьОш.вНабор_УД() : пусто;
                }

                цел результат;

                version(Win32)
                {
                        while ((результат = .сделвыб (cast(цел) т_сокет.max - 1,  fr, fw, fe, tv)) == -1)
                        {
                                if(ВСАДайПоследнююОшибку() != WSAEINTR)
                                   break;
                        }
                }
                else version (Posix)
                {
                        т_сокет максуд = 0;

                        if (проверьЧит)
                                максуд = проверьЧит.максуд;

                        if (проверьЗап && проверьЗап.максуд > максуд)
                                максуд = проверьЗап.максуд;

                        if (проверьОш && проверьОш.максуд > максуд)
                                максуд = проверьОш.максуд;

                        while ((результат = .выбери (максуд + 1, fr, fw, fe, tv)) == -1)
                        {
                                if(дайНомОш() != EINTR)
                                   break;
                        }
                }
                else
                {
                        static assert(0);
                }

                return результат;
        }

        /***********************************************************************

                выбери with specified таймаут

        ***********************************************************************/

        static цел выбери (НаборСокетов проверьЧит, НаборСокетов проверьЗап, НаборСокетов проверьОш, дол микросекунды)
        {       
                значврем tv = {
                             cast(typeof(значврем.сек)) (микросекунды / 1000000), 
                             cast(typeof(значврем.микросекунды)) (микросекунды % 1000000)
                             };
                return выбери (проверьЧит, проверьЗап, проверьОш, &tv);
        }

        /***********************************************************************

                выбери with maximum таймаут

        ***********************************************************************/

        static цел выбери (НаборСокетов проверьЧит, НаборСокетов проверьЗап, НаборСокетов проверьОш)
        {
                return выбери (проверьЧит, проверьЗап, проверьОш, пусто);
        }
}


