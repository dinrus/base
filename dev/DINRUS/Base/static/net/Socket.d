module net.Socket;

private import  time.Time, sys.common, exception;

version=Dinrus;
version (Dinrus)
{
        private ткст вТкст (ткст врем, цел i)
        {
                цел j = врем.length;
                do {
                   врем[--j] = cast(сим)(i % 10 + '0');
                   } while (i /= 10);

                return врем [j .. $];
        }
}

version (linux)
         version = СОКЕТЫБСД;

version (darwin)
         version = СОКЕТЫБСД;

version (Posix)
         version = СОКЕТЫБСД;


/*******************************************************************************


*******************************************************************************/

version (Win32)
{
		public import sys.WinConsts: МАСКА_ВВПАРАМ, ВВК_ВХО,ВВФСБВВ, ДЛИНА_ВСАОПИСАНИЯ, ДЛИНА_ВСАСИС_СТАТУСА, НЕВЕРНСОК, СОКОШИБ, ПОпцияСокета, ППротокол, ПЭкстрЗакрытиеСокета, ПФлагиСокета, ПТипСок;
		
        private const цел WSAEWOULDBLOCK =  10035;
        private const цел WSAEINTR =        10004;

public import sys.WinStructs: ВИНСОКДАН, набор_уд, значврем, хостзап, адрессок, заминка, адрес_ин;



public import sys.WinFuncs: закройсок, ВСАСтарт, ВСАЧистка, сокет, адр_инет, ввктлсок, свяжисок, подключи, слушай, закройсок, экстрзак, дайимяпира, дайимясок,  шли, шли_на, пусти, прими, прими_от, выбери, дайопцсок, установиопцсок, дайимяхоста, инетс8а, дайхостпоимени,  дайхостпоадресу, ВСАДайПоследнююОшибку, х8сбк, х8сбц, с8хбк, с8хбц;

alias экстрзак глуши;
alias закройсок закрой;
                

        static this()
        {
                ВИНСОКДАН wd;
                if (ВСАСтарт (0x0101, &wd))
                    throw new СокетИскл("Не удаётся инициализировать библиотеку сокетов.");
        }


        static ~this()
        {
                ВСАЧистка();
        }

}

version (СОКЕТЫБСД)
 {
        private import cidrus;

        private typedef цел т_сокет = -1;

        private const цел F_GETFL       = 3;
        private const цел F_SETFL       = 4;
        version (darwin)
                 private const цел O_NONBLOCK = 0x0004;
		else version (solaris)
                 private const цел O_NONBLOCK = 0x80;
           else
                 private const цел O_NONBLOCK = 04000;  // OCTAL! Thx куда volcore

        extern  (C)
                {
                т_сокет сокет(цел af, цел тип, цел протокол);
                цел fcntl(т_сокет s, цел f, ...);
                бцел адр_инет(ткст0 cp);
                цел свяжисок(т_сокет s, адрессок* имя, цел namelen);
                цел подключи(т_сокет s, адрессок* имя, цел namelen);
                цел слушай(т_сокет s, цел backlog);
                т_сокет пусти(т_сокет s, адрессок* адр, цел* Addrlen);
                цел закройсок(т_сокет s);
                цел экстрзак(т_сокет s, цел как);
                цел дайимяпира(т_сокет s, адрессок* имя, цел* namelen);
                цел дайимясок(т_сокет s, адрессок* имя, цел* namelen);
                цел шли(т_сокет s, ук буф, цел длин, цел флаги);
                цел шли_на(т_сокет s, ук буф, цел длин, цел флаги, адрессок* куда, цел tolen);
                цел прими(т_сокет s, ук буф, цел длин, цел флаги);
                цел прими_от(т_сокет s, ук буф, цел длин, цел флаги, адрессок* из_, цел* fromlen);
                цел выбери(цел nfds, набор_уд* readfds, набор_уд* writefds, набор_уд* errorfds, значврем* таймаут);
                цел дайопцсок(т_сокет s, цел уровень, цел optname, ук optval, цел* optlen);
                цел установиопцсок(т_сокет s, цел уровень, цел optname, ук optval, цел optlen);
                цел дайимяхоста(ук namebuffer, цел buflen);
                ткст0 инетс8а(бцел ina);
                хостзап* дайхостпоимени(ткст0 имя);
                хостзап* дайхостпоадресу(ук адр, цел длин, цел тип);
                }
 }



/*******************************************************************************


*******************************************************************************/

private extern (C) цел strlen(сим*);

private static ткст вТкст(ткст0 s)
{
        return s ? s[0 .. strlen(s)] : cast(ткст) пусто;
}

private static ткст преобразуй2Си (ткст ввод, ткст вывод)
{
        вывод [0 .. ввод.length] = ввод;
        вывод [ввод.length] = 0;
        return вывод;
}

public:

static цел последнОшиб ()
{
        version (Win32)
                {
                return ВСАДайПоследнююОшибку();
                }
        version (Posix)
                {
                return errno;
                }
}


version(Win32)
{
        import sys.WinConsts: ПСемействоАдресов;
}
else version(СОКЕТЫБСД)
{
        version (darwin)
        {
                enum ПСемействоАдресов: цел
                {
                        НЕУК =     0,
                        ЮНИКС =       1,
                        ИНЕТ =       2,
                        АЙПИЭКС =        23,
                        ЭПЛТОК =  16,
                        //INET6 =      10,
                }
        }
        else version (freebsd)
        {
                enum ПСемействоАдресов: цел
                {
                        НЕУК =     0,
                        ЮНИКС =       1,
                        ИНЕТ =       2,
                        АЙПИЭКС =        23,
                        ЭПЛТОК =  16,
                        //INET6 =      28,
                }
        }    
        else version (linux)
        {
                enum ПСемействоАдресов: цел
                {
                        НЕУК =     0,
                        ЮНИКС =       1,
                        ИНЕТ =       2,
                        АЙПИЭКС =        4,
                        ЭПЛТОК =  5,
                        //INET6 =      10,
                }
        } // конец version
		else version (solaris)
		{
            enum ПСемействоАдресов: цел
            {
                    НЕУК =     0,
                    ЮНИКС =       1,
                    ИНЕТ =       2,
                    АЙПИЭКС =        23,
                    ЭПЛТОК =  16,
                    INET6 =      26,
            }
		}
}



/*******************************************************************************

*******************************************************************************/

class Сокет
{
        т_сокет        сок;
        ПТипСок      тип;
        ПСемействоАдресов   семейство;
        ППротокол    протокол;

        version(Win32)
                private бул _блокируется = да;

        // For use with прими().
        package this()
        {
        }


        /**
         * Describe a сокет flavor. If a single протокол тип есть_ли куда support
         * this сокет тип внутри the адрес семейство, the ППротокол may be
         * omitted.
         */
        this(ПСемействоАдресов семейство, ПТипСок тип, ППротокол протокол, бул создай=да)
        {
                this.тип = тип;
                this.семейство = семейство;
                this.протокол = протокол;
                if (создай)
                    инициализуй ();
        }


        /**
         * Создаёт или присваивает сокет
         */
        private проц инициализуй (т_сокет сок = сок.init)
        {
                if (this.сок)
                    this.открепи;

                if (сок is сок.init)
                   {
                   сок = cast(т_сокет) сокет(семейство, тип, протокол);
                   if (сок is сок.init)
                       исключение ("Не удаётся создать сокет: ");
                   }

                this.сок = сок;
        }

        /***********************************************************************

                Возвращает соответствуюший указатель ОС на данный Провод

        ***********************************************************************/

        т_сокет фукз ()
        {
                return сок;
        }

        /***********************************************************************

                Создаёт new исконный сокет экземпляр для этого Сокет

        ***********************************************************************/

        проц переоткрой (т_сокет сок = сок.init)
        {
                инициализуй (сок);
        }

        /***********************************************************************

                Is this сокет still alive? A закрыт сокет is consопрered куда
                be dead, but a глуши сокет is still alive.

        ***********************************************************************/

        бул жив_ли()
        {
                цел тип, разм_типа = тип.sizeof;
                return дайопцсок (сок, ППротокол.СОКЕТ,
                                   ПОпцияСокета.Тип, cast(сим*) &тип,
                                   &разм_типа) != СОКОШИБ;
        }


        /***********************************************************************


        ***********************************************************************/

        override ткст вТкст()
        {
                return "Сокет";
        }


        /***********************************************************************

                getter

        ***********************************************************************/

        бул блокируется()
        {
                version(Win32)
                {
                        return _блокируется;
                }
                else version(СОКЕТЫБСД)
                {
                        return !(fcntl(сок, F_GETFL, 0) & O_NONBLOCK);
                }
        }


        /***********************************************************************

                setter

        ***********************************************************************/

        проц блокируется(бул бда)
        {
                version(Win32)
                {
                        бцел чис = !бда;
                        if(СОКОШИБ == ввктлсок(сок, ВВФСБВВ, &чис))
                                goto err;
                        _блокируется = бда;
                }
                else version(СОКЕТЫБСД)
                {
                        цел x = fcntl(сок, F_GETFL, 0);
                        if(бда)
                                x &= ~O_NONBLOCK;
                        else
                                x |= O_NONBLOCK;
                        if(СОКОШИБ == fcntl(сок, F_SETFL, x))
                                goto err;
                }
                return; //success

                err:
                исключение("Не удаётся установить блокировку сокета: ");
        }


        /***********************************************************************


        ***********************************************************************/

        ПСемействоАдресов семействоАдресов()
        {
                return семейство;
        }


        /***********************************************************************


        ***********************************************************************/

        Сокет вяжи(Адрес адр)
        {
                if(СОКОШИБ == .свяжисок (сок, адр.имя(), адр.длинаИмени()))
                   исключение ("Не удаётся привязка сокета: ");
                return this;
        }


        /***********************************************************************


        ***********************************************************************/

        Сокет подключись(Адрес куда)
        {
                if(СОКОШИБ == .подключи (сок, куда.имя(), куда.длинаИмени()))
                {
                        if(!блокируется)
                        {
                                version(Win32)
                                {
                                        if(WSAEWOULDBLOCK == ВСАДайПоследнююОшибку())
                                                return this;
                                }
                                else version (Posix)
                                {
                                        if(EINPROGRESS == errno)
                                                return this;
                                }
                                else
                                {
                                        static assert(0);
                                }
                        }
                        исключение ("Не удаётся подключить сокет: ");
                }
                return this;
        }


        /***********************************************************************

                need куда вяжи() первый

        ***********************************************************************/

        Сокет слушай(цел backlog)
        {
                if(СОКОШИБ == .слушай (сок, backlog))
                   исключение ("Не удаётся прослушивание сокета: ");
                return this;
        }

        /**
         * Акцепт an incoming connection. If the сокет is блокируется, прими
         * waits for a connection request. Выводит исключение СокетПриёмИскл if unable
         * куда прими. See accepting для использования с производный classes.
         */
        Сокет прими ()
        {
                return прими (new Сокет);
        }

        Сокет прими (Сокет мишень)
        {
                auto newsock = cast(т_сокет).пусти(сок, пусто, пусто); // DMD 0.101 ошибка: найдено '(' when expecting ';' following 'statement
                if (т_сокет.init == newsock)
                   throw new СокетПриёмИскл("Не удаётся приём подключения к сокету: " ~ СисОш.найди(последнОшиб));

                мишень.инициализуй (newsock);
                version(Win32)
                        мишень._блокируется = _блокируется;  //inherits блокируется режим

                мишень.протокол = протокол;            //same протокол
                мишень.семейство = семейство;                //same семейство
                мишень.тип = тип;                    //same тип

                return мишень;                         //return configured мишень
        }

        /***********************************************************************

                The глуши function shuts down the connection of the сокет.
                Depending on the аргумент значение, it will:

                    -   stop receiving данные для этого сокет. If further данные
                        arrives, it is rejected.

                    -   stop trying куда transmit данные из_ this сокет. Also
                        discards any данные waiting куда be sent. Стоп looking for
                        acknowledgement of данные already sent; don't retransmit
                        if any данные is lost.

        ***********************************************************************/

        Сокет глуши(ПЭкстрЗакрытиеСокета как)
        {
                .глуши (сок, как);
                return this;
        }


        /***********************************************************************

                Dinrus: добавьed

        ***********************************************************************/

        Сокет установиПериодЗаминки (цел период)
        {
                заминка l;

                l.вкл = 1;                          //опция on/off
                l.время = cast(бкрат) период;       //заминка время

                return установиОпцию (ППротокол.СОКЕТ, ПОпцияСокета.Заминка, l.массив);
        }


        /***********************************************************************


                Dinrus: добавьed

        ***********************************************************************/

        Сокет установиПовторнИспАдреса (бул включен)
        {
                цел[1] x = включен;
                return установиОпцию (ППротокол.СОКЕТ, ПОпцияСокета.ПереиспАдр, x);
        }


        /***********************************************************************


                Dinrus: добавьed

        ***********************************************************************/

        Сокет установиБезЗаминки (бул включен)
        {
                цел[1] x = включен;
                return установиОпцию (ППротокол.ПУТ, ПОпцияСокета.ПУТБезЗадержек, x);
        }


        /***********************************************************************

                Helper function куда укз the добавим и dropping of группа
                membershИП.

                Dinrus: добавьed

        ***********************************************************************/

        проц включиВГруппу (АдресИПв4 адрес, бул onOff)
        {
                assert (адрес, "Сокет.включиВГруппу :: пустой адрес недопустим");

                struct ИП_mreq
                {
                бцел  imr_multiAddr;  /* ИП multicast адрес of группа */
                бцел  imr_interface;  /* local ИП адрес of interface */
                };

                ИП_mreq mrq;

                auto опция = (onOff) ? ПОпцияСокета.ИПВ6ВГруппу : ПОпцияСокета.ИПВ6ИзГруппы;
                mrq.imr_interface = 0;
                mrq.imr_multiAddr = адрес.син.адрИС;

                if (.установиопцсок(сок, ППротокол.ИП, опция, &mrq, mrq.sizeof) == СОКОШИБ)
                    исключение ("Не удаётся выполнить мультикастное объединение: ");
        }


        /***********************************************************************

                calling глуши() перед this is recommended for connection-
                oriented СОКЕТs

        ***********************************************************************/

        проц открепи ()
        {
                if (сок != сок.init)
                   {
                   version (TraceLinux)
                            printf ("closing сокет укз ...\n");

                   version(Win32)
                           .закройсок (сок);
                   else
                   version(СОКЕТЫБСД)
                           .закрой (сок);

                   version (TraceLinux)
                            printf ("сокет укз закрыт\n");

                   сок = сок.init;
                   }
        }

        /***********************************************************************


        ***********************************************************************/

        Адрес новОбъектСемейства ()
        {
                Адрес результат;
                switch(семейство)
                {
                        case ПСемействоАдресов.ИНЕТ:
                                результат = new АдресИПв4;
                                break;

                        default:
                                результат = new НеизвестныйАдрес;
                }
                return результат;
        }


        /***********************************************************************

                Dinrus: добавьed this куда return the имя_хоста

        ***********************************************************************/

        static ткст имяХоста ()
        {
                сим[64] имя;

                if(СОКОШИБ == .дайимяхоста (имя, имя.length))
                   исключение ("Не удаётся получение имени хоста: ");
                return имя [0 .. strlen(имя.ptr)].dup;
        }


        /***********************************************************************

                Dinrus: добавьed this куда return the default хост адрес (ИПv4)

        ***********************************************************************/

        static бцел адресХоста ()
        {
                НетХост ih = new НетХост;

                ткст имя_хоста = имяХоста();
                ih.дайХостПоИмени (имя_хоста);
                assert (ih.АдрСписок.length);
                return ih.АдрСписок[0];
        }


        /***********************************************************************


        ***********************************************************************/

        Адрес удалённыйАдрес ()
        {
                Адрес адр = новОбъектСемейства ();
                цел длинаИмени = адр.длинаИмени ();
                if(СОКОШИБ == .дайимяпира (сок, адр.имя(), &длинаИмени))
                   исключение ("Не удаётся получить адрес удалённого сокета: ");
                assert (адр.семействоАдресов() == семейство);
                return адр;
        }


        /***********************************************************************


        ***********************************************************************/

        Адрес локальныйАдрес ()
        {
                Адрес адр = новОбъектСемейства ();
                цел длинаИмени = адр.длинаИмени();
                if(СОКОШИБ == .дайимясок (сок, адр.имя(), &длинаИмени))
                   исключение ("Не удаётся получить адрес локального сокета: ");
                assert (адр.семействоАдресов() == семейство);
                return адр;
        }

        /// Отправка or принять ошибка код.
        const цел ERROR = СОКОШИБ;


        /**
         * Отправка данные on the connection. Возвращает the число of байты actually
         * sent, либо ERROR on failure. If the сокет is блокируется и there is no
         * буфер пространство лево, шли waits.
         */
        //returns число of байты actually sent, либо -1 on ошибка
        цел шли(проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                return .шли(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги);
        }

        /**
         * Отправка данные куда a specific приёмник адрес. If the приёмник адрес is not specified, a connection must have been made и that адрес is использован. If the сокет is блокируется и there is no буфер пространство лево, отправь_на waits.
         */
        цел отправь_на(проц[] буф, ПФлагиСокета флаги, Адрес куда)
        {
                return .шли_на(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги, cast(адрессок*) куда.имя(), куда.длинаИмени());
        }

        /// описано ранее
        цел отправь_на(проц[] буф, Адрес куда)
        {
                return отправь_на(буф, ПФлагиСокета.Неук, куда);
        }


        //assumes you подключись()ed
        /// описано ранее
        цел отправь_на(проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                return .шли_на(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги, пусто, 0);
        }


        /**
         * принять данные on the connection. Возвращает the число of байты actually
         * Приёмd, 0 if the remote sопрe имеется закрыт the connection, либо ERROR on
         * failure. If the сокет is блокируется, принять waits until there is данные
         * куда be Приёмd.
         */
        //returns число of байты actually Приёмd, 0 on connection closure, либо -1 on ошибка
        цел принять(проц[] буф, ПФлагиСокета флаги=ПФлагиСокета.Неук)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять :: у целевого буфера нулевая длина");

                return .прими(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги);
        }

        /**
         * принять данные и получи the remote endpoint адрес. Возвращает the число of байты actually Приёмd, 0 if the remote sопрe имеется закрыт the connection, либо ERROR on failure. If the сокет is блокируется, принять_от waits until there is данные куда be Приёмd.
         */
        цел принять_от(проц[] буф, ПФлагиСокета флаги, Адрес из_)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять_от :: у целевого буфера нулевая длина");

                assert(из_.семействоАдресов() == семейство);
                цел длинаИмени = из_.длинаИмени();
                return .прими_от(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги, cast(адрессок*)из_.имя(), &длинаИмени);
        }


        /// описано ранее
        цел принять_от(проц[] буф, Адрес из_)
        {
                return принять_от(буф, ПФлагиСокета.Неук, из_);
        }


        //assumes you подключись()ed
        /// описано ранее
        цел принять_от(проц[] буф, ПФлагиСокета флаги = ПФлагиСокета.Неук)
        {
                if (!буф.length)
                     плохойАрг ("Сокет.принять_от :: у целевого буфера нулевая длина");

                return .прими_от(cast(СОКЕТ) сок, буф.ptr, буф.length, cast(ПФлагиСокета)флаги, пусто, пусто);
        }


        /***********************************************************************

                returns the length, in байты, of the actual результат - very
                different из_ дайопцсок()

        ***********************************************************************/

        цел дайОпцию (ППротокол уровень, ПОпцияСокета опция, проц[] результат)
        {
                цел длин = результат.length;
                if(СОКОШИБ == .дайопцсок (cast(СОКЕТ) сок, уровень, опция, результат.ptr, &длин))
                   исключение ("Не удаётся получить опцию сокета: ");
                return длин;
        }


        /***********************************************************************


        ***********************************************************************/

        Сокет установиОпцию (ППротокол уровень, ПОпцияСокета опция, проц[] значение)
        {
                if(СОКОШИБ == .установиопцсок (сок, cast(цел)уровень, cast(цел)опция, значение.ptr, значение.length))
                   исключение ("Не удаётся установить опцию сокета: ");
                return this;
        }


        /***********************************************************************

                Dinrus: добавьed this common function

        ***********************************************************************/

        protected static проц исключение (ткст сооб)
        {
                throw new СокетИскл (сооб ~ СисОш.найди(последнОшиб));
        }


        /***********************************************************************

                Dinrus: добавьed this common function

        ***********************************************************************/

        protected static проц плохойАрг (ткст сооб)
        {
                throw new ИсклНелегальногоАргумента (сооб);
        }


        /***********************************************************************

                НаборСокетов's are updated куда include only those СОКЕТs which an
                событие occured.

                Возвращает the число of события, 0 on таймаут, либо -1 on ошибка

                for a подключись()ing сокет, writeability means подключен
                for a слушай()ing сокет, readability means listening

                Winsock: possibly internally limited куда 64 СОКЕТs per установи

        ***********************************************************************/

        static цел выбери (НаборСокетов проверьЧит, НаборСокетов проверьЗап, НаборСокетов проверьОш, значврем* tv)
        in
        {
                //сделай sure Неук of the НаборСокетов's are the same объект
                if(проверьЧит)
                {
                        assert(проверьЧит !is проверьЗап);
                        assert(проверьЧит !is проверьОш);
                }
                if(проверьЗап)
                {
                        assert(проверьЗап !is проверьОш);
                }
        }
        body
        {
                набор_уд* fr, fw, fe;

                version(Win32)
                {
                        //Windows имеется a problem with пустой набор_уд's that aren't пусто
                        fr = (проверьЧит && проверьЧит.счёт()) ? проверьЧит.вНабор_УД() : пусто;
                        fw = (проверьЗап && проверьЗап.счёт()) ? проверьЗап.вНабор_УД() : пусто;
                        fe = (проверьОш && проверьОш.счёт()) ? проверьОш.вНабор_УД() : пусто;
                }
                else
                {
                        fr = проверьЧит ? проверьЧит.вНабор_УД() : пусто;
                        fw = проверьЗап ? проверьЗап.вНабор_УД() : пусто;
                        fe = проверьОш ? проверьОш.вНабор_УД() : пусто;
                }

                цел результат;

                // Dinrus: if выбери() was interrupted, we сейчас try again
                version(Win32)
                {
                        while ((результат = .выбери (т_сокет.max - 1, fr, fw, fe, tv)) == -1)
                        {
                                if(ВСАДайПоследнююОшибку() != WSAEINTR)
                                   break;
                        }
                }
                else version (Posix)
                {
                        т_сокет максуд = 0;

                        if (проверьЧит)
                                максуд = проверьЧит.максуд;

                        if (проверьЗап && проверьЗап.максуд > максуд)
                                максуд = проверьЗап.максуд;

                        if (проверьОш && проверьОш.максуд > максуд)
                                максуд = проверьОш.максуд;

                        while ((результат = .выбери (максуд + 1, fr, fw, fe, tv)) == -1)
                        {
                                if(дайНомОш() != EINTR)
                                   break;
                        }
                }
                else
                {
                        static assert(0);
                }
                // Dinrus: don't throw an исключение here ... жди until we получи
                // a bit further задний along the control путь
                //if(СОКОШИБ == результат)
                //   throw new СокетИскл("Сокет выбери ошибка.");

                return результат;
        }

        /***********************************************************************

                выбери with specified таймаут

        ***********************************************************************/

        static цел выбери (НаборСокетов проверьЧит, НаборСокетов проверьЗап, НаборСокетов проверьОш, ИнтервалВремени время)
        {
                auto tv = вЗначВрем (время);
                return выбери (проверьЧит, проверьЗап, проверьОш, &tv);
        }

        /***********************************************************************

                выбери with maximum таймаут

        ***********************************************************************/

        static цел выбери (НаборСокетов проверьЧит, НаборСокетов проверьЗап, НаборСокетов проверьОш)
        {
                return выбери (проверьЧит, проверьЗап, проверьОш, пусто);
        }

        /***********************************************************************

                Handy utility for converting ИнтервалВремени преобр_в значврем

        ***********************************************************************/

        static значврем вЗначВрем (ИнтервалВремени время)
        {
                значврем tv;
                tv.сек = cast(бцел) время.сек;
                tv.микросек = cast(бцел) время.микросек % 1_000_000;
                return tv;
        }
}



/*******************************************************************************


*******************************************************************************/

abstract class Адрес
{
        protected адрессок* имя();
        protected цел длинаИмени();
        ПСемействоАдресов семействоАдресов();
        ткст вТкст();

        /***********************************************************************

                Dinrus: добавьed this common function

        ***********************************************************************/

        static проц исключение (ткст сооб)
        {
                throw new АдрИскл (сооб);
        }

}


/*******************************************************************************


*******************************************************************************/

class НеизвестныйАдрес: Адрес
{
        protected:
        адрессок sa;


        /***********************************************************************


        ***********************************************************************/

        адрессок* имя()
        {
                return &sa;
        }


        /***********************************************************************


        ***********************************************************************/

        цел длинаИмени()
        {
                return sa.sizeof;
        }


        public:
        /***********************************************************************


        ***********************************************************************/

        ПСемействоАдресов семействоАдресов()
        {
                return cast(ПСемействоАдресов) sa.семейство;
        }


        /***********************************************************************


        ***********************************************************************/

        ткст вТкст()
        {
                return "Неизвестно";
        }
}


/*******************************************************************************


*******************************************************************************/

class НетХост
{
        ткст имя;
        ткст[] алиасы;
        бцел[] АдрСписок;


        /***********************************************************************


        ***********************************************************************/

        protected проц проверьХостзап(хостзап* he)
        {
                if(he.типадр != cast(крат)ПСемействоАдресов.ИНЕТ || he.длина != 4)
                        throw new ХостИскл("Семейства адресов не совпадают.");
        }


        /***********************************************************************


        ***********************************************************************/

        проц наполни(хостзап* he)
        {
                цел i;
                ткст0 p;

                имя = .вТкст(he.имя);

                for(i = 0;; i++)
                {
                        p = he.алиасы[i];
                        if(!p)
                                break;
                }

                if(i)
                {
                        алиасы = new ткст[i];
                        for(i = 0; i != алиасы.length; i++)
                        {
                                алиасы[i] = .вТкст(he.алиасы[i]);
                        }
                }
                else
                {
                        алиасы = пусто;
                }

                for(i = 0;; i++)
                {
                        p = he.списадр[i];
                        if(!p)
                                break;
                }

                if(i)
                {
                        АдрСписок = new бцел[i];
                        for(i = 0; i != АдрСписок.length; i++)
                        {
                                АдрСписок[i] = с8хбц(*(cast(бцел*)he.списадр[i]));
                        }
                }
                else
                {
                        АдрСписок = пусто;
                }
        }


        /***********************************************************************


        ***********************************************************************/

        бул дайХостПоИмени(ткст имя)
        {
                сим[1024] врем;

                synchronized (Сокет.classinfo)
                             {
                             хостзап* he = дайхостпоимени(преобразуй2Си (имя, врем));
                             if(!he)
                                return нет;
                             проверьХостзап(he);
                             наполни(he);
                             }
                return да;
        }


        /***********************************************************************


        ***********************************************************************/

        бул дайХостПоАдресу(бцел адр)
        {
                бцел x = х8сбц(адр);
                synchronized (Сокет.classinfo)
                             {
                             хостзап* he = дайхостпоадресу(&x, 4, cast(цел)ПСемействоАдресов.ИНЕТ);
                             if(!he)
                                 return нет;
                             проверьХостзап(he);
                             наполни(he);
                             }
                return да;
        }


        /***********************************************************************


        ***********************************************************************/

        //shortcut
        бул дайХостПоАдресу(ткст адр)
        {
                сим[64] врем;

                synchronized (Сокет.classinfo)
                             {
                             бцел x = адр_инет(преобразуй2Си (адр, врем));
                             хостзап* he = дайхостпоадресу(&x, 4, cast(цел)ПСемействоАдресов.ИНЕТ);
                             if(!he)
                                 return нет;
                             проверьХостзап(he);
                             наполни(he);
                             }
                return да;
        }
}


debug (UnitText)
{
extern (C) цел printf(сим*, ...);
unittest
{
        try
        {
        НетХост ih = new НетХост;
        ih.дайХостПоИмени(Сокет.имяХоста());
        assert(ih.АдрСписок.length > 0);
        АдресИПв4 ia = new АдресИПв4(ih.АдрСписок[0], АдресИПв4.ПОРТ_ЛЮБОЙ);
        printf("ИП адрес = %.*s\nname = %.*s\n", ia.вТкстАдреса(), ih.имя);
        foreach(цел i, ткст s; ih.алиасы)
        {
                printf("алиасы[%d] = %.*s\n", i, s);
        }

        printf("---\n");

        assert(ih.дайХостПоАдресу(ih.АдрСписок[0]));
        printf("имя = %.*s\n", ih.имя);
        foreach(цел i, ткст s; ih.алиасы)
        {
                printf("алиасы[%d] = %.*s\n", i, s);
                }
        }
        catch( Объект o )
        {
            assert( нет );
        }
}
}


/*******************************************************************************


*******************************************************************************/

class АдресИПв4 : Адрес
{
        protected:
        сим[8] _port;

        /***********************************************************************


        ***********************************************************************/

        struct сокадр_ин
        {
                бкрат семействоИС = cast(бкрат) ПСемействоАдресов.ИНЕТ;
                бкрат портИС;
                бцел адрИС; //in_Addr
                сим[8] зероИС = 0;
        }

        сокадр_ин син;


        /***********************************************************************


        ***********************************************************************/

        адрессок* имя()
        {
                return cast(адрессок*)&син;
        }


        /***********************************************************************


        ***********************************************************************/

        цел длинаИмени()
        {
                return син.sizeof;
        }


        public:

        /***********************************************************************


        ***********************************************************************/

        this()
        {
        }


        const бцел АДР_ЛЮБОЙ = 0;
        const бцел АДР_НЕУК = cast(бцел)-1;
        const бкрат ПОРТ_ЛЮБОЙ = 0;


        /***********************************************************************


        ***********************************************************************/

        ПСемействоАдресов семействоАдресов()
        {
                return ПСемействоАдресов.ИНЕТ;
        }


        /***********************************************************************


        ***********************************************************************/

        бкрат порт()
        {
                return с8хбк(син.портИС);
        }


        /***********************************************************************


        ***********************************************************************/

        бцел адр()
        {
                return с8хбц(син.адрИС);
        }


        /***********************************************************************

                -порт- can be ПОРТ_ЛЮБОЙ
                -адр- is an ИП адрес or хост имя

        ***********************************************************************/

        this(ткст адр, цел порт = ПОРТ_ЛЮБОЙ)
        {
                бцел uiAddr = разбор(адр);
                if(АДР_НЕУК == uiAddr)
                {
                        НетХост ih = new НетХост;
                        if(!ih.дайХостПоИмени(адр))
                          {
                          сим[16] врем =void;
                          исключение ("Не удаётся разобрать "~адр~":"~.вТкст(врем, порт));
                          }
                        uiAddr = ih.АдрСписок[0];
                }
                син.адрИС = х8сбц(uiAddr);
                син.портИС = х8сбк(cast(бкрат) порт);
        }


        /***********************************************************************


        ***********************************************************************/

        this(бцел адр, бкрат порт)
        {
                син.адрИС = х8сбц(адр);
                син.портИС = х8сбк(порт);
        }


        /***********************************************************************


        ***********************************************************************/

        this(бкрат порт)
        {
                син.адрИС = 0; //any, "0.0.0.0"
                син.портИС = х8сбк(порт);
        }

        /***********************************************************************


        ***********************************************************************/

        synchronized ткст вТкстАдреса()
        {
		адрес_ин адр;
		адр.с_адр = син.адрИС;
                return инетс8а(адр).dup;
        }


        /***********************************************************************


        ***********************************************************************/

        ткст вТкстПорта()
        {
                return .вТкст (_port, порт());
        }


        /***********************************************************************


        ***********************************************************************/

        ткст вТкст()
        {
                return вТкстАдреса() ~ ":" ~ вТкстПорта();
        }


        /***********************************************************************

                -адр- is an ИП адрес in the форматируй "a.b.c.d"
                returns АДР_НЕУК on failure

        ***********************************************************************/

        static бцел разбор(ткст адр)
        {
                сим[64] врем;

                synchronized (АдресИПв4.classinfo)
                              return с8хбц(адр_инет(преобразуй2Си (адр, врем)));
        }
}

debug(Unittest)
{
unittest
{
        АдресИПв4 ia = new АдресИПв4("63.105.9.61", 80);
        assert(ia.вТкст() == "63.105.9.61:80");
}
}

/*******************************************************************************


*******************************************************************************/

//набор of СОКЕТs for Сокет.выбери()
class НаборСокетов
{
        private бцел  члоБайт; //Win32: excludes бцел.размер "счёт"
        private байт* буф;

        version(Win32)
        {
                бцел счёт()
                {
                        return *(cast(бцел*)буф);
                }


                проц счёт(цел setter)
                {
                        *(cast(бцел*)буф) = setter;
                }


                т_сокет* первый()
                {
                        return cast(т_сокет*)(буф + бцел.sizeof);
                }
        }
        else version (Posix)
        {
                import core.BitManip;


                бцел nfdbits;
                т_сокет _maxfd = 0;

                бцел fdelt(т_сокет s)
                {
                        return cast(бцел)s / nfdbits;
                }


                бцел fdmask(т_сокет s)
                {
                        return 1 << cast(бцел)s % nfdbits;
                }


                бцел* первый()
                {
                        return cast(бцел*)буф;
                }

                public т_сокет максуд()
                {
                        return _maxfd;
                }
        }


        public:
        /***********************************************************************


        ***********************************************************************/

        this (бцел max)
        {
                version(Win32)
                {
                        члоБайт = max * т_сокет.sizeof;
                        буф = (new байт[члоБайт + бцел.sizeof]).ptr;
                        счёт = 0;
                }
                else version (Posix)
                {
                        if (max <= 32)
                            члоБайт = 32 * бцел.sizeof;
                        else
                           члоБайт = max * бцел.sizeof;

                        буф = (new байт[члоБайт]).ptr;
                        nfdbits = члоБайт * 8;
                        //очисть(); //new initializes куда 0
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        this (НаборСокетов o) 
        {
                члоБайт = o.члоБайт;
                auto размер = члоБайт;
                version (Win32) 
                         размер += бцел.sizeof;

                version (Posix) 
                        {
                        nfdbits = o.nfdbits;
                        _maxfd = o._maxfd;
                        }
                
                auto b = new байт[размер];
                b[] = o.буф[0..размер];
                буф = b.ptr;
        }

        /***********************************************************************


        ***********************************************************************/

        this()
        {
                version(Win32)
                {
                        this(64);
                }
                else version (Posix)
                {
                        this(32);
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/
        
        НаборСокетов dup() 
        {
                return new НаборСокетов (this);
        }
        
        /***********************************************************************


        ***********************************************************************/

        проц сбрось()
        {
                version(Win32)
                {
                        счёт = 0;
                }
                else version (Posix)
                {
                        буф[0 .. члоБайт] = 0;
                        _maxfd = 0;
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        проц добавь(т_сокет s)
        in
        {
                version(Win32)
                {
                        assert(счёт < макс); //добавьed too many СОКЕТs; specify a higher max in the constructor
                }
        }
        body
        {
                version(Win32)
                {
                        бцел c = счёт;
                        первый[c] = s;
                        счёт = c + 1;
                }
                else version (Posix)
                {
                        if (s > _maxfd)
                                _maxfd = s;

                        bts(cast(бцел*)&первый[fdelt(s)], cast(бцел)s % nfdbits);
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        проц добавь(Сокет s)
        {
                добавь(s.сок);
        }

        /***********************************************************************


        ***********************************************************************/

        проц удали(т_сокет s)
        {
                version(Win32)
                {
                        бцел c = счёт;
                        т_сокет* старт = первый;
                        т_сокет* stop = старт + c;

                        for(; старт != stop; старт++)
                        {
                                if(*старт == s)
                                        goto найдено;
                        }
                        return; //не найден

                        найдено:
                        for(++старт; старт != stop; старт++)
                        {
                                *(старт - 1) = *старт;
                        }

                        счёт = c - 1;
                }
                else version (Posix)
                {
                        btr(cast(бцел*)&первый[fdelt(s)], cast(бцел)s % nfdbits);

                        // If we're removing the biggest файл descrИПtor we've
                        // entered so far we need куда recalculate this значение
                        // for the сокет установи.
                        if (s == _maxfd)
                        {
                                while (--_maxfd >= 0)
                                {
                                        if (набор_ли(_maxfd))
                                        {
                                                break;
                                        }
                                }
                        }
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        проц удали(Сокет s)
        {
                удали(s.сок);
        }

        /***********************************************************************


        ***********************************************************************/

        цел набор_ли(т_сокет s)
        {
                version(Win32)
                {
                        т_сокет* старт = первый;
                        т_сокет* stop = старт + счёт;

                        for(; старт != stop; старт++)
                        {
                                if(*старт == s)
                                        return да;
                        }
                        return нет;
                }
                else version (Posix)
                {
                        //return bt(cast(бцел*)&первый[fdelt(s)], cast(бцел)s % nfdbits);
                        цел индекс = cast(бцел)s % nfdbits;
                        return (cast(бцел*)&первый[fdelt(s)])[индекс / (бцел.sizeof*8)] & (1 << (индекс & ((бцел.sizeof*8) - 1)));
                }
                else
                {
                        static assert(0);
                }
        }

        /***********************************************************************


        ***********************************************************************/

        цел набор_ли(Сокет s)
        {
                return набор_ли(s.сок);
        }

        /***********************************************************************

                max СОКЕТs that can be добавьed, like FD_SETSIZE

        ***********************************************************************/

        бцел макс()
        {
                return члоБайт / т_сокет.sizeof;
        }

        /***********************************************************************


        ***********************************************************************/

        набор_уд* вНабор_УД()
        {
                return cast(набор_уд*)буф;
        }
}


