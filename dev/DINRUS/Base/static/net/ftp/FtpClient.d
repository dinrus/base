/**
 * Author:          Lester L. Martin II
 *                  UWB, bobef
 * Copyright:       (c) Lester L. Martin II
 *                  UWB, bobef
 * Based upon приор FtpClient.d
 * License:         BSD стиль: $(LICENSE)
 * Initial release:  August 8, 2008
 */

module net.ftp.FtpClient;

private
{
    import net.ftp.Telnet;
    import text.Util;
    import time.Clock;
    import text.Regex:    Regex;
    import time.chrono.Gregorian;
    import tpl.array;
    import net.device.Socket;
    import net.device.Berkeley;
    import io.device.Conduit;
    import io.device.Array;
    import io.device.File;

    import sys.common;

    import Текст = text.Util;
    import Ascii = text.Ascii;
    import Целое = text.convert.Integer;
    import Timestamp = text.convert.TimeStamp;
}

/******************************************************************************
* Делегат процесса FTP.
*
* Может потребоваться добавить сюда позицию рестарта, и использовать SIZE,
* чтобы определить процентность выполнения. Здесь представлено только число
* переданных данных.
*
* Параметры:
* поз =                 текущее смещение в потоке
 ******************************************************************************/
alias проц delegate(in т_мера поз) ХодФтп;

/******************************************************************************
 Формат перемещаемых данных.
 ******************************************************************************/
enum ПФорматФтп
{
    /**********************************************************************
     Указывает формат ASCII NON PRINT (преобразование окончаний строк в CRLF.)
     **********************************************************************/
    Аски,
    /**********************************************************************
     Указывает формат IMAGE (8-битный двоичный октет.)
     **********************************************************************/
    Образ,
}

/******************************************************************************
 Структура АдресФтп содержит всё необходимое для СоединениеФтп.
 ******************************************************************************/
struct АдресФтп
{
    static АдресФтп* opCall(ткст стр)
    {
        if(стр.length == 0)
            return пусто;
        try
        {
            auto возвр = new АдресФтп;
            //удали ftp://
            auto i = местоположениеОбразца(стр, "ftp://");
            if(i == 0)
                стр = стр[6 .. $];

            //проверка ника и/или пароля пользователь[:пароль]@
            i = местоположениеПеред(стр, '@');
            if(i != стр.length)
            {
                ткст up = стр[0 .. i];
                стр = стр[i + 1 .. $];
                i = местоположение(up, ':');
                if(i != up.length)
                {
                    возвр.пользователь = up[0 .. i];
                    возвр.пароль = up[i + 1 .. $];
                }
                else
                    возвр.пользователь = up;
            }

            //проверка порта
            i = местоположениеПеред(стр, ':');
            if(i != стр.length)
            {
                возвр.порт = cast(бцел) Целое.вДол(стр[i + 1 .. $]);
                стр = стр[0 .. i];
            }

            //проверка любых директорий после адреса
            i = местоположение(стр, '/');
            if(i != стр.length)
                возвр.дир = стр[i + 1 .. $];

            //остальное должно быть адресом
            возвр.адрес = стр[0 .. i];
            if(возвр.адрес.length == 0)
                return пусто;

            return возвр;

        }
        catch(Объект o)
        {
            return пусто;
        }
    }

    ткст адрес;
    ткст дир;
    ткст пользователь = "anonymous";
    ткст пароль = "anonymous@anonymous";
    бцел порт = 21;
}

/******************************************************************************
 Ответ сервера, состоящий из кода и потенциально многострочного
 сообщения.
 ******************************************************************************/
struct ОтветФтп
{
    /**********************************************************************
     Ответный код.

     Цифры в ответном коде могут использоваться для определения статуса
     программным путём.

     Первая Цифра (статус):
     1xx =             предварительный ответ положителен
     2xx =             положительный ответ, указывающий на завершение
     3xx =             положительный ответ, указывающий неполный статус
     4xx =             временный негативный ответ
     5xx =             постоянный негативный ответ

     Вторая Цифра (субъект):
     x0x =             условие, основанное на синтаксисе
     x1x =             информационное
     x2x =             соединение
     x3x =             аутентификация/обработка
     x5x =             файловая система
     **********************************************************************/
    сим[3] код = "000";

    /*********************************************************************
     Сообщение от сервера.

     With some responses, the сообщение may contain parseable information.
     Например, this is да of the 257 ответ.
     **********************************************************************/
    ткст сообщение = пусто;
}

/******************************************************************************
 Режим активного или пассивного подключения.
 ******************************************************************************/
enum ПТипСоединенияФтп
{
    /**********************************************************************
     Активное - сервер подпкючается к клиенту на открытый порт.
     **********************************************************************/
    Активное,
    /**********************************************************************
     Пассивное - сервер прослушивает подключение от клиента.
     **********************************************************************/
    Пассивное,
}

/******************************************************************************
 Детали о данных подключения.
 Используется для надлежащей отправки команд PORT и PASV.
 ******************************************************************************/
struct ДеталиПодключенияФтп
{
    /**********************************************************************
     Используемый тип.
     **********************************************************************/
    ПТипСоединенияФтп тип = ПТипСоединенияФтп.Пассивное;

    /**********************************************************************
     Адрес для передачи серверу.
     **********************************************************************/
    Адрес адрес = пусто;

    /**********************************************************************
     Адрес для актуальной прослушки.
     **********************************************************************/
    Адрес слушай = пусто;
}

/******************************************************************************
 Поддерживаемая фича FTP сервера.
 ******************************************************************************/
struct ЭлтФтп
{
    /**********************************************************************
     Поддерживаемая команда, напр. SIZE.
     **********************************************************************/
    ткст команда = пусто;
    /**********************************************************************
     Параметры для этой команды; напр. факты для MLST.
     **********************************************************************/
    ткст парамы = пусто;
}

/******************************************************************************
 Тип файла в листинге FTP.
 ******************************************************************************/
enum ПТипФайлаФтп
{
    /**********************************************************************
     Неизвестный файл или тип (без фактического типа.)
     **********************************************************************/
    Неизвестен,
    /**********************************************************************
     Регулярный файл или нечто подобное.
     **********************************************************************/
    Файл,
    /**********************************************************************
     Текущая директория (напр. ., но не обязательно.)
     **********************************************************************/
    Текдир,
    /**********************************************************************
     Директория-родитель (обычно "..".)
     **********************************************************************/
    Предокдир,
    /**********************************************************************
     Директория любого другого типа.
     **********************************************************************/
    Дрдир,
    /**********************************************************************
     Другой тип файла.  Consult the "тип" fact.
     **********************************************************************/
    Другой,
}

/******************************************************************************
 Информация о файле в листинге FTP.
 ******************************************************************************/
struct ИнфОФайлеФтп
{
    /**********************************************************************
     Имя файла.
     **********************************************************************/
    ткст имя = пусто;
    /**********************************************************************
     Его тип.
     **********************************************************************/
    ПТипФайлаФтп тип = ПТипФайлаФтп.Неизвестен;
    /**********************************************************************
     Размер in байты (8 bit octets), либо бдол.max if not available.
     Since: 0.99.8
     **********************************************************************/
    бдол размер = бдол.max;
    /**********************************************************************
     Modification время, if available.
     **********************************************************************/
    Время изменён = Время.макс;
    /**********************************************************************
     Creation время, if available (not often.)
     **********************************************************************/
    Время создан = Время.макс;
    /**********************************************************************
     The файл's mime тип, if known.
     **********************************************************************/
    ткст майм = пусто;
    /***********************************************************************
     An associative Массив of все факты returned by the сервер, lowercased.
     ***********************************************************************/
    ткст[ткст] факты;
}

/*******************************************************************************
 Changed location Since: 0.99.8
 Documentation Pending
 *******************************************************************************/
class ИсклФтп: Исключение
{
    сим[3] responseCode_ = "000";

    /***********************************************************************
     Конструирует ИсклФтп based on a сообщение и код.

     Параметры:
     сообщение =         the исключение сообщение
     код =            the код (5xx for фатал ошибки)
     ***********************************************************************/
    this(ткст сообщение, сим[3] код = "420")
    {
        this.responseCode_[] = код;
        super(сообщение);
    }

    /***********************************************************************
     Конструирует ИсклФтп based on a ответ.

     Параметры:
     r =               the сервер ответ
     ***********************************************************************/
    this(ОтветФтп r)
    {
        this.responseCode_[] = r.код;
        super(r.сообщение);
    }

    /***********************************************************************
     A ткст представление of the ошибка.
     ***********************************************************************/
    ткст вТкст()
    {
        ткст буфер = new сим[this.сооб.length + 4];

        буфер[0 .. 3] = this.responseCode_;
        буфер[3] = ' ';
        буфер[4 .. буфер.length] = this.сооб;

        return буфер;
    }
}

/*******************************************************************************
 Seriously изменён Since: 0.99.8
 Documentation pending
 *******************************************************************************/
class СоединениеФтп: Telnet
{

    ЭлтФтп[] supportedFeatures_ = пусто;
    ДеталиПодключенияФтп inf_;
    т_мера restartPos_ = 0;
    ткст currFile_ = "";
    Сокет dataСОКЕТ_;
    ИнтервалВремени timeout_ ;

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    public ИнтервалВремени таймаут()
    {
        return timeout_;
    }

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    public проц таймаут(ИнтервалВремени t)
    {
        timeout_ = t;
    }

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    public ИнтервалВремени времяШатдауна()
    {
        return timeout_ + timeout_;
    }

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    public ЭлтФтп[] поддерживаемыеВозможности()
    {
        if(supportedFeatures_ !is пусто)
        {
            return supportedFeatures_;
        }
        дайВозможности();
        return supportedFeatures_;
    }

    /***********************************************************************
     Изменено с версии: 0.99.8
     ***********************************************************************/
    проц исключение(ткст сообщение)
    {
        throw new ИсклФтп(сообщение);
    }

    /***********************************************************************
     Изменено с версии: 0.99.8
     ***********************************************************************/
    проц исключение(ОтветФтп fr)
    {
        исключение(fr.сообщение);
    }

    public this()
    {
        timeout_ = ИнтервалВремени.изМиллисек(5000);
    }

    public this(ткст имя_хоста, ткст ник = "anonymous",
                ткст пароль = "anonymous@anonymous", бцел порт = 21)
    {
        timeout_ = ИнтервалВремени.изМиллисек(5000);
        this.подключись(имя_хоста, ник, пароль, порт);
    }

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    public this(АдресФтп fad)
    {
        timeout_ = ИнтервалВремени.изМиллисек(5000);
        подключись(fad);
    }

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    public проц подключись(АдресФтп fad)
    {
        this.подключись(fad.адрес, fad.пользователь, fad.пароль, fad.порт);
    }

    /************************************************************************
     Изменено с версии: 0.99.8
     ************************************************************************/
    public проц подключись(ткст имя_хоста, ткст ник = "anonymous",
                                         ткст пароль = "anonymous@anonymous", бцел порт = 21)
    in
    {
        // We definitely need a имя_хоста и порт.
        assert(имя_хоста.length > 0);
        assert(порт > 0);
    }
    body
    {

        if(сокет_ !is пусто)
        {
            сокет_.закрой();
        }

        this.найдиДоступныйСервер(имя_хоста, порт);

        scope(failure)
        {
            закрой();
        }

        читайОтвет("220");

        if(ник.length == 0)
        {
            return;
        }

        шлиКоманду("USER", ник);
        ОтветФтп ответ = читайОтвет();

        if(ответ.код == "331")
        {
            шлиКоманду("PASS", пароль);
            ответ = читайОтвет();
        }

        if(ответ.код != "230" && ответ.код != "202")
        {
            исключение(ответ);
        }
    }

    public проц закрой()
    {
        //сделай sure no открой данные connection и if открой данные connection then затуши
        if(dataСОКЕТ_ !is пусто)
            this.завершиКомандуДанных(dataСОКЕТ_);
        if(сокет_ !is пусто)
        {
            try
            {
                шлиКоманду("QUIT");
                читайОтвет("221");
            }
            catch(ИсклФтп)
            {

            }

            сокет_.закрой();

            delete supportedFeatures_;
            delete сокет_;
        }
    }

    public проц устПассив()
    {
        inf_.тип = ПТипСоединенияФтп.Пассивное;

        delete inf_.адрес;
        delete inf_.слушай;
    }

    public проц устАктив(ткст ИП, бкрат порт, ткст ип_прослушки = пусто,
                                     бкрат порт_прослушки = 0)
    in
    {
        assert(ИП.length > 0);
        assert(порт > 0);
    }
    body
    {
        inf_.тип = ПТипСоединенияФтп.Активное;
        inf_.адрес = new АдресИПв4(ИП, порт);

        // A local-sопрe порт?
        if(порт_прослушки == 0)
            порт_прослушки = порт;

        // Any specific ИП в_ слушай on?
        if(ип_прослушки == пусто)
            inf_.слушай = new АдресИПв4(АдресИПв4.АДР_ЛЮБОЙ, порт_прослушки);
        else
            inf_.слушай = new АдресИПв4(ип_прослушки, порт_прослушки);
    }

    public проц cd(ткст пап)
    in
    {
        assert(пап.length > 0);
    }
    body
    {
        шлиКоманду("CWD", пап);
        читайОтвет("250");
    }

    public проц cdup()
    {
        шлиКоманду("CDUP");
        ОтветФтп fr = читайОтвет();
        if(fr.код == "200" || fr.код == "250")
            return;
        else
            исключение(fr);
    }

    public ткст текрабпап()
    {
        шлиКоманду("PWD");
        auto ответ = читайОтвет("257");

        return разбор257(ответ);
    }

    public проц chmod(ткст путь, цел режим)
    in
    {
        assert(путь.length > 0);
        assert(режим >= 0 && (режим >> 16) == 0);
    }
    body
    {
        ткст врем = "000";
        // Convert our octal parameter в_ a ткст.
        Целое.форматируй(врем, cast(дол) режим, "o");
        шлиКоманду("SITE CHMOD", врем, путь);
        читайОтвет("200");
    }

    public проц del(ткст путь)
    in
    {
        assert(путь.length > 0);
    }
    body
    {
        шлиКоманду("DELE", путь);
        auto ответ = читайОтвет("250");

        //Try it как дир, then...?
        if(ответ.код != "250")
            rm(путь);
    }

    public проц rm(ткст путь)
    in
    {
        assert(путь.length > 0);
    }
    body
    {
        шлиКоманду("RMD", путь);
        читайОтвет("250");
    }

    public проц переименуй(ткст old_path, ткст new_path)
    in
    {
        assert(old_path.length > 0);
        assert(new_path.length > 0);
    }
    body
    {
        // Rename из_... переименуй в_.  Pretty simple.
        шлиКоманду("RNFR", old_path);
        читайОтвет("350");

        шлиКоманду("RNTO", new_path);
        читайОтвет("250");
    }

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    цел есть_ли(ткст файл)
    {
        try
        {
            auto fi = дайИнфОФайле(файл);
            if(fi.тип == ПТипФайлаФтп.Файл)
            {
                return 1;
            }
            else if(fi.тип == ПТипФайлаФтп.Дрдир || fi.тип == ПТипФайлаФтп.Текдир || fi.тип == ПТипФайлаФтп.Предокдир)
            {
                return 2;
            }
        }
        catch(ИсклФтп o)
        {
            if(o.responseCode_ != "501")
            {
                return 0;
            }
        }
        return 0;
    }

    public т_мера размер(ткст путь, ПФорматФтп форматируй = ПФорматФтп.Образ)
    in
    {
        assert(путь.length > 0);
    }
    body
    {
        тип(форматируй);

        шлиКоманду("SIZE", путь);
        auto ответ = this.читайОтвет("213");

        // Only try в_ разбор the numeric байты of the ответ.
        т_мера end_pos = 0;
        while(end_pos < ответ.сообщение.length)
        {
            if(ответ.сообщение[end_pos] < '0' || ответ.сообщение[end_pos] > '9')
                break;
            end_pos++;
        }

        return cast(цел) Целое.разбор((ответ.сообщение[0 .. end_pos]));
    }

    public проц тип(ПФорматФтп форматируй)
    {
        if(форматируй == ПФорматФтп.Аски)
            шлиКоманду("TYPE", "A");
        else
            шлиКоманду("TYPE", "I");

        читайОтвет("200");
    }

    /***********************************************************************
     Добавлено с версии: 0.99.8
     ***********************************************************************/
    Время изменён(ткст файл)
    in
    {
        assert(файл.length > 0);
    }
    body
    {
        this.шлиКоманду("MDTM", файл);
        auto ответ = this.читайОтвет("213");

        // The whole ответ should be a значврем.
        return this.разборВремзнач(ответ.сообщение);
    }

    protected Время разборВремзнач(ткст значврем)
    {
        if(значврем.length < 14)
            throw new ИсклФтп("КЛИЕНТ: Не удаётся разобрать значврем", "501");

        return Грегориан.генерный.воВремя(
                   Целое.atoi(значврем[0 .. 4]),
                   Целое.atoi(значврем[4 .. 6]),
                   Целое.atoi(значврем[6 .. 8]),
                   Целое.atoi(значврем[8 .. 10]),
                   Целое.atoi(значврем[10 .. 12]),
                   Целое.atoi(значврем[12 .. 14]));
    }

    public проц noop()
    {
        this.шлиКоманду("NOOP");
        this.читайОтвет("200");
    }

    public ткст mkdir(ткст путь)
    in
    {
        assert(путь.length > 0);
    }
    body
    {
        this.шлиКоманду("MKD", путь);
        auto ответ = this.читайОтвет("257");

        return this.разбор257(ответ);
    }

    public проц дайВозможности()
    {
        this.шлиКоманду("FEAT");
        auto ответ = this.читайОтвет();

        // 221 means FEAT is supported, и a список follows.  Otherwise we don't know...
        if(ответ.код != "211")
            delete supportedFeatures_;
        else
        {
            ткст[] строки = Текст.рабейнастр(ответ.сообщение);

            // There are two ещё строки than features, but we also have FEAT.
            supportedFeatures_ = new ЭлтФтп[строки.length - 1];
            supportedFeatures_[0].команда = "FEAT";

            for(т_мера i = 1; i < строки.length - 1; i++)
            {
                т_мера поз = Текст.местоположение(строки[i], ' ');

                supportedFeatures_[i].команда = строки[i][0 .. поз];
                if(поз < строки[i].length - 1)
                    supportedFeatures_[i].парамы = строки[i][поз + 1 .. строки[i].length];
            }

            delete строки;
        }
    }

    public проц шлиКоманду(ткст команда, ткст[] параметры...)
    {

        ткст командаСокету = команда;

        // Отправка the команда, параметры, и then a CRLF.

        foreach(ткст param; параметры)
        {
            командаСокету ~= " " ~ param;

        }

        командаСокету ~= "\r\n";

        debug(FtpDebug)
        {
            Стдвыв.форматнс("[шлиКоманду] Отправка команды '{0}'",
                                          командаСокету);
        }
        отправьДанные(командаСокету);
    }

    public ОтветФтп читайОтвет(ткст ожидаемый_код)
    {
        debug(FtpDebug)
        {
            Стдвыв.форматнс("[читайОтвет] Ожидаемый Ответ {0}",
                                          ожидаемый_код)();
        }
        auto ответ = читайОтвет();
        debug(FtpDebug)
        {
            Стдвыв.форматнс("[читайОтвет] Действительный Ответ {0}", ответ.код)();
        }

        if(ответ.код != ожидаемый_код)
            исключение(ответ);

        return ответ;
    }

    public ОтветФтп читайОтвет()
    {
        assert(this.сокет_ !is пусто);

        // Pick a время at which we stop reading.  It can't возьми too дол, but it could возьми a bit for the whole ответ.
        Время end_time = Часы.сейчас + ИнтервалВремени.изМиллисек(2500) * 10;

        ОтветФтп ответ;
        ткст single_line = пусто;

        // Danger, Will Robinson, don't fall преобр_в an endless loop из_ a malicious сервер.
        while(Часы.сейчас < end_time)
        {
            single_line = this.читайСтроку();

            // This is the первый строка.
            if(ответ.сообщение.length == 0)
            {
                // The первый строка must have a код и then a пространство or hyphen.
                // #1
                // Response might be exactly 4 симвы e.g. '230-'
                // (see ftp-stud.fht-esslingen.de or ftp.sunfreeware.com)
                if(single_line.length < 4)
                {
                    ответ.код[] = "500";
                    break;
                }

                // The код is the первый three characters.
                ответ.код[] = single_line[0 .. 3];
                ответ.сообщение = single_line[4 .. single_line.length];
            }
            // This is either an extra строка, либо the последний строка.
            else
            {
                ответ.сообщение ~= "\n";

                // If the строка начинается like "123-", that is not часть of the ответ сообщение.
                if(single_line.length > 4 && single_line[0 .. 3] == ответ.код)
                    ответ.сообщение ~= single_line[4 .. single_line.length];
                // If it начинается with a пространство, that isn't either.
                else if(single_line.length > 2 && single_line[0] == ' ')
                    ответ.сообщение ~= single_line[1 .. single_line.length];
                else
                    ответ.сообщение ~= single_line;
            }

            // We're готово if the строка начинается like "123 ".  Otherwise we're not.
            // #1
            // Response might be exactly 4 симвы e.g. '220 '
            // (see ftp.knoppix.нс)
            if(single_line.length >= 4 && single_line[0 .. 3] == ответ.код && single_line[3] == ' ')
                break;
        }

        return ответ;
    }

    protected ткст разбор257(ОтветФтп ответ)
    {
        ткст путь = new сим[ответ.сообщение.length];
        т_мера поз = 1, длин = 0;

        // Since it should be quoted, it имеется в_ be at least 3 characters in length.
        if(ответ.сообщение.length <= 2)
            исключение(ответ);

        //assert (ответ.сообщение[0] == '"');

        // Trapse through the ответ...
        while(поз < ответ.сообщение.length)
        {
            if(ответ.сообщение[поз] == '"')
            {
                // #2
                // Is it the последний character?
                if(поз + 1 == ответ.сообщение.length)
                    // then we are готово
                    break;

                // An эскапирован quote, keep going.  Нет alarm.
                if(ответ.сообщение[++поз] == '"')
                    путь[длин++] = ответ.сообщение[поз];
                else
                    break;
            }
            else
                путь[длин++] = ответ.сообщение[поз];

            поз++;
        }

        // Okay, готово!  That wasn't too hard.
        путь.length = длин;
        return путь;
    }

    /*******************************************************************************
     Get a данные сокет из_ the сервер.

     This Отправкаs PASV/PORT as necessary.

     Возвращает:             the данные сокет or a listener
     Изменено с версии: 0.99.8
     *******************************************************************************/
    protected Сокет дайСокетДанных()
    {
        //сделай sure no открой данные connection и if открой данные connection then затуши
        if(dataСОКЕТ_ !is пусто)
            this.завершиКомандуДанных(dataСОКЕТ_);

        // What тип are we using?
        switch(this.inf_.тип)
        {
        default:
            исключение("подключение неизвестного типа");

        // Passive is complicated.  Дескр it in другой member.
        case ПТипСоединенияФтп.Пассивное:
            return this.подключисьПассивно();

        // Active is simpler, but not as fool-proof.
        case ПТипСоединенияФтп.Активное:
            АдресИПв4 data_Addr = cast(АдресИПв4) this.inf_.адрес;

            // Start listening.
            Сокет listener = new Сокет;
            listener.вяжи(this.inf_.слушай);
            listener.сокет.слушай(32);

            // Use EPRT if we know it's supported.
            if(this.поддерживается_ли("EPRT"))
            {
                сим[64] врем =void;

                this.шлиКоманду("EPRT", Текст.выкладка(врем, "|1|%0|%1|",
                                          data_Addr.вТкстАдреса, data_Addr.вТкстПорта));
                // this.шлиКоманду("EPRT", форматируй("|1|%s|%s|", data_Addr.вТкстАдреса(), data_Addr.вТкстПорта()));
                this.читайОтвет("200");
            }
            else
            {
                цел h1, h2, h3, h4, p1, p2;
                h1 = (data_Addr.адр() >> 24) % 256;
                h2 = (data_Addr.адр() >> 16) % 256;
                h3 = (data_Addr.адр() >> 8_) % 256;
                h4 = (data_Addr.адр() >> 0_) % 256;
                p1 = (data_Addr.порт() >> 8_) % 256;
                p2 = (data_Addr.порт() >> 0_) % 256;

                // low overhead метод в_ форматируй a numerical ткст
                сим[64] врем =void;
                сим[20] foo =void;
                auto стр = Текст.выкладка(врем, "%0,%1,%2,%3,%4,%5",
                              Целое.форматируй(foo[0 .. 3], h1),
                              Целое.форматируй(foo[3 .. 6], h2),
                              Целое.форматируй(foo[6 .. 9], h3),
                              Целое.форматируй(foo[9 .. 12], h4),
                              Целое.форматируй(foo[12 .. 15], p1),
                              Целое.форматируй(foo[15 .. 18], p2));

                // This formatting is weird.
                // this.шлиКоманду("PORT", форматируй("%d,%d,%d,%d,%d,%d", h1, h2, h3, h4, p1, p2));

                this.шлиКоманду("PORT", стр);
                this.читайОтвет("200");
            }

            return listener;
        }
    }

    /*******************************************************************************
     Отправка PASV и инициализация соединения.

     Возвращает:             подключенный сокет
      *******************************************************************************/
    public Сокет подключисьПассивно()
    {
        Адрес connect_to = пусто;

        // SPSV, просто номер порта.
        if(this.поддерживается_ли("SPSV"))
        {
            this.шлиКоманду("SPSV");
            auto ответ = this.читайОтвет("227");

            // Подключение в тому же хосту.
            АдресИПв4
            remote = cast(АдресИПв4) this.сокет_.сокет.удалённыйАдрес();
            assert(remote !is пусто);

            бцел адрес = remote.адр();
            бцел порт = cast(цел) Целое.разбор(((ответ.сообщение)));

            connect_to = new АдресИПв4(адрес, cast(бкрат) порт);
        }
        // Расширенный пассивный режим (ИП v6, etc.)
        else if(this.поддерживается_ли("EPSV"))
        {
            this.шлиКоманду("EPSV");
            auto ответ = this.читайОтвет("229");

            // Попытка вытянуть (возможно, не в кавычках) адрес.
            auto r = Regex(`\([^0-9][^0-9][^0-9](\d+)[^0-9]\)`);
            if(!r.тест(ответ.сообщение[0 .. найди(ответ.сообщение, '\n')]))
                throw new ИсклФтп("КЛИЕНТ: Не удаётся разобрать адрес", "501");

            АдресИПв4
            remote = cast(АдресИПв4) this.сокет_.сокет.удалённыйАдрес();
            assert(remote !is пусто);

            бцел адрес = remote.адр();
            бцел порт = cast(цел) Целое.разбор(((r.сверь(1))));

            connect_to = new АдресИПв4(адрес, cast(бкрат) порт);
        }
        else
        {
            this.шлиКоманду("PASV");
            auto ответ = this.читайОтвет("227");

            // Try в_ pull out the (possibly not parenthesized) адрес.
            auto r = Regex(`(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)(,\s*(\d+))?`);
            if(!r.тест(ответ.сообщение[0 .. найди(ответ.сообщение, '\n')]))
                throw new ИсклФтп("КЛИЕНТ: Не удаётся разобрать адрес", "501");

            // Сейчас помести it преобр_в something std.сокет will understand.
            ткст адрес = r.сверь(1) ~ "." ~ r.сверь(2) ~ "." ~ r.сверь(3) ~ "." ~ r.сверь(4);
            бцел порт = (((cast(цел) Целое.разбор(r.сверь(5))) << 8) + (r.сверь(7).
                                 length > 0 ? cast(цел) Целое.разбор(r.сверь(7)) : 0));

            // Okay, we've got it!
            connect_to = new АдресИПв4(адрес, порт);
        }

        scope(exit)
        delete connect_to;

        // This will throw an исключение if it cannot подключись.
        auto сок = new Сокет;
        сок.подключись(connect_to);
        return сок;
    }

    /*
     Сокет сок = new Сокет();
     сок.подключись(connect_to);
     return сок;
     */

    public бул поддерживается(ткст команда)
    in
    {
        assert(команда.length > 0);
    }
    body
    {
        if(this.supportedFeatures_.length == 0)
            return да;

        // Поиск through the список for the feature.
        foreach(ЭлтФтп feat; this.supportedFeatures_)
        {
            if(Ascii.сравнилюб(feat.команда, команда) == 0)
                return да;
        }

        return нет;
    }

    public бул поддерживается_ли(ткст команда)
    {
        if(this.supportedFeatures_.length == 0)
            return нет;

        return this.поддерживается(команда);
    }

    /*******************************************************************************
     Подготовить данные сокета для использования.
     В некоторых случаях модифицирует сокет.

     Параметры:
     данные =            сокет прослушивателя данных
     ********************************************************************************/
    protected проц подготовьСокетДанных(ref Сокет данные)
    {
        switch(this.inf_.тип)
        {
        default:
            исключение("подключение неизвестного типа");

        case ПТипСоединенияФтп.Активное:
            Беркли new_data;

            scope набор = new net.device.Berkeley.НаборСокетов;

            // At end_time, we bail.
            Время end_time = Часы.сейчас + this.таймаут;

            while(Часы.сейчас < end_time)
            {
                набор.сбрось();
                набор.добавь(данные.сокет);

                // Can we прими yet?
                цел код = набор.выбери(набор, пусто, пусто, cast(дол)таймаут.микросек);
                if(код == -1 || код == 0)
                    break;

                данные.сокет.прими(new_data);
                break;
            }

            if(new_data.сок is new_data.сок.init)
                throw new ИсклФтп("КЛИЕНТ: Нет подключения к серверу", "420");

            // We don't need the listener anymore.
            данные.глуши.открепи;

            // This is the actual сокет.
            данные.сокет.сок = new_data.сок;
            break;

        case ПТипСоединенияФтп.Пассивное:
            break;
        }
    }

    /*****************************************************************************
     Изменено с версии: 0.99.8
     *****************************************************************************/
    public проц завершиКомандуДанных(Сокет данные)
    {
        // Close the сокет.  This tells the сервер we're готово (EOF.)
        данные.закрой();
        данные.открепи();

        // We shouldn't получи a 250 in Поток режим.
        ОтветФтп r = читайОтвет();
        if(!(r.код == "226" || r.код == "420"))
            исключение("Плохой финиш");

    }

    /*****************************************************************************
     Изменено с версии: 0.99.8
     *****************************************************************************/
    public Сокет обработайКомандуДанных(ткст команда, ткст[] параметры...)
    {
        // Создаёт connection.
        Сокет данные = this.дайСокетДанных();
        scope(failure)
        {
            // Close the сокет, whether we were listening or not.
            данные.закрой();
        }

        // Tell the сервер about it.
        this.шлиКоманду(команда, параметры);

        // We should всегда получи a 150/125 ответ.
        auto ответ = this.читайОтвет();
        if(ответ.код != "150" && ответ.код != "125")
            исключение(ответ);

        // We might need в_ do this for активное connections.
        this.подготовьСокетДанных(данные);

        return данные;
    }

    public ИнфОФайлеФтп[] ls(ткст путь = "")
    // default в_ текущ Пап
    in
    {
        assert(путь.length == 0 || путь[путь.length - 1] != '/');
    }
    body
    {
        ИнфОФайлеФтп[] пап;

        // We'll try MLSD (which is so much better) первый... but it may краш.
        бул mlsd_success = нет;
        Сокет данные = пусто;

        // Try it if it could/might/maybe is supported.
        if(this.поддерживается("MLST"))
        {
            mlsd_success = да;

            // Since this is a данные команда, обработайКомандуДанных handles
            // проверьing the ответ... just catch its Исключение.
            try
            {
                if(путь.length > 0)
                    данные = this.обработайКомандуДанных("MLSD", путь);
                else
                    данные = this.обработайКомандуДанных("MLSD");
            }
            catch(ИсклФтп)
                mlsd_success = нет;
        }

        // If it passed, разбор away!
        if(mlsd_success)
        {
            auto listing = new io.device.Array.Массив(256, 65536);
            this.читайПоток(данные, listing);
            this.завершиКомандуДанных(данные);

            // Each строка is something in that дир.
            ткст[] строки = Текст.рабейнастр(cast(ткст) listing.срез());
            scope(exit)
            delete строки;

            foreach(ткст строка; строки)
            {
                if(строка.length == 0)
                    continue;
                // Parse each строка exactly like MLST does.
                try
                {
                    ИнфОФайлеФтп инфо = this.разборСтрокиМлст(строка);
                    if(инфо.имя.length > 0)
                        пап ~= инфо;
                }
                catch(ИсклФтп)
                {
                    return this.шлиКомандуСписок(путь);
                }
            }

            return пап;
        }
        // Fall задний в_ LIST.
        else
            return this.шлиКомандуСписок(путь);
    }

    /*****************************************************************************
     Изменено с версии: 0.99.8
     *****************************************************************************/
    protected проц читайПоток(Сокет данные, ИПотокВывода поток,
                                            ХодФтп ход = пусто)
    in
    {
        assert(данные !is пусто);
        assert(поток !is пусто);
    }
    body
    {
        // Набор up a НаборСокетов so we can use выбери() - it's pretty efficient.
        scope установи = new НаборСокетов;

        // At end_time, we bail.
        Время end_time = Часы.сейчас + this.таймаут;

        // This is the буфер the поток данные is stored in.
        ббайт[8 * 1024] буф;
        цел buf_size = 0;

        бул completed = нет;
        т_мера поз;
        while(Часы.сейчас < end_time)
        {
            установи.сбрось();
            установи.добавь(данные.сокет);

            // Can we читай yet, can we читай yet?
            цел код = установи.выбери(установи, пусто, пусто, таймаут.микросек);
            if(код == -1 || код == 0)
                break;

            buf_size = данные.сокет.принять(буф);
            if(buf_size == данные.сокет.ОШИБКА)
                break;

            if(buf_size == 0)
            {
                completed = да;
                break;
            }

            поток.пиши(буф[0 .. buf_size]);

            поз += buf_size;
            if(ход !is пусто)
                ход(поз);

            // Give it ещё время as дол as данные is going through.
            end_time = Часы.сейчас + this.таймаут;
        }

        // Dопр все the данные получи Приёмd?
        if(!completed)
            throw new ИсклФтп("КЛИЕНТ: Таймаут при чтении данных", "420");
    }

    /*****************************************************************************
     Изменено с версии: 0.99.8
     *****************************************************************************/
    protected проц шлиВПоток(Сокет данные, ИПотокВвода поток,
                                          ХодФтп ход = пусто)
    in
    {
        assert(данные !is пусто);
        assert(поток !is пусто);
    }
    body
    {
        // Набор up a НаборСокетов so we can use выбери() - it's pretty efficient.
        scope установи = new НаборСокетов;

        // At end_time, we bail.
        Время end_time = Часы.сейчас + this.таймаут;

        // This is the буфер the поток данные is stored in.
        ббайт[8 * 1024] буф;
        т_мера buf_size = 0, buf_pos = 0;
        цел дельта = 0;

        т_мера поз = 0;
        бул completed = нет;
        while(!completed && Часы.сейчас < end_time)
        {
            установи.сбрось();
            установи.добавь(данные.сокет);

            // Can we пиши yet, can we пиши yet?
            цел код = установи.выбери(пусто, установи, пусто, таймаут.микросек);
            if(код == -1 || код == 0)
                break;

            if(buf_size - buf_pos <= 0)
            {
                if((buf_size = поток.читай(буф)) is поток.Кф)
                    buf_size = 0, completed = да;
                buf_pos = 0;
            }

            // Отправка the чанк (or as much of it as possible!)
            дельта = данные.сокет.шли(буф[buf_pos .. buf_size]);
            if(дельта == данные.сокет.ОШИБКА)
                break;

            buf_pos += дельта;

            поз += дельта;
            if(ход !is пусто)
                ход(поз);

            // Give it ещё время as дол as данные is going through.
            if(дельта != 0)
                end_time = Часы.сейчас + this.таймаут;
        }

        // Dопр все the данные получи sent?
        if(!completed)
            throw new ИсклФтп("КЛИЕНТ: Таймаут при отправке данных", "420");
    }

    protected ИнфОФайлеФтп[] шлиКомандуСписок(ткст путь)
    {
        ИнфОФайлеФтп[] пап;
        Сокет данные = пусто;

        if(путь.length > 0)
            данные = this.обработайКомандуДанных("LIST", путь);
        else
            данные = this.обработайКомандуДанных("LIST");

        // Чит in the stupопр non-standardized ответ.
        auto listing = new io.device.Array.Массив(256, 65536);
        this.читайПоток(данные, listing);
        this.завершиКомандуДанных(данные);

        // разбей out the строки.  Most of the время, it's one-в_-one.
        ткст[] строки = Текст.рабейнастр(cast(ткст) listing.срез());
        scope(exit)
        delete строки;

        foreach(ткст строка; строки)
        {
            if(строка.length == 0)
                continue;
            // If there are no пробелы, либо if there's only one... пропусти the строка.
            // This is probably like a "total 8" строка.
            if(Текст.местоположение(строка, ' ') == Текст.местоположениеПеред(строка, ' '))
                continue;

            // Сейчас разбор the строка, либо try в_.
            ИнфОФайлеФтп инфо = this.разборСтрокиСписка(строка);
            if(инфо.имя.length > 0)
                пап ~= инфо;
        }

        return пап;
    }

    protected ИнфОФайлеФтп разборСтрокиСписка(ткст строка)
    {
        ИнфОФайлеФтп инфо;
        т_мера поз = 0;

        // Convenience function в_ разбор a word из_ the строка.
        ткст parse_word()
        {
            т_мера старт = 0, конец = 0;

            // SkИП пробел перед.
            while(поз < строка.length && строка[поз] == ' ')
                поз++;

            старт = поз;
            while(поз < строка.length && строка[поз] != ' ')
                поз++;
            конец = поз;

            // SkИП пробел после.
            while(поз < строка.length && строка[поз] == ' ')
                поз++;

            return строка[старт .. конец];
        }

        // We have в_ sniff this... :/.
        switch(!Текст.содержит("0123456789", строка[0]))
        {
        // Not a число; this is ЮНИКС форматируй.
        case да:
            // The строка must be at least 20 characters дол.
            if(строка.length < 20)
                return инфо;

            // The первый character tells us что it is.
            if(строка[0] == 'd')
                инфо.тип = ПТипФайлаФтп.Дрдир;
            // #3
            // Might be a link Запись - добавьitional тест down below
            else if(строка[0] == 'l')
                инфо.тип = ПТипФайлаФтп.Другой;
            else if(строка[0] == '-')
                инфо.тип = ПТипФайлаФтп.Файл;
            else
                инфо.тип = ПТипФайлаФтп.Неизвестен;

            // Parse out the режим... rwxrwxrwx = 777.
            ткст unix_mode = "0000".dup;
            проц read_mode(цел цифра)
            {
                for(поз = 1 + цифра * 3; поз <= 3 + цифра * 3; поз++)
                {
                    if(строка[поз] == 'r')
                        unix_mode[цифра + 1] |= 4;
                    else if(строка[поз] == 'w')
                        unix_mode[цифра + 1] |= 2;
                    else if(строка[поз] == 'x')
                        unix_mode[цифра + 1] |= 1;
                }
            }

            // This makes it easier, huh?
            read_mode(0);
            read_mode(1);
            read_mode(2);

            инфо.факты["UNIX.mode"] = unix_mode;

            // #4
            // Not only разбор строки like
            //    drwxrwxr-x    2 10490    100          4096 May 20  2005 Acrobat
            //    lrwxrwxrwx    1 корень     другой           7 Sep 21  2007 Broker.link -> Acrobat
            //    -rwxrwxr-x    1 filelib  100           468 Nov  1  1999 Web_Users_Click_Here.html
            // but also разбор строки like
            //    d--x--x--x   2 staff        512 Sep 24  2000 dev
            // (see ftp.sunfreeware.com)

            // Links, хозяин.  These are hard в_ translate в_ MLST факты.
            parse_word();
            parse_word();

            // Group or размер in байты
            ткст group_or_size = parse_word();
            т_мера oldpos = поз;

            // Размер in байты or месяц
            ткст size_or_month = parse_word();

            if(!Текст.содержит("0123456789", size_or_month[0]))
            {
                // Oops, no размер here - go задний в_ previous column
                поз = oldpos;
                инфо.размер = cast(бдол) Целое.разбор(group_or_size);
            }
            else
                инфо.размер = cast(бдол) Целое.разбор(size_or_month);

            // Make sure we still have enough пространство.
            if(поз + 13 >= строка.length)
                return инфо;

            // Not parsing дата for сейчас.  It's too weird (последний 12 месяцы, etc.)
            поз += 13;

            инфо.имя = строка[поз .. строка.length];
            // #3
            // Might be a link Запись - добавьitional тест here
            if(инфо.тип == ПТипФайлаФтп.Другой)
            {
                // Is имя like 'имя -> /some/другой/путь'?
                т_мера pos2 = Текст.местоположениеОбразца(инфо.имя, " -> ");
                if(pos2 != инфо.имя.length)
                {
                    // It is a link - разбей преобр_в мишень и имя
                    инфо.факты["target"] = инфо.имя[pos2 + 4 .. инфо.имя.length];
                    инфо.имя = инфо.имя[0 .. pos2];
                    инфо.факты["type"] = "link";
                }
            }
            break;

        // A число; this is DOS форматируй.
        case нет:
            // We need some данные here, в_ разбор.
            if(строка.length < 18)
                return инфо;

            // The order is 1 MM, 2 DD, 3 YY, 4 HH, 5 MM, 6 P
            auto r = Regex(`(\d\d)-(\d\d)-(\d\d)\s+(\d\d):(\d\d)(A|P)M`);
            // #5
            // wrong тест
            if(!r.тест(строка))
                return инфо;

            if(Timestamp.досвремя(r.сверь(0), инфо.изменён) is 0)
                инфо.изменён = Время.макс;

            поз = r.сверь(0).length;
            delete r;

            // This will either be <Пап>, либо a число.
            ткст dir_or_size = parse_word();

            if(dir_or_size.length < 0)
                return инфо;
            else if(dir_or_size[0] == '<')
                инфо.тип = ПТипФайлаФтп.Дрдир;
            else
            {
                // #5
                // It is a файл
                инфо.размер = cast(бдол) Целое.разбор((dir_or_size));
                инфо.тип = ПТипФайлаФтп.Файл;
            }

            инфо.имя = строка[поз .. строка.length];
            break;

        // Something else, not supported.
        default:
            throw new ИсклФтп("КЛИЕНТ: Неподдерживаемый формат LIST", "501");
        }

        // Try в_ fix the тип?
        if(инфо.имя == ".")
            инфо.тип = ПТипФайлаФтп.Текдир;
        else if(инфо.имя == "..")
            инфо.тип = ПТипФайлаФтп.Предокдир;

        return инфо;
    }

    protected ИнфОФайлеФтп разборСтрокиМлст(ткст строка)
    {
        ИнфОФайлеФтп инфо;

        // After this loop, filename_pos will be location of пространство + 1.
        т_мера filename_pos = 0;
        while(filename_pos < строка.length && строка[filename_pos++] != ' ')
            continue;

        if(filename_pos == строка.length)
            throw new ИсклФтп("КЛИЕНТ: Плохой синтаксис в ответе MLSx", "501");
        /*{
         инфо.имя = "";
         return инфо;
         }*/

        инфо.имя = строка[filename_pos .. строка.length];

        // Everything else is frosting on верх.
        if(filename_pos > 1)
        {
            ткст[]
            temp_facts = Текст.разграничь(строка[0 .. filename_pos - 1], ";");

            // Go through each fact и разбор them преобр_в the Массив.
            foreach(ткст fact; temp_facts)
            {
                цел поз = Текст.местоположение(fact, '=');
                if(поз == fact.length)
                    continue;

                инфо.факты[Ascii.вПроп(fact[0 .. поз])] = fact[поз + 1 .. fact.length];
            }

            // Do we have a тип?
            if("type" in инфо.факты)
            {
                // Some reflection might be nice here.
                switch(Ascii.вПроп(инфо.факты["type"]))
                {
                case "file":
                    инфо.тип = ПТипФайлаФтп.Файл;
                    break;

                case "cdir":
                    инфо.тип = ПТипФайлаФтп.Текдир;
                    break;

                case "pdir":
                    инфо.тип = ПТипФайлаФтп.Предокдир;
                    break;

                case "dir":
                    инфо.тип = ПТипФайлаФтп.Дрдир;
                    break;

                default:
                    инфо.тип = ПТипФайлаФтп.Другой;
                }
            }

            // Размер, mime, etc...
            if("size" in инфо.факты)
                инфо.размер = cast(бдол) Целое.разбор((инфо.факты["size"]));
            if("media-type" in инфо.факты)
                инфо.майм = инфо.факты["media-type"];

            // And the two dates.
            if("modify" in инфо.факты)
                инфо.изменён = this.разборВремзнач(инфо.факты["modify"]);
            if("create" in инфо.факты)
                инфо.создан = this.разборВремзнач(инфо.факты["create"]);
        }

        return инфо;
    }

    public ИнфОФайлеФтп дайИнфОФайле(ткст путь)
    in
    {
        assert(путь.length > 0);
    }
    body
    {
        // Start assuming the MLST dопрn't work.
        бул mlst_success = нет;
        ОтветФтп ответ;
        auto inf = ls(путь);
        if(inf.length == 1)
            return inf[0];
        else {
            debug(FtpUnitTest)
            {
                Стдвыв("In дайИнфОФайле.").нс.слей;
            }
            {
                // Отправка a список команда.  This may список the contents of a дир, even.
                ИнфОФайлеФтп[] temp = this.шлиКомандуСписок(путь);

                // If there wasn't at least one строка, the файл dопрn't есть_ли?
                // We should have already handled that.
                if(temp.length < 1)
                    throw new ИсклФтп(
                        "КЛИЕНТ: Плохой ответ LIST от сервера", "501");

                // If there are multИПle строки, try в_ return the correct one.
                if(temp.length != 1)
                    foreach(ИнфОФайлеФтп инфо; temp)
                {
                    if(инфо.тип == ПТипФайлаФтп.Текдир)
                        return инфо;
                }

                // Okay then, the первый строка.  Наилучший we can do?
                return temp[0];
            }
        }
    }

    public проц помести(ткст путь, ткст локальн_файл,
                                   ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.Образ)
    in
    {
        assert(путь.length > 0);
        assert(локальн_файл.length > 0);
    }
    body
    {
        // Открыть the файл for reading...
        auto файл = new Файл(локальн_файл);
        scope(exit)
        {
            файл.открепи();
            delete файл;
        }

        // Seek в_ the correct place, if specified.
        if(this.restartPos_ > 0)
        {
            файл.сместись(this.restartPos_);
            this.restartPos_ = 0;
        }
        else {
            // Размести пространство for the файл, if we need в_.
            //this.размести(файл.length);
        }

        // Сейчас that it's открой, we do что we всегда do.
        this.помести(путь, файл, ход, форматируй);
    }

    /********************************************************************************
     Store данные из_ a поток on the сервер.

     Calling this function will change the текущ данные перемести форматируй.

     Параметры:
     путь =            the путь в_ the remote файл
     поток =          данные в_ сохрани, либо пусто for a blank файл
     ход =        a delegate в_ вызов with ход information
     форматируй =          что форматируй в_ шли the данные in
     ********************************************************************************/
    public проц помести(ткст путь, ИПотокВвода поток = пусто,
                                   ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.Образ)
    in
    {
        assert(путь.length > 0);
    }
    body
    {
        // Change в_ the specified форматируй.
        this.тип(форматируй);

        // Okay сервер, we want в_ сохрани something...
        Сокет данные = this.обработайКомандуДанных("STOR", путь);

        // Отправка the поток over the сокет!
        if(поток !is пусто)
            this.шлиВПоток(данные, поток, ход);

        this.завершиКомандуДанных(данные);
    }

    /********************************************************************************
     Доб данные в_ a файл on the сервер.

     Calling this function will change the текущ данные перемести форматируй.

     Параметры:
     путь =            the путь в_ the remote файл
     поток =          данные в_ добавь в_ the файл
     ход =        a delegate в_ вызов with ход information
     форматируй =          что форматируй в_ шли the данные in
     ********************************************************************************/
    public проц добавь(ткст путь, ИПотокВвода поток,
                                 ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.Образ)
    in
    {
        assert(путь.length > 0);
        assert(поток !is пусто);
    }
    body
    {
        // Change в_ the specified форматируй.
        this.тип(форматируй);

        // Okay сервер, we want в_ сохрани something...
        Сокет данные = this.обработайКомандуДанных("APPE", путь);

        // Отправка the поток over the сокет!
        this.шлиВПоток(данные, поток, ход);

        this.завершиКомандуДанных(данные);
    }

    /*********************************************************************************
     Seek в_ a байт смещение for the следщ перемести.

     Параметры:
     смещение =          the число of байты в_ сместись вперёд
     **********************************************************************************/
    public проц рестартСик(т_мера смещение)
    {
        сим[16] врем;
        this.шлиКоманду("REST", Целое.форматируй(врем, cast(дол) смещение));
        this.читайОтвет("350");

        // Набор this for later use.
        this.restartPos_ = смещение;
    }

    /**********************************************************************************
     Размести пространство for a файл.

     After calling this, добавь() or помести() should be the следщ команда.

     Параметры:
     байты =           the число of байты в_ размести
     ***********************************************************************************/
    public проц размести(дол байты)
    in
    {
        assert(байты > 0);
    }
    body
    {
        сим[16] врем;
        this.шлиКоманду("ALLO", Целое.форматируй(врем, байты));
        auto ответ = this.читайОтвет();

        // For our purposes 200 и 202 are Всё fine.
        if(ответ.код != "200" && ответ.код != "202")
            исключение(ответ);
    }

    /**********************************************************************************
     Retrieve a remote файл's contents преобр_в a local файл.

     Calling this function will change the текущ данные перемести форматируй.

     Параметры:
     путь =            the путь в_ the remote файл
     локальн_файл =      the путь в_ the local файл
     ход =        a delegate в_ вызов with ход information
     форматируй =          что форматируй в_ читай the данные in
     **********************************************************************************/
    public проц получи(ткст путь, ткст локальн_файл,
                                 ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.Образ)
    in
    {
        assert(путь.length > 0);
        assert(локальн_файл.length > 0);
    }
    body
    {
        Файл файл = пусто;

        // We may either создай a new файл...
        if(this.restartPos_ == 0)
            файл = new Файл(локальн_файл, Файл.ЧитЗапСозд);
        // Or открой an existing файл, и сместись в_ the specified позиция (читай: not конец, necessarily.)
        else {
            файл = new Файл(локальн_файл, Файл.ЧитЗапСущ);
            файл.сместись(this.restartPos_);

            this.restartPos_ = 0;
        }

        scope(exit)
        {
            файл.открепи();
            delete файл;
        }

        // Сейчас that it's открой, we do что we всегда do.
        this.получи(путь, файл, ход, форматируй);
    }

    /*********************************************************************************
     Enable UTF8 on servers that don't use this as default. Might need some work
     *********************************************************************************/
    public проц активируйУТФ8()
    {
        шлиКоманду("OPTS UTF8 ON");
        читайОтвет("200");
    }

    /**********************************************************************************
     Retrieve a remote файл's contents преобр_в a local файл.

     Calling this function will change the текущ данные перемести форматируй.

     Параметры:
     путь =            the путь в_ the remote файл
     поток =          поток в_ пиши the данные в_
     ход =        a delegate в_ вызов with ход information
     форматируй =          что форматируй в_ читай the данные in
     ***********************************************************************************/
    public проц получи(ткст путь, ИПотокВывода поток,
                                 ХодФтп ход = пусто, ПФорматФтп форматируй = ПФорматФтп.Образ)
    in
    {
        assert(путь.length > 0);
        assert(поток !is пусто);
    }
    body
    {
        // Change в_ the specified форматируй.
        this.тип(форматируй);

        // Okay сервер, we want в_ получи this файл...
        Сокет данные = this.обработайКомандуДанных("RETR", путь);

        // Чит the поток in из_ the сокет!
        this.читайПоток(данные, поток, ход);

        this.завершиКомандуДанных(данные);
    }

    /*****************************************************************************
     Добавлено с версии: 0.99.8
     *****************************************************************************/
    public ИПотокВвода ввод(ткст путь)
    {
        тип(ПФорматФтп.Образ);
        dataСОКЕТ_ = this.обработайКомандуДанных("RETR", путь);
        return dataСОКЕТ_;
    }

    /*****************************************************************************
     Добавлено с версии: 0.99.8
     *****************************************************************************/
    public ИПотокВывода вывод(ткст путь)
    {
        тип(ПФорматФтп.Образ);
        dataСОКЕТ_ = this.обработайКомандуДанных("STOR", путь);
        return dataСОКЕТ_;
    }
}
