/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. Все права защищены

        license:        BSD стиль: $(LICENSE)

        version:        Initial release: April 2004

        author:         Kris, John Reimer

*******************************************************************************/

module net.http.HttpStack;

private import  exception;

/******************************************************************************

        Unix doesn't appear в_ have a memicmp() ... JJR notes that the
        strncasecmp() is available instead.

******************************************************************************/

version (Win32)
{
    extern (C) цел memicmp (сим *, сим *, бцел);
}

version (Posix)
{
    extern (C) цел strncasecmp (сим *, сим*, бцел);
}

extern (C) ук memmove (ук приёмн, ук ист, цел n);


/******************************************************************************

        Internal представление of a токен

******************************************************************************/

class Токен
{
    private ткст значение;

    Токен установи (ткст значение)
    {
        this.значение = значение;
        return this;
    }

    ткст вТкст ()
    {
        return значение;
    }
}

/******************************************************************************

        A стэк of Tokens, использован for capturing http заголовки. The токены
        themselves are typically mapped onto the контент of a Буфер,
        or some другой external контент, so there's minimal allocation
        involved (typically zero).

******************************************************************************/

class СтэкППГТ
{
    private цел     глубина;
    private Токен[] токены;

    private static const цел МаксРазмСтэкаППГТ = 256;

    /**********************************************************************

            Construct a СтэкППГТ with the specified начальное размер.
            The стэк will later be resized as necessary.

    **********************************************************************/

    this (цел размер = 10)
    {
        токены = new Токен[0];
        перемерь (токены, размер);
    }

    /**********************************************************************

            Clone this стэк of токены

    **********************************************************************/

    СтэкППГТ клонируй ()
    {
        // установи a new СтэкППГТ of the same глубина
        СтэкППГТ клонируй = new СтэкППГТ(глубина);

        клонируй.глубина = глубина;

        // дубликат the контент of each original токен
        for (цел i=0; i < глубина; ++i)
            клонируй.токены[i].установи (токены[i].вТкст().dup);

        return клонируй;
    }

    /**********************************************************************

            Iterate over все токены in стэк

    **********************************************************************/

    цел opApply (цел delegate(ref Токен) дг)
    {
        цел результат = 0;

        for (цел i=0; i < глубина; ++i)
            if ((результат = дг (токены[i])) != 0)
                break;
        return результат;
    }

    /**********************************************************************

            Pop the стэк все the way задний в_ zero

    **********************************************************************/

    final проц сбрось ()
    {
        глубина = 0;
    }

    /**********************************************************************

            Scan the токены looking for the первый one with a совпадают
            имя. Возвращает the совпадают Токен, либо пусто if there is no
            such сверь.

    **********************************************************************/

    final Токен найдиТокен (ткст сверь)
    {
        Токен tok;

        for (цел i=0; i < глубина; ++i)
        {
            tok = токены[i];
            if (совпадает (tok, сверь))
                return tok;
        }
        return пусто;
    }

    /**********************************************************************

            Scan the токены looking for the первый one with a совпадают
            имя, и удали it. Возвращает да, если a сверь was найдено, or
            нет if not.

    **********************************************************************/

    final бул удалиТокен (ткст сверь)
    {
        for (цел i=0; i < глубина; ++i)
            if (совпадает (токены[i], сверь))
            {
                токены[i].значение = пусто;
                return да;
            }
        return нет;
    }

    /**********************************************************************

            Возвращает текущ стэк глубина

    **********************************************************************/

    final цел размер ()
    {
        return глубина;
    }

    /**********************************************************************

            Push a new токен onto the стэк, и установи it контент в_
            that предоставленный. Возвращает the new Токен.

    **********************************************************************/

    final Токен сунь (ткст контент)
    {
        return сунь().установи (контент);
    }

    /**********************************************************************

            Push a new токен onto the стэк, и установи it контент в_
            be that указанного токен. Возвращает the new Токен.

    **********************************************************************/

    final Токен сунь (ref Токен токен)
    {
        return сунь (токен.вТкст());
    }

    /**********************************************************************

            Push a new токен onto the стэк, и return it.

    **********************************************************************/

    final Токен сунь ()
    {
        if (глубина == токены.length)
            перемерь (токены, глубина * 2);
        return токены[глубина++];
    }

    /**********************************************************************

            Pop the стэк by one.

    **********************************************************************/

    final проц вынь ()
    {
        if (глубина)
            --глубина;
        else
            throw new ВВИскл ("нелегальная попытка извлечь Токен из стэка");
    }

    /**********************************************************************

            See if the given токен совпадает the specified текст. The
            two must сверь the minimal протяженность exactly.

    **********************************************************************/

    final static бул совпадает (ref Токен токен, ткст сверь)
    {
        ткст мишень = токен.вТкст();

        цел length = мишень.length;
        if (length > сверь.length)
            length = сверь.length;

        if (length is 0)
            return нет;

        version (Win32)
        return memicmp (мишень.ptr, сверь.ptr, length) is 0;
        version (Posix)
        return strncasecmp (мишень.ptr, сверь.ptr, length) is 0;
    }

    /**********************************************************************

            Resize this стэк by extending the Массив.

    **********************************************************************/

    final static проц перемерь (ref Токен[] токены, цел размер)
    {
        цел i = токены.length;

        // this should *never* realistically happen
        if (размер > МаксРазмСтэкаППГТ)
            throw new ВВИскл ("Стэк токенов превышает максимальную глубину");

        for (токены.length=размер; i < токены.length; ++i)
            токены[i] = new Токен();
    }
}
