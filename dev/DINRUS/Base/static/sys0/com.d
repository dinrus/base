module sys.com;
private import tpl.com, tpl.args, tpl.stream, win, exception; 

extern(D)
{

	проц откройКОМ();
	проц закройКОМ();
	ткст прогИдИзКлсид(ГУИД клсид);
	ГУИД клсидИзПрогИд(ткст прогИд);
	Исключение исклКомРез(цел кодОшибки);
	проц ошибкаКомРез(цел кодОшибки);
	ДЕСЯТОК дес(ткст т)();
	проц высвободиПосле(Инкогнито obj, проц delegate() блокируй);
	проц сотриПосле(ВАРИАНТ var, проц delegate() блокируй) ;
	проц пробуйСброс(Инкогнито obj);
	проц финальныйСброс(Инкогнито obj) ;
	шим* вБткст(ткст s);
	ткст бткстВТкст(шим* s, бул высвободить = true);
	проц высвободиБткст(шим* s);
	бцел длинаБткст(шим* s) ;
	Инкогнито создайЭкземплярКо(ГУИД клсид,Инкогнито внешний, ПКонтекстВып контекст,ГУИД iid) ;
	Инкогнито дайАктивныйОбъект(ткст прогИд);
	бул объектКОМ_ли(Объект obj);
	проц установиСвойство(ИДиспетчер цель, ткст имя, ...) ;
	проц установиССылСвойство(ИДиспетчер цель, ткст имя, ...) ;
	ВАРИАНТ вызовиЧленПоИду(цел dispId, ПДиспачФлаг флаги, ИДиспетчер цель,ВАРИАНТ[] арги...);
	ВАРИАНТ вызовиЧлен(ткст имя, ПДиспачФлаг флаги, ИДиспетчер цель,ВАРИАНТ[] арги...) ;
	protected ВАРИАНТ[] аргиВВариантСписок(ИнфОТипе[] типы, спис_ва аргук) ;
	protected проц фиксАрги(ref ИнфОТипе[] арги, ref спис_ва аргук) ;
	
	final class КомОбъект
	 {
	  this(Инкогнито obj) ;
	  ~this() ;
	 Инкогнито opCast() ;
	}
}
///////////////////////////////////

	R вызовиМетод(R =ВАРИАНТ)(ИДиспетчер цель, ткст имя, ...)
	 {
	  auto арги = _arguments;
	  auto аргук = _argptr;
	  if (арги.length == 2) фиксАрги(арги, аргук);

	 ВАРИАНТ ret = вызовиЧлен(имя, ПДиспачФлаг.ВызватьМетод, цель, аргиВВариантСписок(арги, аргук));
	  static if (is(R ==ВАРИАНТ)) {
		return ret;
	  }
	  else {
		return com_cast!(R)(ret);
	  }
	}

	R дайСвойство(R =ВАРИАНТ)(ИДиспетчер цель, ткст имя, ...)
	 {
	  auto арги = _arguments;
	  auto аргук = _argptr;
	  if (арги.length == 2) фиксАрги(арги, аргук);

	 ВАРИАНТ ret = вызовиЧлен(имя, ПДиспачФлаг.ДатьСвойство, цель, аргиВВариантСписок(арги, аргук));
	  static if (is(R ==ВАРИАНТ))
		return ret;
	  else
		return com_cast!(R)(ret);
	}

//////////////////////////////////	

class Диспетчер

 {

  private ИДиспетчер цель_;
  private ВАРИАНТ результат_;
  
  /**
   */
  this(ГУИД клсид, ПКонтекстВып контекст = cast(ПКонтекстВып)(0x1 | 0x4)) {
    цель_ = создайКо!(ИДиспетчер)(клсид, контекст);
    if (цель_ is null)
      throw new ОпИскл;
  }

  /**
   */
  this(ГУИД клсид, ткст сервер, ПКонтекстВып контекст = cast(ПКонтекстВып)(0x1 | 0x10)) {
    цель_ = создайКоДоп!(ИДиспетчер)(клсид, сервер, контекст);
    if (цель_ is null)
      throw new ОпИскл;
  }

  /**
   */
  this(ткст прогИд, ПКонтекстВып контекст = cast(ПКонтекстВып)(0x1 | 0x4)) {
    цель_ = создайКо!(ИДиспетчер)(прогИд, контекст);
    if (цель_ is null)
      throw new ОпИскл;
  }

  /**
   */
  this(ткст прогИд, ткст сервер, ПКонтекстВып контекст = cast(ПКонтекстВып)(0x1 | 0x10)) {
    цель_ = создайКоДоп!(ИДиспетчер)(прогИд, сервер, контекст);
    if (цель_ is null)
      throw new ОпИскл;
  }

  /**
   */
  this(ИДиспетчер цель) {
    if (цель is null)
      throw new ПустойАргИскл("цель");

    цель.AddRef();
    цель_ = цель;
  }

  /**
   * ditto
   */
  this(ВАРИАНТ цель) {
    if (auto цель = com_cast!(ИДиспетчер)(результат)) {
      цель_ = цель;
    }
  }

  private this(ВАРИАНТ результат, бцел игнорировать) {
    if (auto цель = com_cast!(ИДиспетчер)(результат)) {
      цель_ = цель;
    }
    результат_ = результат;
  }

  ~this() {
    сбрось();
  }

  /**
   */
  final проц сбрось() {
    if (!(результат_.нулл_ли || результат_.пуст_ли))
      результат_.сотри();

    if (цель_ !is null) {
      пробуйСброс(цель_);
      цель_ = null;
    }
  }

  /**
   */
  R вызови(R = Диспетчер)(ткст имя, ...) {
    static if (is(R == Диспетчер)) {
      return new Диспетчер(вызовиМетод(цель_, имя, _arguments, _argptr), 0);
    }
    else {
      R ret = вызовиМетод!(R)(цель_, имя, _arguments, _argptr);
      результат_ = ret;
      return ret;
    }
  }

  /**
   */
  R дай(R = Диспетчер)(ткст имя, ...) {
    static if (is(R == Диспетчер)) {
      return new Диспетчер(дайСвойство(цель_, имя, _arguments, _argptr), 0);
    }
    else {
      R ret = дайСвойство!(R)(цель_, имя, _arguments, _argptr);
      результат_ = ret;
      return ret;
    }
  }

  /**
   */
  проц установи(ткст имя, ...)
  {
    установиСвойство(цель_, имя, _arguments, _argptr);
  }

  /**
   */
  проц установиСсылку(ткст имя, ...)
  {
    установиССылСвойство(цель_, имя, _arguments, _argptr);
  }

  /**
   */
  final ИДиспетчер цель() {
    return цель_;
  }

  /**
   */
  final ВАРИАНТ результат() {
    return результат_;
  }

}
alias Диспетчер Обдис;

////////////////////////////////////////////////////////////
/**
 * Предлагает реализацию интерфейса ИПоток.
 */
 
class КОМПоток : Реализует!(ИПоток) {

  protected Поток поток_; 

 this(Поток поток) {
    if (поток is null)
      throw new Ошибка ("Нулевой аргумент 'поток'");
    поток_ = поток;
  }

 Поток потокОснова() {
    return поток_;
  }

 цел Read(ук pv, бцел кб, ref бцел кбЧтен) {
    бцел ret = поток_.читайБлок(pv, кб);
    if (&кбЧтен)
      кбЧтен = ret;
    return ПКомРез.Да;
  }
alias Read читай;

  цел Write(in ук pv, бцел кб, ref бцел кбСчитанных) {
    бцел ret = поток_.пишиБлок(pv, кб);
    if (&кбСчитанных)
      кбСчитанных = ret;
    return ПКомРез.Да;
  }
alias Write пиши;

  цел Seek(дол dlibMove, бцел dwOrigin, ref бдол plibNewPosition) {
    ППозКурсора whence;
    if (dwOrigin ==ППозПотока.Уст)
      whence = ППозКурсора.Уст;
    else if (dwOrigin ==ППозПотока.Тек)
      whence = ППозКурсора.Тек;
    else if (dwOrigin ==ППозПотока.Кон)
      whence = ППозКурсора.Кон;

    бдол ret = поток_.сместись(dlibMove, whence);
    if (&plibNewPosition)
      plibNewPosition = ret;
    return ПКомРез.Да;
  }
alias Seek сместись;

  цел SetSize(бдол libNewSize) {
    return ПКомРез.Нереализовано;
  }
alias SetSize установиРазм;

  цел CopyTo(ИПоток поток, бдол кб, ref бдол кбЧтен, ref бдол кбСчитанных) {
    if (&кбЧтен)
      кбЧтен = 0;
    if (&кбСчитанных)
      кбСчитанных = 0;
    return ПКомРез.Нереализовано;
  }
alias CopyTo копируйВ;

  цел Commit(бцел hrfCommitFlags) {
    return ПКомРез.Нереализовано;
  }
alias Commit передай;

  цел Revert() {
    return ПКомРез.Нереализовано;
  }
alias Revert верни;

  цел LockRegion(бдол смещБиб, бдол кб, бцел типБлокир) {
    return ПКомРез.Нереализовано;
  }
alias LockRegion блокРегион;

  цел UnlockRegion(бдол смещБиб, бдол кб, бцел типБлокир) {
    return ПКомРез.Нереализовано;
  }
alias UnlockRegion разблокРегион;

  цел Stat(out ОТКРПМБ pstatstg, бцел grfStatFlag) {
    pstatstg.тип = STGTY_STREAM;
    pstatstg.бРазм = поток_.размер;
    return ПКомРез.Да;
  }
alias Stat стат;

  цел Clone(out ИПоток ppstm) {
    ppstm = null;
    return ПКомРез.Нереализовано;
  }
alias Clone клонируй;

}


