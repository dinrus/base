/******************************************************
 * Стековые Потоки (СтэкНити) - это сотрудничающие, легковесные
 * потоки. СтэкНити очень эффективны, требуют
 * меньше времени на переключение контекста, чем реальные потоки.
 * Для них также нужно меньше ресурсов, чем для реальных потоков,
 * что дает возможность одновременного существования большого числа
 * СтэкНити. К тому же, СтэкНити не требуется явная синхронизация,
 * так как они non-preemptive.  Не требуется, чтобы код был для повторного входа.
 *
 * Данный модуль реализует систему стековых потоков на основе
 * контекстного слоя.
 *
 * Версия: 0.3
 * Дата: July 4, 2006
 * Авторы:
 *  Mikola Lysenko, mclysenk@mtu.edu
 * Лицензия: Use/копируй/modify freely, just give credit.
 * Авторское Право: Public domain.
 *
 * Баги:
 *  Не потоко-безопасны.  Могут изменяться в последующих версиях,
 *  однако для этого потребуется коренная переделка.
 *
 * История:
 *  v0.7 - Резолюция отсчета времени переключена на миллисекунды.
 *
 *	v0.6 - Удалены функции отсчета времени из сн_жни/сн_бросайЖни
 *
 *  v0.5 - Добавлены сн_бросайЖни и MAX/MIN_THREAD_PRIORITY
 *
 *  v0.4 - Unittests готов для первоначального выпуска.
 *
 *  v0.3 - Changed имя задний to СтэкНить и added
 *      linux support.  Context switching is now handled
 *      in the stackcontext module, и much simpler to
 *      port.
 *
 *  v0.2 - Changed имя to QThread, fixed many issues.
 *
 *  v0.1 - Initial стэковый поток system. Very buggy.
 *
 ******************************************************/
module st.stackthread;

//Импорты модуля
private import st.stackcontext, stdrus;

/// Приоритет стэкового потока определяет его порядок в
/// планировщике.  Первыми идут потоки с высшим приоритетом.
alias цел т_приоритет;

/// Дефолтный приоритет для стэкового потока = 0.
const т_приоритет ДЕФ_ПРИОРИТЕТ_СТЭКНИТИ = 0;

/// Максимальный приоритет потока
const т_приоритет МАКС_ПРИОРИТЕТ_СТЭКНИТИ = 0x7fffffff;

///  Минимальный приоритет потока
const т_приоритет МИН_ПРИОРИТЕТ_СТЭКНИТИ = 0x80000000;

/// Состояние стэкового потока
enum ПСостояниеНити
{
    Готов,      /// Нить готова к пуску
    Выполняется,    /// Нить в данный момент выполняется
    Завершён,       /// Нить завершилась
    Подвешен,  /// Нить заморожена (подвешена)
}

/// Состояние планировщика
enum ПСостояниеПланировщика
{
    Готов,      /// Планировщик готов к пуску нити
    Выполняется,    /// Планировшик выполняет срез времени
}

//СрезыВремени
private ОчередьПриоритетовСН активн_срез;
private ОчередьПриоритетовСН следщ_срез;

//Состояние планировщика
private ПСостояниеПланировщика сост_планировщ;

//Время старта среза времени
private бдол план_вр0;

//Текущая активная стэковая нить
private СтэкНить план_сн;

version(Win32)
{
    private extern(Windows) цел QueryPerformanceFrequency(бдол *);
    private бдол план_произв_част;
}


//Инициализация планировщика
static this()
{
    активн_срез = new ОчередьПриоритетовСН();
    следщ_срез = new ОчередьПриоритетовСН();
    сост_планировщ = ПСостояниеПланировщика.Готов;
    план_вр0 = -1;
    план_сн = пусто;

    version(Win32)
    QueryPerformanceFrequency(&план_произв_част);
}


/******************************************************
 * ИсклСтэкНити генерируется при неправильном вызове
 * стэковых потоков. При попытке запуска среза времени,
 * когда срез времени уже в процессе выполнения,
 * выводится ИсклСтэкНити.
 ******************************************************/
class ИсклСтэкНити : Исключение
{
    this(ткст сооб)
    {
        super(сооб);
    }

    this(СтэкНить сн, ткст сооб)
    {
        super(фм("%s: %s", сн.вТкст, сооб));
    }
}



/******************************************************
 * СтэкНити походи на обычные нити, только они планируются
* кооперативно. Пользователь может переключиться между
 * СтэкНитями, используя st_yielauxd.
 ******************************************************/
class СтэкНить
{
    /**
     * Создаёт новый стэковый поток и добавляет его в
     * планировщик.
     *
     * Параметры:
     *  дг = Вызываемый делегат.
     *  размер_стэка = Размер стэка.
     *  приоритет = Приоритет стэкового потока.
     */
    public this
    (
        проц delegate() дг,
        т_приоритет приоритет = ДЕФ_ПРИОРИТЕТ_СТЭКНИТИ,
        т_мера размер_стэка = ДЕФ_РАЗМЕР_СТЕКА
    )
    {
        this.м_делегат = дг;
        this.контекст = new КонтекстСтэка(&м_проц, ДЕФ_РАЗМЕР_СТЕКА);
        this.м_приоритет = приоритет;

        //Заплавнировать поток
        сн_запланируй(this);

        debug (СтэкНить) скажифнс("Создана нить, %s", вТкст);
    }

    /**
     * Создаёт новый стэковый поток и добавляет его в
     * планировщик, используя указатель на функцию.
     *
     * Параметры:
     *  фн = Указатель на функцию, вызываемую стэкровым
     *  потоком.
     *  размер_стэка = Размер стэка для стэкового
     *  потока.
     *  приоритет =Приоритет стэкового потока.
     */
    public this
    (
        проц function() фн,
        т_приоритет приоритет = ДЕФ_ПРИОРИТЕТ_СТЭКНИТИ,
        т_мера размер_стэка = ДЕФ_РАЗМЕР_СТЕКА
    )
    {
        this.м_делегат = &делегатор;
        this.м_функция = фн;
        this.контекст = new КонтекстСтэка(&м_проц, ДЕФ_РАЗМЕР_СТЕКА);
        this.м_приоритет = приоритет;

        //Запланировать поток
        сн_запланируй(this);

        debug (СтэкНить) скажифнс("Создан поток, %s", вТкст);
    }

    /**
     * Преобразует поток в ткст.
     *
     * Возвращает: Ткст, представляющий стэковый поток.
     */
    public ткст вТкст()
    {
        debug(PQueue)
        {
            return фм("ST[t:%8x,p:%8x,l:%8x,r:%8x]",
                        cast(ук)this,
                        cast(ук)родитель,
                        cast(ук)лево,
                        cast(ук)право);
        }
        else
        {
            static ткст[] названия_состояний =
                [
                    "RDY",
                    "RUN",
                    "XXX",
                    "PAU",
                ];

            //horrid хак for getting the address of a delegate
            union хак
            {
                struct деле
                {
                    ук кадр;
                    ук фнук;
                }

                деле d;
                проц delegate () дг;
            }
            хак h;
            if(м_функция !is пусто)
                h.d.фнук = cast(ук) м_функция;
            else if(м_делегат !is пусто)
                h.дг = м_делегат;
            else
                h.дг = &пуск;

            return фм(
                       "Нить[pr=%d,сн=%s,фн=%8x]",
                       приоритет,
                       названия_состояний[cast(бцел)состояние],
                       h.d.фнук);
        }
    }

    invariant
    {
        assert(контекст);

        switch(состояние)
        {
        case ПСостояниеНити.Готов:
            assert(контекст.готов);
            break;

        case ПСостояниеНити.Выполняется:
            assert(контекст.выполняется);
            break;

        case ПСостояниеНити.Завершён:
            assert(!контекст.выполняется);
            break;

        case ПСостояниеНити.Подвешен:
            assert(контекст.готов);
            break;

        default:
            assert(false);
        }

        if(лево !is пусто)
        {
            assert(лево.родитель is this);
        }

        if(право !is пусто)
        {
            assert(право.родитель is this);
        }
    }

    /**
     * Удаляет данный стэковый поток из планировщика.
     * Поток не будет запущен, пока его не добавят обратно
     * в планировщик.
     */
    public final проц пауза()
    {
        debug (СтэкНить) скажифнс("Ставится на паузу %s", вТкст);

        switch(состояние)
        {
        case ПСостояниеНити.Готов:
            сн_отмени(this);
            состояние = ПСостояниеНити.Подвешен;
            break;

        case ПСостояниеНити.Выполняется:
            переход_в(ПСостояниеНити.Подвешен);
            break;

        case ПСостояниеНити.Завершён:
            throw new ИсклСтэкНити(this, "Пельзя приостановить завершённный поток");

        case ПСостояниеНити.Подвешен:
            throw new ИсклСтэкНити(this, "Нельзя приостановить поток, уже находящийся на паузе");

        default:
            assert(false);
        }
    }

    /**
     * Добавляет стэковый поток обратно в планировщик. Он
     * будет снова выполняться с неизменёнными приоритетом и состоянием.
     */
    public final проц возобнови()
    {
        debug (СтэкНить) скажифнс("Возобновляется %s", вТкст);

        //Может возобновить только потоки на паузе
        if(состояние != ПСостояниеНити.Подвешен)
        {
            throw new ИсклСтэкНити(this, "Нить не заморожена!");
        }

        //Установить состояние в готов и запланировать
        состояние = ПСостояниеНити.Готов;
        сн_запланируй(this);
    }

    /**
     * Жёстко обрубает данный стэковый поток. У потока не
     * остаётся шанса на завершение или зачистку,
     * он выкидывается из плана и все ссылки на него в
     * сборщике мусора удаляются.
     */
    public final проц души()
    {
        debug (СтэкНить) скажифнс("Обрубается %s", вТкст);

        switch(состояние)
        {
        case ПСостояниеНити.Готов:
            //Обрубить поток и удалить из планировщика
            сн_отмени(this);
            состояние = ПСостояниеНити.Завершён;
            контекст.души();
            break;

        case ПСостояниеНити.Выполняется:
            //Переход в завершён
            переход_в(ПСостояниеНити.Завершён);
            break;

        case ПСостояниеНити.Завершён:
            throw new ИсклСтэкНити(this, "Уже потушенную нить удушить нельзя");

        case ПСостояниеНити.Подвешен:
            //Требеутся "задушить" этот стэк, не надо трогать планировщик
            состояние = ПСостояниеНити.Завершён;
            контекст.души();
            break;

        default:
            assert(false);
        }
    }

    /**
     * Ждать до объединения с этим потоком.  Если данное количество
     * миллисекунд истерает до завершения потока,
     * возврат происходит автоматически.
     *
     * Параметры:
     *  мс = Максимальное количество времени, которое этой нить
     *  позволено ждать. Особое значение -1 подразумевает
     *  неопределённое ожидание объединения.
     *
     * Возвращает:
     *  Число миллисекунд, которое нить действительно провела в
     *  ожидании.
     */
    public final бдол объедини(бдол мс = -1)
    {
        debug (СтэкНить) скажифнс("Объединяется %s", вТкст);

        //Проверить, что мы в срезе времени
        if(сост_планировщ != ПСостояниеПланировщика.Выполняется)
        {
            throw new ИсклСтэкНити(this, "Нельзя объединить, если срез времени не в прогрессирующем состоянии.");
        }

        //Убедиться,  что присоединяем к действительному потоку
        switch(состояние)
        {
        case ПСостояниеНити.Готов:
            break;

        case ПСостояниеНити.Выполняется:
            throw new ИсклСтэкНити(this, "Нельзя объединить нить с самой собою!");

        case ПСостояниеНити.Завершён:
            throw new ИсклСтэкНити(this, "Нельзя объединить нить с завершённым потоком");

        case ПСостояниеНити.Подвешен:
            throw new ИсклСтэкНити(this, "Нельзя объединить нить с потоком на паузе");

        default:
            assert(false);
        }

        //Усердно ждать пока поток не прекратится или
        //этот таймер не истечёт.
        бдол время_старта = дайСисМиллисек();
        бдол таймаут = (мс == -1) ? мс : время_старта + мс;

        while(
            состояние != ПСостояниеНити.Завершён &&
            таймаут > дайСисМиллисек())
        {
            КонтекстСтэка.жни();
        }

        return дайСисМиллисек() - время_старта;
    }

    /**
     * Перезапускает выполнение нити с самого начала
     * Завершённые и замороженные потоки не возобновляются,
     * но перезапускаются при возобновлении.
     */
    public final проц перезапуск()
    {
        debug (СтэкНить) скажифнс("Перезапускается %s", вТкст);

        //С каждым состоянием нужно аккуратно поработать
        switch(состояние)
        {
        case ПСостояниеНити.Готов:
            //Если готов,
            контекст.перезапуск();
            break;

        case ПСостояниеНити.Выполняется:
            //Переустановить поток.
            переход_в(ПСостояниеНити.Готов);
            break;

        case ПСостояниеНити.Завершён:
            //Мёртвые потоки подвешиваются
            контекст.перезапуск();
            состояние = ПСостояниеНити.Подвешен;
            break;

        case ПСостояниеНити.Подвешен:
            //Подвешенные потоки остаются таковыми
            контекст.перезапуск();
            break;

        default:
            assert(false);
        }
    }

    /**
     * Получает приоритет потока. Используется как
     * свойство.
     *
     * Возвращает: Приоритет этого стэкового потока.
     */
    public final т_приоритет приоритет()
    {
        return м_приоритет;
    }

    /**
     * Устанавливает приоритет стэкового потока  Используется либо
     * для перепланировки либо сброса потока. Изменения
     * не действуют до следующего тура планировки.
     *
     * Параметры:
     *  p = Новый приоритет для потока.
     *
     * Возвращает:
     *  Новый приоритет для потока.
     */
    public final т_приоритет приоритет(т_приоритет p)
    {
        //Обновить приоритет
        if(сост_планировщ == ПСостояниеПланировщика.Готов &&
                состояние == ПСостояниеНити.Готов)
        {
            следщ_срез.удали(this);
            м_приоритет = p;
            следщ_срез.добавь(this);
        }

        return м_приоритет = p;
    }

    /**
     * Возвращает: Состояние данного потока.
     */
    public final ПСостояниеНити дайСостояние()
    {
        return состояние;
    }

    /**
     * Возвращает: True, если поток готов к пуску.
     */
    public final бул готов()
    {
        return состояние == ПСостояниеНити.Готов;
    }

    /**
     * Возвращает: True, если поток сейчас выполняется.
     */
    public final бул выполняется()
    {
        return состояние == ПСостояниеНити.Выполняется;
    }

    /**
     * Возвращает: True, если поток мёртв.
     */
    public final бул завершён()
    {
        return состояние == ПСостояниеНити.Завершён;
    }

    /**
     * Возвращает: True, если поток не мёртв.
     */
    public final бул жив()
    {
        return состояние != ПСостояниеНити.Завершён;
    }

    /**
     * Возвращает: True, если поток на паузее.
     */
    public final бул на_паузе()
    {
        return состояние == ПСостояниеНити.Подвешен;
    }

    /**
     * Создаёт стэковый поток без указателя на функцию
     * или делегата. Используется, когда пользователь переписывает
     * класс стэкового потока.
     */
    protected this
    (
        т_приоритет приоритет = ДЕФ_ПРИОРИТЕТ_СТЭКНИТИ,
        т_мера размер_стэка = ДЕФ_РАЗМЕР_СТЕКА
    )
    {
        this.контекст = new КонтекстСтэка(&м_проц, размер_стэка);
        this.м_приоритет = приоритет;

        //Запланировать поток
        сн_запланируй(this);

        debug (СтэкНить) скажифнс("Создан поток, %s", вТкст);
    }

    /**
     * Запустить стэковый поток. Метод может быть перегружен
     * в классах, наследующих от стэковый поток, как
     * альтернатива к передаче делегатов.
     *
     * Выводит исключение: Любое.
     */
    protected проц пуск()
    {
        м_делегат();
    }

    // Информация кучи
    private СтэкНить родитель = пусто;
    private СтэкНить лево = пусто;
    private СтэкНить право = пусто;

    // Приоритет этого потока
    private т_приоритет м_приоритет;

    // Состояние этого потока
    private ПСостояниеНити состояние;

    // Контекст этого потока
    private КонтекстСтэка контекст;

    //Обработчик делегата
    private проц function() м_функция;
    private проц delegate() м_делегат;
    private проц делегатор()
    {
        м_функция();
    }

    //Локальная процедура
    private final проц м_проц()
    {
        try
        {
            debug (СтэкНить) скажифнс("Запускается %s", вТкст);
            пуск;
        }
        catch(Объект o)
        {
            debug (СтэкНить) скажифнс("Получено исключение %s из %s", o.вТкст, вТкст);
            throw o;
        }
        finally
        {
            debug (СтэкНить) скажифнс("Завершён %s", вТкст);
            состояние = ПСостояниеНити.Завершён;
        }
    }

    /**
     * Используется для изменения состояния выполняемого потока
     */
    private final проц переход_в(ПСостояниеНити следщ_состояние)
    {
        состояние = следщ_состояние;
        КонтекстСтэка.жни();
    }
}



/******************************************************
 * ОчередьПриоритетовСН используется планировщиком для
 * упорядочивания объектов в стэковых потоках.  На данный
 * момент реализована бинарная куча, но в будущих
 * версиях может использоваться биномиальная куча для
 * улучшения производительности.
 ******************************************************/
private class ОчередьПриоритетовСН
{
public:

    /**
     * Добавить стэковый поток в эту очередь.
     *
     * Параметры:
     *  сн = Добавляемый поток.
     */
    проц добавь(СтэкНить сн)
    in
    {
        assert(сн !is пусто);
        assert(сн);
        assert(сн.родитель is пусто);
        assert(сн.лево is пусто);
        assert(сн.право is пусто);
    }
    body
    {
        размер++;

        //Обработать тривиальный случай
        if(голова is пусто)
        {
            голова = сн;
            return;
        }

        //Во-первых, вставить сн
        СтэкНить врм = голова;
        цел поз;
        for(поз = размер; поз>3; поз>>>=1)
        {
            assert(врм);
            врм = (поз & 1) ? врм.право : врм.лево;
        }

        assert(врм !is пусто);
        assert(врм);

        if(поз&1)
        {
            assert(врм.лево !is пусто);
            assert(врм.право is пусто);
            врм.право = сн;
        }
        else
        {
            assert(врм.лево is пусто);
            assert(врм.право is пусто);
            врм.лево = сн;
        }
        сн.родитель = врм;

        assert(врм);
        assert(сн);

        //Наладить стэк.
        вспень(сн);
    }

    /**
     * Удалить стэковый поток.
     *
     * Параметры:
     *  сн = Удаляемый стэковый поток.
     */
    проц удали(СтэкНить сн)
    in
    {
        assert(сн);
        assert(естьНить(сн));
    }
    out
    {
        assert(сн);
        assert(сн.лево is пусто);
        assert(сн.право is пусто);
        assert(сн.родитель is пусто);
    }
    body
    {
        //Обработать тривиальный случай
        if(размер == 1)
        {
            assert(сн is голова);

            --размер;

            сн.родитель =
            сн.лево =
            сн.право =
            голова = пусто;

            return;
        }

        //Циклировать до низа кучи
        СтэкНить врм = голова;
        цел поз;
        for(поз = размер; поз>3; поз>>>=1)
        {
            assert(врм);
            врм = (поз & 1) ? врм.право : врм.лево;
        }
        врм = (поз & 1) ? врм.право : врм.лево;


        assert(врм !is пусто);
        assert(врм.лево is пусто);
        assert(врм.право is пусто);

        //Удалить врм
        if(врм.родитель.лево is врм)
        {
            врм.родитель.лево = пусто;
        }
        else
        {
            assert(врм.родитель.право is врм);
            врм.родитель.право = пусто;
        }
        врм.родитель = пусто;
        размер--;

        assert(врм);

        //Обработать второй тривиальный случай
        if(врм is сн)
        {
            return;
        }

        //Заменить сн на врм
        if(сн is голова)
        {
            голова = врм;
        }

        //Исправить родителя врм.
        врм.родитель = сн.родитель;
        if(врм.родитель !is пусто)
        {
            if(врм.родитель.лево is сн)
            {
                врм.родитель.лево = врм;
            }
            else
            {
                assert(врм.родитель.право is сн);
                врм.родитель.право = врм;
            }
        }

        //Фиксировать врм's лево
        врм.лево = сн.лево;
        if(врм.лево !is пусто)
        {
            врм.лево.родитель = врм;
        }

        //Фиксировать врм's право
        врм.право = сн.право;
        if(врм.право !is пусто)
        {
            врм.право.родитель = врм;
        }

        //Unlink сн
        сн.родитель =
            сн.лево =
                сн.право = пусто;


        //Bubble up
        вспень(врм);
        //Bubble задний down
        запень(врм);

    }

    /**
     * Извлечь поток с верхом приоритета Он удаляется
     * из очереди.
     *
     * Возвращает: Поток с верхом приоритета.
     */
    СтэкНить верх()
    in
    {
        assert(голова !is пусто);
    }
    out(r)
    {
        assert(r !is пусто);
        assert(r);
        assert(r.родитель is пусто);
        assert(r.право is пусто);
        assert(r.лево is пусто);
    }
    body
    {
        СтэкНить результат = голова;

        //Обработать тривиальный случай
        if(размер == 1)
        {
            //Drop размер и return
            --размер;
            результат.родитель =
            результат.лево =
            результат.право = пусто;
            голова = пусто;
            return результат;
        }

        //Cycle to the bottom of the heap
        СтэкНить врм = голова;
        цел поз;
        for(поз = размер; поз>3; поз>>>=1)
        {
            assert(врм);
            врм = (поз & 1) ? врм.право : врм.лево;
        }
        врм = (поз & 1) ? врм.право : врм.лево;

        assert(врм !is пусто);
        assert(врм.лево is пусто);
        assert(врм.право is пусто);

        //Remove врм
        if(врм.родитель.лево is врм)
        {
            врм.родитель.лево = пусто;
        }
        else
        {
            assert(врм.родитель.право is врм);
            врм.родитель.право = пусто;
        }
        врм.родитель = пусто;

        //Add врм to верх
        врм.лево = голова.лево;
        врм.право = голова.право;
        if(врм.лево !is пусто) врм.лево.родитель = врм;
        if(врм.право !is пусто) врм.право.родитель = врм;

        //Unlink голова
        голова.право =
        голова.лево = пусто;

        //Verify results
        assert(голова);
        assert(врм);

        //Set the new голова
        голова = врм;

        //Bubble down
        запень(врм);

        //Drop размер и return
        --размер;
        return результат;
    }

    /**
     * Merges two приоритет queues. The результат is stored
     * in this queue, while other is emptieauxd.
     *
     * Параметры:
     *  other = The queue we are merging with.
     */
    проц совмести(ОчередьПриоритетовСН other)
    {
        СтэкНить[] стэк;
        стэк ~= other.голова;

        while(стэк.length > 0)
        {
            СтэкНить врм = стэк[$-1];
            стэк.length = стэк.length - 1;

            if(врм !is пусто)
            {
                стэк ~= врм.право;
                стэк ~= врм.лево;

                врм.родитель =
                    врм.право =
                        врм.лево = пусто;

                добавь(врм);
            }
        }

        //Clear the list
        other.голова = пусто;
        other.размер = 0;
    }

    /**
     * Возвращает: true if the heap actually contains the thread сн.
     */
    бул естьНить(СтэкНить сн)
    {
        СтэкНить врм = сн;
        while(врм !is пусто)
        {
            if(врм is голова)
                return true;
            врм = врм.родитель;
        }

        return false;
    }

    invariant
    {
        if(голова !is пусто)
        {
            assert(голова);
            assert(размер > 0);
        }
    }

    //Top of the heap
    СтэкНить голова = пусто;

    //Размер of the стэк
    цел размер;

    debug (PQueue) проц печать()
    {
        СтэкНить[] стэк;
        стэк ~= голова;

        while(стэк.length > 0)
        {
            СтэкНить врм = стэк[$-1];
            стэк.length = стэк.length - 1;

            if(врм !is пусто)
            {
                пишиф("%s, ", врм.м_приоритет);

                if(врм.лево !is пусто)
                {
                    assert(врм.лево.м_приоритет <= врм.м_приоритет);
                    стэк ~= врм.лево;
                }

                if(врм.право !is пусто)
                {
                    assert(врм.право.м_приоритет <= врм.м_приоритет);
                    стэк ~= врм.право;
                }

            }
        }

        нс;
    }

    проц вспень(СтэкНить сн)
    {
        //Ok, now we are at the bottom, so time to bubble up
        while(сн.родитель !is пусто)
        {
            //Test for end condition
            if(сн.родитель.м_приоритет >= сн.м_приоритет)
                return;

            //Otherwise, just swap
            СтэкНить a = сн.родитель, tp;

            assert(сн);
            assert(сн.родитель);

            //скажифнс("%s <-> %s", a.вТкст, сн.вТкст);

            //Switch parents
            сн.родитель = a.родитель;
            a.родитель = сн;

            //Fixup
            if(сн.родитель !is пусто)
            {
                if(сн.родитель.лево is a)
                {
                    сн.родитель.лево = сн;
                }
                else
                {
                    assert(сн.родитель.право is a);
                    сн.родитель.право = сн;
                }

                assert(сн.родитель);
            }

            //Switch children
            if(a.лево is сн)
            {
                a.лево = сн.лево;
                сн.лево = a;

                tp = сн.право;
                сн.право = a.право;
                a.право = tp;

                if(сн.право !is пусто) сн.право.родитель = сн;
            }
            else
            {
                a.право = сн.право;
                сн.право = a;

                tp = сн.лево;
                сн.лево = a.лево;
                a.лево = tp;

                if(сн.лево !is пусто) сн.лево.родитель = сн;
            }

            if(a.право !is пусто) a.право.родитель = a;
            if(a.лево !is пусто) a.лево.родитель = a;

            //скажифнс("%s <-> %s", a.вТкст, сн.вТкст);

            assert(сн);
            assert(a);
        }

        голова = сн;
    }

    //Bubbles a thread downward
    проц запень(СтэкНить сн)
    {
        while(сн.лево !is пусто)
        {
            СтэкНить a, tp;

            assert(сн);

            if(сн.право is пусто ||
                    сн.лево.м_приоритет >= сн.право.м_приоритет)
            {
                if(сн.лево.м_приоритет > сн.м_приоритет)
                {
                    a = сн.лево;
                    assert(a);
                    //скажифнс("Left: %s - %s", сн, a);

                    сн.лево = a.лево;
                    a.лево = сн;

                    tp = сн.право;
                    сн.право = a.право;
                    a.право = tp;

                    if(a.право !is пусто) a.право.родитель = a;
                }
                else break;
            }
            else if(сн.право.м_приоритет > сн.м_приоритет)
            {
                a = сн.право;
                assert(a);
                //скажифнс("Right: %s - %s", сн, a);

                сн.право = a.право;
                a.право = сн;

                tp = сн.лево;
                сн.лево = a.лево;
                a.лево = tp;

                if(a.лево !is пусто) a.лево.родитель = a;
            }
            else break;

            //Фиксировать the родитель
            a.родитель = сн.родитель;
            сн.родитель = a;
            if(a.родитель !is пусто)
            {
                if(a.родитель.лево is сн)
                {
                    a.родитель.лево = a;
                }
                else
                {
                    assert(a.родитель.право is сн);
                    a.родитель.право = a;
                }
            }
            else
            {
                голова = a;
            }

            if(сн.лево !is пусто) сн.лево.родитель = сн;
            if(сн.право !is пусто) сн.право.родитель = сн;

            assert(a);
            assert(сн);
            //скажифнс("Done: %s - %s", сн, a);
        }
    }
}

debug (PQueue)
unittest
{
    скажинс("Тестируется очередь приоритетов");


    //Созд some queue
    ОчередьПриоритетовСН q1 = new ОчередьПриоритетовСН();
    ОчередьПриоритетовСН q2 = new ОчередьПриоритетовСН();
    ОчередьПриоритетовСН q3 = new ОчередьПриоритетовСН();

    assert(q1);
    assert(q2);
    assert(q3);

    //Add some элементы
    скажинс("Добавляются элементы");
    q1.добавь(new СтэкНить(1));
    q1.печать();
    assert(q1);
    q1.добавь(new СтэкНить(2));
    q1.печать();
    assert(q1);
    q1.добавь(new СтэкНить(3));
    q1.печать();
    assert(q1);
    q1.добавь(new СтэкНить(4));
    q1.печать();
    assert(q1);

    скажинс("Удаляются элементы");
    СтэкНить t;

    t = q1.верх();
    скажифнс("t:%s",t.приоритет);
    q1.печать();
    assert(t.приоритет == 4);
    assert(q1);

    t = q1.верх();
    скажифнс("t:%s",t.приоритет);
    q1.печать();
    assert(t.приоритет == 3);
    assert(q1);

    t = q1.верх();
    скажифнс("t:%s",t.приоритет);
    q1.печать();
    assert(t.приоритет == 2);
    assert(q1);

    t = q1.верх();
    скажифнс("t:%s",t.приоритет);
    q1.печать();
    assert(t.приоритет == 1);
    assert(q1);

    скажинс("Второй тур добавок");
    q2.добавь(new СтэкНить(5));
    q2.добавь(new СтэкНить(4));
    q2.добавь(new СтэкНить(1));
    q2.добавь(new СтэкНить(3));
    q2.добавь(new СтэкНить(6));
    q2.добавь(new СтэкНить(2));
    q2.добавь(new СтэкНить(7));
    q2.добавь(new СтэкНить(0));
    assert(q2);
    q2.печать();

    скажинс("Тестируется опять откидывание верха");
    assert(q2.верх.приоритет == 7);
    q2.печать();
    assert(q2.верх.приоритет == 6);
    assert(q2.верх.приоритет == 5);
    assert(q2.верх.приоритет == 4);
    assert(q2.верх.приоритет == 3);
    assert(q2.верх.приоритет == 2);
    assert(q2.верх.приоритет == 1);
    assert(q2.верх.приоритет == 0);
    assert(q2);

    скажинс("Третий тур");
    q2.добавь(new СтэкНить(10));
    q2.добавь(new СтэкНить(7));
    q2.добавь(new СтэкНить(5));
    q2.добавь(new СтэкНить(7));
    q2.печать();
    assert(q2);

    скажифнс("Testing выкиньion");
    assert(q2.верх.приоритет == 10);
    assert(q2.верх.приоритет == 7);
    assert(q2.верх.приоритет == 7);
    assert(q2.верх.приоритет == 5);

    скажифнс("Тестируются слияния");
    q3.добавь(new СтэкНить(10));
    q3.добавь(new СтэкНить(-10));
    q3.добавь(new СтэкНить(10));
    q3.добавь(new СтэкНить(-10));

    q2.добавь(new СтэкНить(-9));
    q2.добавь(new СтэкНить(9));
    q2.добавь(new СтэкНить(-9));
    q2.добавь(new СтэкНить(9));

    q2.печать();
    q3.печать();
    q3.совмести(q2);

    скажифнс("q2:%d", q2.размер);
    q2.печать();
    скажифнс("q3:%d", q3.размер);
    q3.печать();
    assert(q2);
    assert(q3);
    assert(q2.размер == 0);
    assert(q3.размер == 8);

    скажинс("Извлекаются слияния");
    assert(q3.верх.приоритет == 10);
    assert(q3.верх.приоритет == 10);
    assert(q3.верх.приоритет == 9);
    assert(q3.верх.приоритет == 9);
    assert(q3.верх.приоритет == -9);
    assert(q3.верх.приоритет == -9);
    assert(q3.верх.приоритет == -10);
    assert(q3.верх.приоритет == -10);

    скажинс("Тестируется удаление");
    СтэкНить ta = new СтэкНить(5);
    СтэкНить tb = new СтэкНить(6);
    СтэкНить tc = new СтэкНить(10);

    q2.добавь(new СтэкНить(7));
    q2.добавь(new СтэкНить(1));
    q2.добавь(ta);
    q2.добавь(tb);
    q2.добавь(tc);

    assert(q2);
    assert(q2.размер == 5);

    скажинс("Удаление");
    q2.удали(ta);
    q2.удали(tc);
    q2.удали(tb);
    assert(q2.размер == 2);

    скажинс("Демпируется куча");
    assert(q2.верх.приоритет == 7);
    assert(q2.верх.приоритет == 1);


    скажинс("Тестируется большая добка/субтракт");
    СтэкНить[100] сн;
    ОчередьПриоритетовСН stq = new ОчередьПриоритетовСН();

    for(цел i=0; i<100; i++)
    {
        сн[i] = new СтэкНить(i);
        stq.добавь(сн[i]);
    }

    stq.удали(сн[50]);
    stq.удали(сн[10]);
    stq.удали(сн[31]);
    stq.удали(сн[88]);

    for(цел i=99; i>=0; i--)
    {
        if(i != 50 && i!=10 &&i!=31 &&i!=88)
        {
            assert(stq.верх.приоритет == i);
        }
    }
    скажинс("Большая добка/удаление работает");

    скажинс("Очередь приоритетов пройдена");
}


// -------------------------------------------------
//          SCHEDULER FUNCTIONS
// -------------------------------------------------

/**
 * Grabs the number of milliseconds on the system clock.
 *
 * (Adapted from std.perf)
 *
 * Возвращает: The amount of milliseconds the system имеется been
 * up.
 */
version(Win32)
{
    private extern(Windows) цел  QueryPerformanceCounter(бдол* cnt);

    private бдол дайСисМиллисек()
    {
        бдол результат;
        QueryPerformanceCounter(&результат);

        if(результат < 0x20C49BA5E353F7L)
        {
            результат = (результат * 1000) / план_произв_част;
        }
        else
        {
            результат = (результат / план_произв_част) * 1000;
        }

        return результат;
    }
}
else version(linux)
{
    extern (C)
    {
        private struct timeval
        {
            цел tv_sec;
            цел tv_usec;
        };
        private struct timezone
        {
            цел tz_minuteswest;
            цел tz_dsttime;
        };
        private проц gettimeofday(timeval *tv, timezone *tz);
    }

    private бдол дайСисМиллисек()
    {
        timeval     tv;
        timezone    tz;

        gettimeofday(&tv, &tz);

        return
            cast(бдол)tv.tv_sec * 1000 +
            cast(бдол)tv.tv_usec / 1000;
    }
}
else
{
    static assert(false);
}


/**
 * Schedules a thread such that it will be пуск in the next
 * timeslice.
 *
 * Параметры:
 *  сн = Нить we are scheduling
 */
private проц сн_запланируй(СтэкНить сн)
in
{
    assert(сн.состояние == ПСостояниеНити.Готов);
}
body
{
    debug(PQueue)
    {
        return;
    }

    debug (СтэкНить) скажифнс("Планируется %s", сн.вТкст);
    следщ_срез.добавь(сн);
}

/**
 * Removes a thread from the планировщик.
 *
 * Параметры:
 *  сн = Нить we are removing.
 */
private проц сн_отмени(СтэкНить сн)
in
{
    assert(сн.состояние == ПСостояниеНити.Готов);
}
body
{
    debug (СтэкНить) скажифнс("Descheduling %s", сн.вТкст);
    if(активн_срез.естьНить(сн))
    {
        активн_срез.удали(сн);
    }
    else
    {
        следщ_срез.удали(сн);
    }
}

/**
 * Runs a single timeslice.  During a timeslice each
 * currently выполняется thread is executed once, with the
 * highest приоритет первый.  Any number of things may
 * cause a timeslice to be aborted, inclduing;
 *
 *  o An exception is unhandled in a thread which is пуск
 *  o The сн_прекратиСрез function is called
 *  o The timelimit is exceeded in сн_запустиСрез
 *
 * If a timeslice is not finished, it will be resumed on
 * the next call to сн_запустиСрез.  If this is undesirable,
 * calling сн_перезапустиСрез will cause the timeslice to
 * execute from the beginning again.
 *
 * Newly created threads are not пуск until the next
 * timeslice.
 *
 * This works just like the regular сн_запустиСрез, except it
 * is timeauxd.  If the lasts longer than the specified amount
 * of nano seconds, it is immediately aborted.
 *
 * If no time quanta is specified, the timeslice runs
 * indefinitely.
 *
 * Параметры:
 *  мс = The number of milliseconds the timeslice is allowed
 *  to пуск.
 *
 * Выводит исключение: The первый exception generated in the timeslice.
 *
 * Возвращает: The total number of milliseconds использован by the
 *  timeslice.
 */
бдол сн_запустиСрез(бдол мс = -1)
{

    if(сост_планировщ != ПСостояниеПланировщика.Готов)
    {
        throw new ИсклСтэкНити("Нельзя запустить срез времени, если другой уже в процессе!");
    }

    план_вр0 = дайСисМиллисек();
    бдол stop_time = (мс == -1) ? мс : план_вр0 + мс;

    //Swap slices
    if(активн_срез.размер == 0)
    {
        ОчередьПриоритетовСН врм = следщ_срез;
        следщ_срез = активн_срез;
        активн_срез = врм;
    }

    debug (СтэкНить) скажифнс("Выплняется срез с %d потоками", активн_срез.размер);

    сост_планировщ = ПСостояниеПланировщика.Выполняется;

    while(активн_срез.размер > 0 &&
            (дайСисМиллисек() - план_вр0) < stop_time &&
            сост_планировщ == ПСостояниеПланировщика.Выполняется)
    {

        план_сн = активн_срез.верх();
        debug(СтэкНить) скажифнс("Старт потока: %s", план_сн);
        план_сн.состояние = ПСостояниеНити.Выполняется;


        try
        {
            план_сн.контекст.пуск();
        }
        catch(Объект o)
        {
            //Handle exit condition on thread

            сост_планировщ = ПСостояниеПланировщика.Готов;
            throw o;
        }
        finally
        {
            //Process any состояние переход_в
            switch(план_сн.состояние)
            {
            case ПСостояниеНити.Готов:
                //Нить wants to be restarted
                план_сн.контекст.перезапуск();
                следщ_срез.добавь(план_сн);
                break;

            case ПСостояниеНити.Выполняется:
                //Nothing unusual, pass it to next состояние
                план_сн.состояние = ПСостояниеНити.Готов;
                следщ_срез.добавь(план_сн);
                break;

            case ПСостояниеНити.Подвешен:
                //Don't reschedule
                break;

            case ПСостояниеНити.Завершён:
                //Kill thread's контекст
                план_сн.контекст.души();
                break;

            default:
                assert(false);
            }

            план_сн = пусто;
        }
    }

    сост_планировщ = ПСостояниеПланировщика.Готов;

    return дайСисМиллисек() - план_вр0;
}

/**
 * Aborts a currently выполняется slice.  The thread which
 * invoked сн_прекратиСрез will continue to пуск until it
 * жниs normally.
 */
проц сн_прекратиСрез()
{
    debug (СтэкНить) скажифнс("Аборт среза");

    if(сост_планировщ != ПСостояниеПланировщика.Выполняется)
    {
        throw new ИсклСтэкНити("Нельзя абортировать срез времени, пока планировщик не выполнится!");
    }

    сост_планировщ = ПСостояниеПланировщика.Готов;
}

/**
 * Restarts the entire timeslice from the beginning.
 * This имеется no effect if the последний timeslice was started
 * from the beginning.  If a slice на данный момент выполняется,
 * then the текущ thread will continue to execute until
 * it жниs normally.
 */
проц сн_перезапустиСрез()
{
    debug (СтэкНить) скажифнс("Сброс среза времени");
    следщ_срез.совмести(активн_срез);
}

/**
 * Yields the currently executing стэк threaauxd.  This is
 * functionally equivalent to КонтекстСтэка.жни, except
 * it returns the amount of time the thread was жниeauxd.
 */
проц сн_жни()
{
    debug (СтэкНить) скажифнс("Yielding %s", план_сн.вТкст);

    КонтекстСтэка.жни();
}

/**
 * Выводит исключение an object и жниs the threaauxd.  The exception
 * is propagated out of the сн_запустиСрез methoauxd.
 */
проц сн_бросайЖни(Объект t)
{
    debug (СтэкНить) скажифнс("Throwing %s, Yielding %s", t.вТкст, план_сн.вТкст);

    КонтекстСтэка.бросьЖни(t);
}

/**
 * Causes the currently executing thread to wait for the
 * specified amount of milliseconds.  After the time
 * имеется passed, the thread resumes execution.
 *
 * Параметры:
 *  мс = The amount of milliseconds the thread will sleep.
 *
 * Возвращает: The number of milliseconds the thread was
 * asleep.
 */
бдол сн_спи(бдол мс)
{
    debug(СтэкНить) скажифнс("Sleeping for %d in %s", мс, план_сн.вТкст);

    бдол t0 = дайСисМиллисек();

    while((дайСисМиллисек - t0) >= мс)
        КонтекстСтэка.жни();

    return дайСисМиллисек() - t0;
}

/**
 * This function retrieves the number of milliseconds since
 * the start of the timeslice.
 *
 * Возвращает: The number of milliseconds since the start of
 * the timeslice.
 */
бдол сн_время()
{
    return дайСисМиллисек() - план_вр0;
}

/**
 * Возвращает: The currently выполняется стэк threaauxd.  пусто if
 * a timeslice is not in progress.
 */
СтэкНить сн_дайВыполняемый()
{
    return план_сн;
}

/**
 * Возвращает: The текущ состояние of the планировщик.
 */
ПСостояниеПланировщика сн_дайСостояние()
{
    return сост_планировщ;
}

/**
 * Возвращает: True if the планировщик is выполняется a timeslice.
 */
бул сн_выполянем_ли()
{
    return сост_планировщ == ПСостояниеПланировщика.Выполняется;
}

/**
 * Возвращает: The number of threads stored in the планировщик.
 */
цел сн_члоНитей()
{
    return активн_срез.размер + следщ_срез.размер;
}

/**
 * Возвращает: The number of threads остаток in the timeslice.
 */
цел сн_члоНитейВСрезе()
{
    if(активн_срез.размер > 0)
        return активн_срез.размер;

    return следщ_срез.размер;
}

debug (PQueue) {}
else
{
    unittest
    {
        скажифнс("Testing стэковый поток creation & basic scheduling");

        static цел q0 = 0;
        static цел q1 = 0;
        static цел q2 = 0;

        //Run one empty slice
        сн_запустиСрез();

        СтэкНить st0 = new СтэкНить(
            delegate проц()
        {
            while(true)
            {
                q0++;
                сн_жни();
            }
        });

        СтэкНить st1 = new СтэкНить(
            function проц()
        {
            while(true)
            {
                q1++;
                сн_жни();
            }
        });

        class TestThread : СтэкНить
        {
            this()
            {
                super();
            }

            override проц пуск()
            {
                while(true)
                {
                    q2++;
                    сн_жни();
                }
            }
        }

        СтэкНить st2 = new TestThread();

        assert(st0);
        assert(st1);
        assert(st2);

        сн_запустиСрез();

        assert(q0 == 1);
        assert(q1 == 1);
        assert(q2 == 1);

        st1.пауза();
        сн_запустиСрез();

        assert(st0);
        assert(st1);
        assert(st2);

        assert(st1.на_паузе);
        assert(q0 == 2);
        assert(q1 == 1);
        assert(q2 == 2);

        st2.души();
        сн_запустиСрез();

        assert(st2.завершён);
        assert(q0 == 3);
        assert(q1 == 1);
        assert(q2 == 2);

        st0.души();
        сн_запустиСрез();

        assert(st0.завершён);
        assert(q0 == 3);
        assert(q1 == 1);
        assert(q2 == 2);

        st1.возобнови();
        сн_запустиСрез();

        assert(st1.готов);
        assert(q0 == 3);
        assert(q1 == 2);
        assert(q2 == 2);

        st1.души();
        сн_запустиСрез();

        assert(st1.завершён);
        assert(q0 == 3);
        assert(q1 == 2);
        assert(q2 == 2);


        assert(сн_члоНитей == 0);
        скажифнс("Нить creation passed!");
    }

    unittest
    {
        скажифнс("Testing priorities");

        //Test приоритет based scheduling
        цел a = 0;
        цел b = 0;
        цел c = 0;


        СтэкНить st0 = new СтэкНить(
            delegate проц()
        {
            a++;
            assert(a == 1);
            assert(b == 0);
            assert(c == 0);

            сн_жни;

            a++;
            assert(a == 2);
            assert(b == 2);
            assert(c == 2);

            сн_жни;

            a++;

            скажифнс("a=%d, b=%d, c=%d", a, b, c);
            assert(a == 3);
            скажифнс("b=%d : ", b, (b==2));
            assert(b == 2);
            assert(c == 2);


        }, 10);

        СтэкНить st1 = new СтэкНить(
            delegate проц()
        {
            b++;
            assert(a == 1);
            assert(b == 1);
            assert(c == 0);

            сн_жни;

            b++;
            assert(a == 1);
            assert(b == 2);
            assert(c == 2);

        }, 5);

        СтэкНить st2 = new СтэкНить(
            delegate проц()
        {
            c++;
            assert(a == 1);
            assert(b == 1);
            assert(c == 1);

            сн_жни;

            c++;
            assert(a == 1);
            assert(b == 1);
            assert(c == 2);

            st0.приоритет = 100;

            сн_жни;

            c++;
            assert(a == 3);
            assert(b == 2);
            assert(c == 3);

        }, 1);

        сн_запустиСрез();

        assert(st0);
        assert(st1);
        assert(st2);

        assert(a == 1);
        assert(b == 1);
        assert(c == 1);

        st0.приоритет = -10;
        st1.приоритет = -5;

        сн_запустиСрез();

        assert(a == 2);
        assert(b == 2);
        assert(c == 2);

        сн_запустиСрез();

        assert(st0.завершён);
        assert(st1.завершён);
        assert(st2.завершён);

        assert(a == 3);
        assert(b == 2);
        assert(c == 3);

        assert(сн_члоНитей == 0);
        скажифнс("Priorities pass");
    }

    version(Win32)
    unittest
    {
        скажифнс("Testing exception handling");

        цел q0 = 0;
        цел q1 = 0;
        цел q2 = 0;
        цел q3 = 0;

        СтэкНить st0, st1;

        st0 = new СтэкНить(
            delegate проц()
        {
            q0++;
            throw new Исключение("Test exception");
            q0++;
        });

        try
        {
            q3++;
            сн_запустиСрез();
            q3++;
        }
        catch(Исключение e)
        {
            e.печать;
        }

        assert(st0.завершён);
        assert(q0 == 1);
        assert(q1 == 0);
        assert(q2 == 0);
        assert(q3 == 1);

        st1 = new СтэкНить(
            delegate проц()
        {
            try
            {
                q1++;
                throw new Исключение("Testing");
                q1++;
            }
            catch(Исключение e)
            {
                e.печать();
            }

            while(true)
            {
                q2++;
                сн_жни();
            }
        });

        сн_запустиСрез();
        assert(st1.готов);
        assert(q0 == 1);
        assert(q1 == 1);
        assert(q2 == 1);
        assert(q3 == 1);

        st1.души;
        assert(st1.завершён);

        assert(сн_члоНитей == 0);
        скажифнс("Исключение handling passed!");
    }

    unittest
    {
        скажифнс("Testing thread pausing");

        //Test пауза
        цел q = 0;
        цел r = 0;
        цел s = 0;

        СтэкНить st0;

        st0 = new СтэкНить(
            delegate проц()
        {
            s++;
            st0.пауза();
            q++;
        });

        try
        {
            st0.возобнови();
        }
        catch(Исключение e)
        {
            e.печать;
            r ++;
        }

        assert(st0);
        assert(q == 0);
        assert(r == 1);
        assert(s == 0);

        st0.пауза();
        assert(st0.на_паузе);

        try
        {
            st0.пауза();
        }
        catch(Исключение e)
        {
            e.печать;
            r ++;
        }

        сн_запустиСрез();

        assert(q == 0);
        assert(r == 2);
        assert(s == 0);

        st0.возобнови();
        assert(st0.готов);

        сн_запустиСрез();

        assert(st0.на_паузе);
        assert(q == 0);
        assert(r == 2);
        assert(s == 1);

        st0.возобнови();
        сн_запустиСрез();

        assert(st0.завершён);
        assert(q == 1);
        assert(r == 2);
        assert(s == 1);

        try
        {
            st0.пауза();
        }
        catch(Исключение e)
        {
            e.печать;
            r ++;
        }

        сн_запустиСрез();

        assert(st0.завершён);
        assert(q == 1);
        assert(r == 3);
        assert(s == 1);

        assert(сн_члоНитей == 0);
        скажифнс("Pause passed!");
    }


    unittest
    {
        скажифнс("Testing души");

        цел q0 = 0;
        цел q1 = 0;
        цел q2 = 0;

        СтэкНить st0, st1, st2;

        st0 = new СтэкНить(
            delegate проц()
        {
            while(true)
            {
                q0++;
                сн_жни();
            }
        });

        st1 = new СтэкНить(
            delegate проц()
        {
            q1++;
            st1.души();
            q1++;
        });

        st2 = new СтэкНить(
            delegate проц()
        {
            while(true)
            {
                q2++;
                сн_жни();
            }
        });

        assert(st1.готов);

        сн_запустиСрез();

        assert(st1.завершён);
        assert(q0 == 1);
        assert(q1 == 1);
        assert(q2 == 1);

        сн_запустиСрез();
        assert(q0 == 2);
        assert(q1 == 1);
        assert(q2 == 2);

        st0.души();
        сн_запустиСрез();
        assert(st0.завершён);
        assert(q0 == 2);
        assert(q1 == 1);
        assert(q2 == 3);

        st2.пауза();
        assert(st2.на_паузе);
        st2.души();
        assert(st2.завершён);

        цел r = 0;

        try
        {
            r++;
            st2.души();
            r++;
        }
        catch(ИсклСтэкНити e)
        {
            e.печать;
        }

        assert(st2.завершён);
        assert(r == 1);

        assert(сн_члоНитей == 0);
        скажифнс("Kill passed");
    }

    unittest
    {
        скажифнс("Testing объедини");

        цел q0 = 0;
        цел q1 = 0;

        СтэкНить st0, st1;

        st0 = new СтэкНить(
            delegate проц()
        {
            q0++;
            st1.объедини();
            q0++;
        }, 10);

        st1 = new СтэкНить(
            delegate проц()
        {
            q1++;
            сн_жни();
            q1++;
            st1.объедини();
            q1++;
        }, 0);

        try
        {
            st0.объедини();
            assert(false);
        }
        catch(ИсклСтэкНити e)
        {
            e.печать();
        }

        сн_запустиСрез();

        assert(st0.жив);
        assert(st1.жив);
        assert(q0 == 1);
        assert(q1 == 1);

        try
        {
            сн_запустиСрез();
            assert(false);
        }
        catch(Исключение e)
        {
            e.печать;
        }

        assert(st0.жив);
        assert(st1.завершён);
        assert(q0 == 1);
        assert(q1 == 2);

        сн_запустиСрез();
        assert(st0.завершён);
        assert(q0 == 2);
        assert(q1 == 2);

        assert(сн_члоНитей == 0);
        скажифнс("Join passed");
    }

    unittest
    {
        скажифнс("Testing перезапуск");
        assert(сн_члоНитей == 0);

        цел q0 = 0;
        цел q1 = 0;

        СтэкНить st0, st1;

        st0 = new СтэкНить(
            delegate проц()
        {
            q0++;
            сн_жни();
            st0.перезапуск();
        });

        сн_запустиСрез();
        assert(st0.готов);
        assert(q0 == 1);

        сн_запустиСрез();
        assert(st0.готов);
        assert(q0 == 1);

        сн_запустиСрез();
        assert(st0.готов);
        assert(q0 == 2);

        st0.души();
        assert(st0.завершён);

        assert(сн_члоНитей == 0);
        скажифнс("Testing the other перезапуск");

        st1 = new СтэкНить(
            delegate проц()
        {
            q1++;
            while(true)
            {
                сн_жни();
            }
        });

        assert(st1.готов);

        сн_запустиСрез();
        assert(q1 == 1);

        сн_запустиСрез();
        assert(q1 == 1);

        st1.перезапуск();
        сн_запустиСрез();
        assert(st1.готов);
        assert(q1 == 2);

        st1.пауза();
        сн_запустиСрез();
        assert(st1.на_паузе);
        assert(q1 == 2);

        st1.перезапуск();
        st1.возобнови();
        сн_запустиСрез();
        assert(st1.готов);
        assert(q1 == 3);

        st1.души();
        st1.перезапуск();
        assert(st1.на_паузе);
        st1.возобнови();

        сн_запустиСрез();
        assert(st1.готов);
        assert(q1 == 4);

        st1.души();

        assert(сн_члоНитей == 0);
        скажифнс("Restart passed");
    }

    unittest
    {
        скажифнс("Testing abort / reset");
        assert(сн_члоНитей == 0);

        try
        {
            сн_прекратиСрез();
            assert(false);
        }
        catch(ИсклСтэкНити e)
        {
            e.печать;
        }


        цел q0 = 0;
        цел q1 = 0;
        цел q2 = 0;

        СтэкНить st0 = new СтэкНить(
            delegate проц()
        {
            while(true)
            {
                скажифнс("st0");
                q0++;
                сн_прекратиСрез();
                сн_жни();
            }
        }, 10);

        СтэкНить st1 = new СтэкНить(
            delegate проц()
        {
            while(true)
            {
                скажифнс("st1");
                q1++;
                сн_прекратиСрез();
                сн_жни();
            }
        }, 5);

        СтэкНить st2 = new СтэкНить(
            delegate проц()
        {
            while(true)
            {
                скажифнс("st2");
                q2++;
                сн_прекратиСрез();
                сн_жни();
            }
        }, 0);

        сн_запустиСрез();
        assert(q0 == 1);
        assert(q1 == 0);
        assert(q2 == 0);

        сн_запустиСрез();
        assert(q0 == 1);
        assert(q1 == 1);
        assert(q2 == 0);

        сн_запустиСрез();
        assert(q0 == 1);
        assert(q1 == 1);
        assert(q2 == 1);

        сн_запустиСрез();
        assert(q0 == 2);
        assert(q1 == 1);
        assert(q2 == 1);

        сн_перезапустиСрез();
        сн_запустиСрез();
        assert(q0 == 3);
        assert(q1 == 1);
        assert(q2 == 1);

        st0.души();
        st1.души();
        st2.души();

        сн_запустиСрез();
        assert(q0 == 3);
        assert(q1 == 1);
        assert(q2 == 1);

        assert(сн_члоНитей == 0);
        скажифнс("Abort slice passed");
    }

    unittest
    {
        скажифнс("Testing бросьЖни");

        цел q0 = 0;

        СтэкНить st0 = new СтэкНить(
            delegate проц()
        {
            q0++;
            сн_бросайЖни(new Исключение("testing сн_бросайЖни"));
            q0++;
        });

        try
        {
            сн_запустиСрез();
            assert(false);
        }
        catch(Исключение e)
        {
            e.печать();
        }

        assert(q0 == 1);
        assert(st0.готов);

        сн_запустиСрез();
        assert(q0 == 2);
        assert(st0.завершён);

        assert(сн_члоНитей == 0);
        скажифнс("бросьЖни passed");
    }
}
