module io.Buffer;

private import exception, cidrus: memcpy;
public  import io.model;

//debug=Buffer;
//pragma (msg, "Внимание: работа io.Buffer разделена на io.stream.Buffered и io.device.Array - первый используется для дискретных потоков, а последний для комбинированного ВВ");
class Буфер : ИБуфер
{
    protected ИПотокВывода  бвывод;                // опциональные данные бвывод
    protected ИПотокВвода   бввод;                 // опциональные данные бввод
    protected проц[]        данные;                   // буфер необработанных данных
    protected т_мера        индекс;                  // текущая позиция чтения
    protected т_мера        протяженность;                 // предел действительного контента
    protected т_мера        дименсия;              // максимальная протяженность контента
    protected бул          можноСжать = да;     // сжимать ли контент обходчика?


    protected static ткст перебор  = "буфер вывода полон";
    protected static ткст недобор = "буфер ввода пуст";
    protected static ткст кфЧтен   = "достигнут конец потока при чтении";
    protected static ткст кфЗап  = "достигнут конец потока при записи";

    invariant
    {
        assert (индекс <= протяженность);
        assert (протяженность <= дименсия);
    }



    this (ИПровод провод)
    {
        assert (провод);

        this (провод.размерБуфера);
        устПровод (провод);
    }


    this (ИПотокВвода поток, т_мера ёмкость)
    {
        this (ёмкость);
        ввод = поток;
    }

    this (ИПотокВывода поток, т_мера ёмкость)
    {
        this (ёмкость);
        вывод = поток;
    }


    this (т_мера ёмкость = 0)
    {
        устКонтент (new ббайт[ёмкость], 0);
    }


    this (проц[] данные)
    {
        устКонтент (данные, данные.length);
    }


    this (проц[] данные, т_мера читаемый)
    {
        устКонтент (данные, читаемый);
    }


    static ИБуфер совместно (ИПотокВвода поток, т_мера размер = т_мера.max)
    {
        auto b = cast(ИБуферированный) поток;
        if (b)
            return b.буфер;

        if (размер is т_мера.max)
            размер = поток.провод.размерБуфера;

        return new Буфер (поток, размер);
    }

    static ИБуфер совместно (ИПотокВывода поток, т_мера размер = т_мера.max)
    {
        auto b = cast(ИБуферированный) поток;
        if (b)
            return b.буфер;

        if (размер is т_мера.max)
            размер = поток.провод.размерБуфера;

        return new Буфер (поток, размер);
    }

    ИБуфер устКонтент (проц[] данные)
    {
        return устКонтент (данные, данные.length);
    }

    ИБуфер устКонтент (проц[] данные, т_мера читаемый)
    {
        this.данные = данные;
        this.протяженность = читаемый;
        this.дименсия = данные.length;

        // сбросить на начало ввода
        this.индекс = 0;

        return this;
    }


    проц[] срез ()
    {
        return  данные [индекс .. протяженность];
    }

    final проц[] opSlice (т_мера старт, т_мера конец)
    {
        assert (старт <= протяженность && конец <= протяженность && старт <= конец);
        return данные [старт .. конец];
    }

    проц[] срез (т_мера размер, бул съешь = да)
    {
        if (размер > читаемый)
        {
            if (бввод is пусто)
                ошибка (недобор);

            if (размер > (дименсия - индекс))
            {
                if (размер > дименсия)
                    ошибка (недобор);
                if (можноСжать)
                    сожми ();
            }

            // наполнить хвост буфера новым контентом
            do
            {
                if (заполни(бввод) is ИПровод.Кф)
                    ошибка (кфЧтен);
            }
            while (размер > читаемый);
        }

        auto i = индекс;
        if (съешь)
            индекс += размер;
        return данные [i .. i + размер];
    }

    т_мера заполни (проц[] приёмн)
    {
        т_мера длин = 0;

        while (длин < приёмн.length)
        {
            auto i = читай (приёмн [длин .. $]);
            if (i is ИПровод.Кф)
                return (длин > 0) ? длин : ИПровод.Кф;
            длин += i;
        }
        return длин;
    }

    проц[]  читайРовно (ук приёмн, т_мера байты)
    {
        auto врем = приёмн [0 .. байты];
        if (заполни (врем) != байты)
            ошибка (кфЧтен);

        return врем;
    }


    ИБуфер добавь (проц[] ист)
    {
        return добавь (ист.ptr, ист.length);
    }


    ИБуфер добавь (ук ист, т_мера длина)
    {
        if (длина > записываемый)
            // cможем ли писать извне?
            if (бвывод)
            {
                слей;

                // проверить на паталогию
                if (длина > дименсия)
                {
                    do
                    {
                        auto записано = бвывод.пиши (ист [0 .. длина]);
                        if (записано is ИПровод.Кф)
                            ошибка (кфЗап);
                        ист += записано, длина -= записано;
                    }
                    while (длина > дименсия);
                }
            }
            else
                ошибка (перебор);

        копируй (ист, длина);
        return this;
    }

    ИБуфер добавь (ИБуфер другой)
    {
        return добавь (другой.срез);
    }


    проц потреби (проц[] x)
    {
        добавь (x);
    }


    бул пропусти (цел размер)
    {
        if (размер < 0)
        {
            размер = -размер;
            if (индекс >= размер)
            {
                индекс -= размер;
                return да;
            }
            return нет;
        }
        return срез(размер) !is пусто;
    }

    дол сместись (дол смещение, Якорь старт = Якорь.Нач)
    {
        if (старт is Якорь.Тек)
        {
            // Так как экземпляр буфферированный,
            // требуется преобразовывать позицию в буфере
            // при перемещении (т.е. seeking'е) СИКИНГ!
            смещение -= this.читаемый;
            auto bpos = смещение + this.предел;

            if (bpos >= 0 && bpos < this.предел)
            {
                // Новая позиция расположена внутри текущего
                // буфера, пропускаем до этой позиции.
                пропусти (cast(цел) bpos - cast(цел) this.позиция);
                return 0;
                //return провод.позиция - ввод.читаемый;
            }
            // Иначе позиция вне буфера. Выполнить реальное
            // смещение, используя прикреплённую позицию.
        }

        очисть;
        return бввод.сместись (смещение, старт);
    }

    бул следщ (т_мера delegate (проц[]) скан)
    {
        while (читатель(скан) is ИПровод.Кф)
            // не найден - это стриминг?
            if (бввод)
            {
                if (позиция && можноСжать)
                      сожми;
                else
                    // Есть ли ещё пространство в буфере?
                    if (записываемый is 0 && расширь(0) is 0)
                        ошибка ("Токен слишком массивен и не помещается в буфер");

                // читай другой чанк of данные
                if (заполни(бввод) is ИПровод.Кф)
                    return нет;
            }
            else
                return нет;

        return да;
    }

    final бул сожми (бул да)
    {
        auto возвр = можноСжать;
        можноСжать = да;
        return возвр;
    }

    т_мера читаемый ()
    {
        return протяженность - индекс;
    }


    т_мера записываемый ()
    {
        return дименсия - протяженность;
    }


    final т_мера резервируй (т_мера пространство)
    {
        assert (пространство < дименсия);

        if ((дименсия - индекс) < пространство)
            сожми;
        return индекс;
    }


    т_мера писатель (т_мера delegate (проц[]) дг)
    {
        auto счёт = дг (данные [протяженность..дименсия]);

        if (счёт != ИПровод.Кф)
        {
            протяженность += счёт;
            assert (протяженность <= дименсия);
        }
        return счёт;
    }

    т_мера читатель (т_мера delegate (проц[]) дг)
    {
        auto счёт = дг (данные [индекс..протяженность]);

        if (счёт != ИПровод.Кф)
        {
            индекс += счёт;
            assert (индекс <= протяженность);
        }
        return счёт;
    }

    ИБуфер сожми ()
    {
        auto r = читаемый;

        if (индекс > 0 && r > 0)
            // контент may overlap ...
            memcpy (&данные[0], &данные[индекс], r);

        индекс = 0;
        протяженность = r;
        return this;
    }

    т_мера заполни (ИПотокВвода ист)
    {
        if (ист is пусто)
            return ИПровод.Кф;
        /+
        // Сброс здесь не нужен, так как мы только заполняем!
        if (читаемый is 0 && можноСжать)
            индекс = протяженность = 0;  // то же что и очисть(), бев цепи вызовов
        else if (записываемый is 0)
            return 0;
        +/
        return писатель (&ист.читай);
    }

    final т_мера дренируй (ИПотокВывода приёмн)
    {
        if (приёмн is пусто)
            return ИПровод.Кф;

        auto возвр = читатель (&приёмн.пиши);
        if (возвр is ИПровод.Кф)
            ошибка (кфЗап);

        сожми ();
        return возвр;
    }


    бул упрости (т_мера length)
    {
        if (length <= данные.length)
        {
            протяженность = length;
            return да;
        }
        return нет;
    }


    т_мера предел ()
    {
        return протяженность;
    }


    т_мера ёмкость ()
    {
        return дименсия;
    }


    т_мера позиция ()
    {
        return индекс;
    }


    ИБуфер устПровод (ИПровод провод)
    {
        бвывод = провод;
        бввод = провод;
        return this;
    }

    final ИБуфер вывод (ИПотокВывода бвывод)
    {
        this.бвывод = бвывод;
        return this;
    }

    final ИБуфер ввод (ИПотокВвода бввод)
    {
        this.бввод = бввод;
        return this;
    }

    protected проц[] дайКонтент ()
    {
        return данные;
    }

    protected проц копируй (проц *ист, т_мера размер)
    {
        // Тест во избежание "out of bounds" при нулевом размере
        if (размер)
        {
            // контент может нахлёстываться ...
            memcpy (&данные[протяженность], ист, размер);
            протяженность += размер;
        }
    }

    protected т_мера расширь (т_мера размер)
    {
        return записываемый;
    }

    static T[] преобразуй(T)(проц[] x)
    {
        return (cast(T*) x.ptr) [0 .. (x.length / T.sizeof)];
    }


    ИБуфер буфер ()
    {
        return this;
    }


    БуферВвода бвхо ()
    {
        return пусто;
    }

    БуферВывода бвых ()
    {
        return пусто;
    }


    override ткст вТкст ()
    {
        return "<буфер>";
    }

    final проц ошибка (ткст сооб)
    {
        throw new ВВИскл (сооб);
    }

    override ИПотокВывода слей ()
    {
        if (бвывод)
        {
            while (читаемый() > 0)
                дренируй (бвывод);

            // слить также цепочку-фильтр
            бвывод.слей;
        }
        return this;
    }

    override ИПотокВвода очисть ()
    {
        индекс = протяженность = 0;

        // очисть the фильтр chain also
        if (бввод)
            бввод.слей;
        return this;
    }

    override ИПотокВывода копируй (ИПотокВвода ист, т_мера max=-1)
    {
        while (заполни(ист) != ИПровод.Кф)
            // не дренировать, пока действительно не понадобится
            if (записываемый is 0)
                if (бвывод)
                    дренируй (бвывод);
                else
                    ошибка (перебор);
        return this;
    }


    проц[] загрузи (т_мера max=-1)
    {
        return срез;
    }

    override т_мера читай (проц[] приёмн)
    {
        auto контент = читаемый();
        if (контент)
        {
            if (контент >= приёмн.length)
                контент = приёмн.length;

            // переместить контент буфера
            приёмн [0 .. контент] = данные [индекс .. индекс + контент];
            индекс += контент;
        }
        else if (бввод)
        {
            // pathological cases читай directly из_ провод
            if (приёмн.length > дименсия)
                контент = бввод.читай (приёмн);
            else
            {
                if (записываемый is 0)
                    индекс = протяженность = 0;  // same as очисть(), without вызов-chain

                // keep буфер partially populated
                if ((контент = заполни(бввод)) != ИПровод.Кф && контент > 0)
                    контент = читай (приёмн);
            }
        }
        else
            контент = ИПровод.Кф;
        return контент;
    }


    override т_мера пиши (проц[] ист)
    {
        добавь (ист.ptr, ист.length);
        return ист.length;
    }

    final override ИПровод провод ()
    {
        if (бвывод)
            return бвывод.провод;
        else if (бввод)
            return бввод.провод;
        return this;
    }


    final override т_мера размерБуфера ()
    {
        return 32 * 1024;
    }

    final override бул жив_ли ()
    {
        return да;
    }


    final ИПотокВывода вывод ()
    {
        return бвывод;
    }


    final ИПотокВвода ввод ()
    {
        return бввод;
    }

    final override проц открепи ()
    {
    }


    override проц закрой ()
    {
        if (бвывод)
            бвывод.закрой;
        else if (бввод)
            бввод.закрой;
    }
}


Буфер объБуфер (ИПровод провод)
{
    return new Буфер(провод);
}


Буфер объБуфер (ИПотокВвода поток, т_мера ёмкость)
{
    return new Буфер(поток, ёмкость);
}

Буфер объБуфер(ИПотокВывода поток, т_мера ёмкость)
{
    return new Буфер(поток, ёмкость);
}


Буфер объБуфер(т_мера ёмкость = 0)
{
    return new Буфер(ёмкость);
}


Буфер объБуфер (проц[] данные)
{
    return new Буфер(данные);
}


Буфер объБуфер (проц[] данные, т_мера читаемый)
{
    return new Буфер(данные, читаемый);
}

class БуферРоста : Буфер
{
    private т_мера инкремент;

    alias Буфер.срез  срез;
    alias Буфер.добавь добавь;



    this (т_мера размер = 1024, т_мера инкремент = 1024)
    {
        super (размер);

        assert (инкремент >= 32);
        this.инкремент = инкремент;
    }


    this (ИПровод провод, т_мера размер = 1024)
    {
        this (размер, размер);
        устПровод (провод);
    }


    override проц[] срез (т_мера размер, бул съешь = да)
    {
        if (размер > читаемый)
        {
            if (бввод is пусто)
                ошибка (недобор);

            if (размер + индекс > дименсия)
                расширь (размер);

            // наполни хвост of буфер with new контент
            do
            {
                if (заполни(бввод) is ИПровод.Кф)
                    ошибка (кфЧтен);
            }
            while (размер > читаемый);
        }

        auto i = индекс;
        if (съешь)
            индекс += размер;
        return данные [i .. i + размер];
    }


    override ИБуфер добавь (проц *ист, т_мера length)
    {
        if (length > записываемый)
            расширь (length);

        копируй (ист, length);
        return this;
    }


    override т_мера заполни (ИПотокВвода ист)
    {
        if (записываемый <= инкремент/8)
            расширь (инкремент);

        return писатель (&ист.читай);
    }


    т_мера заполни (т_мера размер = т_мера.max)
    {
        while (читаемый < размер)
            if (заполни(бввод) is ИПровод.Кф)
                break;
        return читаемый;
    }

    override т_мера расширь (т_мера размер)
    {
        if (размер < инкремент)
            размер = инкремент;

        дименсия += размер;
        данные.length = дименсия;
        return записываемый;
    }
}

БуферРоста объБуферРоста (т_мера размер = 1024, т_мера инкремент = 1024)
{
    return new БуферРоста(размер, инкремент);
}


БуферРоста объБуферРоста (ИПровод провод, т_мера размер = 1024)
{
    return new БуферРоста(провод, размер);
}


debug (Buffer)
{
    unittest
    {
        auto б = new Буфер(6);
        б.добавь ("что-то");
        б.резервируй (1);
        б.срез (5);
        б.резервируй (4);
    }
}
