/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. Все права защищены

        license:        BSD стиль: $(LICENSE)

        version:        Jun 2004: Initial release
        version:        Dec 2006: Pacific release

        author:         Kris

*******************************************************************************/

module io.FileScan;

public  import io.FilePath;
private import exception;

/*******************************************************************************

        Рекурсивно сканирует файлы и папки, добавляя отфильтрованные файлы в
        структуру вывода. Может использоваться для создания списка подпапок
        и содержащихся в них файлов. Следующий пример создаёт список всех файлов
        с суффиксом ".d", включающий текущую папку со всеми, расположенными в ней,
        подпапками:
        ---
        auto скан = new СканФайл;

        скан (".", ".d");

        Стдвыв.форматнс ("{} Папкок", скан.папки.length);
        foreach (папка; скан.папки)
                 Стдвыв.форматнс ("{}", папка);

        Стдвыв.форматнс ("\n{} Файлов", скан.файлы.length);
        foreach (файл; скан.файлы)
                 Стдвыв.форматнс ("{}", файл);
        ---

        Это непохоже на большинство эффективных методов сканирования большого числа
        файлов, но работает в удобной манере.
        
*******************************************************************************/

class СканФайл
{       
        alias смети     opCall;

        ФПуть[]      наборФайлов;
        ткст[]        наборОшибок;
        ФПуть[]      наборПапок;
        
        /***********************************************************************

            Псевдоним для делегата от Фильтр.Принимает ФПуть & бул в 
            качестве аргументов и возвращает булево значение.

            Аргумент ФПуть представляет файл, найденный при сканировании, 
            и бул, если ФПуть является папкой.

            Этот фильтр возвращает да, если находит совпадения. Заметьте,
            возврат нет, когда путь представляет папку, приводит к тому, 
            что все содержащиеся в ней файлы игнорируются. Чтобы всегда 
            проводить рекурсию папкок, делаем следующее:
            ---
            return (папка_ли || свер (fp.имя));
            ---

        ***********************************************************************/

        alias ФПуть.Фильтр Фильтр;

       /***********************************************************************

            Возвращает все ошибки, найденные при последнем сканировании.

        ***********************************************************************/


        public ткст[] ошибки ()
        {
                return наборОшибок;
        }

        /***********************************************************************

            Возвращает все файлы, найденные при последнем сканировании.

        ***********************************************************************/

        public ФПуть[] файлы ()
        {
                return наборФайлов;
        }

        /***********************************************************************
        
            Возвращает все папки, найденные при последнем сканировании.

        ***********************************************************************/

        public ФПуть[] папки ()
        {
                return наборПапок;
        }

        /***********************************************************************

                Sweep a установи of файлы and directories из_ the given родитель
                путь, with no filtering applied
        
        ***********************************************************************/
        
        СканФайл смети (ткст путь, бул рекурсия=да)
        {
                return смети (путь, cast(Фильтр) пусто, рекурсия);
        }

        /***********************************************************************

                Sweep a установи of файлы and directories из_ the given родитель
                путь, where the файлы are filtered by the given суффикс
        
        ***********************************************************************/
        
        СканФайл смети (ткст путь, ткст свер, бул рекурсия=да)
        {
                return смети (путь, (ФПуть fp, бул папка_ли)
                             {return папка_ли || fp.суффикс == свер;}, рекурсия);
        }

        /***********************************************************************

                Sweep a установи of файлы and directories из_ the given родитель
                путь, where the файлы are filtered by the предоставленный delegate

        ***********************************************************************/
        
        СканФайл смети (ткст путь, Фильтр фильтр, бул рекурсия=да)
        {
                наборОшибок = пусто, наборФайлов = наборПапок = пусто;
                return скан (new ФПуть(путь), фильтр, рекурсия);
        }

        /***********************************************************************

                Internal routine в_ местоположение файлы and sub-directories. We
                пропусти записи with names composed only of '.' characters. 

        ***********************************************************************/

        private СканФайл скан (ФПуть папка, Фильтр фильтр, бул рекурсия) 
        {
                try {
                    auto пути = папка.вСписок (фильтр);
                
                    auto счёт = наборФайлов.length;
                    foreach (путь; пути)
                             if (! путь.папка_ли)
                                   наборФайлов ~= путь;
                             else
                                if (рекурсия)
                                    скан (путь, фильтр, рекурсия);
                
                    // добавь packages only if there's something in them
                    if (наборФайлов.length > счёт)
                        наборПапок ~= папка;

                    } catch (ВВИскл e)
                             наборОшибок ~= e.вТкст;
                return this;
        }
}


/*******************************************************************************

*******************************************************************************/

debug (СканФайл)
{
        import io.Stdout;

        проц main()
        {
                auto скан = new СканФайл;

                скан (".");

                Стдвыв.форматнс ("{} Папки", скан.папки.length);
                foreach (папка; скан.папки)
                         Стдвыв (папка).нс;

                Стдвыв.форматнс ("\n{} Файлы", скан.файлы.length);
                foreach (файл; скан.файлы)
                         Стдвыв (файл).нс;

                Стдвыв.форматнс ("\n{} Ошибки", скан.ошибки.length);
                foreach (ошибка; скан.ошибки)
                         Стдвыв (ошибка).нс;
        }
}
