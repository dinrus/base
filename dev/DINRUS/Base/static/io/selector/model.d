module io.selector.model;

public import time.Time;
public import io.model;

/**
 * События, используемые для регистрации Провода к селектору и возвращаемые
 * в КлючеВыбора после вызова ИСелектор.выбери().
 */
enum Событие: бцел
{
    Нет            = 0,        // Нет события
    // ВАЖНО: Не меняйте значения следующих символов. Они установлены
    //            в соответствии со значениями, возвращаемыми системой вызовов POSIX poll().
    Чит            = (1 << 0), // POLLIN
    СрочноеЧтение      = (1 << 1), // POLLPRI
    Зап           = (1 << 2), // POLLOUT
    // Следующие события не следует использовать при регистрировании провода в
    // селектор. Они используются только при возвращении события пользователю.
    Ошибка           = (1 << 3), // POLLERR
    Зависание          = (1 << 4), // POLLHUP
    НеверныйУк   = (1 << 5)  // POLLNVAL
}


/**
 * Структура КлючВыбора содержит информацию, касающуюся проводов и их ассоциации
 * с селектором. Каждый ключ содержит ссылку на зарегистрированный провод
 * провод и события, которые бубуд на нём отслеживаться. Член 'события'
 * этого ключа может принимать два значения, в зависимости от того, где используется.
 * Если он использован с методом регистрируй() селектора, то представляет события,
 * которые нам нужно отслеживать; если использован внутри цикла foreach на ИНаборВыделений,
 * то он представляет события, которые были детектированы на проводе.
 *
 * КлючВыбора может также содержать необязательно объект через член 'атачмент'.
 * Этот член очень удобен для хранения специфичных данных приложения,
 * которые понадобятся при триггировании отслеживаемого события.
 *
 * Смотрите $(LINK $(CODEURL)io.selector.ИСелектор),
 * $(LINK $(CODEURL)io.selector.ИНаборВыделений)
 */
struct КлючВыбора
{
    /**
     * Провод, на который ссылается КлючВыбора.
     */
    ИВыбираемый провод;

    /**
     * Зарегистрированные (или селектированные) события как бит-маска 
	 * значения другого События.
     */
    Событие события;

    /**
     * Прикреплённый Объект, на который ссылается КлючВыбора.
     */
    Объект атачмент;

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Чит.
     */
    public бул читаем_ли()
    {
        return ((события & Событие.Чит) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие СрочноеЧтение.
     */
    public бул срочноеЧтен_ли()
    {
        return ((события & Событие.СрочноеЧтение) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Зап.
     */
    public бул записываем_ли()
    {
        return ((события & Событие.Зап) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Ошибка.
     */
    public бул ошибка_ли()
    {
        return ((события & Событие.Ошибка) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие Зависание.
     */
    public бул зависание_ли()
    {
        return ((события & Событие.Зависание) != 0);
    }

    /**
     * Проверяет, если с этим КлючомВыбора ассоциировано событие НеверныйУк.
     */
    public бул невернУк_ли()
    {
        return ((события & Событие.НеверныйУк) != 0);
    }
}


/**
 * Контейнер, хранящий КлючиВыбора для всех проводов, триггировавших
 * события при первом вызове метода ИСелектор.выбери().
 * Экземпляры этого контейнера обычно возвращаются из вызова
 * ИСелектор.наборВыд().
 */
interface ИНаборВыделений
{
    /**
     * Возвращает число КлючейВыбора в этом наборе.
     */
    public abstract бцел длина();

    /**
     * Оператор для итерации по набору с помощью блока foreach. Помните, что
     * любые изменения этого КлючаВыбора будут игнорироваться.
     */
    public abstract цел opApply(цел delegate(ref КлючВыбора) дг);
}


/**
 * Селектор - это мультиплексор для событий ввода-вывода, ассоциированный с Проводом.
 * Все селекоры должны реадизовывать этот интерфейс.
 *
 * Селектор нужно инициализировать вызовом метода открой(), чтобы сообщить
 * начальное количество проводов, на которые он будет указывать, и максимальное
 * количество событий, которое будет возвращено при каждом вызове выбери().
 * В любом случае эти значени - только рекомендации;они могут даже не использоваться
 * в определённых реализациях ИСелектор, поэтому трудно предсказать результат
 * вызова метода выбери() (то есть может быть больше или меньше событий,
 * нежели вами указано в аргументе 'максСобытий'. Количество проводов, с которыми
 * может иметь дело селектор, при необходимости будет динамически увеличено.
 *
 * Для добавления или изменения регистрации проводов в селекторе, используется
 * метод регистрируй(). Для удаления регистрации проводов из селектора,- метод
 * отмениРег().
 *
 * Для ожидания событий от проводов нужно вызвать любой из методов выбери().
 * Селектор не может быть изменён из другой нити (потока), пока он блокирован
 * вызовами этих методов.
 *
 * Когда селектор больше не используется требуется вызвать метод закрой(), чтобы
 * селектор смог освободить ресурсы, размещённые им в памяти при вызове открой().
 *
  * Примеры:
 * ---
 * import io.selector.model;
 * import net.device.Socket;
 * import io.Stdout;
 *
 * АбстрактныйСелектор селектор;
 * СокетПровод провод1;
 * СокетПровод провод2;
 * МойКласс объект1;
 * МойКласс объект2;
 * бцел счётСобытий;
 *
 * // Инициализируем селектор, предполагая его работу с двумя проводами
 * // и приём им двух событий на каждый вызов метода выбери().
 * селектор.открой(2, 2);
 *
 * селектор.регистрируй(провод, Событие.Чит, объект1);
 * селектор.регистрируй(провод, Событие.Зап, объект2);
 *
 * счётСобытий = селектор.выбери();
 *
 * if (счётСобытий > 0)
 * {
 *     сим[16] буфер;
 *     цел счёт;
 *
 *     foreach (КлючВыбора ключ, селектор.наборВыд())
 *     {
 *         if (ключ.читаем_ли())
 *         {
 *             счёт = (cast(СокетПровод) ключ.провод).читай(буфер);
 *             if (счёт != ИПровод.Кф)
 *             {
 *                 Стдвыв.форматируй("Принято '{0}' из пира\n", буфер[0..счёт]);
 *                 селектор.регистрируй(ключ.провод, Событие.Зап, ключ.атачмент);
 *             }
 *             else
 *             {
 *                 селектор.отмениРег(ключ.провод);
 *                 ключ.провод.закрой();
 *             }
 *         }
 *
 *         if (ключ.записываем_ли())
 *         {
 *             счёт = (cast(СокетПровод) ключ.провод).пиши("СООБЩЕНИЕ");
 *             if (счёт != ИПровод.Кф)
 *             {
 *                 Стдвыв("'СООБЩЕНИЕ' отправлено в пир\n");
 *                 селектор.регистрируй(ключ.провод, Событие.Чит, ключ.атачмент);
 *             }
 *             else
 *             {
 *                 селектор.отмениРег(ключ.провод);
 *                 ключ.провод.закрой();
 *             }
 *         }
 *
 *         if (ключ.ошибка_ли() || ключ.зависание_ли() || ключ.невернУк_ли())
 *         {
 *             селектор.отмениРег(ключ.провод);
 *             ключ.провод.закрой();
 *         }
 *     }
 * }
 *
 * селектор.закрой();
 * ---
 */
interface ИСелектор
{
    /**
     * Инициализирует селектор.
     *
     * Параметры:
     * размер         = значение, рекомендующее максимальное число 
     *                регестрируемых проводов.
     * максСобытий    = значение, рекомендующее максимальное число событий
     *                провода, возвращаемое в наборе селекции
     *                на каждый вызов метода выбери.
     */
    public abstract проц открой(бцел размер, бцел maxEvents);

    /**
     * Освободить ресурсы операционной системы, которые могли быть размещены в
     * впамяти при вызове метода открой().
     *
     * Примечания:
     * Требуется освобождение памяти только тех ресурсов, которые размещены там селектором.
     * Не все селекторы это делают. В их деструкторе обычно присутствует метод закрой().
     */
    public abstract проц закрой();

    /**
     * Ассоциировать провод с селектором и отслеживать события ввода-вывода.
     *
     * Параметры:
     * провод      = провод, ассоциируемый с селектором.
     * события       = бит-маска значения События, представляющая события,
     *                которые будут отслеживаться на этом проводе.
     * атачмент   = необязательный объект со специфицными для приложения данными,
     *                которые будут доступны при тригерировании события для этого провода.
     *
     * Примеры:
     * ---
     * АбстрактныйСелектор селектор;
     * СокетПровод провод;
     * МойКласс объект;
     *
     * селектор.регистрируй(провод, Событие.Чит | Событие.Зап, объект);
     * ---
     */
    public abstract проц регистрируй(ИВыбираемый провод, Событие события,
    Объект атачмент = пусто);

    /**
     * Удаляет провод из селектора.
     *
     * Параметры:
     * провод      = провод, ранее ассоциированный с селектором; может быть равен пусто.
     *
     * Примечания:
     * Отрегистрирование провода со значением пусто допустимо, и  исключение не выводится.
     */
    public abstract проц отмениРег(ИВыбираемый провод);


    /**
     * Wait indefinitely for I/O события из_ the registered conduits.
     *
     * Возвращает:
     * The amount of conduits that have Приёмd события; 0 if no conduits
     * have Приёмd события внутри the specified таймаут и -1 if there
     * was an ошибка.
     */
    public abstract цел выбери();

    /**
     * Wait for I/O события из_ the registered conduits for a specified
     * amount времени.
     *
     * Параметры:
     * таймаут  = ИнтервалВремени with the maximum amount времени that the
     *            selector will жди for события из_ the conduits; the
     *            amount времени is relative в_ the текущ system время
     *            (т.е. just the число of milliseconds that the selector
     *            имеется в_ жди for the события).
     *
     * Возвращает:
     * The amount of conduits that have Приёмd события; 0 if no conduits
     * have Приёмd события внутри the specified таймаут.
     */
    public abstract цел выбери(ИнтервалВремени таймаут);

    /**
     * Wait for I/O события из_ the registered conduits for a specified
     * amount времени.
     *
     * Note: This представление of таймаут is not всегда accurate, so it is
     * possible that the function will return with a таймаут перед the
     * specified период.  For ещё accuracy, use the ИнтервалВремени version.
     *
     * Note: Implementers should define this метод as:
     * -------
     * выбери(ИнтервалВремени.интервал(таймаут));
     * -------
     *
     * Параметры:
     * таймаут  = the maximum amount времени in сек that the
     *            selector will жди for события из_ the conduits; the
     *            amount времени is relative в_ the текущ system время
     *            (т.е. just the число of milliseconds that the selector
     *            имеется в_ жди for the события).
     *
     * Возвращает:
     * The amount of conduits that have Приёмd события; 0 if no conduits
     * have Приёмd события внутри the specified таймаут.
     */
    public abstract цел выбери(дво таймаут);

    /**
     * Возвращает the выделение установи результатing из_ the вызов в_ any of the выбери()
     * methods.
     *
     * Примечания:
     * If the вызов в_ выбери() was unsuccessful or it dопр not return any
     * события, the returned значение will be пусто.
     */
    public abstract ИНаборВыделений наборВыд();

    /**
     * Возвращает the выделение ключ результатing из_ the registration of a провод
     * в_ the selector.
     *
     * Примечания:
     * If the провод is not registered в_ the selector the returned
     * значение will КлючВыбора.init. No исключение will be thrown by this
     * метод.
     */
    public abstract КлючВыбора ключ(ИВыбираемый провод);

    /**
     * Iterate through the currently registered выделение ключи.  Note that you
     * should not erase or добавь any items из_ the selector while iterating,
     * although you can регистрируй existing conduits again.
     */
    public abstract цел opApply(цел delegate(ref КлючВыбора sk) дг);
}
