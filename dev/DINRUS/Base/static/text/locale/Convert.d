module text.locale.Convert;

private import  time.WallClock;

private import  exception;

private import  text.locale.Core;

private import  time.chrono.Calendar;

private import  Целое = text.convert.Integer;

/******************************************************************************

******************************************************************************/

private struct Результат
{
        private бцел    индекс;
        private ткст  цель_;

        /**********************************************************************

        **********************************************************************/

        private static Результат opCall (ткст мишень)
        {
                Результат результат;

                результат.цель_ = мишень;
                return результат;
        }

        /**********************************************************************

        **********************************************************************/

        private проц opCatAssign (ткст rhs)
        {
                бцел конец = индекс + rhs.length;

                цель_[индекс .. конец] = rhs;
                индекс = конец;
        }

        /**********************************************************************

        **********************************************************************/

        private проц opCatAssign (сим rhs)
        {
                цель_[индекс++] = rhs;
        }

        /**********************************************************************

        **********************************************************************/

        private ткст получи ()
        {
                return цель_[0 .. индекс];
        }

        /**********************************************************************

        **********************************************************************/

        private ткст черновик ()
        {
                return цель_;
        }
}


/******************************************************************************

   * Converts the значение of this экземпляр в_ its equivalent ткст представление using the specified _format и культура-specific formatting information.
   * Параметры: 
   *   формат = A _format ткст.
   *   службаФормата = An ИСлужбаФормата that provопрes культура-specific formatting information.
   * Возвращает: A ткст представление of the значение of this экземпляр as specified by формат и службаФормата.
   * Примечания: See $(LINK2 datetimeformat.html, Время Formatting) for ещё information about дата и время formatting.
   * Examples:
   * ---
   * import io.stream.Format, text.locale.Core, time.WallClock;
   *
   * проц main() {
   *   Культура культура = Культура.текущ;
   *   Время сейчас = Куранты.сейчас;
   *
   *   Println("Текущий дата и время: %s", сейчас.вТкст());
   *   Println();
   *
   *   // Формат the текущ дата и время in a число of ways.
   *   Println("Культура: %s", культура.англИмя);
   *   Println();
   *
   *   Println("Short дата:              %s", сейчас.вТкст("d"));
   *   Println("Long дата:               %s", сейчас.вТкст("D"));
   *   Println("Short время:              %s", сейчас.вТкст("t"));
   *   Println("Long время:               %s", сейчас.вТкст("T"));
   *   Println("General дата крат время: %s", сейчас.вТкст("g"));
   *   Println("General дата дол время:  %s", сейчас.вТкст("G"));
   *   Println("Месяц:                   %s", сейчас.вТкст("M"));
   *   Println("RFC1123:                 %s", сейчас.вТкст("R"));
   *   Println("Сортируемый:                %s", сейчас.вТкст("s"));
   *   Println("Год:                    %s", сейчас.вТкст("Y"));
   *   Println();
   *
   *   // Display the same значения using a different культура.
   *   культура = Культура.дайКультуру("fr-FR");
   *   Println("Культура: %s", культура.англИмя);
   *   Println();
   *
   *   Println("Short дата:              %s", сейчас.вТкст("d", культура));
   *   Println("Long дата:               %s", сейчас.вТкст("D", культура));
   *   Println("Short время:              %s", сейчас.вТкст("t", культура));
   *   Println("Long время:               %s", сейчас.вТкст("T", культура));
   *   Println("General дата крат время: %s", сейчас.вТкст("g", культура));
   *   Println("General дата дол время:  %s", сейчас.вТкст("G", культура));
   *   Println("Месяц:                   %s", сейчас.вТкст("M", культура));
   *   Println("RFC1123:                 %s", сейчас.вТкст("R", культура));
   *   Println("Сортируемый:                %s", сейчас.вТкст("s", культура));
   *   Println("Год:                    %s", сейчас.вТкст("Y", культура));
   *   Println();
   * }
   *
   * // Produces the following вывод:
   * // Текущий дата и время: 26/05/2006 10:04:57 AM
   * //
   * // Культура: English (United Kingdom)
   * //
   * // Short дата:              26/05/2006
   * // Long дата:               26 May 2006
   * // Short время:              10:04
   * // Long время:               10:04:57 AM
   * // General дата крат время: 26/05/2006 10:04
   * // General дата дол время:  26/05/2006 10:04:57 AM
   * // Месяц:                   26 May
   * // RFC1123:                 Fri, 26 May 2006 10:04:57 GMT
   * // Сортируемый:                2006-05-26T10:04:57
   * // Год:                    May 2006
   * //
   * // Культура: French (France)
   * //
   * // Short дата:              26/05/2006
   * // Long дата:               vendredi 26 mai 2006
   * // Short время:              10:04
   * // Long время:               10:04:57
   * // General дата крат время: 26/05/2006 10:04
   * // General дата дол время:  26/05/2006 10:04:57
   * // Месяц:                   26 mai
   * // RFC1123:                 ven., 26 mai 2006 10:04:57 GMT
   * // Сортируемый:                2006-05-26T10:04:57
   * // Год:                    mai 2006
   * ---

******************************************************************************/

public ткст форматируйДатуВремя (ткст вывод, Время датаВремя, ткст формат, ИСлужбаФормата службаФормата = пусто) 
{
    return форматируйДатуВремя (вывод, датаВремя, формат, ФорматДатыВремени.дайЭкземпляр(службаФормата));
}

ткст форматируйДатуВремя (ткст вывод, Время датаВремя, ткст формат, ФорматДатыВремени dtf)
{
        /**********************************************************************

        **********************************************************************/

        ткст разверниИзвестныйФормат(ткст формат, ref Время датаВремя)
        {
                ткст f;

                switch (формат[0])
                       {
                       case 'd':
                            f = dtf.краткийОбразецДаты;
                            break;
                       case 'D':
                            f = dtf.длинныйОбразецДаты;
                            break;
                       case 'f':
                            f = dtf.длинныйОбразецДаты ~ " " ~ dtf.краткийОбразецВремени;
                            break;
                       case 'F':
                            f = dtf.полныйОбразецДатыВремени;
                            break;
                       case 'g':
                            f = dtf.общКраткийОбразецВремени;
                            break;
                       case 'G':
                            f = dtf.общДлинныйОбразецВремени;
                            break;
                       case 'm':
                       case 'M':
                            f = dtf.образецДняМесяца;
                            break;
                       case 'r':
                       case 'R':
                            f = dtf.образецРФС1123;
                            break;
                       case 's':
                            f = dtf.сортируемыйОбразецДатыВремени;
                            break;
                       case 't':
                            f = dtf.краткийОбразецВремени;
                            break;
                       case 'T':
                            f = dtf.длинныйОбразецВремени;
                            break;
version (Full)
{
                       case 'u':
                            датаВремя = датаВремя.toUniversalTime();
                            dtf = ФорматДатыВремени.инвариантныйФормат;
                            f = dtf.универсальныйСортируемыйОбразецДатыВремени;
                            break;
                       case 'U':
                            dtf = cast(ФорматДатыВремени) dtf.клонируй();
                            датаВремя = датаВремя.toUniversalTime();
                            if (typeid(typeof(dtf.Календарь)) !is typeid(Грегориан))
                                dtf.Календарь = Грегориан.генерный;
                            f = dtf.полныйОбразецДатыВремени;
                            break;
}
                       case 'y':
                       case 'Y':
                            f = dtf.образецМесяцаГода;
                            break;
                       default:
                           throw new ИсклНелегальногоАргумента("Неверные данные формата.");
                       }

                return f;
        }

        /**********************************************************************

        **********************************************************************/

        ткст форматируйОсобо (ref Результат результат, Время датаВремя, ткст формат)
        {

                цел повториРазбор(ткст формат, цел поз, сим c)
                {
                        цел n = поз + 1;
                        while (n < формат.length && формат[n] is c)
                                n++;
                        return n - поз;
                }

                ткст форматируйДеньНедели(Календарь.ДеньНедели ДеньНедели, цел rpt)
                {
                        if (rpt is 3)
                                return dtf.дайСокращённоеИмяДня(ДеньНедели);
                        return dtf.дайИмяДня(ДеньНедели);
                }

                ткст форматируйМесяц(цел месяц, цел rpt)
                {
                        if (rpt is 3)
                                return dtf.дайСокращённоеИмяМесяца(месяц);
                        return dtf.дайИмяМесяца(месяц);
                }

                ткст форматируйЦел (ткст врем, цел знач, цел minimum)
                {
                        auto чис = Целое.форматируй (врем, знач, "u");
                        if ((minimum -= чис.length) > 0)
                           {
                           auto p = врем.ptr + врем.length - чис.length;
                           while (minimum--)
                                  *--p = '0';
                           чис = врем [p-врем.ptr .. $];
                           }
                        return чис;
                }

                цел разборКавычек(ткст формат, цел поз, out ткст результат)
                {
                        цел старт = поз;
                        сим chQuote = формат[поз++];
                        бул найдено;
                        while (поз < формат.length)
                              {
                              сим c = формат[поз++];
                              if (c is chQuote)
                                 {
                                 найдено = да;
                                 break;
                                 }
                              else
                                 if (c is '\\')
                                    { // escaped
                                    if (поз < формат.length)
                                        результат ~= формат[поз++];
                                    }
                                 else
                                    результат ~= c;
                              }
                        return поз - старт;
                }


                Календарь календарь = dtf.календарь;
                бул justTime = да;
                цел индекс, длин;
                сим[10] врем;

                if (формат[0] is '%')
                    {
                    // specifiers for Всё стандарт формат strings и custom ones
                    const ткст commonSpecs = "dmMsty";
                    foreach (c; commonSpecs)
                        if (формат[1] is c)
                            {
                            индекс += 1;
                            break;
                            }
                    }

                while (индекс < формат.length)
                      {
                      сим c = формат[индекс];
                      auto время = датаВремя.время;

                      switch (c)
                             {
                             case 'd':  // день
                                  длин = повториРазбор(формат, индекс, c);
                                  if (длин <= 2)
                                     {
                                     цел день = календарь.дайДеньМесяца(датаВремя);
                                     результат ~= форматируйЦел (врем, день, длин);
                                     }
                                  else
                                     результат ~= форматируйДеньНедели(календарь.дайДеньНедели(датаВремя), длин);
                                  justTime = нет;
                                  break;

                             case 'M':  // месяц
                                  длин = повториРазбор(формат, индекс, c);
                                  цел месяц = календарь.дайМесяц(датаВремя);
                                  if (длин <= 2)
                                      результат ~= форматируйЦел (врем, месяц, длин);
                                  else
                                     результат ~= форматируйМесяц(месяц, длин);
                                  justTime = нет;
                                  break;
                             case 'y':  // год
                                  длин = повториРазбор(формат, индекс, c);
                                  цел год = календарь.дайГод(датаВремя);
                                  // Two-цифра годы for Japanese
                                  if (календарь.опр is календарь.ЯПОНСКИЙ)
                                      результат ~= форматируйЦел (врем, год, 2);
                                  else
                                     {
                                     if (длин <= 2)
                                         результат ~= форматируйЦел (врем, год % 100, длин);
                                     else
                                        результат ~= форматируйЦел (врем, год, длин);
                                     }
                                  justTime = нет;
                                  break;
                             case 'h':  // час (12-час clock)
                                  длин = повториРазбор(формат, индекс, c);
                                  цел час = время.часы % 12;
                                  if (час is 0)
                                      час = 12;
                                  результат ~= форматируйЦел (врем, час, длин);
                                  break;
                             case 'H':  // час (24-час clock)
                                  длин = повториРазбор(формат, индекс, c);
                                  результат ~= форматируйЦел (врем, время.часы, длин);
                                  break;
                             case 'm':  // минута
                                  длин = повториРазбор(формат, индекс, c);
                                  результат ~= форматируйЦел (врем, время.минуты, длин);
                                  break;
                             case 's':  // секунда
                                  длин = повториРазбор(формат, индекс, c);
                                  результат ~= форматируйЦел (врем, время.сек, длин);
                                  break;
                             case 't':  // AM/PM
                                  длин = повториРазбор(формат, индекс, c);
                                  if (длин is 1)
                                     {
                                     if (время.часы < 12)
                                        {
                                        if (dtf.определительДоПолудня.length != 0)
                                            результат ~= dtf.определительДоПолудня[0];
                                        }
                                     else
                                        {
                                        if (dtf.определительПослеПолудня.length != 0)
                                            результат ~= dtf.определительПослеПолудня[0];
                                        }
                                     }
                                  else
                                     результат ~= (время.часы < 12) ? dtf.определительДоПолудня : dtf.определительПослеПолудня;
                                  break;
                             case 'z':  // timezone смещение
                                  длин = повториРазбор(формат, индекс, c);
version (Full)
{
                                  ИнтервалВремени смещение = (justTime && датаВремя.тики < TICKS_PER_DAY)
                                                     ? TimeZone.текущ.getUtcOffset(Куранты.сейчас)
                                                     : TimeZone.текущ.getUtcOffset(датаВремя);
                                  цел часы = смещение.часы;
                                  цел минуты = смещение.минуты;
                                  результат ~= (смещение.backward) ? '-' : '+';
}
else
{
                                  auto минуты = cast(цел) (Куранты.зона.минуты);
                                  if (минуты < 0)
                                      минуты = -минуты, результат ~= '-';
                                  else
                                     результат ~= '+';
                                  цел часы = минуты / 60;
                                  минуты %= 60;
}
                                  if (длин is 1)
                                      результат ~= форматируйЦел (врем, часы, 1);
                                  else
                                     if (длин is 2)
                                         результат ~= форматируйЦел (врем, часы, 2);
                                     else
                                        {
                                        результат ~= форматируйЦел (врем, часы, 2);
                                        результат ~= ':';
                                        результат ~= форматируйЦел (врем, минуты, 2);
                                        }
                                  break;
                             case ':':  // время разделитель
                                  длин = 1;
                                  результат ~= dtf.разделительВремени;
                                  break;
                             case '/':  // дата разделитель
                                  длин = 1;
                                  результат ~= dtf.разделительДаты;
                                  break;
                             case '\"':  // ткст literal
                             case '\'':  // сим literal
                                  ткст quote;
                                  длин = разборКавычек(формат, индекс, quote);
                                  результат ~= quote;
                                  break;
                             default:
                                 длин = 1;
                                 результат ~= c;
                                 break;
                             }
                      индекс += длин;
                      }
                return результат.получи;
        }


        auto результат = Результат (вывод);

        if (формат is пусто)
            формат = "G"; // Default в_ general формат.

        if (формат.length is 1) // It might be one of our shortcuts.
            формат = разверниИзвестныйФормат (формат, датаВремя);

        return форматируйОсобо (результат, датаВремя, формат);
}



/*******************************************************************************

*******************************************************************************/

private extern (C) сим* ecvt(дво d, цел цифры, out цел decpt, out бул знак);

/*******************************************************************************

*******************************************************************************/

// Must сверь ФорматЧисла.decimalPositivePattern
package const   ткст positiveNumberFormat = "#";

// Must сверь ФорматЧисла.decimalNegativePattern
package const   ткст[] negativeNumberFormats =
                [
                "(#)", "-#", "- #", "#-", "# -"
                ];

// Must сверь ФорматЧисла.валютнПоложитОбразец
package const   ткст[] positiveCurrencyFormats =
                [
                "$#", "#$", "$ #", "# $"
                ];

// Must сверь ФорматЧисла.валютнОтрицатОбразец
package const   ткст[] negativeCurrencyFormats =
                [
                "($#)", "-$#", "$-#", "$#-", "(#$)",
                "-#$", "#-$", "#$-", "-# $", "-$ #",
                "# $-", "$ #-", "$ -#", "#- $", "($ #)", "(# $)"
                ];

/*******************************************************************************

*******************************************************************************/

package template charTerm (T)
{
        package цел charTerm(T* s)
        {
                цел i;
                while (*s++ != '\0')
                        i++;
                return i;
        }
}

/*******************************************************************************

*******************************************************************************/

ткст долВТкст (ткст буфер, дол значение, цел цифры, ткст отрицатЗнак)
{
        if (цифры < 1)
            цифры = 1;

        цел n = буфер.length;
        бдол uv = (значение >= 0) ? значение : cast(бдол) -значение;

        if (uv > бцел.max)
           {
           while (--цифры >= 0 || uv != 0)
                 {
                 буфер[--n] = cast(сим)(uv % 10 + '0');
                 uv /= 10;
                 }
           }
        else
           {
           бцел знач = cast(бцел) uv;
           while (--цифры >= 0 || знач != 0)
                 {
                 буфер[--n] = cast(сим)(знач % 10 + '0');
                 знач /= 10;
                 }
           }


        if (значение < 0)
           {
           for (цел i = отрицатЗнак.length - 1; i >= 0; i--)
                буфер[--n] = отрицатЗнак[i];
           }

        return буфер[n .. $];
}

/*******************************************************************************

*******************************************************************************/

ткст долВГексТкст (ткст буфер, бдол значение, цел цифры, сим формат)
{
        if (цифры < 1)
            цифры = 1;

        цел n = буфер.length;
        while (--цифры >= 0 || значение != 0)
              {
              auto знач = cast(бцел) значение & 0xF;
              буфер[--n] = cast(сим)((знач < 10) ? знач + '0' : знач + формат - ('X' - 'A' + 10));
              значение >>= 4;
              }

        return буфер[n .. $];
}

/*******************************************************************************

*******************************************************************************/

ткст долВБинТкст (ткст буфер, бдол значение, цел цифры)
{
        if (цифры < 1)
            цифры = 1;

        цел n = буфер.length;
        while (--цифры >= 0 || значение != 0)
              {
              буфер[--n] = cast(сим)((значение & 1) + '0');
              значение >>= 1;
              }

        return буфер[n .. $];
}

/*******************************************************************************

*******************************************************************************/

сим разборОпределенияФормата (ткст формат, out цел length)
{
        цел     i = -1;
        сим    specifier;

        if (формат.length)
           {
           auto s = формат[0];

           if (s >= 'A' && s <= 'Z' || s >= 'a' && s <= 'z')
              {
              specifier = s;

              foreach (c; формат [1..$])
                       if (c >= '0' && c <= '9')
                          {
                          c -= '0';
                          if (i < 0)
                             i = c;
                          else
                             i = i * 10 + c;
                          }
                       else
                          break;
              }
           }
        else
           specifier = 'G';

        length = i;
        return specifier;
}

/*******************************************************************************

*******************************************************************************/

ткст форматируйЦелое (ткст вывод, дол значение, ткст формат, ФорматЧисла nf)
{
        цел     length;
        auto    specifier = разборОпределенияФормата (формат, length);

        switch (specifier)
               {
               case 'g':
               case 'G':
                    if (length > 0)
                        break;
                    // Fall through.

               case 'd':
               case 'D':
                    return долВТкст (вывод, значение, length, nf.отрицатЗнак);

               case 'x':
               case 'X':
                    return долВГексТкст (вывод, cast(бдол)значение, length, specifier);

               case 'b':
               case 'B':
                    return долВБинТкст (вывод, cast(бдол)значение, length);

               default:
                    break;
               }

        Результат результат = Результат (вывод);
        Число число = Число (значение);
        if (specifier != сим.init)
            return вТкст (число, результат, specifier, length, nf);

        return число.вТкстФормат (результат, формат, nf);
}

/*******************************************************************************

*******************************************************************************/

private enum {
             ЭКСП = 0x7ff,
             ФЛАГ_НЧ = 0x80000000,
             ФЛАГ_БЕСК = 0x7fffffff,
             }

ткст форматируйДво (ткст вывод, дво значение, ткст формат, ФорматЧисла nf)
{
        цел length;
        цел точность = 6;
        Результат результат = Результат (вывод);
        сим specifier = разборОпределенияФормата (формат, length);

        switch (specifier)
               {
               case 'r':
               case 'R':
                    Число число = Число (значение, 15);

                    if (число.шкала == ФЛАГ_НЧ)
                        return nf.символНЧ;

                    if (число.шкала == ФЛАГ_БЕСК)
                        return число.знак ? nf.отрицатСимволБесконечности
                                           : nf.положитСимволБесконечности;

                    дво d;
                    число.вДво(d);
                    if (d == значение)
                        return вТкст (число, результат, 'G', 15, nf);

                    число = Число(значение, 17);
                    return вТкст (число, результат, 'G', 17, nf);

               case 'g':
               case 'G':
                    if (length > 15)
                        точность = 17;
                    // Fall through.

               default:
                    break;
        }

        Число число = Число(значение, точность);

        if (число.шкала == ФЛАГ_НЧ)
            return nf.символНЧ;

        if (число.шкала == ФЛАГ_БЕСК)
            return число.знак ? nf.отрицатСимволБесконечности
                               : nf.положитСимволБесконечности;

        if (specifier != сим.init)
            return вТкст (число, результат, specifier, length, nf);

        return число.вТкстФормат (результат, формат, nf);
}

/*******************************************************************************

*******************************************************************************/

проц форматируйВОбщем (ref Число число, ref Результат мишень, цел length, сим формат, ФорматЧисла nf)
{
        цел поз = число.шкала;

        auto p = число.цифры.ptr;
        if (поз > 0)
           {
           while (поз > 0)
                 {
                 мишень ~= (*p != '\0') ? *p++ : '0';
                 поз--;
                 }
           }
        else
           мишень ~= '0';

        if (*p != '\0')
           {
           мишень ~= nf.разделительЧисловыхДесятков;
           while (поз < 0)
                 {
                 мишень ~= '0';
                 поз++;
                 }

           while (*p != '\0')
                  мишень ~= *p++;
           }
}

/*******************************************************************************

*******************************************************************************/

проц форматируйЧисло (ref Число число, ref Результат мишень, цел length, ФорматЧисла nf)
{
        ткст формат = число.знак ? negativeNumberFormats[nf.члоОтрицатОбразцов]
                                    : positiveNumberFormat;

        // Parse the формат.
        foreach (c; формат)
                {
                switch (c)
                       {
                       case '#':
                            форматируйФиксированно (число, мишень, length, nf.размерыЧисловыхГрупп,
                                         nf.разделительЧисловыхДесятков, nf.разделительЧисловыхГрупп);
                            break;

                       case '-':
                            мишень ~= nf.отрицатЗнак;
                            break;

                       default:
                            мишень ~= c;
                            break;
                       }
                }
}

/*******************************************************************************

*******************************************************************************/

проц форматируйВалюту (ref Число число, ref Результат мишень, цел length, ФорматЧисла nf)
{
        ткст формат = число.знак ? negativeCurrencyFormats[nf.валютнОтрицатОбразец]
                                    : positiveCurrencyFormats[nf.валютнПоложитОбразец];

        // Parse the формат.
        foreach (c; формат)
                {
                switch (c)
                       {
                       case '#':
                            форматируйФиксированно (число, мишень, length, nf.размерыВалютныхГрупп,
                                         nf.десятичнРазделительВалюты, nf.разделительГруппыВалют);
                            break;

                       case '-':
                            мишень ~= nf.отрицатЗнак;
                            break;

                       case '$':
                            мишень ~= nf.символВалюты;
                            break;

                       default:
                            мишень ~= c;
                            break;
                       }
                }
}

/*******************************************************************************

*******************************************************************************/

проц форматируйФиксированно (ref Число число, ref Результат мишень, цел length,
                  цел[] размерыГруппы, ткст decimalSeparator, ткст groupSeparator)
{
        цел поз = число.шкала;
        auto p = число.цифры.ptr;

        if (поз > 0)
           {
           if (размерыГруппы.length != 0)
              {
              // Calculate whether we have enough цифры в_ формат.
              цел счёт = размерыГруппы[0];
              цел индекс, размер;

              while (поз > счёт)
                    {
                    размер = размерыГруппы[индекс];
                    if (размер == 0)
                        break;

                    if (индекс < размерыГруппы.length - 1)
                       индекс++;

                    счёт += размерыГруппы[индекс];
                    }

              размер = (счёт == 0) ? 0 : размерыГруппы[0];

              // Insert the разделитель according в_ размерыГруппы.
              цел конец = charTerm(p);
              цел старт = (поз < конец) ? поз : конец;


              ткст разделитель = groupSeparator;
              индекс = 0;

              // questionable: use the задний конец of the вывод буфер в_
              // формат the разделители, и then копируй задний в_ старт
              ткст temp = мишень.черновик;
              бцел ii = temp.length;

              for (цел c, i = поз - 1; i >= 0; i--)
                  {
                  temp[--ii] = (i < старт) ? число.цифры[i] : '0';
                  if (размер > 0)
                     {
                     c++;
                     if (c == размер && i != 0)
                        {
                        бцел iii = ii - разделитель.length;
                        temp[iii .. ii] = разделитель;
                        ii = iii;

                        if (индекс < размерыГруппы.length - 1)
                            размер = размерыГруппы[++индекс];

                        c = 0;
                        }
                     }
                  }
              мишень ~= temp[ii..$];
              p += старт;
              }
           else
              {
              while (поз > 0)
                    {
                    мишень ~= (*p != '\0') ? *p++ : '0';
                    поз--;
                    }
              }
           }
        else
           // Negative шкала.
           мишень ~= '0';

        if (length > 0)
           {
           мишень ~= decimalSeparator;
           while (поз < 0 && length > 0)
                 {
                 мишень ~= '0';
                 поз++;
                 length--;
                 }

           while (length > 0)
                 {
                 мишень ~= (*p != '\0') ? *p++ : '0';
                 length--;
                 }
           }
}

/******************************************************************************

******************************************************************************/

ткст вТкст (ref Число число, ref Результат результат, сим формат, цел length, ФорматЧисла nf)
{
        switch (формат)
               {
               case 'c':
               case 'C':
                     // Currency
                     if (length < 0)
                         length = nf.валютнДесятичнЦифры;

                     число.округли(число.шкала + length);
                     форматируйВалюту (число, результат, length, nf);
                     break;

               case 'f':
               case 'F':
                     // Fixed
                     if (length < 0)
                         length = nf.члоДесятичнЦифр;

                     число.округли(число.шкала + length);
                     if (число.знак)
                         результат ~= nf.отрицатЗнак;

                     форматируйФиксированно (число, результат, length, пусто, nf.разделительЧисловыхДесятков, пусто);
                     break;

               case 'n':
               case 'N':
                     // Число
                        if (length < 0)
                            length = nf.члоДесятичнЦифр;

                     число.округли (число.шкала + length);
                     форматируйЧисло (число, результат, length, nf);
                     break;

               case 'g':
               case 'G':
                     // General
                     if (length < 1)
                         length = число.точность;

                     число.округли(length);
                     if (число.знак)
                         результат ~= nf.отрицатЗнак;

                     форматируйВОбщем (число, результат, length, cast(сим)((формат == 'g') ? 'e' : 'Е'), nf);
                     break;

               default:
                     return "{не_годится FP формат specifier '" ~ формат ~ "'}";
               }
        return результат.получи;
}


/*******************************************************************************

*******************************************************************************/

private struct Число
{
        цел шкала;
        бул знак;
        цел точность;
        сим[32] цифры =void;

        /**********************************************************************

        **********************************************************************/

        private static Число opCall (дол значение)
        {
                Число число;
                число.точность = 20;

                if (значение < 0)
                   {
                   число.знак = да;
                   значение = -значение;
                   }

                сим[20] буфер =void;
                цел n = буфер.length;

                while (значение != 0)
                      {
                      буфер[--n] = cast(сим)(значение % 10 + '0');
                      значение /= 10;
                      }

                цел конец = число.шкала = -(n - буфер.length);
                число.цифры[0 .. конец] = буфер[n .. n + конец];
                число.цифры[конец] = '\0';

                return число;
        }

        /**********************************************************************

        **********************************************************************/

        private static Число opCall (дво значение, цел точность)
        {
                Число число;
                число.точность = точность;

                auto p = число.цифры.ptr;
                дол биты = *cast(дол*) & значение;
                дол mant = биты & 0x000FFFFFFFFFFFFFL;
                цел эксп = cast(цел)((биты >> 52) & ЭКСП);

                if (эксп == ЭКСП)
                   {
                   число.шкала = (mant != 0) ? ФЛАГ_НЧ : ФЛАГ_БЕСК;
                   if (((биты >> 63) & 1) != 0)
                         число.знак = да;
                   }
                else
                   {
                   // Get the цифры, decimal точка и знак.
                   сим* симвы = ecvt(значение, число.точность, число.шкала, число.знак);
                   if (*симвы != '\0')
                      {
                      while (*симвы != '\0')
                             *p++ = *симвы++;
                      }
                   }

                *p = '\0';
                return число;
        }

        /**********************************************************************

        **********************************************************************/

        private бул вДво(out дво значение)
        {
                const   бдол[] pow10 =
                        [
                        0xa000000000000000UL,
                        0xc800000000000000UL,
                        0xfa00000000000000UL,
                        0x9c40000000000000UL,
                        0xc350000000000000UL,
                        0xf424000000000000UL,
                        0x9896800000000000UL,
                        0xbebc200000000000UL,
                        0xee6b280000000000UL,
                        0x9502f90000000000UL,
                        0xba43b74000000000UL,
                        0xe8d4a51000000000UL,
                        0x9184e72a00000000UL,
                        0xb5e620f480000000UL,
                        0xe35fa931a0000000UL,
                        0xcccccccccccccccdUL,
                        0xa3d70a3d70a3d70bUL,
                        0x83126e978d4fdf3cUL,
                        0xd1b71758e219652eUL,
                        0xa7c5ac471b478425UL,
                        0x8637bd05af6c69b7UL,
                        0xd6bf94d5e57a42beUL,
                        0xabcc77118461ceffUL,
                        0x89705f4136b4a599UL,
                        0xdbe6fecebdedd5c2UL,
                        0xafebff0bcb24ab02UL,
                        0x8cbccc096f5088cfUL,
                        0xe12e13424bb40e18UL,
                        0xb424dc35095cd813UL,
                        0x901d7cf73ab0acdcUL,
                        0x8e1bc9bf04000000UL,
                        0x9dc5ada82b70b59eUL,
                        0xaf298d050e4395d6UL,
                        0xc2781f49ffcfa6d4UL,
                        0xd7e77a8f87daf7faUL,
                        0xefb3ab16c59b14a0UL,
                        0x850fadc09923329cUL,
                        0x93ba47c980e98cdeUL,
                        0xa402b9c5a8d3a6e6UL,
                        0xb616a12b7fe617a8UL,
                        0xca28a291859bbf90UL,
                        0xe070f78d39275566UL,
                        0xf92e0c3537826140UL,
                        0x8a5296ffe33cc92cUL,
                        0x9991a6f3d6bf1762UL,
                        0xaa7eebfb9df9de8aUL,
                        0xbd49d14aa79dbc7eUL,
                        0xd226fc195c6a2f88UL,
                        0xe950df20247c83f8UL,
                        0x81842f29f2cce373UL,
                        0x8fcac257558ee4e2UL,
                        ];

                const   бцел[] pow10Exp =
                        [
                        4, 7, 10, 14, 17, 20, 24, 27, 30, 34,
                        37, 40, 44, 47, 50, 54, 107, 160, 213, 266,
                        319, 373, 426, 479, 532, 585, 638, 691, 745, 798,
                        851, 904, 957, 1010, 1064, 1117
                        ];

                бцел getDigits(сим* p, цел длин)
                {
                        сим* конец = p + длин;
                        бцел r = *p - '0';
                        p++;
                        while (p < конец)
                              {
                              r = 10 * r + *p - '0';
                              p++;
                              }
                        return r;
                }

                бдол mult64(бцел val1, бцел val2)
                {
                        return cast(бдол)val1 * cast(бдол)val2;
                }

                бдол mult64L(бдол val1, бдол val2)
                {
                        бдол знач = mult64(cast(бцел)(val1 >> 32), cast(бцел)(val2 >> 32));
                        знач += mult64(cast(бцел)(val1 >> 32), cast(бцел)val2) >> 32;
                        знач += mult64(cast(бцел)val1, cast(бцел)(val2 >> 32)) >> 32;
                        return знач;
                }

                auto p = цифры.ptr;
                цел счёт = charTerm(p);
                цел лево = счёт;

                while (*p == '0')
                      {
                      лево--;
                      p++;
                      }

                // If the цифры consist of nothing but zeros...
                if (лево == 0)
                   {
                   значение = 0.0;
                   return да;
                   }

                // Get цифры, 9 at a время.
                цел n = (лево > 9) ? 9 : лево;
                лево -= n;
                бдол биты = getDigits(p, n);
                if (лево > 0)
                   {
                   n = (лево > 9) ? 9 : лево;
                   лево -= n;
                   биты = mult64(cast(бцел)биты, cast(бцел)(pow10[n - 1] >>> (64 - pow10Exp[n - 1])));
                   биты += getDigits(p + 9, n);
                   }

                цел шкала = this.шкала - (счёт - лево);
                цел s = (шкала < 0) ? -шкала : шкала;

                if (s >= 352)
                   {
                   *cast(дол*)&значение = (шкала > 0) ? 0x7FF0000000000000 : 0;
                   return нет;
                   }

                // Normalise mantissa и биты.
                цел bexp = 64;
                цел nzero;
                if ((биты >> 32) != 0)
                     nzero = 32;

                if ((биты >> (16 + nzero)) != 0)
                     nzero += 16;

                if ((биты >> (8 + nzero)) != 0)
                     nzero += 8;

                if ((биты >> (4 + nzero)) != 0)
                     nzero += 4;

                if ((биты >> (2 + nzero)) != 0)
                     nzero += 2;

                if ((биты >> (1 + nzero)) != 0)
                     nzero++;

                if ((биты >> nzero) != 0)
                     nzero++;

                биты <<= 64 - nzero;
                bexp -= 64 - nzero;

                // Get decimal exponent.
                if ((s & 15) != 0)
                   {
                   цел expMult = pow10Exp[(s & 15) - 1];
                   bexp += (шкала < 0) ? ( -expMult + 1) : expMult;
                   биты = mult64L(биты, pow10[(s & 15) + ((шкала < 0) ? 15 : 0) - 1]);
                   if ((биты & 0x8000000000000000L) == 0)
                      {
                      биты <<= 1;
                      bexp--;
                      }
                   }

                if ((s >> 4) != 0)
                   {
                   цел expMult = pow10Exp[15 + ((s >> 4) - 1)];
                   bexp += (шкала < 0) ? ( -expMult + 1) : expMult;
                   биты = mult64L(биты, pow10[30 + ((s >> 4) + ((шкала < 0) ? 21 : 0) - 1)]);
                   if ((биты & 0x8000000000000000L) == 0)
                      {
                      биты <<= 1;
                      bexp--;
                      }
                   }

                // Round и шкала.
                if (cast(бцел)биты & (1 << 10) != 0)
                   {
                   биты += (1 << 10) - 1 + (биты >>> 11) & 1;
                   биты >>= 11;
                   if (биты == 0)
                       bexp++;
                   }
                else
                   биты >>= 11;

                bexp += 1022;
                if (bexp <= 0)
                   {
                   if (bexp < -53)
                       биты = 0;
                   else
                      биты >>= ( -bexp + 1);
                   }
                биты = (cast(бдол)bexp << 52) + (биты & 0x000FFFFFFFFFFFFFL);

                if (знак)
                    биты |= 0x8000000000000000L;

                значение = *cast(дво*) & биты;
                return да;
        }



        /**********************************************************************

        **********************************************************************/

        private ткст вТкстФормат (ref Результат результат, ткст формат, ФорматЧисла nf)
        {
                бул hasGroups;
                цел groupCount;
                цел groupPos = -1, pointPos = -1;
                цел первый = цел.max, последний, счёт;
                бул scientific;
                цел n;
                сим c;

                while (n < формат.length)
                      {
                      c = формат[n++];
                      switch (c)
                             {
                             case '#':
                                  счёт++;
                                  break;

                             case '0':
                                  if (первый == цел.max)
                                      первый = счёт;
                                  счёт++;
                                  последний = счёт;
                                  break;

                             case '.':
                                  if (pointPos < 0)
                                      pointPos = счёт;
                                  break;

                             case ',':
                                  if (счёт > 0 && pointPos < 0)
                                     {
                                     if (groupPos >= 0)
                                        {
                                        if (groupPos == счёт)
                                           {
                                           groupCount++;
                                           break;
                                           }
                                        hasGroups = да;
                                        }
                                     groupPos = счёт;
                                     groupCount = 1;
                                     }
                                  break;

                             case '\'':
                             case '\"':
                                   while (n < формат.length && формат[n++] != c)
                                         {}
                                   break;

                             case '\\':
                                  if (n < формат.length)
                                      n++;
                                  break;

                             default:
                                  break;
                             }
                      }

                if (pointPos < 0)
                    pointPos = счёт;

                цел исправь;
                if (groupPos >= 0)
                   {
                   if (groupPos == pointPos)
                       исправь -= groupCount * 3;
                   else
                      hasGroups = да;
                   }

                if (цифры[0] != '\0')
                   {
                   шкала += исправь;
                   округли(scientific ? счёт : шкала + счёт - pointPos);
                   }

                первый = (первый < pointPos) ? pointPos - первый : 0;
                последний = (последний > pointPos) ? pointPos - последний : 0;

                цел поз = pointPos;
                цел extra;
                if (!scientific)
                   {
                   поз = (шкала > pointPos) ? шкала : pointPos;
                   extra = шкала - pointPos;
                   }

                ткст groupSeparator = nf.разделительЧисловыхГрупп;
                ткст decimalSeparator = nf.разделительЧисловыхДесятков;

                // Work out the positions of the группа разделитель.
                цел[] groupPositions;
                цел groupIndex = -1;
                if (hasGroups)
                   {
                   if (nf.размерыЧисловыхГрупп.length == 0)
                       hasGroups = нет;
                   else
                      {
                      цел groupРазмерsTotal = nf.размерыЧисловыхГрупп[0];
                      цел groupРазмер = groupРазмерsTotal;
                      цел digitsTotal = поз + ((extra < 0) ? extra : 0);
                      цел digitCount = (первый > digitsTotal) ? первый : digitsTotal;

                      цел sizeIndex;
                      while (digitCount > groupРазмерsTotal)
                            {
                            if (groupРазмер == 0)
                                break;

                            groupPositions ~= groupРазмерsTotal;
                            groupIndex++;

                            if (sizeIndex < nf.размерыЧисловыхГрупп.length - 1)
                                groupРазмер = nf.размерыЧисловыхГрупп[++sizeIndex];

                            groupРазмерsTotal += groupРазмер;
                            }
                      }
                }

                //ткст результат;
                if (знак)
                    результат ~= nf.отрицатЗнак;

                auto p = цифры.ptr;
                n = 0;
                бул pointWritten;

                while (n < формат.length)
                      {
                      c = формат[n++];
                      if (extra > 0 && (c == '#' || c == '0' || c == '.'))
                         {
                         while (extra > 0)
                               {
                               результат ~= (*p != '\0') ? *p++ : '0';

                               if (hasGroups && поз > 1 && groupIndex >= 0)
                                  {
                                  if (поз == groupPositions[groupIndex] + 1)
                                     {
                                     результат ~= groupSeparator;
                                     groupIndex--;
                                     }
                                  }
                               поз--;
                               extra--;
                               }
                         }

                      switch (c)
                             {
                             case '#':
                             case '0':
                                  if (extra < 0)
                                     {
                                     extra++;
                                     c = (поз <= первый) ? '0' : сим.init;
                                     }
                                  else
                                     c = (*p != '\0') ? *p++ : поз > последний ? '0' : сим.init;

                                  if (c != сим.init)
                                     {
                                     результат ~= c;

                                     if (hasGroups && поз > 1 && groupIndex >= 0)
                                        {
                                        if (поз == groupPositions[groupIndex] + 1)
                                           {
                                           результат ~= groupSeparator;
                                           groupIndex--;
                                           }
                                        }
                                     }
                                  поз--;
                                  break;

                             case '.':
                                  if (поз != 0 || pointWritten)
                                      break;
                                  if (последний < 0 || (pointPos < счёт && *p != '\0'))
                                     {
                                     результат ~= decimalSeparator;
                                     pointWritten = да;
                                     }
                                  break;

                             case ',':
                                  break;

                             case '\'':
                             case '\"':
                                  if (n < формат.length)
                                      n++;
                                  break;

                             case '\\':
                                  if (n < формат.length)
                                      результат ~= формат[n++];
                                  break;

                             default:
                                  результат ~= c;
                                  break;
                             }
                      }
                return результат.получи;
        }

        /**********************************************************************

        **********************************************************************/

        private проц округли (цел поз)
        {
                цел индекс;
                while (индекс < поз && цифры[индекс] != '\0')
                       индекс++;

                if (индекс == поз && цифры[индекс] >= '5')
                   {
                   while (индекс > 0 && цифры[индекс - 1] == '9')
                          индекс--;

                   if (индекс > 0)
                       цифры[индекс - 1]++;
                   else
                      {
                      шкала++;
                      цифры[0] = '1';
                      индекс = 1;
                      }
                   }
                else
                   while (индекс > 0 && цифры[индекс - 1] == '0')
                          индекс--;

                if (индекс == 0)
                   {
                   шкала = 0;
                   знак = нет;
                   }

                цифры[индекс] = '\0';
        }
}
