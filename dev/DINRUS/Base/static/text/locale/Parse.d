/*******************************************************************************

        copyright:      Copyright (c) 2005 John Chapman. Все права защищены

        license:        BSD стиль: $(LICENSE)

        version:        Initial release: 2005

        author:         John Chapman

******************************************************************************/

module text.locale.Parse;

private import  time.WallClock;

private import  exception;

private import  text.locale.Core;

private import  time.chrono.Calendar;

private struct РезультатРазбораДатыВремени {

  цел год = -1;
  цел месяц = -1;
  цел день = -1;
  цел час;
  цел минута;
  цел секунда;
  дво дробь;
  цел меткаВремени;
  Календарь календарь;
  ИнтервалВремени смещениеЧП;
  Время разобраннаяДата;

}

package Время разборВремени(ткст s, ФорматДатыВремени dtf) {
  РезультатРазбораДатыВремени результат;
  if (!пробуйРазборТочноНесколько(s, dtf.дайВсеОбразцыДатыВремени(), dtf, результат))
    throw new ИсклНелегальногоАргумента("Предложенная строка не являлась временем.");
  return результат.разобраннаяДата;
}

package Время разборВремениТочно(ткст s, ткст форматируй, ФорматДатыВремени dtf) {
  РезультатРазбораДатыВремени результат;
  if (!пробуйРазборТочно(s, форматируй, dtf, результат))
    throw new ИсклНелегальногоАргумента("Предложенная строка не являлась временем.");
  return результат.разобраннаяДата;
}

package бул пробуйРазборВремени(ткст s, ФорматДатыВремени dtf, out Время результат) {
  результат = Время.мин;
  РезультатРазбораДатыВремени записьРезультата;
  if (!пробуйРазборТочноНесколько(s, dtf.дайВсеОбразцыДатыВремени(), dtf, записьРезультата))
    return нет;
  результат = записьРезультата.разобраннаяДата;
  return да;
}

package бул пробуйРазборВремениТочно(ткст s, ткст форматируй, ФорматДатыВремени dtf, out Время результат) {
  результат = Время.мин;
  РезультатРазбораДатыВремени записьРезультата;
  if (!пробуйРазборТочно(s, форматируй, dtf, записьРезультата))
    return нет;
  результат = записьРезультата.разобраннаяДата;
  return да;
}

private бул пробуйРазборТочноНесколько(ткст s, ткст[] форматы, ФорматДатыВремени dtf, ref РезультатРазбораДатыВремени результат) {
  foreach (ткст форматируй; форматы) {
    if (пробуйРазборТочно(s, форматируй, dtf, результат))
      return да;
  }
  return нет;
}

private бул пробуйРазборТочно(ткст s, ткст образец, ФорматДатыВремени dtf, ref РезультатРазбораДатыВремени результат) {

  бул doParse() {

    цел разборЦифр(ткст s, ref цел поз, цел макс) {
      цел результат = s[поз++] - '0';
      while (макс > 1 && поз < s.length && s[поз] >= '0' && s[поз] <= '9') {
        результат = результат * 10 + s[поз++] - '0';
        --макс;
      }
      return результат;
    }

    бул разбериОдин(ткст s, ref цел поз, ткст значение) {
      if (s[поз .. поз + значение.length] != значение)
        return нет;
      поз += значение.length;
      return да;
    }

    цел разбериНесколько(ткст s, ref цел поз, ткст[] значения, ...) {
      цел результат = -1, макс;
      foreach (цел i, ткст значение; значения) {
        if (значение.length == 0 || s.length - поз < значение.length)
          continue;

        if (s[поз .. поз + значение.length] == значение) {
          if (результат == 0 || значение.length > макс) {
            результат = i + 1;
            макс = значение.length;
          }
        }
      }
      поз += макс;
      return результат;
    }

    ИнтервалВремени разборСмещенияЧП(ткст s, ref цел поз) {
      бул знак;
      if (поз < s.length) {
        if (s[поз] == '-') {
          знак = да;
          поз++;
        }
        else if (s[поз] == '+')
          поз++;
      }
      цел час = разборЦифр(s, поз, 2);
      цел минута;
      if (поз < s.length && s[поз] == ':') {
        поз++;
        минута = разборЦифр(s, поз, 2);
      }
      ИнтервалВремени результат = ИнтервалВремени.изЧасов(час) +  ИнтервалВремени.изМин(минута);
      if (знак)
        результат = -результат;
      return результат;
    }
      
    ткст stringOf(сим c, цел счёт = 1) {
      ткст s = new сим[счёт];
      s[0 .. счёт] = c;
      return s;
    }

    результат.календарь = dtf.календарь;
    результат.год = результат.месяц = результат.день = -1;
    результат.час = результат.минута = результат.секунда = 0;
    результат.дробь = 0.0;

    цел поз, i, счёт;
    сим c;

    while (поз < образец.length && i < s.length) {
      c = образец[поз++];

      if (c == ' ') {
        i++;
        while (i < s.length && s[i] == ' ')
          i++;
        if (i >= s.length)
          break;
        continue;
      }

      счёт = 1;

      switch (c) {
        case 'd': case 'm': case 'M': case 'y':
        case 'h': case 'H': case 's':
        case 't': case 'z':
          while (поз < образец.length && образец[поз] == c) {
            поз++;
            счёт++;
          }
          break;
        case ':':
          if (!разбериОдин(s, i, dtf.разделительВремени))
            return нет;
          continue;
        case '/':
          if (!разбериОдин(s, i, dtf.разделительДаты))
            return нет;
          continue;
        case '\\':
          if (поз < образец.length) {
            c = образец[поз++];
            if (s[i++] != c)
              return нет;
          }
          else
            return нет;
          continue;
        case '\'':
          while (поз < образец.length) {
            c = образец[поз++];
            if (c == '\'')
              break;
            if (s[i++] != c)
              return нет;
          }
          continue;
        default:
          if (s[i++] != c)
            return нет;
          continue;
      }

      switch (c) {
        case 'd': // день
          if (счёт == 1 || счёт == 2)
            результат.день = разборЦифр(s, i, 2);
          else if (счёт == 3)
            результат.день = разбериНесколько(s, i, cast(ткст[]) dtf.сокращённыеИменаДней);
          else
            результат.день = разбериНесколько(s, i, cast(ткст[]) dtf.именаДней);
          if (результат.день == -1)
            return нет;
          break;
        case 'M': // месяц
          if (счёт == 1 || счёт == 2)
            результат.месяц = разборЦифр(s, i, 2);
          else if (счёт == 3)
            результат.месяц = разбериНесколько(s, i, dtf.сокращённыеИменаМесяцев);
          else
            результат.месяц = разбериНесколько(s, i, dtf.именаМесяцев);
          if (результат.месяц == -1)
            return нет;
          break;
        case 'y': // год
          if (счёт == 1 || счёт == 2)
            результат.год = разборЦифр(s, i, 2);
          else
            результат.год = разборЦифр(s, i, 4);
          if (результат.год == -1)
            return нет;
          break;
        case 'h': // 12-час clock
        case 'H': // 24-час clock
          результат.час = разборЦифр(s, i, 2);
          break;
        case 'm': // минута
          результат.минута = разборЦифр(s, i, 2);
          break;
        case 's': // секунда
          результат.секунда = разборЦифр(s, i, 2);
          break;
        case 't': // время метка
          if (счёт == 1)
            результат.меткаВремени = разбериНесколько(s, i, cast(ткст[]) stringOf(dtf.определительДоПолудня[0]), cast(ткст[]) stringOf(dtf.определительПослеПолудня[0]));
          else
            результат.меткаВремени = разбериНесколько(s, i, cast(ткст[]) dtf.определительДоПолудня, cast(ткст[]) dtf.определительПослеПолудня);
          break;
        case 'z':
          результат.смещениеЧП = разборСмещенияЧП(s, i);
          break;
        default:
          break;
      }
    }

    if (поз < образец.length || i < s.length)
      return нет;

    if (результат.меткаВремени == 1) { // am
      if (результат.час == 12)
        результат.час = 0;
    }
    else if (результат.меткаВремени == 2) { // pm
      if (результат.час < 12)
        результат.час += 12;
    }

    // If the ввод ткст dопрn't specify a дата часть, try в_ return something meaningful.
    if (результат.год == -1 || результат.месяц == -1 || результат.день == -1) {
      Время сейчас = Куранты.сейчас;
      if (результат.месяц == -1 && результат.день == -1) {
        if (результат.год == -1) {
          результат.год = результат.календарь.дайГод(сейчас);
          результат.месяц = результат.календарь.дайМесяц(сейчас);
          результат.день = результат.календарь.дайДеньМесяца(сейчас);
        }
        else
          результат.месяц = результат.день = 1;
      }
      else {
        if (результат.год == -1)
          результат.год = результат.календарь.дайГод(сейчас);
        if (результат.месяц == -1)
          результат.месяц = 1;
        if (результат.день == -1)
          результат.день = 1;
      }
    }
    return да;
  }

  if (doParse()) {
    результат.разобраннаяДата = результат.календарь.воВремя(результат.год, результат.месяц, результат.день, результат.час, результат.минута, результат.секунда, 0);
    return да;
  }
  return нет;
}
