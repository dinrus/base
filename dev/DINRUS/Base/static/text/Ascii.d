/*******************************************************************************
        Placeholder for a выделение of ASCII utilities. These generally will
        not work with utf8, и cannot be easily extended в_ utf16 or utf32        
*******************************************************************************/

module text.Ascii;

version (Win32)
        {
        private extern (C) цел memicmp (сим *, сим *, бцел);
        private extern (C) цел memcmp (сим *, сим *, бцел);
        }

version (Posix)
        {
        private extern (C) цел memcmp (сим *, сим *, бцел);
        private extern (C) цел strncasecmp (сим *, сим*, бцел);
        private alias strncasecmp memicmp;
        }

/******************************************************************************

        Convert в_ lowercase. Возвращает the преобразованый контент in приёмн,
        performing an in-place conversion if приёмн is пусто

******************************************************************************/

ткст вПроп (ткст ист, ткст приёмн = пусто)
{
        if (приёмн.ptr)
           {
           assert (приёмн.length >= ист.length);
           приёмн[0 .. ист.length] = ист [0 .. $];
           }
        else
           приёмн = ист;
        
        foreach (ref c; приёмн)
                 if (c>= 'A' && c <= 'Z')
                     c = cast(сим)(c + 32);
        return приёмн [0  .. ист.length];
}

/******************************************************************************

        Преобразовать в верхний регистр. Возвращает на приёмник преобразованный
		контент, выполняя преобразование на месте, если приёмник == пусто

******************************************************************************/

ткст вЗаг (ткст ист, ткст приёмн = пусто)
{
        if (приёмн.ptr)
           {
           assert (приёмн.length >= ист.length);
           приёмн[0 .. ист.length] = ист [0 .. $];
           }
        else
           приёмн = ист;
        
        foreach (ref c; приёмн)
                 if (c>= 'a' && c <= 'z')
                     c = cast(сим)(c - 32);
        return приёмн[0 .. ист.length];
}

/******************************************************************************

        Сравнить два текста, игнорируя регистр. Возвращает 0, если они равны
        
******************************************************************************/

цел сравнилюб (ткст s1, ткст s2)
{
        auto длин = s1.length;
        if (s2.length < длин)
            длин = s2.length;

        auto результат = memicmp (s1.ptr, s2.ptr, длин);

        if (результат is 0)
            результат = s1.length - s2.length;
        return результат;
}


/******************************************************************************

        Сравнивает два ткст с регистром. Возвращает 0, если равны
        
******************************************************************************/

цел сравни (ткст s1, ткст s2)
{
        auto длин = s1.length;
        if (s2.length < длин)
            длин = s2.length;

        auto результат = memcmp (s1.ptr, s2.ptr, длин);

        if (результат is 0)
            результат = s1.length - s2.length;
        return результат;
}



/******************************************************************************

        Return the индекс позиция of a текст образец внутри ист, or
        ист.length upon failure.

        This is a case-insensitive ищи (with thanks в_ Nietsnie)
        
******************************************************************************/

static цел найдилюб (in ткст ист, in ткст образец)
{
        static  ткст _caseMap = 
                [ 
                '\000','\001','\002','\003','\004','\005','\006','\007',
                '\010','\011','\012','\013','\014','\015','\016','\017',
                '\020','\021','\022','\023','\024','\025','\026','\027',
                '\030','\031','\032','\033','\034','\035','\036','\037',
                '\040','\041','\042','\043','\044','\045','\046','\047',
                '\050','\051','\052','\053','\054','\055','\056','\057',
                '\060','\061','\062','\063','\064','\065','\066','\067',
                '\070','\071','\072','\073','\074','\075','\076','\077',
                '\100','\141','\142','\143','\144','\145','\146','\147',
                '\150','\151','\152','\153','\154','\155','\156','\157',
                '\160','\161','\162','\163','\164','\165','\166','\167',
                '\170','\171','\172','\133','\134','\135','\136','\137',
                '\140','\141','\142','\143','\144','\145','\146','\147',
                '\150','\151','\152','\153','\154','\155','\156','\157',
                '\160','\161','\162','\163','\164','\165','\166','\167',
                '\170','\171','\172','\173','\174','\175','\176','\177',
                '\200','\201','\202','\203','\204','\205','\206','\207',
                '\210','\211','\212','\213','\214','\215','\216','\217',
                '\220','\221','\222','\223','\224','\225','\226','\227',
                '\230','\231','\232','\233','\234','\235','\236','\237',
                '\240','\241','\242','\243','\244','\245','\246','\247',
                '\250','\251','\252','\253','\254','\255','\256','\257',
                '\260','\261','\262','\263','\264','\265','\266','\267',
                '\270','\271','\272','\273','\274','\275','\276','\277',
                '\300','\341','\342','\343','\344','\345','\346','\347',
                '\350','\351','\352','\353','\354','\355','\356','\357',
                '\360','\361','\362','\363','\364','\365','\366','\367',
                '\370','\371','\372','\333','\334','\335','\336','\337',
                '\340','\341','\342','\343','\344','\345','\346','\347',
                '\350','\351','\352','\353','\354','\355','\356','\357',
                '\360','\361','\362','\363','\364','\365','\366','\367',
                '\370','\371','\372','\373','\374','\375','\376','\377',
                ];  


        assert(ист.ptr);
        assert(образец.ptr);

        for (цел i1=0, i2; i1 <= cast(цел)(ист.length - образец.length); ++i1)
            {   
            for (i2=0; i2 < образец.length; ++i2)
                 if (_caseMap[ист[i1 + i2]] != _caseMap[образец[i2]])
                     break;

            if (i2 is образец.length)
                return i1;
            }   
        return ист.length;
}



/******************************************************************************

******************************************************************************/

debug (UnitTest)
{       
        unittest
        {
        сим[20] врем;
        
        assert (вПроп("1bac", врем) == "1bac");
        assert (вПроп("1BAC", врем) == "1bac");
        assert (вЗаг("1bac", врем) == "1BAC");
        assert (вЗаг("1BAC", врем) == "1BAC");
        assert (сравнилюб ("ABC", "abc") is 0);
        assert (сравнилюб ("abc", "abc") is 0);
        assert (сравнилюб ("abcd", "abc") > 0);
        assert (сравнилюб ("abc", "abcd") < 0);
        assert (сравнилюб ("ACC", "abc") > 0);

        assert (найдилюб ("ACC", "abc") is 3);
        assert (найдилюб ("ACC", "acc") is 0);
        assert (найдилюб ("aACC", "acc") is 1);
        }
}

debug (Ascii)
{
        проц main() {}
}
