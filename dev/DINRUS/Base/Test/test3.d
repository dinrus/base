import dinrus, com.com, mesa, sdl, minid;

бул АКТИВИРОВАНА = нет;	
проц СТАРТ() {if(!АКТИВИРОВАНА) динрусСтарт(смДайПрокси()); АКТИВИРОВАНА = да;}
проц СТОП() {if(АКТИВИРОВАНА) динрусСтоп(); АКТИВИРОВАНА = нет;}


проц тестПроизводительности()
{
alias СчётчикТиков   тип_счётчик;

	тип_счётчик    счётчик = new тип_счётчик();

	счётчик.старт();
	volatile for(int и = 0; и < 10000000; ++и)
	{   }
	счётчик.стоп();

	тип_счётчик.т_интервал  us1 =   счётчик.микросекунды();
	тип_счётчик.т_интервал  ms1 =   счётчик.миллисекунды();
	тип_счётчик.т_интервал  s1  =   счётчик.секунды();

	volatile for(int и = 0; и < 10000000; ++и)
	{   }
	счётчик.стоп();

	тип_счётчик.т_интервал  us2 =   счётчик.микросекунды();
	тип_счётчик.т_интервал  ms2 =   счётчик.миллисекунды();
	тип_счётчик.т_интервал  s2  =   счётчик.секунды();

	assert(us2 >= us1);
	assert(ms2 >= ms1);
	assert(s2 >= s1);
	
скажинс("Тест производительности = ОК");
}

проц тестСДЛ()
{
//СДЛ.загружай();
скажинс(форматируй("cак утверждает СДЛ, число СиДи-Драйвов равно %s",сдлЧлоКдДрайвов()));
скажинс(форматируй("cак утверждает СДЛ, РДТЦ на компютере ?... %s",cast(бул) сдлЕстьРДТСЦ()));
скажинс(форматируй("cак утверждает СДЛ, ЭмЭмЭкса ?... %s",cast(бул) сдлЕстьММЭкс()));
скажинс(форматируй("cак утверждает СДЛ, ЭмЭмЭксЭкст ?... %s",cast(бул) сдлЕстьММЭксЭкст()));
скажинс(форматируй("cак утверждает СДЛ, ТриДэНау ?...... %s",cast(бул) сдлЕсть3ДНау()));
скажинс(форматируй("cак утверждает СДЛ, ЭсЭсЭ ?... %s",cast(бул) сдлЕстьССЭ()));
скажинс(форматируй("cак утверждает СДЛ, а ССЭ2?... %s",cast(бул) сдлЕстьССЭ2()));
СДЛ.выгружай();

пауза;
}

проц тестМД5()
{
    скажинс("проверка МД5\n");

    ббайт[16] digest;

    суммаМД5 (digest, "");
    assert(digest == cast(ббайт[])x"d41d8cd98f00b204e9800998ecf8427e");

    суммаМД5 (digest, "a");
    assert(digest == cast(ббайт[])x"0cc175b9c0f1b6a831c399e269772661");

    суммаМД5 (digest, "abc");
    assert(digest == cast(ббайт[])x"900150983cd24fb0d6963f7d28e17f72");

    суммаМД5 (digest, "message digest");
    assert(digest == cast(ббайт[])x"f96b697d7cb7938d525a2f31aaf161d0");

    суммаМД5 (digest, "abcdefghijklmnopqrstuvwxyz");
    assert(digest == cast(ббайт[])x"c3fcd3d76192e4007dfb496cca67e13b");

    суммаМД5 (digest, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    assert(digest == cast(ббайт[])x"d174ab98d277d9f5a5611c2c9f419d9f");

    суммаМД5 (digest,
	"1234567890123456789012345678901234567890"
	"1234567890123456789012345678901234567890");
    assert(digest == cast(ббайт[])x"57edf4a22be3c955ac49da2e2107b67a");

    assert(дайджестМД5вТкст(cast(ббайт[16])x"c3fcd3d76192e4007dfb496cca67e13b")
        == "C3FCD3D76192E4007DFB496CCA67E13B");
	скажинс("МД5 дышит");
}

проц тестРПФайл() {
	const т_мера K = 1024;
	т_мера win = 64*K; // assume the page size is 64K
	
	РПФайл mf = new РПФайл("testing.txt",РПФайл.Режим.ЧтенЗапНов,100*K,пусто,win);
	ббайт[] стр = cast(ббайт[])"1234567890";
	ббайт[] данные = cast(ббайт[])mf[0 .. 10];
	данные[] = стр[];
	assert( mf[0 .. 10] == стр );
	данные = cast(ббайт[])mf[50 .. 60];
	данные[] = стр[];
	assert( mf[50 .. 60] == стр );
	ббайт[] data2 = cast(ббайт[])mf[20*K .. 60*K];
	assert( data2.длина == 40*K );
	assert( data2[длина-1] == 0 );
	mf[100*K-1] = cast(ббайт)'b';
	data2 = cast(ббайт[])mf[21*K .. 100*K];
	assert( data2.длина == 79*K );
	assert( data2[длина-1] == 'b' );
	delete mf;
	удалиФайл("testing.txt");
	скажинс("РПФайл мурлычет...");

	// Create anonymous mapping
	auto test = new РПФайл(null, РПФайл.Режим.ЧтенЗапНов, 1024*1024, пусто);
	пауза;
}

  проц тестСФайл() {
    фук f = откройфл("d:\\stream.txt","w");
	скажинс("странно...");
    assert(f !is пусто);
	скажинс("странно");
    СФайл файл = new СФайл(f,ПФРежим.Вывод);
	скажинс("странно");
    цел и = 666;    
    assert(файл.записываемый());
	скажинс("странно");
    файл.пишиСтр("Testing stream.d:");
    файл.пишиТкст("Hello, world!");
    файл.пиши(и);    
	скажинс("странно");
      assert(файл.позиция() == 19 + 13 + 4);   
    файл.закрой();
    // no operations are allowed when file is closed
    assert(!файл.читаемый() && !файл.записываемый() && !файл.сканируемый());
    f = откройфл("d:\\stream.txt","r");
    файл = new СФайл(f,ПФРежим.Ввод, да);
    // should be ok to read
    assert(файл.читаемый);
	скажинс("странно");
    auto строка = файл.читайСтр();
    auto exp = "Testing stream.d:";
    assert(строка[0] == 'T');
    assert(строка.длина == exp.длина);
    assert(!сравни(строка, "Testing stream.d:"));
    // jump over "Hello, "
    файл.сместись(7, ППозКурсора.Тек);    
      assert(файл.позиция() == 19 + 7);
    скажинс("странно");
    assert(!сравни(файл.читайТкст(6), "world!"));
    и = 0; файл.читай(и);
    assert(и == 666);
    assert(файл.позиция() == 19 + 13 + 4);    
    // we must be at the end of файл
    файл.закрой();
	скажинс("странно");
    f = откройфл("d:\\stream.txt","w+");
    файл = new СФайл(f,ПФРежим.Ввод|ПФРежим.Вывод, да);
    файл.читайСтр("Testing stream.d:");
    файл.читайСтр("Another line");
    файл.читайСтр("");
    файл.читайСтр("That was blank");
    файл.позиция = 0;
    char[][] строки;
    foreach(char[] строка; файл) {
      строки ~= строка.dup;
    }
    assert( строки.длина == 5 );
    assert( строки[0] == "Testing stream.d:");
    assert( строки[1] == "Another строка");
    assert( строки[2] == "");
    assert( строки[3] == "That was blank");
    файл.позиция = 0;
    строки = new ткст[5];
    foreach(бдол n, ткст строка; файл) {
      строки[cast(т_мера)(n-1)] = строка.dup;
    }
    assert( строки[0] == "Testing stream.d:");
    assert( строки[1] == "Another строка");
    assert( строки[2] == "");
    assert( строки[3] == "That was blank");
    файл.закрой();
    удалиФайл("d:\\stream.txt");
	скажинс("странно однако!!!!!!!!!!");
 }
 
проц тестЗлиб()
{
    ббайт[] src = cast(ббайт[])
"the quick brown fox jumps over the lazy dog\r
the quick brown fox jumps over the lazy dog\r
";
    ббайт[] dst;
    ббайт[] результат;

	скажинс("Тест сжатия Злиб"); нс;
    скажинс(форматируй(src));
    dst = cast(ббайт[])сожмиЗлиб(cast(проц[])src);
    скажинс(форматируй(dst));
    результат = cast(ббайт[])разожмиЗлиб(cast(проц[])dst);
    скажинс(форматируй(результат));
    assert(результат == src);
	скажинс("Злиб 1 окей!");нс;
	/////////////////////////////////////////////////
    СжатиеЗлиб cmp = new СжатиеЗлиб;
    РасжатиеЗлиб decmp = new РасжатиеЗлиб;

    проц[] input;
    input = "tesatdffadf ... и что-нибудь по-нашему!";

    проц[] buf = cmp.сжать(input);
    buf ~= cmp.слей();
    проц[] output = decmp.расжать(buf);

    скажинс(форматируй("вход = '%s'", cast(char[])input));
    скажинс(форматируй("выход = '%s'", cast(char[])output));
    assert( output[] == input[] );
	
	скажинс("Злиб 2 окей!");нс;

}

проц тестКС()
{
    static ббайт[] данные = [1,2,3,4,5,6,7,8,9,10];

    бцел crc;

    скажинс(" тест цпи32 (контрольной суммы) злиб\n");
    crc = цпи32(0u, cast(проц[])данные);
    скажи(форматируй("crc = %x\n", crc));
    assert(crc == 0x2520577b);
	скажинс("цпи32 окей!"); нс;
}

проц тестАдлер()
{
    static ббайт[] данные = [1,2,3,4,5,6,7,8,9,10];

    бцел adler;

    скажинс("злиб, адлер32 тест\n");
    adler = адлер32(0u, cast(проц[])данные);
    скажинс(форматируй("адлер = %x\n", adler));
    assert(adler == 0xdc0037);
	скажинс("адлер32 окей!"); нс;
}

проц тестУИР()
{
    скажинс("Тест кодирования УИР (Универсального Идентификатора Ресурса)\n");

    ткст т = "http://www.digitalmars.com/~fred/fred'т RX.html#foo";
    ткст t = "http://www.digitalmars.com/~fred/fred'т%20RX.html#foo";
    ткст r;

    r = кодируйУИР(т);
    скажи(форматируй("r = '%s'\n", r));
    assert(r == t);
    r = раскодируйУИР(t);
    скажи(форматируй("r = '%s'\n", r));
    assert(r == т);

    r = кодируйУИР( раскодируйУИР("%E3%81%82%E3%81%82") );
    assert(r == "%E3%81%82%E3%81%82");

	скажинс("жив..");
	
    r = кодкомпуир("c++");
    скажи(форматируй("r = '%s'\n", r));
    assert(r == "c%2B%2B");

    ткст стр = new сим[10_000_000];
    стр[] = 'A';
    r = кодкомпуир(стр);
    foreach (сим к; r)
	assert(к == 'A');

	скажинс("жив..");
	
    r = раскодируйУИР("%41%42%43");
	скажинс("жив1..");
    пишифнс(r);
	скажинс("жив2..");
	скажинс("cодуир окей!"); нс;
}
проц тестУни()
{
    for (бцел и = 0; и < 0x80; и++)
    {
	if (и >= 'A' && и <= 'Z'){
	    assert(юцб_ли(и));
		скажи("проверен "); скажинс(форматируй(и));}
	else if (и >= 'a' && и <= 'z')
	    {assert(юцб_ли(и));
		скажи("проверен "); скажинс(форматируй(и));}
	else{
	    assert(!юцб_ли(и));
		скажи("проверен "); скажинс(форматируй(и));}
    }
 скажинс("юцб_ли тест прошёл!"); нс;
}

проц тестФайл()
{
скажинс("файл .... пока не создан");
    Файл файл = new Файл;
	скажинс("файл .... уже инициирован");
    цел и = 666;
	скажинс("нач...");	
    файл.создай("d:\\stream.txt", ПФРежим.Ввод);    
	скажинс("файл создан");
	assert(файл.записываемый);
	скажинс("попытка записи файла ...");
	пауза;
    //файл.пишиСтр("Testing stream.d:");
	скажинс("записана строка");
	пауза;
    файл.пишиТкст("Hello, world!");
	скажинс("записан текст");
	пауза;
    файл.пиши(и);
   
      assert(файл.позиция() == 19 + 13 + 4); скажи("да ");
    
    // we must be at the end of файл
    assert(файл.кф()); скажи("да ");
    файл.закрой();
    // no operations are allowed when файл is закройd
    assert(!файл.читаемый && !файл.записываемый && !файл.сканируемый); скажи("да ");
    файл.открой("d:\\stream.txt");
    // should be ok to читай
   // if(файл.проверьЧитаемость())скажинс("Файл читаемый!");
    assert(файл.доступно == файл.размер); скажи("да ");
    ткст строка = файл.читайСтр();	
    ткст exp = "Testing stream.d:";
    assert(строка[0] == 'T');
    assert(строка.длина == exp.длина);
    assert(!сравни(строка, "Testing stream.d:"));
    // jump over "Hello, "
    файл.сместись(7, ППозКурсора.Тек);	
    version (Win32)
      assert(файл.позиция() == 19 + 7);
    version (Posix)
      assert(файл.позиция() == 18 + 7);
    assert(!сравни(файл.читайТкст(6), "world!"));	
    и = 0; файл.читай(и);
    assert(и == 666);
    // ткст#1 + ткст#2 + цел should give exacly that
    version (Win32)
      assert(файл.позиция() == 19 + 13 + 4);
    version (Posix)
      assert(файл.позиция() == 18 + 13 + 4);
    // we must be at the end of файл
    assert(файл.кф());
    файл.закрой();	
    файл.открой("d:\\stream.txt",ПФРежим.ВыводНов | ПФРежим.Ввод);
	файл.пишиСтр("Testing stream.d:");
    файл.пишиСтр("Another строка");
    файл.пишиСтр("");
    файл.пишиСтр("That was blank");
    файл.позиция = 0;
    ткст[] строки;
    foreach(ткст строка; файл) {
      строки ~= строка.dup;
	  скажи("дубль ");
    }
	скажи("дубль2 ");
    assert( строки.длина == 4 );
    assert( строки[0] == "Testing stream.d:");
    assert( строки[1] == "Another строка");
    assert( строки[2] == "");
    assert( строки[3] == "That was blank");
    файл.позиция = 0;
	скажинс("Файл//!!!yhy");
    строки = new ткст[4];
    foreach(бдол n, ткст строка; файл) {
      строки[cast(т_мера)(n-1)] = строка.dup;
    }
    assert( строки[0] == "Testing stream.d:");
    assert( строки[1] == "Another строка");
    assert( строки[2] == "");
    assert( строки[3] == "That was blank");
	скажинс("Файл//!!!");
	файл.удали("d:\\stream.txt");
	//скажинс("Файл удалён");
}

  проц тестБуфФайл() {
	скажинс("\nПроверка БуфФАЙЛ\n");
    БуфФайл файл = new БуфФайл;
    цел и = 666;
    файл.создай("e:\\stream.txt");
    скажинс("Файл создан");
    assert(файл.записываемый);
    файл.пишиСтр("Testing stream.d:");
    файл.пишиТкст("Hello, world!");
    файл.пиши(и);
    // ткст#1 + ткст#2 + цел should give exacly that
    version (Win32)
	      assert(файл.позиция() == 19 + 13 + 4);
	        // we must be at the end of файл
    assert(файл.кф());
    дол oldsize = cast(дол)файл.размер();
    файл.закрой();
	   // no operations are allowed when файл is закройd
    assert(!файл.читаемый && !файл.записываемый && !файл.сканируемый);
	  файл.открой("e:\\stream.txt");
	   // should be ok to читай
    assert(файл.читаемый);
	  // test берис/отдайс and размер()
    сим c1 = файл.берис();
	скажинс(форматируй(c1));
    файл.отдайс(c1);
	assert( файл.размер() == oldsize );
	//assert(!сравни(файл.читайСтр(), "Testing stream.d:"));
    // jump over "Hello, "
    файл.сместись(7, ППозКурсора.Тек);  
	скажинс(форматируй(файл.позиция()));
      assert(файл.позиция() == 8);
		скажинс(файл.читайТкст(6));
    assert(сравни(файл.читайТкст(6), "stream"));
    и = 0; файл.читай(и);
    assert(и != 666);
    // ткст#1 + ткст#2 + цел should give exacly that 
		скажинс(форматируй(файл.позиция()));
      assert(файл.позиция() == 24 );   
    // we must be at the end of файл    
    файл.закрой();
	//НайдиЗакрой(&файл);
    файл.удали("e:\\stream.txt");
	
	пауза;
  }
  
    проц тестПотокЭндианец()
	{
    ПотокПамяти m;
	скажинс("Файл создан");
    m = new ПотокПамяти ();
	скажинс("Файл создан");
    ПотокЭндианец em = new ПотокЭндианец(m,Эндиан.БигЭндиан);
	скажинс("Файл создан");
    бцел x = 0x11223344;
    em.пиши(x);	
    assert( m.данные[0] == 0x11 );
    assert( m.данные[1] == 0x22 );
    assert( m.данные[2] == 0x33 );
    assert( m.данные[3] == 0x44 );
    em.позиция(0);
    бкрат x2 = 0x5566;
    em.пиши(x2);
    assert( m.данные[0] == 0x55 );
   assert( m.данные[1] == 0x66 );
    em.позиция(0);
    static ббайт[12] x3 = [1,2,3,4,5,6,7,8,9,10,11,12];
    em.фиксируйПБ(x3.укз,12);
    if (_эндиан == Эндиан.ЛитлЭндиан) {
      assert( x3[0] == 12 ); 
      assert( x3[1] == 11 );
      assert( x3[2] == 10 );
      assert( x3[4] == 8 );
      assert( x3[5] == 7 );
      assert( x3[6] == 6 );
      assert( x3[8] == 4 );
      assert( x3[9] == 3 );
      assert( x3[10] == 2 );
      assert( x3[11] == 1 );
	  скажинс("ЛЕ подтвержден\n");
    }
	em.выведиЭндиан();
    em.устЭндиан(Эндиан.ЛитлЭндиан);
	em.выведиЭндиан();
    em.пиши(x);
	assert( m.данные[0] == 0x44 );
    assert( m.данные[1] == 0x33 );
    assert( m.данные[2] == 0x22 );
   assert( m.данные[3] == 0x11 );
    em.позиция(0);
    em.пиши(x2);
	assert( m.данные[0] == 0x66 );
    assert( m.данные[1] == 0x55 );
    em.позиция(0);
    em.фиксируйПБ(x3.укз,12);
    if (_эндиан == Эндиан.БигЭндиан) {
      assert( x3[0] == 12 );
      assert( x3[1] == 11 );
      assert( x3[2] == 10 );
      assert( x3[4] == 8 );
      assert( x3[5] == 7 );
      assert( x3[6] == 6 );
      assert( x3[8] == 4 );
      assert( x3[9] == 3 );
      assert( x3[10] == 2 );
      assert( x3[11] == 1 );
    }
    em.пишиМПБ(МПБ.Ю8);
	
    assert( m.позиция() == 3 );
   assert( m.данные[0] == 0xEF );
    assert( m.данные[1] == 0xBB );
    assert( m.данные[2] == 0xBF );
	em.позиция(3);
	em.выведиЭндиан();
    em.пишиТкст ("Hello, world");
    em.позиция(0);
    assert( m.позиция() == 0 );
    assert( em.читайМПБ == МПБ.Ю8 );
    assert( m.позиция() == 3 );
	assert( m.данные[3] == 'H' );
    assert( em.берис() == 'H' );
    em.позиция(0);
    em.пишиМПБ(МПБ.Ю16БЕ);
    assert( m.данные[0] == 0xFE );
    assert( m.данные[1] == 0xFF );
    em.позиция(0);
    em.пишиМПБ(МПБ.Ю16ЛЕ);
    assert( m.данные[0] == 0xFF );
    assert( m.данные[1] == 0xFE );
    em.позиция(0);
    em.пишиТкст ("Hello, world");
    em.позиция(0);
	
    //assert( em.читайМПБ == -1 );	
    assert( em.берис() == 'H' );
	assert( em.берис() == 'e' );
    assert( em.берис() == 'l' );
    assert( em.берис() == 'l' );
   em.позиция(0);	
	пауза;
  }

/* Test the ТПотокМассив */
проц тестТПотокМассив() {
  сим[100] буф;
  ТПотокМассив!(ткст) m;

  m = new ТПотокМассив!(ткст) (буф);
  //assert (m.открыт_ли);
  m.пишиТкст ("Hello, world");
  assert (m.позиция () == 12);
  assert (m.доступно == 88);
  assert (m.измпозУст (0) == 0);
  assert (m.доступно == 100);
  assert (m.измпозТек (4) == 4);
  assert (m.доступно == 96);
  assert (m.измпозКон (-8) == 92);
  assert (m.доступно == 8);
  assert (m.размер () == 100);
  assert (m.измпозУст (4) == 4);
  assert (m.читайТкст (4) == "o, w");
  m.пишиТкст ("ie");
  assert (буф[0..12] == "Hello, wield");
  assert (m.позиция == 10);
  assert (m.доступно == 90);
  assert (m.размер () == 100);
  скажинс("ТПотокМассив дышит однако...");
  пауза;
}


  проц тестПотокПамяти() {
    ПотокПамяти m;

	 скажинс("Проверка ПотокаПамяти\n");
    m = new ПотокПамяти ();
	 скажинс("Поток инициирован\n");
	// m.открытый(да);
    //assert (m.открытый);
    m.пишиТкст ("Hello, world");
    assert (m.позиция () == 12);
    assert (m.измпозУст (0) == 0);
    assert (m.доступно == 12);
    assert (m.измпозТек (4) == 4);
    assert (m.доступно == 8);
    assert (m.измпозКон (-8) == 4);
    assert (m.доступно == 8);
    assert (m.размер () == 12);
    assert (m.читайТкст (4) == "o, w");
    m.пишиТкст ("ie");
    assert (cast(ткст) m.данные () == "Hello, wield");
    m.измпозКон (0);
    m.пишиТкст ("Foo");
    assert (m.позиция () == 15);
    assert (m.доступно == 0);
    m.пишиТкст ("Foo foo foo foo foo foo foo");
    assert (m.позиция () == 42);
    m.позиция = 0;
    assert (m.доступно == 42);
    m.пишиф("%d %d %s",100,345,"hello");
    auto стр = m.вТкст;
    assert (стр[0..13] == "100 345 hello", стр[0 .. 13]);
    assert (m.доступно == 29);
    assert (m.позиция == 13);
    
    ПотокПамяти m2;
    m.позиция = 3;
    m2 = new ПотокПамяти ();
    m2.пишиТкст("before");
    m2.копируй_из(m,10);
    стр = m2.вТкст;
    assert (стр[0..16] == "before 345 hello");
    m2.позиция = 3;
    m2.копируй_из(m);
    auto str2 = m.вТкст;
    стр = m2.вТкст;
    assert (стр == ("bef" ~ str2));
	скажинс("И ПотокПамяти живой...");
	пауза;
  }
 import std.к:free;
///
  цел тестРПФайлПоток() {
  РПФайл mf = new РПФайл("c:\\testing.txt",РПФайл.Режим.ЧтенЗапНов,100,пусто);
  РПФайлПоток m;
  m = new РПФайлПоток (mf);
  m.пишиТкст ("Hello, world");
  assert (m.позиция () == 12);
  assert (m.измпозУст (0) == 0);
  assert (m.измпозТек (4) == 4);
  assert (m.измпозКон (-8) == 92);
  assert (m.размер() == 100);
  assert (m.измпозУст (4));
  assert (m.читайТкст (4) == "o, w");
  m.пишиТкст ("ie");
  ббайт[] dd = m.данные();
  assert ((cast(ткст) dd)[0 .. 12] == "Hello, wield");
  m.позиция = 12;
  m.пишиТкст ("Foo");
  assert (m.позиция () == 15);
  m.пишиТкст ("Foo foo foo foo foo foo foo");
  assert (m.позиция () == 42);
  mf.слей();
  m.закрой();
  //delete mf;
  m.удали("c:\\testing.txt");
  скажинс("РПФайлПоток был создан и закрыт");
  return 0;
  }
  

  проц тестПотокСрез() {
    ПотокПамяти m;
    ПотокСрез т;

	скажинс("Входим в ПотокСрез");
    m = new ПотокПамяти ((cast(ткст)"Hello, world").dup);
	скажинс("Создаём ПотокПамяти");
    т = new ПотокСрез (m, 4, 8);
	скажинс("Создаём ПотокСрез");
    assert (т.размер () == 4);
    assert (m.позиция () == 0);
    assert (т.позиция () == 0);
    assert (m.доступно == 12);
    assert (т.доступно == 4);

    assert (т.пишиБлок (cast(сим *) "Vroom", 5) == 4);
    assert (m.позиция () == 0);
    assert (т.позиция () == 4);
    assert (m.доступно == 12);
    assert (т.доступно == 0);
    assert (т.измпозКон (-2) == 2);
    assert (т.доступно == 2);
    assert (т.измпозКон (2) == 4);
    assert (т.доступно == 0);
    assert (m.позиция () == 0);
    assert (m.доступно == 12);

    m.измпозКон(0);
    m.пишиТкст("\nBlaho");
    assert (m.позиция == 18);
    assert (m.доступно == 0);
    assert (т.позиция == 4);
    assert (т.доступно == 0);

    т = new ПотокСрез (m, 4);
    assert (т.размер () == 14);
	скажинс(т.вТкст());
    assert (т.вТкст () == "Vrooorld\nBlaho");////
    т.измпозКон (0);
    assert (т.доступно == 0);

    т.пишиТкст (", etcetera.");
    assert (т.позиция () == 25);
    assert (т.измпозУст (0) == 0);
    assert (т.размер () == 25);
    assert (m.позиция () == 18);
    assert (m.размер () == 29);
    assert (m.вТкст() == "HellVrooorld\nBlaho, etcetera.");
	скажинс("ПотокСрез что-то мычит...");
  }
  
проц тстФорматируй()
{
    цел и;
    ткст т;

    скажинс("Тест формат:");
 
    т = форматируй("hello world! %s %s ", да, 57, 1_000_000_000, 'x', " foo");
    assert(т == "hello world! да 57 1000000000x foo"); скажи("Ок1.1 ");

    т = форматируй(1.67, " %A ", -1.28, плав.nan);
    /* The host C library is used to format floats.
     * C99 doesn't specify what the hex digit before the decimal point
     * is for %A.
     */
    version (Posix)
	{assert(т == "1.67 -0XA.3D70A3D70A3D8P-3 nan"); скажи("Ок2 ");}
    else{
	assert(т == "1.67 -0X1.47AE147AE147BP+0 nan"); скажи("Ок3 ");}

    т = форматируй("%x %X", 0x1234AF, 0xAFAFAFAF);
    assert(т == "1234af AFAFAFAF"); скажи("Ок4 ");

    т = форматируй("%b %o", 0x1234AF, 0xAFAFAFAF);
    assert(т == "100100011010010101111 25753727657"); скажи("Ок5 ");

    т = форматируй("%d %s", 0x1234AF, 0xAFAFAFAF);
    assert(т == "1193135 2947526575"); скажи("Ок6 ");

    т = форматируй("%s", 1.2 + 3.4i);
    assert(т == "1.2+3.4i"); скажи("Ок7 ");

    т = форматируй("%x %X", 1.32, 6.78f);
    assert(т == "3ff51eb851eb851f 40D8F5C3"); скажи("Ок8 ");

    т = форматируй("%#06.*f",2,12.345);
    assert(т == "012.35"); скажи("Ок9.2 ");

    т = форматируй("%#0*.*f",6,2,12.345);
    assert(т == "012.35"); скажи("Ок1 ");

    т = форматируй("%7.4g:", 12.678);
    assert(т == "  12.68:"); скажи("Ок2 ");

    т = форматируй("%7.4g:", 12.678L);
    assert(т == "  12.68:"); скажи("Ок3 ");

    т = форматируй("%04f|%05d|%#05x|%#5x",-4.,-10,1,1);
    assert(т == "-4.000000|-0010|0x001|  0x1"); скажи("Ок4 ");

    и = -10;
    т = форматируй("%d|%3d|%03d|%1d|%01.4f",и,и,и,и,cast(дво) и);
    assert(т == "-10|-10|-10|-10|-10.0000"); скажи("Ок5 ");

    и = -5;
    т = форматируй("%d|%3d|%03d|%1d|%01.4f",и,и,и,и,cast(дво) и);
    assert(т == "-5| -5|-05|-5|-5.0000"); скажи("Ок6 ");

    и = 0;
    т = форматируй("%d|%3d|%03d|%1d|%01.4f",и,и,и,и,cast(дво) и);
    assert(т == "0|  0|000|0|0.0000"); скажи("Ок7 ");

    и = 5;
    т = форматируй("%d|%3d|%03d|%1d|%01.4f",и,и,и,и,cast(дво) и);
    assert(т == "5|  5|005|5|5.0000"); скажи("Ок8 ");

    и = 10;
    т = форматируй("%d|%3d|%03d|%1d|%01.4f",и,и,и,и,cast(дво) и);
    assert(т == "10| 10|010|10|10.0000"); скажи("Ок9 ");

    т = форматируй("%.0d", 0);
    assert(т == ""); скажи("Ок1.3 ");

    т = форматируй("%.g", .34);
    assert(т == "0.3"); скажи("Ок2 ");

    т = форматируй("%.0g", .34);
    assert(т == "0.3"); скажи("Ок3 ");

    т = форматируй("%.2g", .34);
    assert(т == "0.34"); скажи("Ок4 ");

    т = форматируй("%0.0008f", 1e-08);
    assert(т == "0.00000001"); скажи("Ок5 ");

    т = форматируй("%0.0008f", 1e-05);
    assert(т == "0.00001000"); скажи("Ок6 ");

    т = "helloworld";
    ткст r;
    r = форматируй("%.2s", т[0..5]);
    assert(r == "he"); скажи("Ок7 ");
    r = форматируй("%.20s", т[0..5]);
    assert(r == "hello"); скажи("Ок8 ");
    r = форматируй("%8s", т[0..5]);
    assert(r == "   hello"); скажи("Ок9 ");

    байт[] arrbyte = new байт[4];
    arrbyte[0] = 100;
    arrbyte[1] = -99;
    arrbyte[3] = 0;
    r = форматируй(arrbyte);
    assert(r == "[100,-99,0,0]"); скажи("Ок1.4 ");

    ббайт[] arrббайт = new ббайт[4];
    arrббайт[0] = 100;
    arrббайт[1] = 200;
    arrббайт[3] = 0;
    r = форматируй(arrббайт);
    assert(r == "[100,200,0,0]"); скажи("Ок2 ");

    крат[] arrshort = new крат[4];
    arrshort[0] = 100;
    arrshort[1] = -999;
    arrshort[3] = 0;
    r = форматируй(arrshort);
    assert(r == "[100,-999,0,0]"); скажи("Ок3 ");
    r = форматируй("%s",arrshort);
    assert(r == "[100,-999,0,0]"); скажи("Ок4 ");

    бкрат[] arrushort = new бкрат[4];
    arrushort[0] = 100;
    arrushort[1] = 20_000;
    arrushort[3] = 0;
    r = форматируй(arrushort);
    assert(r == "[100,20000,0,0]"); скажи("Ок5 ");

    цел[] arrint = new цел[4];
    arrint[0] = 100;
    arrint[1] = -999;
    arrint[3] = 0;
    r = форматируй(arrint);
    assert(r == "[100,-999,0,0]"); скажи("Ок6 ");
    r = форматируй("%s",arrint);
    assert(r == "[100,-999,0,0]"); скажи("Ок7 ");

    дол[] arrlong = new дол[4];
    arrlong[0] = 100;
    arrlong[1] = -999;
    arrlong[3] = 0;
    r = форматируй(arrlong);
    assert(r == "[100,-999,0,0]"); скажи("Ок8 ");
    r = форматируй("%s",arrlong);
    assert(r == "[100,-999,0,0]"); скажи("Ок9 ");

    бдол[] arrulong = new бдол[4];
    arrulong[0] = 100;
    arrulong[1] = 999;
    arrulong[3] = 0;
    r = форматируй(arrulong);
    assert(r == "[100,999,0,0]"); скажи("Ок1.5 ");

    ткст[] arr2 = new ткст[4];
    arr2[0] = "hello";
    arr2[1] = "world";
    arr2[3] = "foo";
    r = форматируй(cast(ткст[]) arr2);//!
    assert(r == "[hello,world,,foo]"); скажи("Ок2 ");

    r = форматируй("%.8d", 7);
    assert(r == "00000007"); скажи("Ок3 ");
    r = форматируй("%.8x", 10);
    assert(r == "0000000a"); скажи("Ок4 ");

    r = форматируй("%-3d", 7);
    assert(r == "7  "); скажи("Ок5 ");

    r = форматируй("%*d", -3, 7);
    assert(r == "7  "); скажи("Ок6 ");

    r = форматируй("%.*d", -3, 7);
    assert(r == "7"); скажи("Ок7 ");

    typedef цел myint;
    myint m = -7;
    r = форматируй(cast(цел) m);
    assert(r == "-7"); скажи("Ок8 ");

    r = форматируй("abc"c);
    assert(r == "abc"); скажи("Ок9 ");
    r = форматируй("def"w);
    assert(r == "def"); скажи("Ок1.6 ");
    r = форматируй("ghi"d);
    assert(r == "ghi"); скажи("Ок2 ");

    ук p = cast(ук )0xDEADBEEF;
    r = форматируй(p);
    assert(r == "DEADBEEF"); скажи("Ок3 ");

    r = форматируй("%#x", 0xabcd);
    assert(r == "0xabcd"); скажи("Ок4 ");
    r = форматируй("%#X", 0xABCD);
    assert(r == "0XABCD"); скажи("Ок5 ");

    r = форматируй("%#o", 012345);
    assert(r == "012345"); скажи("Ок6 ");
    r = форматируй("%o", 9);
    assert(r == "11"); скажи("Ок7 ");

    r = форматируй("%+d", 123);
    assert(r == "+123"); скажи("Ок8 ");
    r = форматируй("%+d", -123);
    assert(r == "-123"); скажи("Ок9 ");
    r = форматируй("% d", 123);
    assert(r == " 123"); скажи("Ок1.7 ");
    r = форматируй("% d", -123);
    assert(r == "-123"); скажи("Ок2 ");

    r = форматируй("%%");
    assert(r == "%"); скажи("Ок3 ");

    r = форматируй("%d", да);
    assert(r == "1"); скажи("Ок4 ");
    r = форматируй("%d", false);
    assert(r == "0"); скажи("Ок5 ");

    r = форматируй("%d", 'a');
    assert(r == "97"); скажи("Ок6 ");
    шим wc = 'a';
    r = форматируй("%d", wc);
    assert(r == "97"); скажи("Ок7 ");
    дим dc = 'a';
    r = форматируй("%d", dc);
    assert(r == "97"); скажи("Ок8 ");

    байт b = байт.max;
    r = форматируй("%x", b);
    assert(r == "7f"); скажи("Ок9 ");
    r = форматируй("%x", ++b);
    assert(r == "80"); скажи("Ок1.8 ");
    r = форматируй("%x", ++b);
    assert(r == "81"); скажи("Ок2 ");

    крат sh = крат.max;
    r = форматируй("%x", sh);
    assert(r == "7fff"); скажи("Ок3 ");
    r = форматируй("%x", ++sh);
    assert(r == "8000"); скажи("Ок4 ");
    r = форматируй("%x", ++sh);
    assert(r == "8001"); скажи("Ок5 ");

    и = цел.max;
    r = форматируй("%x", и);
    assert(r == "7fffffff"); скажи("Ок6 ");
    r = форматируй("%x", ++и);
    assert(r == "80000000"); скажи("Ок7 ");
    r = форматируй("%x", ++и);
    assert(r == "80000001"); скажи("Ок8 ");

    r = форматируй("%x", 10);
    assert(r == "a"); скажи("Ок9 ");
    r = форматируй("%X", 10);
    assert(r == "A"); скажи("Ок1.0 ");
    r = форматируй("%x", 15);
    assert(r == "f"); скажи("Ок2 ");
    r = форматируй("%X", 15);
    assert(r == "F"); скажи("Ок3 ");

    Object к = пусто;
    r = форматируй(к);
    assert(r == "пусто"); скажи("Ок4 объект ");

    enum TestEnum
    {
	    Value1, Value2
    }
    r = форматируй("%s", TestEnum.Value2);
    assert(r == "1"); скажи("Ок5 ");

    сим[5][цел] aa = ([3:"hello", 4:"betty"]);
    r = форматируй("%s", aa.values);
    assert(r == "[[h,e,l,l,o],[b,e,t,t,y]]"); скажи("Ок6 ");
    r = форматируй("%s", aa);
    assert(r == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]"); скажи("Ок7 ");

    static const дим[] ds = ['a','b'];
    for (цел j = 0; j < ds.длина; ++j)
    {
	r = форматируй(" %d", ds[j]);
	if (j == 0)
	    {assert(r == " 97"); скажи("Ок8 ");  }
	else
	    {assert(r == " 98"); скажи("Ок9 ");}
    }

    r = форматируй(">%14d<, ", 15, [1,2,3]);
    assert(r == ">            15<, [1,2,3]"); скажи("Ок1... ");

    assert(форматируй("%8s", "bar") == "     bar"); скажи("Ок2 ");
    assert(форматируй("%8s", "b\u00e9ll\u00f4") == "   b\u00e9ll\u00f4"); скажи("Ок3 -Финиш! ");
}

export extern (System) проц отобразиСцену()
{
глОчисти(БИТ_БУФЕРА_ЦВЕТА);
глЦвет(1.0, 1.0, 0.0);
глПрямоуг(-25.0, 25.0, 25.0, -25.0);
глСлей();
}

export extern (System) проц измениРазмер(Гцразм ш, Гцразм в)
{
плав соотнош;
if(в==0)
в = 1;
глВьюпорт(0,0,ш,в);
глРежимМатр(ПРОЕКЦИЯ);
глЗагрузиИдент();
соотнош =cast(плав) ш/cast(плав) в;
if(ш<=в)
 глОрто(-100.0, 100.0, -100/соотнош, 100.0/соотнош, 1.0, -1.0);
 глРежимМатр(ОБЗОР_МОДЕЛИ);
 глЗагрузиИдент;
}
проц установиРС()
{
глЦветОчистки(0.0,0.0,0.1,0.1);
}

проц вход()
{
глутИницРежимПоказа(GLUT_SINGLE|GLUT_RGB);
глутСоздайОкно("GLUT Window");
глутФункцПоказа(&отобразиСцену);
глутФункцПерерисовки(&измениРазмер);
установиРС();
глутГлавныйЦикл();
}

/*
цел окно()
{

открой_окно("ARC Window", 800, 600, 0);
	открой_ввод(); 
	открой_звук(); 
		ЗвукоФайл sf2 = ЗвукоФайл("d:\\dm\\dev\\dinrus\\cycleness.ogg"); 
		sf2.выведи();
		Звук зв =  Звук(sf2); 
	зв.играй();
	while (!(нажатаКлавиша(27) || нажатаКлавиша(КЛ_ПБЕЛ)))
	{
		обработай_ввод(); 
		очисти_окно();
		if (нажатаКлавиша('s'))
		{
			зв.стоп(); 
			зв.играй();
			скажинс("Повторение с начала"); 
		}
		зв.обработай();
		рисуйКруг(Точка(150, 200), 25, 20, Цвет.Красный, да);
		рисуйПрямоуг(Точка(100,100), Размер(300,200), Цвет.Зелёный, нет);
		отобрази();
	}
	scope(exit) {  закрой_звук(); закрой_окно();} 
	return 0;

}
*/

проц тестБокс()
{
скажинс ("ТестБокс");

    class A { }
    class B : A { }
    struct SA { }
    struct SB { }
    
    Бокс a, b;
    
    /* Call the function, catch UnboxException, return that it threw correctly. */
    bool fails(проц delegate()func)
    {
        try {func();}
        catch (РазбоксИскл error)
		{
		скажинс("поймано");
		delete error;
            return да;
		}
        return false;
    }
    
    /* Check that equals and comparison work properly. */
    a = вБокс(0);
    b = вБокс(32);
    assert (a != b);
    assert (a == a);
    assert (a < b);
    
    /* Check that toString works properly. */
    assert (b.вТкст == "32");
    
    /* Assert that unboxable works. */
    assert (разбоксОбъ!(ткст)(вБокс("foobar")));
    
    /* Assert that we can cast from цел to байт. */
    assert (тестРазбокс!(байт)(b) == 32);
    
    /* Assert that we can cast from цел to реал. */
    assert (тестРазбокс!(реал)(b) == 32.0L);
    
    /* Check that реал works properly. */
    assert (тестРазбокс!(реал)(вБокс(32.45L)) == 32.45L);
    
    /* Assert that we cannot implicitly cast from реал to цел. */
   // !!!!assert(fails(delegate проц() { тестРазбокс!(цел)(вБокс(1.3)); }));
    
    /* Check that the unspecialized unbox template works. */
    assert(тестРазбокс!(ткст)(вБокс("foobar")) == "foobar");
    
    /* Assert that complex works correctly. */
    assert(тестРазбокс!(кдво)(вБокс(1 + 2i)) == 1 + 2i);
    
    /* Assert that imaginary works correctly. */
    assert(тестРазбокс!(вреал)(вБокс(45i)) == 45i);
    
    /* Create an array of boxes from arguments. */
    Бокс[] array = массивБокс(16, "foobar", new Object);
    
    assert(array.длина == 3);
    assert(тестРазбокс!(цел)(array[0]) == 16);
    assert(тестРазбокс!(ткст)(array[1]) == "foobar");
    assert(тестРазбокс!(Object)(array[2]) !is пусто);
	скажинс("объект прошёл проверку");
    
    /* Convert the вБокс array back into arguments. */
    ИнфОТипе[] array_types;
    ук array_данные;
    
    массивБоксВАргументы(array, array_types, array_данные);
    assert (array_types.длина == 3);
    
    /* Confirm the symmetry. */
   //!!!1 assert (массивБокс(array_types, array_данные) == array);
    
    /* Assert that we can cast from цел to креал. */
    assert (тестРазбокс!(креал)(вБокс(45)) == 45+0i);
    
    /* Assert that we can cast from вдво to креал. */
    assert (тестРазбокс!(креал)(вБокс(45i)) == 0+45i);
    
    /* Assert that equality testing casts properly. */
    assert (вБокс(1) == вБокс(cast(байт)1));
    assert (вБокс(cast(реал)4) == вБокс(4));
    assert (вБокс(5) == вБокс(5+0i));
    assert (вБокс(0+4i) == вБокс(4i));
    assert (вБокс(8i) == вБокс(0+8i));
    
    /* Assert that comparisons cast properly. */
    assert (вБокс(450) < вБокс(451));
    assert (вБокс(4) > вБокс(3.0));
    assert (вБокс(0+3i) < вБокс(0+4i));
    
    /* Assert that casting from bool to цел works. */
    assert (1 == тестРазбокс!(цел)(вБокс(да)));
    assert (вБокс(1) == вБокс(да));
 
    /* Assert that unboxing to an object works properly. */
    assert (тестРазбокс!(B)(вБокс(cast(A)new B)) !is пусто);
    
    /* Assert that illegal object casting fails properly. */   
    assert (fails(delegate проц() { тестРазбокс!(B)(вБокс(new A)); }));
    
    /* Assert that we can unbox a пусто. */
    assert (тестРазбокс!(A)(вБокс(cast(A)пусто)) is пусто);
    assert (тестРазбокс!(A)(вБокс(пусто)) is пусто);
    
    /* Unboxing пусто in various contexts. */
    assert (тестРазбокс!(ткст)(вБокс(пусто)) is пусто);
    assert (тестРазбокс!(цел*)(вБокс(пусто)) is пусто);
    
    /* Assert that unboxing between pointer types fails. */
    цел [1] p;
    assert (fails(delegate проц() { тестРазбокс!(сим*)(вБокс(p.укз)); }));
    
    /* Assert that unboxing various types as ук does work. */
    assert (тестРазбокс!(ук )(вБокс(p.укз))); // цел*
    assert (тестРазбокс!(ук )(вБокс(p))); // цел[]
    assert (тестРазбокс!(ук )(вБокс(new A))); // Object
    
    /* Assert that we can't unbox an integer as bool. */
    assert (!разбоксОбъ!(bool) (вБокс(4)));
    
    /* Assert that we can't unbox a struct as another struct. */
    SA sa;
    assert (!разбоксОбъ!(SB)(вБокс(sa)));
	
	скажинс ("ТестБокс прошёл удачно");
}

 проц batest()
    {
	debug(bitarray) эхо("BitArray.opCat unittest\n");

	static bool[] ba = [1,0];
	static bool[] bb = [0,1,0];

	МассивБит a; a.иниц(ba);
	МассивБит b; b.иниц(bb);
	МассивБит к;

	к = (a ~ b);
	assert(к.длина == 5);
	assert(к[0] == 1);
	assert(к[1] == 0);
	assert(к[2] == 0);
	assert(к[3] == 1);
	assert(к[4] == 0);

	к = (a ~ да);
	assert(к.длина == 3);
	assert(к[0] == 1);
	assert(к[1] == 0);
	assert(к[2] == 1);

	к = (false ~ a);
	assert(к.длина == 3);
	assert(к[0] == 0);
	assert(к[1] == 1);
	assert(к[2] == 0);
	скажинс("БитМассив проверен");
 }
 
 
const плав MAXZ = 8.0;
const плав MINZ = -8.0;
const плав ZINC = 4.;


static плав solidZ = MAXZ;
static плав transparentZ = MINZ;
static бцел sphereList, cubeList;

static проц иниц()
{
   плав mat_specular[] = [ 1.0, 1.0, 1.0, 0.15 ];
   плав mat_shininess[] = [ 100.0 ];
   плав позиция[] = [ 0.5, 0.5, 1.0, 0.0 ];

   глМатериал(ФРОНТ, СПЕКУЛЯРНЫЙ, cast(плав*) mat_specular);
   глМатериал(ФРОНТ, БЛЕСК, cast(плав*) mat_shininess);
   глСвет(СВЕТ0, ПОЗИЦИЯ, cast(плав*) позиция);

   глВключи(ОСВЕЩЕНИЕ);
   глВключи(СВЕТ0);
   глВключи(ТЕСТ_ДАЛИ);

   sphereList = глГенСписки(cast(Гцразм) 1);
   глНовСписок(sphereList, cast(Гперечень) КОМПИЛИРУЙ);
      глутПлотнаяСфера (0.4, 16, 16);
   глКонецСписка();

   cubeList = глГенСписки(cast(Гцразм) 1);
   глНовСписок(cubeList, cast(Гперечень) КОМПИЛИРУЙ);
      глутПлотныйКуб (0.6);
   глКонецСписка();
}

export extern (Windows) проц покажи()
{
   плав mat_solid[] = [ 0.75, 0.75, 0.0, 1.0 ];
   плав mat_zero[] = [ 0.0, 0.0, 0.0, 1.0 ];
   плав mat_transparent[] = [ 0.0, 0.8, 0.8, 0.6 ];
   плав mat_emission[] = [ 0.0, 0.3, 0.3, 0.6 ];

   глОчисти (БИТ_БУФЕРА_ЦВЕТА | БИТ_БУФЕРА_ДАЛИ);

   глСуньМатр ();
      глПеренеси (-0.15, -0.15,  solidZ);
      глМатериал(ФРОНТ, ЭМИССИЯ, cast(плав*) mat_zero);
      глМатериал(ФРОНТ, ДИФФУЗНЫЙ, cast(плав*) mat_solid);
      глВызовиСписок (sphereList);
   глВыньМатр ();

   глСуньМатр ();
      глПеренеси (0.15, 0.15, transparentZ);
      глВращай (15.0, 1.0, 1.0, 0.0);
      глВращай (30.0, 0.0, 1.0, 0.0);
      глМатериал(ФРОНТ, ЭМИССИЯ, cast(плав*) mat_emission);
      глМатериал(ФРОНТ, ДИФФУЗНЫЙ,cast(плав*) mat_transparent);
      глВключи (СМЕСЬ);
      глМаскаДали (г_нет);
      глФункцСмеси (АЛЬФА_ИСТОЧНИКА, ОДИН);
      глВызовиСписок (cubeList);
      глМаскаДали (г_да);
      глОтключи (СМЕСЬ);
   глВыньМатр ();

   глутОбменБуферов();
}

export extern (Windows) проц  перерисуй(цел w, цел h)
{
   глВьюпорт(0, 0, cast(цел) w, cast(цел) h);
   глРежимМатр(ПРОЕКЦИЯ);
   глЗагрузиИдент();
   if (w <= h)
      глОрто (-1.5, 1.5, -1.5*cast(плав)h/cast(плав)w,
               1.5*cast(плав)h/cast(плав)w, -10.0, 10.0);
   else
      глОрто (-1.5*cast(плав)w/cast(плав)h,
               1.5*cast(плав)w/cast(плав)h, -1.5, 1.5, -10.0, 10.0);
   глРежимМатр(ОБЗОР_МОДЕЛИ);
   глЗагрузиИдент();
}

export extern (Windows) проц оживи()
{
   static дво t0 = -1.;
   if (solidZ <= MINZ || transparentZ >= MAXZ)
   {
      глутФункцБездействия(пусто);
      t0 = -1.;
   }
   else {
      дво t, dt;
      t = глутДай(GLUT_ELAPSED_TIME) / 1000.;
      if (t0 < 0.)
         t0 = t;
      dt = t - t0;
      t0 = t;
      solidZ -= ZINC*dt;
      transparentZ += ZINC*dt;
      глутПерепоказ();
   }
}

/* ARGSUSED1 */
export extern (Windows) проц клавиатура(сим клава, цел x, цел y)
{
   switch (клава) {
      case 'a':
      case 'A':
         solidZ = MAXZ;
         transparentZ = MINZ;
         глутФункцБездействия(&оживи);
         break;
      case 'r':
      case 'R':
         solidZ = MAXZ;
         transparentZ = MINZ;
         глутПерепоказ();
         break;
      case ' ':
        выход(0);
		break;
		default: break;
    }
}

цел окно2()
{
   //глутИниц(&argc, argv);
   глутИницРежимПоказа (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
   глутИницРазмерОкна(500, 500);
   глутСоздайОкно("Demo");
   иниц();
   глутФункцПерерисовки (&перерисуй);
   глутФункцКлавиатуры (&клавиатура);
   глутФункцПоказа(&покажи);
   глутГлавныйЦикл();
   return 0;
}
///////////////////////////////
  проц пишификс(фук фу, ИнфОТипе[] аргументы, ук аргук, цел нс = нет)
   {
   скажинс("на месте");
     цел ориентация = cidrus.ширфл(фу, 0);
	 скажинс("на месте2");
    cidrus.блокфл(фу);
	скажинс("на месте3");
    scope(exit) cidrus.разблокфл(фу);
	скажинс("на месте4");
    if (ориентация <= 0)	
    {
	проц putc(дим к)
	{
	    if (к <= 0x7F)
	    {
		cidrus.поместсфл(к, фу);
	    }
	    else
	    {   сим[4] buf;
		auto b = вЮ8(buf, к);
		for (т_мера и = 0; и < b.длина; и++)
		    cidrus.поместсфл(b[и], фу);
	    }
	}

	форматДелай(&putc, аргументы, аргук);
	if (нс)
	    cidrus.поместсфл('\n', фу);
    }
    else if (ориентация > 0)		// wide ориентация
    {	
	 проц putcw(дим к)
    {
		assert(дим_ли(к));
		if (к <= 0xFFFF)
		{
		    cidrus.поместшфл(к, фу);
		}
		else
		{   шим[2] buf;

		    buf[0] = cast(шим) ((((к - 0x10000) >> 10) & 0x3FF) + 0xD800);
		    buf[1] = cast(шим) (((к - 0x10000) & 0x3FF) + 0xDC00);
		    cidrus.поместшфл(buf[0], фу);
		    cidrus.поместшфл(buf[1], фу);
		}
    }
	форматДелай(&putcw, аргументы, аргук);
	if (нс)
	    cidrus.поместшфл('\n', фу);
    }
	скажинс("ушёл");
}

проц писай(...)
	{
	auto args = _arguments;
	пишификс(стдвых, _arguments, _argptr, 0);
	}
///////////////////////////////

/*
	т_мера читайстр(фук fp, inout ткст buf)
{
    cidrus.блокфл(fp);
	scope(exit) cidrus.разблокфл(fp);

	if (фук_инфо[fp._file] & ФУК_ШИМ)
	{   
	    static assert(шим.sizeof == 2);
	    buf.длина = 0;
	    цел c2;
	    for (цел к = void; (к = cidrus.извлшфл(fp)) != -1; )
	    {
		if ((к & ~0x7F) == 0)
		{   buf ~= к;
		    if (к == '\n')
			break;
		}
		else
			{
				if (к >= 0xD800 && к <= 0xDBFF)
				{
				if ((c2 = cidrus.извлшфл(fp)) != -1 ||
					c2 < 0xDC00 && c2 > 0xDFFF)
				{
					std.io.ИсклСтдВВ("беспарный суррогат Ю-16");
				}
				к = ((к - 0xD7C0) << 10) + (c2 - 0xDC00);
				}
				std.utf.encode(buf, к);
			}
	    }
	    if (cidrus.ошибф(fp))
		ИсклСтдВВ();
	    return buf.длина;
	}

	auto разм = std.gc.capacity(buf.укз);
	//auto разм = buf.длина;
	buf = buf.укз[0 .. разм];
	if (fp._flag & ВВНБФ)
	{
	   
	 L1:
	    сим *p;

	    if (разм)
	    {
		p = buf.укз;
	    }
	    else
	    {
		разм = 64;
		p = cast(сим*) std.gc.malloc(разм);
		std.gc.hasNoPointers(p);
		buf = p[0 .. разм];
	    }
	    т_мера и = 0;
	    for (цел к; (к = cidrus.извлсфл(fp)) != -1; )
	    {
		if ((p[и] = cast(сим)к) != '\n')
		{
		    и++;
		    if (и < разм)
			continue;
		    buf = p[0 .. и] ~ читайстр(fp);
		    return buf.длина;
		}
		else
		{
		    buf = p[0 .. и + 1];
		    return и + 1;
		}
	    }
	    if (cidrus.ошибф(fp))
		ИсклСтдВВ();
	    buf = p[0 .. и];
	    return и;
	}
	else
	{
	    цел u = fp._cnt;
	    сим* p = fp._ptr;
	    цел и;
	    if (fp._flag & ВВТРАН)
	    {  
		сим к;
		while (1)
		{
		    if (и == u)		// if end of buffer
			goto L1;	// give up
		    к = p[и];
		    и++;
		    if (к != '\r')
		    {
			if (к == '\n')
			    break;
			if (к != 0x1A)
			    continue;
			goto L1;
		    }
		    else
		    {   if (и != u && p[и] == '\n')
			    break;
			goto L1;
		    }
		}
		if (и > разм)
		{
		    buf = cast(сим[])std.gc.malloc(и);
		    std.gc.hasNoPointers(buf.укз);
		}
		if (и - 1)
		    memcpy(buf.укз, p, и - 1);
		buf[и - 1] = '\n';
		if (к == '\r')
		    и++;
	    }
	    else
	    {
		while (1)
		{
		    if (и == u)		// if end of buffer
			goto L1;	// give up
		    auto к = p[и];
		    и++;
		    if (к == '\n')
			break;
		}
		if (и > разм)
		{
		    buf = cast(сим[])std.gc.malloc(и);
		    std.gc.hasNoPointers(buf.укз);
		}
		memcpy(buf.укз, p, и);
	    }
	    fp._cnt -= и;
	    fp._ptr += и;
	    buf = buf[0 .. и];
	    return и;
	}
}
*/

проц дир()
  {
     bool callback(ПапЗап* de)
     {
       if (de.папка_ли)
         списпап(de.имя, &callback);
       else
        скажинс(de.имя);
       return true;
     }
 
     списпап(".", &callback);
  }
/*
 проц открой_ка()
 {
 ткст д[6] = ["d:","e:","f:","g:","h:","j:"];
for(цел ц ; ц =cast(цел) д[ц] ; )
	{
		if(!откройДисковод(д)) ц++;
		
	}
}
*/
АТРИБУТЫ_БЕЗОПАСНОСТИ *безАтры;

extern (C) проц уды_ы_ды(){удали(".\\rrrrr.txt");}
цел main(){
	
СТАРТ();

ук файлУк = СоздайФайл(вЮ16(".\\rrrrr.txt"c), ППраваДоступа.ГенернаяЗапись, ПСовмИспФайла.Запись,  пусто, ПРежСоздФайла.ОткрытьВсегда, ПФайл.Нормальный, пусто);
НайдиЗакрой(файлУк);
//навыходе(&уды_ы_ды);
//открой_ка();
//откройДисковод("g:");
//почтоваяФорма();
//закройДисковод("g:");

//окно();
скажинс(о_ЦПУ);
//нс;
//скажи("Версия libbz2: "); скажинс(бз2Версия);
//скажи("Версия Windows: "); скажинс(вТкст(ДайВерсию()));
//тестСДЛ();
//читайстр();
//пауза;

batest();
тестУни();
тестУИР();
тестАдлер();
тестКС();

тестТПотокМассив(); //работает
тестРПФайл();//работает

//throw new ОшибкаРЯР(112, форматируй("Поток покушан!"));
//тестФайл();//av
скажинс("дир");
дир();
пауза;
тестПотокЭндианец();//av
//тестБуфФайл();//av

тестПотокПамяти();//!!!!!!!!!!!!!Win32 Исключение
тестРПФайлПоток();//av
тестПотокСрез();//!!!!!!!!!!!!
тестБокс();//!!!!!!!!!!!

скажи(cast(ткст) читайФайл("test.d"));
//двых.кф();
//тестСФайл();//av
//тстФорматируй();
СоздайПапку("Новая Папка", безАтры);
//ткст т = читайстр();
//пишифнс(т);

УстановиТекущуюПапку("C:"w);

перейди_в("d:\\dm\\dev\\dinrus");
скажинс(дайтекпап); нс;
скажинс("Данная машина зарегестрирована под именем "~дайИмяМашины());нс;
скажинс("Пользователь этого компьютера зарегестрирован как "~дайИмяПользователя());нс;
скажинс(форматируй("Число тиков = %d или %d", дайЧлоТиков, ДайСчётТиков));нс;
скажинс(разверниПеременныеСреды("Мой системный диск это %SystemDrive%, а корень моей системы это %SystemRoot%"));нс;

//аборт();
//писай("MUUUU!!!");
//окно();
//вход();
//миниД(["-"]);
//скажинс(дайтекпап);
тестМД5();
тестЗлиб();
//скажи(cast(ткст) читайФайл("test.d"));
//миниД(["-"]
скажинс("Выполнение Тестовых Кодов: ");
скажинс("miniD.samples.speed");
миниД(["miniD.samples.speed"]);
скажинс("miniD.samples.ackermann");
миниД(["miniD.samples.ackermann"]);
скажинс("miniD.samples.antimatroids");
миниД(["miniD.samples.antimatroids"]);
скажинс("miniD.samples.arrays");
миниД(["miniD.samples.arrays"]);
скажинс("miniD.samples.factorial");
миниД(["miniD.samples.factorial"]);
скажинс("miniD.samples.lzw");
миниД(["miniD.samples.lzw", "lo.txt", "lzw.out"]);
скажинс("miniD.samples.matrix");
миниД(["miniD.samples.matrix"]);
скажинс("miniD.samples.regexptest");
миниД(["miniD.samples.regexptest"]);
//скажинс("miniD.samples.threadtest");
//миниД(["miniD.samples.threadtest"]);
//мдКомпилятор();
//мдКомпилятор("beer.md");
//миниД(["beer"]);
//миниД([]);
тестПроизводительности();
//окно();

окно2();

СТОП();
return 0;

}

