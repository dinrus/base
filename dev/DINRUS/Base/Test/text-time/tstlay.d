module tstlay;
import stdrus: пз;
import text.convert.Layout;
import io.Stdout;

проц main()
    {
        auto фмт = Выкладка!(сим).экземпляр;

        // Базовые тесты выкладки
        assert( фмт( "abc" ) == "abc" );		Стдвыв(фмт( "abc" )).нс;
        assert( фмт( "{0}", 1 ) == "1" );		Стдвыв( фмт( "{0}", 1 )).нс;
        assert( фмт( "{0}", -1 ) == "-1" );		Стдвыв(фмт( "{0}", -1 )).нс;

        assert( фмт( "{}", 1 ) == "1" ); Стдвыв(фмт( "{}", 1 )).нс;		
        assert( фмт( "{} {}", 1, 2) == "1 2" );Стдвыв(фмт( "{} {}", 1, 2)).нс;
        assert( фмт( "{} {0} {}", 1, 3) == "1 1 3" );Стдвыв(фмт( "{} {0} {}", 1, 3)).нс;

        assert( фмт( "{0}", да ) == "да", фмт( "{0}", да ));Стдвыв(фмт( "{0}", да )).нс;
        assert( фмт( "{0}", нет ) == "нет" );Стдвыв( фмт( "{0}", нет )).нс;

        assert( фмт( "{0}", cast(байт)-128 ) == "-128" );Стдвыв(фмт( "{0}", cast(байт)-128 )).нс;
        assert( фмт( "{0}", cast(байт)127 ) == "127" );Стдвыв(фмт( "{0}", cast(байт)127 )).нс;
        assert( фмт( "{0}", cast(ббайт)255 ) == "255" );Стдвыв(фмт( "{0}", cast(ббайт)255 )).нс;

        assert( фмт( "{0}", cast(крат)-32768  ) == "-32768" );Стдвыв(фмт( "{0}", cast(крат)-32768  )).нс;
        assert( фмт( "{0}", cast(крат)32767 ) == "32767" );Стдвыв( фмт( "{0}", cast(крат)32767 )).нс;
        assert( фмт( "{0}", cast(бкрат)65535 ) == "65535" );Стдвыв(фмт( "{0}", cast(бкрат)65535 ) ).нс;
        assert( фмт( "{0:x4}", cast(бкрат)0xafe ) == "0afe" );Стдвыв(фмт( "{0:x4}", cast(бкрат)0xafe )).нс;
        assert( фмт( "{0:X4}", cast(бкрат)0xafe ) == "0AFE" );Стдвыв( фмт( "{0:X4}", cast(бкрат)0xafe )).нс;

        assert( фмт( "{0}", -2147483648 ) == "-2147483648" );Стдвыв(фмт( "{0}", -2147483648 )).нс;
        assert( фмт( "{0}", 2147483647 ) == "2147483647" );Стдвыв(фмт( "{0}", 2147483647 )).нс;
        assert( фмт( "{0}", 4294967295 ) == "4294967295" );Стдвыв(фмт( "{0}", 4294967295 )).нс;

        // Большие целочисленные
        assert( фмт( "{0}", -9223372036854775807L) == "-9223372036854775807" );
        assert( фмт( "{0}", 0x8000_0000_0000_0000L) == "9223372036854775808" );
        assert( фмт( "{0}", 9223372036854775807L ) == "9223372036854775807" );
        assert( фмт( "{0:X}", 0xFFFF_FFFF_FFFF_FFFF) == "FFFFFFFFFFFFFFFF" );
        assert( фмт( "{0:x}", 0xFFFF_FFFF_FFFF_FFFF) == "ffffffffffffffff" );
        assert( фмт( "{0:x}", 0xFFFF_1234_FFFF_FFFF) == "ffff1234ffffffff" );
        assert( фмт( "{0:x19}", 0x1234_FFFF_FFFF) == "00000001234ffffffff" );
        assert( фмт( "{0}", 18446744073709551615UL ) == "18446744073709551615" );
        assert( фмт( "{0}", 18446744073709551615UL ) == "18446744073709551615" );

        // Фрагменты перед и после
        assert( фмт( "d{0}d", "s" ) == "dsd" );
        assert( фмт( "d{0}d", "1234567890" ) == "d1234567890d" );

        // Эскапация скобок
        assert( фмт( "d{0}d", "<ткст>" ) == "d<ткст>d");
        assert( фмт( "d{{0}d", "<ткст>" ) == "d{0}d");
        assert( фмт( "d{{{0}d", "<ткст>" ) == "d{<ткст>d");
        assert( фмт( "d{0}}d", "<ткст>" ) == "d<ткст>}d");

        // Гекс-преобразования, где ширина указывает на вводные нули
        assert( фмт( "{0:x}", 0xafe0000 ) == "afe0000" );
        assert( фмт( "{0:x7}", 0xafe0000 ) == "afe0000" );
        assert( фмт( "{0:x8}", 0xafe0000 ) == "0afe0000" );
        assert( фмт( "{0:X8}", 0xafe0000 ) == "0AFE0000" );
        assert( фмт( "{0:X9}", 0xafe0000 ) == "00AFE0000" );
        assert( фмт( "{0:X13}", 0xafe0000 ) == "000000AFE0000" );
        assert( фмт( "{0:x13}", 0xafe0000 ) == "000000afe0000" );

        // Ширина десятка ширина
        assert( фмт( "{0:d6}", 123 ) == "000123" );
        assert( фмт( "{0,7:d6}", 123 ) == " 000123" );
        assert( фмт( "{0,-7:d6}", 123 ) == "000123 " );

        // Сочетания ширина & знак
        assert( фмт( "{0:d7}", -123 ) == "-0000123" );
        assert( фмт( "{0,7:d6}", 123 ) == " 000123" );
        assert( фмт( "{0,7:d7}", -123 ) == "-0000123" );
        assert( фмт( "{0,8:d7}", -123 ) == "-0000123" );
        assert( фмт( "{0,5:d7}", -123 ) == "-0000123" );

        // Отрицательные числа с различным основанием
        assert( фмт( "{:b}", cast(байт) -1 ) == "11111111" );
        assert( фмт( "{:b}", cast(крат) -1 ) == "1111111111111111" );
        assert( фмт( "{:b}", cast(цел) -1 )
        == "11111111111111111111111111111111" );
        assert( фмт( "{:b}", cast(дол) -1 )
        == "1111111111111111111111111111111111111111111111111111111111111111" );

        assert( фмт( "{:o}", cast(байт) -1 ) == "377" );
        assert( фмт( "{:o}", cast(крат) -1 ) == "177777" );
        assert( фмт( "{:o}", cast(цел) -1 ) == "37777777777" );
        assert( фмт( "{:o}", cast(дол) -1 ) == "1777777777777777777777" );

        assert( фмт( "{:d}", cast(байт) -1 ) == "-1" );
        assert( фмт( "{:d}", cast(крат) -1 ) == "-1" );
        assert( фмт( "{:d}", cast(цел) -1 ) == "-1" );
        assert( фмт( "{:d}", cast(дол) -1 ) == "-1" );

        assert( фмт( "{:x}", cast(байт) -1 ) == "ff" );
        assert( фмт( "{:x}", cast(крат) -1 ) == "ffff" );
        assert( фмт( "{:x}", cast(цел) -1 ) == "ffffffff" );
        assert( фмт( "{:x}", cast(дол) -1 ) == "ffffffffffffffff" );

        // Индекс аргумента
        assert( фмт( "a{0}b{1}c{2}", "x", "y", "z" ) == "axbycz" ); скажинс(фмт( "a{0}b{1}c{2}", "x", "y", "z" ));
        assert( фмт( "a{2}b{1}c{0}", "x", "y", "z" ) == "azbycx" );
        assert( фмт( "a{1}b{1}c{1}", "x", "y", "z" ) == "aybycy" );

        // Раскладка не ограничивает длину
        assert( фмт( "{0,5}", "hellohello" ) == "hellohello" );

        // Рскладка заполняется пробелами
        assert( фмт( "->{0,-10}<-", "hello" ) == "->hello     <-" );
        assert( фмт( "->{0,10}<-", "hello" ) == "->     hello<-" );
        assert( фмт( "->{0,-10}<-", 12345 ) == "->12345     <-" );
        assert( фмт( "->{0,10}<-", 12345 ) == "->     12345<-" );

        // Отбой по максимальной указанной длине; вставка эллипов в месте отбоя
        assert( фмт( "->{.5}<-", "hello" ) == "->hello<-" );
        assert( фмт( "->{.4}<-", "hello" ) == "->hell...<-" );
        assert( фмт( "->{.-3}<-", "hello" ) == "->...llo<-" );

        // Определитель ширины указывает число мест десятков
        assert( фмт( "{0:f}", 1.23f ) == "1.23" );
        assert( фмт( "{0:f4}", 1.23456789L ) == "1.2346" );
        assert( фмт( "{0:e4}", 0.0001) == "1.0000e-04");

        assert( фмт( "{0:f}", 1.23f*1i ) == "1.23*1i");
        assert( фмт( "{0:f4}", 1.23456789L*1i ) == "1.2346*1i" );
        assert( фмт( "{0:e4}", 0.0001*1i) == "1.0000e-04*1i");

        assert( фмт( "{0:f}", 1.23f+1i ) == "1.23+1.00*1i" );
        assert( фмт( "{0:f4}", 1.23456789L+1i ) == "1.2346+1.0000*1i" );
        assert( фмт( "{0:e4}", 0.0001+1i) == "1.0000e-04+1.0000e+00*1i");
        assert( фмт( "{0:f}", 1.23f-1i ) == "1.23-1.00*1i" );
        assert( фмт( "{0:f4}", 1.23456789L-1i ) == "1.2346-1.0000*1i" );
        assert( фмт( "{0:e4}", 0.0001-1i) == "1.0000e-04-1.0000e+00*1i");

        // 'f.' & 'e.' формат обрезает нули у десятков с плавающей точкой
        assert( фмт( "{:f4.}", 1.230 ) == "1.23" );
        assert( фмт( "{:f6.}", 1.230 ) == "1.23" );
        assert( фмт( "{:f1.}", 1.230 ) == "1.2" );
        assert( фмт( "{:f.}", 1.233 ) == "1.23" );
        assert( фмт( "{:f.}", 1.237 ) == "1.24" );
        assert( фмт( "{:f.}", 1.000 ) == "1" );
        assert( фмт( "{:f2.}", 200.001 ) == "200");

        // Вывод массивов
        цел[] a = [ 51, 52, 53, 54, 55 ];
        assert( фмт( "{}", a ) == "[51, 52, 53, 54, 55]" );
        assert( фмт( "{:x}", a ) == "[33, 34, 35, 36, 37]" );
        assert( фмт( "{,-4}", a ) == "[51  , 52  , 53  , 54  , 55  ]" );
        assert( фмт( "{,4}", a ) == "[  51,   52,   53,   54,   55]" );
        цел[][] b = [ [ 51, 52 ], [ 53, 54, 55 ] ];
        assert( фмт( "{}", b ) == "[[51, 52], [53, 54, 55]]" );

        бкрат[3] c = [ cast(бкрат)51, 52, 53 ];
        assert( фмт( "{}", c ) == "[51, 52, 53]" );

        // Ассоциативный целочисленный массив
        бкрат[дол] d;
        d[234] = 2;
        d[345] = 3;
        assert( фмт( "{}", d ) == "{234 => 2, 345 => 3}" ||
        фмт( "{}", d ) == "{345 => 3, 234 => 2}");

        // Ассоциативный массив бул/ткст
        бул[ткст] e;
        e[ "ключ".dup ] = да;
        e[ "значение".dup ] = нет;
        assert( фмт( "{}", e ) == "{ключ => да, значение => нет}" ||
        фмт( "{}", e ) == "{значение => нет, ключ => да}");

        // Ассоциативный массив ткст/дво
        ткст[ дво ] f;
        f[ 1.0 ] = "один".dup;
        f[ 3.14 ] = "ПИ".dup;
        assert( фмт( "{}", f ) == "{1.00 => один, 3.14 => ПИ}" ||
        фмт( "{}", f ) == "{3.14 => ПИ, 1.00 => один}");
		
		assert( фмт( "{} {0} {} {}", 1, 3) == "1 1 3 {неверный индекс}" );скажинс(фмт( "{} {0} {} {}", 1, 3));
        assert( фмт( "{} {0} {} {:x}", 1, 3) == "1 1 3 {неверный индекс}" );скажинс(фмт( "{} {0} {} {:x}", 1, 3));
		скажинс("Да без проблем всё проходит....");
		пз;
    }