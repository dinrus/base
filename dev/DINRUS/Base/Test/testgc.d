import cidrus, gc, runtime, stdrus, win, thread;

pragma(lib,"dinrus.lib");


extern (C) цел sprintf(char* т, in char* format, ...);

бцел PERMUTE(бцел ключ)
{
    return ключ + 1;
}

проц заполни(ук p, бцел ключ, бцел размер)
{
    бцел и;
    байт *q = cast(байт *)p;

    for (и = 0; и < размер; и++)
    {
	ключ = PERMUTE(ключ);
	q[и] = cast(байт)ключ;
    }
}

проц проверь(ук p, бцел ключ, бцел размер)
{
    бцел и;
    байт *q = cast(байт *)p;

    for (и = 0; и < размер; и++)
    {
	ключ = PERMUTE(ключ);
	assert(q[и] == cast(байт)ключ);
    }
}

дол desregs()
{
    return strlen("foo");
}

/* ---------------------------- */

проц smoke()
{
    т_см _мсм;

    эхо("--------------------------smoke()\n");

    _мсм = new СМ;
	эхо("gc = %p\n", _мсм);
    delete _мсм;
	эхо("gc = %p\n", _мсм);
эхо("smoke.1\n");

    _мсм = new СМ;
	эхо("gc = %p\n", _мсм);
    //_мсм.иниц();
	_мсм.сканируйСтатДан( _мсм);
	нить_иниц();
    delete _мсм;
	if(_мсм is пусто) эхо("gc = %p\n", _мсм);
	 else скажинс("_мсм не обнаружен. По-видимому, удалён...");
эхо("smoke.2\n");

    _мсм = new СМ;
	эхо("gc = %p\n", _мсм);
	скажинс("Инициализация нового см");
    //_мсм.иниц();
	скажинс("Будут сканироваться статические данные");
	_мсм.сканируйСтатДан( _мсм);
	скажинс("Будет размещение с помощью празмести СМ");
    char *p = cast(char *)_мсм.празмести(10);
	скажинс("Оно уже выполнено");
    assert(p);
    копиртекс(p, "Hello!");
//    char *p2 = _мсм.strdup(p);
//    эхо("p2 = %x, '%s'\n", p2, p2);
//    цел результат = strcmp(p, p2);
//    assert(результат == 0);
//    _мсм.strdup(p);

    эхо("p  = %x\n", p);
    p = null;
    _мсм.собери();
    gc_printStats(_мсм);

    delete _мсм;
 return;
}

/* ---------------------------- */

проц finalizer(ук p, bool dummy)
{
}

проц smoke2()
{
    т_см _мсм;
    цел *p;
    цел и;

    const цел SMOKE2_SIZE = 100;
    цел *foo[SMOKE2_SIZE];

    эхо("--------------------------smoke2()\n");

    _мсм = new СМ;
	эхо("gc = %p\n", _мсм);
    //_мсм.иниц();
	_мсм.сканируйСтатДан( _мсм);

    for (и = 0; и < SMOKE2_SIZE; и++)
    {
	p = cast(цел *)_мсм.кразмести(и + 1, 500);
	p[0] = и * 3;
	foo[и] = p;
	//newFinalizer(cast(ук )p, &finalizer);
    }

    for (и = 0; и < SMOKE2_SIZE; и += 2)
    {
	p = foo[и];
	if (p[0] != и * 3)
	{
	    эхо("p = %x, и = %d, p[0] = %d\n", p, и, p[0]);
	    //к.stdio.fflush(stdout);
	}
	assert(p[0] == и * 3);
	_мсм.освободи(p);
    }

    p = null;
    foo[] = null;

    _мсм.собери();
    gc_printStats(_мсм);

    delete _мсм;
	 return;
}

/* ---------------------------- */

проц smoke3()
{
    т_см _мсм;
    цел *p;
    цел и;

    эхо("--------------------------smoke3()\n");

    _мсм = new СМ;
	эхо("gc = %p\n", _мсм);
  // _мсм.иниц();
	_мсм.сканируйСтатДан( _мсм);

//    for (и = 0; и < 1000000; и++)
    for (и = 0; и < 1000; и++)
    {
	бцел размер = случайно() % 2048;
	p = cast(цел *)_мсм.празмести(размер);
	устбуф(p, и, размер);

	размер = случайно() % 2048;
	p = cast(цел *)_мсм.перемести(p, размер);
	устбуф(p, и + 1, размер);
    }

    p = null;
    desregs();
    _мсм.собери();
    gc_printStats(_мсм);

    delete _мсм;
	 return;
}

/* ---------------------------- */

проц smoke4()
{
    т_см _мсм;
    цел *p;
    цел и;

    эхо("--------------------------smoke4()\n");

    _мсм = new СМ;
	эхо("gc = %p\n", _мсм);
   // _мсм.иниц();

    for (и = 0; и < 80000; и++)
    {
	бцел размер = и;
	p = cast(цел *)_мсм.празмести(размер);
	устбуф(p, и, размер);

	размер = случайно() % 2048;
	смПроверь(p);
	p = cast(цел *)_мсм.перемести(p, размер);
	устбуф(p, и + 1, размер);
    }

    p = null;
    desregs();
    _мсм.собери();
    gc_printStats(_мсм);

    delete _мсм;
	 return;
}

/* ---------------------------- */

проц smoke5(т_см _мсм)
{
    байт *p;
    цел и;
    цел j;
    const цел SMOKE5_SIZE = 1000;
    байт *массив[SMOKE5_SIZE];
    бцел смещение[SMOKE5_SIZE];

    эхо("--------------------------smoke5()\n");
    //скажифнс("_мсм = %p\n", _мсм);
    //скажифнс("_мсм = %p, gcx = %p, этот = %x\n", _мсм, _мсм.gcx, _мсм.gcx.этот);

    for (j = 0; j < 20; j++)
    {
	for (и = 0; и < 2000 /*4000*/; и++)
	{
	    бцел размер = (случайно() % 2048) + 1;
	    бцел индекс = случайно() % SMOKE5_SIZE;

	    //скажифнс("индекс = %d, размер = %d\n", индекс, размер);
	    p = массив[индекс] - смещение[индекс];
	    p = cast(байт *)_мсм.перемести(p, размер);
	    if (массив[индекс])
	    {	бцел т;

		//скажифнс("\tпроверь = %d\n", p[0]);
		т = смещение[индекс];
		if (размер < т)
		    т = размер;
		проверь(p, индекс, т);
	    }
	    массив[индекс] = p;
	    заполни(p, индекс, размер);
	    смещение[индекс] = случайно() % размер;
	    массив[индекс] += смещение[индекс];

	    //скажифнс("p[0] = %d\n", p[0]);
	}
	_мсм.собери();
    }

    p = null;
    массив[] = null;
    _мсм.собери();
    gc_printStats(_мсм);
	 return;
}

/* ---------------------------- */

проц тест1()
{
    скажи("---------------------тест1()\n");
    static char[] a;
    static бцел к = 200;
    while (к--){
	a ~= 'x';
	эхо(".");
	}
    //эхо("a = '%.*т'\n", a);
    скажинс("тест1() выполнен");
	 return;
}

/* ---------------------------- */

проц тест2()
{
    static ткст стр;
скажи("---------------------тест2()\n");
    for (цел и = 0; и < 100; и++){
	стр ~= "ABCDEFGHIJKLMNOPQRST";
	скажинс(стр);
	}
	скажинс("тест2() выполнен");
	 return;
}

/* ---------------------------- */

/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   http://www.bagley.org/~doug/shootout/

   converted to D by Dave Fladebo
   compile: dmd -O -inline -release hash.d
*/


проц тест3()
{
скажи("---------------------тест3()\n");
    цел n = 1000;

    сим[32]    стр;
    цел[ткст] X;//ошибка здесь!

    for(цел и = 1; и <= n; и++) {
        цел len = sprintf(стр.ptr,"%x",и);
        X[стр[0..len].dup] = и;
		эхо(".");
    }

    цел к;
    for(цел и = n; и > 0; и--) {
        цел len = sprintf(стр.ptr,"%d",и);
        if(стр[0..len] in X) к++;
эхо(".");		
    }

    эхо("%d\n", к);
	скажинс("тест3() выполнен");
	 return;
}

/* ---------------------------- */

class C
{
    цел i, j, k;
    реал l, m, n;
}

проц тест4()
{
скажи("---------------------тест4()\n");
    const цел обх = 1000;//1_000_000
    C[] к = new C[обх];
    цел и;	
    for(и = 0; и < обх; и++)
    {
	эхо(".");
        к[и] = new C;
        delete к[и];
		
    }
    эхо("%d\n", и);
	скажинс("тест4() выполнен");
	 return;
}


/* ---------------------------- */

/* The Computer Language Shootout Benchmarks
   http://shootout.alioth.debian.org/

   contributed by Dave Fladebo
   compile: dmd -O -inline -release binarytrees.d
*/


цел тест5()
{
скажи("---------------------тест5()\n");
    УзелДерева*   распрДерево, долговечнДерево, времДерево;
    цел         глуб, минГлуб, максГлуб, распрГлуб, N = 1;

    минГлуб = 4;
    максГлуб = (минГлуб + 2) > N ? минГлуб + 2 : N;
    распрГлуб = максГлуб + 1;

    распрДерево = УзелДерева.ПеревёрнутоеДерево(0, распрГлуб);
    скажинс(фм("распростёртое дерево глубиною %d\t провер: %d\n", распрГлуб, распрДерево.ПроверкаЭлта));
    //УзелДерева.УдалиДерево(распрДерево);

    долговечнДерево = УзелДерева.ПеревёрнутоеДерево(0, максГлуб);

    for(глуб = минГлуб; глуб <= максГлуб; глуб += 2)
    {
        цел провер, обходы = 1 << (максГлуб - глуб + минГлуб);

        for(цел и = 0; и < обходы; и++)
        {
            времДерево = УзелДерева.ПеревёрнутоеДерево(и, глуб);
            провер += времДерево.ПроверкаЭлта;
            //УзелДерева.УдалиДерево(времДерево);

            времДерево = УзелДерева.ПеревёрнутоеДерево(-и, глуб);
            провер += времДерево.ПроверкаЭлта;
            //УзелДерева.УдалиДерево(времДерево);

        }
	
        пишифнс(обходы * 2,"\t trees of depth ",глуб,"\t check: ",провер);
    }

    пишифнс("long lived tree of depth ",максГлуб,"\t check: ",долговечнДерево.ПроверкаЭлта);
	скажинс("тест5() выполнен");
    return 0;
}

struct УзелДерева
{
public:
    static УзелДерева* ПеревёрнутоеДерево(цел элт, цел глуб)
    {
        if(глуб > 0)
            return УзелДерева(элт
                           ,ПеревёрнутоеДерево(2 * элт - 1, глуб - 1)
                           ,ПеревёрнутоеДерево(2 * элт, глуб - 1));
        return УзелДерева(элт);
    }

    цел ПроверкаЭлта()
    {
        if(лево)
            return элт + лево.ПроверкаЭлта() - право.ПроверкаЭлта();
        return элт;
    }

    static проц УдалиДерево(УзелДерева* дерево)
    {
        if(дерево.лево)
        {
            УдалиДерево(дерево.лево);
            УдалиДерево(дерево.право);
        }

        delete дерево;
    }

private:
    УзелДерева*           лево, право;
    цел                 элт;

    static УзелДерева* opCall(цел элт, УзелДерева* лево = null, УзелДерева* право = null)
    {
        УзелДерева* t = new УзелДерева;
        t.лево = лево;
        t.право = право;
        t.элт = элт;
        return t;
    }

    //new(бцел разм)
    //{
    //    return std.к.stdlib.malloc(разм);
    //}

    //delete(проц* p)
    //{
    //    free(p);
    //}
}

/* ---------------------------- */

проц тест6()
{
    скажи("---------------------тест6()\n");

    т_см см;

    см = new СМ();
	эхо("gc = %p\n", см);
	//эхо("Begining to initialize см\n");
    //см.иниц();
	см.сканируйСтатДан(см);
	//нить_прикрепиЭту();
	//эхо("iNITIALIZATION SUCCESSFUL\n");
    auto p = см.празмести(4096);
	эхо("first assert %i\n", p);
	эхо("4096 = %f\n", см.ёмкость(p));
    assert(см.ёмкость(p) == 4096);
    устбуф(p, 3, 4096);

    auto q = см.перемести(p, 4096*4);
	эхо("second assert\n");
    assert(q == p);
	эхо("third assert\n");
	эхо("%f\n", см.ёмкость(q));
    //assert(см.ёмкость(p) == 4096*4);
    устбуф(p, 4, 4096*4);

    q = см.перемести(p, 4096*2);
	эхо("4th assert\n");
   // assert(q == p);
   эхо("%f\n", см.ёмкость(p));
	эхо("5th assert\n");
    //assert(см.ёмкость(p) == 4096*2);
    устбуф(p, 5, 4096*2);

    q = см.перемести(p, 4096*2 + 1000);
    //assert(q == p);
   // assert(см.ёмкость(p) == 4096*3);
    устбуф(p, 6, 4096*2 + 1000);

    q = см.перемести(p, 4096*4);
    //assert(q == p);
   // assert(см.ёмкость(p) == 4096*4);
    устбуф(p, 7, 4096*4);

    q = см.перемести(p, 0);
   // assert(q == null);
   // assert(см.ёмкость(p) == 0);

    см.собери();
    скажинс("тест6() выполнен");
				см.Дтор();
		cidrus.освободи(cast(ук )см);
	//смУдали(см);
	 return;
	
}

/* ---------------------------- */

проц тест7()
{
    скажи("---------------------тест7()\n");

    т_см см2;

    см2 = new СМ;
	эхо("gc2 = %p\n", см2);
    //см2.иниц();

    auto p = см2.празмести(4096);
    //assert(см2.ёмкость(p) == 4096);
    устбуф(p, 3, 4096);

    auto q = см2.расширь(p, 4096, 4096*2);
    assert(q == 4096*2 || q == 4096*3);

    auto т = см2.празмести(4096);
    q = см2.расширь(p, 4096, 4096);
    assert(q == 0);

    см2.собери();
    delete см2;
	скажи("тест7() выполнен\n");
	 return;
}

/* ---------------------------- */

цел main()
{

скажинс("НАЧАЛО ПРОВЕРКИ РАБОТЫ МОДУЛЯ СБОРЩИКА МУСОРА ДИНРУС\n");

	тест1();
    тест2();
    тест3();
    //тест4();
    тест5();
    тест6();
    тест7();   
    
   скажинс("Начало теста СМ smoke");

	//смСобери();
 т_см мсм;
    smoke();
    smoke2();
    smoke3();
    smoke4();
	smoke5(мсм = new СМ);
	
мсм = cast(т_см) дайУкНаСМ();
скажинс("Проверка работы реального СМ, приобретаемого по возвращённому ф-цией дайУкНаСм указателю");
эхо("gc = %p\n", мсм);
   // мсм.иниц();
    

  //  смУдали(мсм); В данном случае означало бы аборт для всей программы...
    
	
	скажинс("ПРОВЕРКА СБОРЩИКА МУСОРА ВЫПОЛНЕНА\n");
   пз;
	   return УДАЧНЫЙ_ВЫХОД;
	
}
