
module io.stream.Iterator;

private import io.stream.Buffered;

protected import io.device.Conduit : ФильтрВвода, ИБуферВвода, ИПотокВвода;

/*******************************************************************************

        Класс-основа для набора потоковых итераторов. Они оперируют
        над буферированным потоком ввода и и расчитаны на частичную
        обработку контента. То есть, потоковые итераторы приступают к
        работе в момент появления в буфере каких-либо данных. Сравните
        это поведение с обхочиками из text.Util, которые имеют дело
        с протяженностью массива.

        Поддерживается два типа обходчиков - исключительные (эксклюзивные) и
        включительные (инклюзивные). Первые являются более общим типом,
		в котором сема разграничивается элементами, считающимися инородными.
		Например, пробелами, запятыми и разграничителями концов строк.
		Инклюзивные семы противоположны - поиск ведётся в образцах,
		находящихся в тексте, которые являются частью самой семы;
		всё прочее считается инородным. На данный момент в io.stream входит
		только инклюзивное подмножество.

        Каждый образец выставляется клиенту как срез исходного контента,
        где этот срез транзитивен (transient). Если нужно удержать предоставленный
        контент, тогда его нужно соответствующе дублировать с помощью .dup. 

        Предполагается, что предоставляемый этим обходчикам контент полностью
        может быть только читаем (только чтение). Этого правила придерживаются
		все текущие токенайзеры (tokenizers, т.е. определители-детекторы
		сысловых символов (сем)), но пользователь может менять содержимое в_
		семантическом срезе. 
		
		Чтобы усилить желаемый аспект только чтения, в этот код пришлось быть
		ввести повторное копирование, либо же компилятор должен поддерживать
		массивы только для чтения (сейчас это уже есть в D2).

        Смотрите Разграничители, Строки, Образцы, Кавычки.

*******************************************************************************/

class Обходчик(T) : ФильтрВвода 
{
        private ИБуферВвода     исток;
        protected T[]           срез,
                                разделитель;

        /***********************************************************************

                Сканер образцов, реализуемый в подклассах.

        ***********************************************************************/

        abstract protected т_мера скан (проц[] данные);

        /***********************************************************************

                Инcтанциировать с буфером.

        ***********************************************************************/

         this (ИПотокВвода поток = пусто)
        {       
                super (поток);
                if (поток)
                    установи (поток);
        }

        /***********************************************************************

                Установить предоставленный поток в качестве истока сканирования.

        ***********************************************************************/

        Обходчик установи (ИПотокВвода поток)
        {
                assert (поток);
                исток = Бввод.создай (поток);
                super.исток = исток;
                return this;
        }

        /***********************************************************************

                Вернуть текущую сему как срез данного контента.

        ***********************************************************************/

        final T[] получи ()
        {
                return срез;
        }

        /**********************************************************************

                Итерирует по набору сем. Должен быть доступ к семам только
                для чтения, но язык D в данное время этого не поддерживает.

        **********************************************************************/

        цел opApply (цел delegate(ref T[]) дг)
        {
                бул ещё;
                цел  результат;

                do {
                   ещё = используй;
                   результат = дг (срез);
                   } while (ещё && !результат);
                return результат;
        }

        /**********************************************************************

                Итерирует по набору сем, выводя счёт сем, 
                начиная от нуля.

        **********************************************************************/

        цел opApply (цел delegate(ref цел, ref T[]) дг)
        {
                бул ещё;
                цел  результат,
                     семы;

                do {
                   ещё = используй;
                   результат = дг (семы, срез);
                   ++семы;
                   } while (ещё && !результат);
                return результат;
        }

        /**********************************************************************

                Итерирует по набору из сем и разграничителей, выводя 
                счёт сем, начиная от нуля.

        **********************************************************************/

        цел opApply (цел delegate(ref цел, ref T[], ref T[]) дг)
        {
                бул ещё;
                цел  результат,
                     семы;

                do {
                   разделитель = пусто;
                   ещё = используй;
                   результат = дг (семы, срез, разделитель);
                   ++семы;
                   } while (ещё && !результат);
                return результат;
        }

        /***********************************************************************

                Определить положение следующей семы. Возвращает эту сему,
				если она найдена, пусто в ином случае. Пусто указывает на
				условие конца потока. Перемещение по проводу осуществляется
				методом следщ():
                ---
                auto строки = new Строки!(сим) (new Файл("myfile"));
                while (строки.следщ)
                       Квывод (строки.получи).нс;
                ---

                В дополнение можно извлекать из провода одну строку:
                ---
                auto строка = (new Строки!(сим) (new Файл("myfile"))).следщ;
                ---

                Разница между следщ() и foreach() в том, что последнее
                обрабатывает все семы по одной, в то время как первое
                обрабатывает кусками:
                ---
                foreach (строка; new Строки!(сим) (new Файл("myfile")))
                         Квывод(строка).нс;
                ---
                
        ***********************************************************************/

        final T[] следщ ()
        {
                if (используй() || срез.length)
                    return срез;
                return пусто;
        }

        /***********************************************************************

                Установить контент текущего среза  в предоставленные				
                точки старта и конца.

        ***********************************************************************/

        protected final т_мера установи (T* контент, т_мера старт, т_мера конец)
        {
                срез = контент [старт .. конец];
                return конец;
        }

        /***********************************************************************

                Установить контент текущего среза  в предоставленные				
                точки старта и конца, а разграничитель - в сегмент между
               конец & следщ (включительно).

        ***********************************************************************/

        protected final т_мера установи (T* контент, т_мера старт, т_мера конец, т_мера следщ)
        {
                срез = контент [старт .. конец];
                разделитель = контент [конец .. следщ+1];
                return конец;
        }

        /***********************************************************************

                Вызывается, когда сканеру не удаётся найти совпадающий образец.
                Это может вызывать перезагрузку контента и его повторное сканирование.

        ***********************************************************************/

        protected final т_мера неНайдено()
        {
                return Кф;
        }

        /***********************************************************************

                Вызывается, когда сканер находит совпадающий образец. Предоставленное
                значение должно быть индексом последнего элемента совпадающего
                образца, который преобразуется обратно в индекс проц[].

        ***********************************************************************/

        protected final т_мера найдено (т_мера i)
        {
                return (i + 1) * T.sizeof;
        }

        /***********************************************************************

                Проверить, содержит ли набор символов отдельный экземпляр.

        ***********************************************************************/

        protected final бул есть (T[] установи, T match)
        {
                foreach (T c; установи)
                         if (match is c)
                             return да;
                return нет;
        }

        /***********************************************************************

                Потребить следующую сему и поместить её в 'срез'. Возвращает 
                да, когда потенциально имеются другие семы.

        ***********************************************************************/

        private бул используй ()
        {
                if (исток.следщ (&скан))
                    return да;

                // используем завершающую сему
                исток.читатель ((void[] масс) 
                              { 
                              срез = (cast(T*) масс.ptr) [0 .. масс.length/T.sizeof];
                              return cast(т_мера)масс.length; 
                              });
                return нет;
        }
}


