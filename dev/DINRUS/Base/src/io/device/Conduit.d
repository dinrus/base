module io.device.Conduit;
import thread, exception, tpl.stream;
public  import io.model;

/+
///////////////////////////////////////////////////////////
class ПотокВВ : ИПотокВВ 
{

   private ШПоток п;
   
        const Кф = -1;  


        enum Якорь {
                    Нач   = 0,
                    Тек = 1,
                    Кон    = 2,
                    };

        дол сместись (дол смещение, Якорь якорь = Якорь.Нач)
		{
		  return п.сместись(смещение, cast(ППозКурсора) якорь);		
		}
		
        Провод провод () {return cast(Провод)  this;}
		
        ПотокВВ слей () 
		{
		this.п.слей();
		return this;
		}    
		
        проц закрой (){}     

        interface Переключатель {}
}
///////////////////////////////////////////////////

class ПотокВвода : ПотокВВ, ИПотокВвода
{
		private ШПоток п;

    т_мера читай (проц[] приём)
		{
		 return п.читай(cast(ббайт[]) приём);
		}	
		
    static  проц[] загрузи (ПотокВвода ист, т_мера макс=-1)
    {
        проц[]  приёмн;
        т_мера  i,
        длин,
        чанк;

        if (макс != -1)
            чанк = макс;
        else
            чанк = ист.провод.размерБуфера;

        while (длин < макс)
        {
            if (приёмн.length - длин is 0)
                приёмн.length = длин + чанк;

            if ((i = ист.читай (приёмн[длин .. $])) is Кф)
                break;
            длин += i;
        }
        return приёмн [0 .. длин];
    }

    проц[] загрузи (т_мера макс = -1)
      {
        return загрузи (this, макс);
      }
		
        ПотокВвода ввод () { return this; }                
}
////////////////////////////////////////////////////////////
class ПотокВывода : ПотокВВ, ИПотокВывода
{
		private ШПоток п;
		
        т_мера пиши (проц[] ист)
		{
		return п.пиши(cast(ббайт[]) ист);
		}
		
    ПотокВывода копируй(ПотокВвода ист, т_мера макс = -1)
    {
        перемести (ист, this, макс);
        return this;
    }
	
	
	static т_мера перемести (ПотокВвода ист, ПотокВывода приёмн, т_мера макс=-1)
    {
        байт[8192] врем;
        т_мера     готово;

        while (макс)
        {
            auto длин = макс;
            if (длин > врем.length)
                длин = врем.length;

            if ((длин = ист.читай(врем[0 .. длин])) is Кф)
                макс = 0;
            else
            {
                макс -= длин;
                готово += длин;
                auto p = врем.ptr;
                for (auto j=0; длин > 0; длин -= j, p += j)
                    if ((j = приёмн.пиши (p[0 .. длин])) is Кф)
                        return Кф;
            }
        }

        return готово;
    }
       


	   ПотокВывода вывод ()   {     return this;   }              
}

+/
///////////////////////////////////////////////////////////////
 private alias tpl.stream.ТПотокМассив!(проц[]) ШПоток;
 
export class Провод : ИПровод
{
    protected Фибра.Планировщик планировщик;            // опциональный планировщик
    private   бцел  продолжительность = -1;        // таймаут	планировки
	private  ШПоток буф;
	т_мера буфразм = 8192;


export:

    this()
    {
        auto f = Фибра.дайЭту;
        if (f)
            планировщик = f.событие.планировщик;		
    }


    ~this ()
    {
        открепи;
    }
	
	проц устПланировщик(Фибра.Планировщик п){	this.планировщик = п;}

    Фибра.Планировщик дайПланировщик()
    {
        return планировщик;
    }

////////////////////////////////////////////////////////////////////////////////

      override ткст вТкст() {
       return буф.вТкст();
      }
	
	//Ранее была абстрактной
     т_мера размерБуфера () {return буфразм;}
	
	//Выполняет функцию из класса Поток
     override т_мера читай (проц[] ист)
	 {
	 this.буфразм = ист.length;
	// this.буф = new ТПотокМассив (ист);
	 return буф.читай(cast(ббайт[]) ист);
	 }
	 
	 //Выполняет функцию из класса Поток
     override т_мера пиши (проц [] приём)
	 {
	  //this.буф = new ТПотокМассив (приём);
	 return буф.пиши(cast(ббайт[]) приём);
	 }
	
	//На данный момент функция ничего не выполняет,
	//но уже не является абстрактной.
     проц открепи () {}
//////////////////////////////////////////////////////////////////////////
    final проц таймаут (бцел миллисек)
    {
        продолжительность = миллисек;
    }

    final бцел таймаут ()
    {
        return продолжительность;
    }

    бул жив_ли ()
    {
        return да;
    }


    final ИПровод провод ()
    {
        return this;
    }


    ИПотокВВ слей ()
    {
        return this;
    }

    проц закрой ()
    {
        this.открепи;
    }

    final проц ошибка (ткст сооб)
    {
        throw new ВВИскл (сооб);
    }


    final ИПотокВвода ввод ()
    {
        return this;
    }


    final ИПотокВывода вывод ()
    {
        return this;
    }


    final Провод помести (проц[] ист)
    {
        помести (ист, this);
        return this;
    }

    final Провод получи (проц[] приёмн)
    {
        получи (приёмн, this);
        return this;
    }


    final Провод отмотай ()
    {
        сместись (0);
        return this;
    }

    ИПотокВывода копируй (ИПотокВвода ист, т_мера макс = -1)
    {
        перемести (ист, this, макс);
        return this;
    }

    дол сместись (дол смещение, Якорь якорь = Якорь.Нач)
    {
        ошибка (this.вТкст ~ " не поддерживается запрос перехода");
        return 0;
    }

    ткст текст(T=сим) (т_мера макс = -1)
    {
        return cast(T[]) загрузи (макс);
    }


    static  проц[] загрузи (ИПотокВвода ист, т_мера макс=-1)
    {
        проц[]  приёмн;
        т_мера  i,
        длин,
        чанк;

        if (макс != -1)
            чанк = макс;
        else
            чанк = ист.провод.размерБуфера;

        while (длин < макс)
        {
            if (приёмн.length - длин is 0)
                приёмн.length = длин + чанк;

            if ((i = ист.читай (приёмн[длин .. $])) is Кф)
                break;
            длин += i;
        }
        return приёмн [0 .. длин];
    }

    проц[] загрузи (т_мера макс = -1)
    {
        return загрузи (this, макс);
    }

    static  проц помести (проц[] ист, ИПотокВывода вывод)
    {
        while (ист.length)
        {
            auto i = вывод.пиши (ист);
            if (i is Кф)
                вывод.провод.ошибка ("Провод.помести :: конец потока достигнут при записи");
            ист = ист [i..$];
        }
    }


    static проц получи (проц[] приёмн, ИПотокВвода ввод)
    {
        while (приёмн.length)
        {
            auto i = ввод.читай (приёмн);
            if (i is Кф)
                ввод.провод.ошибка ("Провод.получи :: конец потока достигнут при чтении");
            приёмн = приёмн [i..$];
        }
    }


    static т_мера перемести (ИПотокВвода ист, ИПотокВывода приёмн, т_мера макс=-1)
    {
        байт[8192] врем;
        т_мера     готово;

        while (макс)
        {
            auto длин = макс;
            if (длин > врем.length)
                длин = врем.length;

            if ((длин = ист.читай(врем[0 .. длин])) is Кф)
                макс = 0;
            else
            {
                макс -= длин;
                готово += длин;
                auto p = врем.ptr;
                for (auto j=0; длин > 0; длин -= j, p += j)
                    if ((j = приёмн.пиши (p[0 .. длин])) is Кф)
                        return Кф;
            }
        }

        return готово;
    }
}


export class ФильтрВвода : ИПотокВвода
{

 protected ИПотокВвода исток;
 
 
    export this (ИПотокВвода исток)
    {
        this.исток = исток;
    }

    export ИПровод провод ()
    {	
        return cast(ИПровод) this.исток;
    }

    export т_мера читай (проц[] приёмн)
    {
        return this.исток.читай (приёмн);
    }

    export проц[] загрузи (т_мера макс = -1)
    {
        return Провод.загрузи (this, макс);
    }

    export ИПотокВВ слей ()
    {
        исток.слей;
        return this;
    }

    export дол сместись (дол смещение, Якорь якорь = Якорь.Нач)
    {
        return исток.сместись (смещение, якорь);
    }


    export ИПотокВвода ввод ()
    {
        return this.исток;
    }
	
	export проц ввод(ИПотокВвода поток)
	{
	 this.исток = поток;
	}

    export проц закрой ()
    {
        this.исток.закрой;
    }
}

export class ФильтрВывода : ИПотокВывода
{
    protected ИПотокВывода сток;
	 

    export this (ИПотокВывода сток)
    {
        this.сток = сток;

    }

    export ИПровод провод ()
    {	
        return cast(ИПровод) this.сток;
    }

    export т_мера пиши (проц[] ист)
    {
        return this.сток.пиши (ист);
    }

    export ИПотокВывода копируй (ИПотокВвода ист, т_мера макс = -1)
    {
        Провод.перемести (ист, this, макс);
        return this;
    }

    export ИПотокВВ слей ()
    {
        this.сток.слей;
        return this;
    }

    export дол сместись (дол смещение, Якорь якорь = Якорь.Нач)
    {
        return this.сток.сместись (смещение, якорь);
    }

    export ИПотокВывода вывод ()
    {
        return this.сток;
    }
	
	export проц вывод(ИПотокВывода поток)
	{
	 this.сток = поток;
	}
	
    export проц закрой ()
    {
        сток.закрой;
    }
}
