module io.Path;

private import  sys.common;
public  import  time.Time : Время, ИнтервалВремени;
private import  io.model : ФайлКонст, ИнфОФайле;
public  import  exception : ВВИскл, ИсклНелегальногоАргумента, СисОш;
private import cidrus : memmove;

enum {
	GetFileInfoLevelStandard,
	GetFileInfoLevelMax
}

/*******************************************************************************

        Различные импорты

*******************************************************************************/

version (Win32)
        {
		
        version (Win32SansUnicode)
                {
                private extern (C) цел strlen (сим *s);
                private alias ПОИСК_ДАННЫХ_А ПоискДанных;
                }
             else
                {
                private extern (C) цел wcslen (шим *s);
                private alias ПОИСК_ДАННЫХ ПоискДанных;
                }
        }

version (Posix)
        {
        private import rt.core.stdc.stdio;
        private import cidrus;
        private import rt.core.stdc.posix.utime;
        private import rt.core.stdc.posix.dirent;
        }


/*******************************************************************************

        Оборачивает специфичные вызовы O/S в Динрус API. 

*******************************************************************************/

export struct ФС
{
        /***********************************************************************

                Информация о штампе времени. 

        ***********************************************************************/

       export struct Штампы
        {
                Время    создан,        /// время создания
                        использовался,       /// последнее время использования
                        изменён;       /// последнее время изменения
        }

        /***********************************************************************

                Некоторые продстройки для импорта листинга папки

        ***********************************************************************/

       export struct Листинг
        {
                ткст папка;
                бул   всеФайлы;
                
               export цел opApply (цел delegate(ref ИнфОФайле) дг)
                {
                        сим[256] врем =void;
                        auto путь = ткт0 (папка, врем);

                        // sanity check on Win32 ...
                        version (Win32)
                                {
                                бул kosher(){foreach (c; путь) if (c is '\\') return нет; return да;};
                                assert (kosher, "попытка использовать нестандартный '\\' в пути при листинге папки");
                                }

                        return список (путь, дг, всеФайлы);
                }
        }

        /***********************************************************************

                Выводит исключение, используя последнюю известную ошибку

        ***********************************************************************/

        export static проц исключение (ткст имяф)
        {
                исключение (имяф[0..$-1] ~ ": ", СисОш.последнСооб);
        }

        /***********************************************************************

                Вывести ВВИскл 

        ***********************************************************************/

        export static проц исключение (ткст префикс, ткст ошибка)
        {
                throw new ВВИскл (префикс ~ ошибка);
        }

        /***********************************************************************

                Возвратить отлаженный путь, чтобы у непустых экземпляров всегда
                в завершении стоял разделитель.

                Примечание: размещает память, где путь ещё не имеет терминации

        ***********************************************************************/

        export static ткст псеп_в_конце (ткст путь, сим c = '/')
        {
                if (путь.length && путь[$-1] != c)
                    путь = путь ~ c;
                return путь;
        }

        /***********************************************************************

                Возвратить отлаженный путь, чтобы у непустых экземпляров всегда
                в завершении стоял разделитель.

        ***********************************************************************/

        export static ткст очищенный (ткст путь, сим c = '/')
        {
                if (путь.length && путь[$-1] is c)
                    путь = путь [0 .. $-1];
                return путь;
        }

        /***********************************************************************

                Объединить вместе набор определений пути. Между каждым из сегментов
                вставляется разделитель пути.

                Примечание: размещает память

        ***********************************************************************/

       export  static ткст объедини (ткст[] пути...)
        {
                ткст результат;

                foreach (путь; пути)
                         результат ~= псеп_в_конце (путь);

                return результат.length ? результат [0 .. $-1] : "";
        }

        /***********************************************************************

                Добавить завершающее пусто к ткст

                Примечание: размещает память, если приёмн слишком мал

        ***********************************************************************/

       export  static ткст ткт0 (ткст ист, ткст приёмн)
        {
                auto i = ист.length + 1;
                if (приёмн.length < i)
                    приёмн.length = i;
                приёмн [0 .. i-1] = ист;
                приёмн[i-1] = 0;
                return приёмн [0 .. i];
        }

        /***********************************************************************

                Win32 API код

        ***********************************************************************/

        version (Win32)
        {
                /***************************************************************

                        Вернуть шим[] экземпляр этого пути

                ***************************************************************/

                private static шим[] вТкст16 (шим[] врем, ткст путь)
                {
                        auto i = МультиБайтВШирСим (ПКодСтр.УТФ8, 0,
                                                      cast(PCHAR)путь.ptr, путь.length,
                                                      врем.ptr, врем.length);
                        return врем [0..i];
                }

                /***************************************************************

                        Вернуть текстовый экземпляр данного пути

                ***************************************************************/

                private static ткст вТкст (ткст врем, шим[] путь)
                {
                        auto i = ШирСимВМультиБайт(ПКодСтр.УТФ8, cast(ПШирСим) 0, путь.ptr, путь.length,
                                                      cast(PCHAR)врем.ptr, врем.length, пусто, 0);
                        return врем [0..i];
                }

                /***************************************************************

                        Получить инфу об этом пути.

                ***************************************************************/

                private static бул инфОФайле (ткст имя, ref ФАЙЛ_АТР_ДАН_ВИН32 инфо)
                {
                        version (Win32SansUnicode)
                                {
                                if (! ДайАтрибутыФайлаДопА (имя, GetFileInfoLevelStandard, &инфо))
                                      return нет;
                                }
                             else
                                {
                                 if (! sys.WinFuncs.ДайАтрибутыФайлаДоп (имя, GetFileInfoLevelStandard, &инфо))
                                      return нет;
                                }

                        return да;
                }

                /***************************************************************

                        Получить инфу о данном пути.

                ***************************************************************/

                private static бцел дайИнф (ткст имя, ref ФАЙЛ_АТР_ДАН_ВИН32 инфо)
                {
                        if (! инфОФайле (имя, инфо))
                              исключение (имя);
                        return инфо.файлАтры;
                }

                /***************************************************************

                        Получить флаги для этого пути.

                ***************************************************************/

                private static бцел дайФлаги (ткст имя)
                {
                        ФАЙЛ_АТР_ДАН_ВИН32 инфо =void;

                        return дайИнф (имя, инфо);
                }

                /***************************************************************

                        Возвращает, существует ли файл или путь.

                ***************************************************************/

                export static бул есть_ли (ткст имя)
                {
                        ФАЙЛ_АТР_ДАН_ВИН32 инфо =void;

                        return инфОФайле (имя, инфо);
                }

                /***************************************************************

                        Возвращает длину файла(в байтах).

                ***************************************************************/

                export static бдол размерФайла (ткст имя)
                {
                        ФАЙЛ_АТР_ДАН_ВИН32 инфо =void;

                        дайИнф (имя, инфо);
                        return (cast(бдол) инфо.размФайлаМакс << 32) +
                                            инфо.размФайлаМин;
                }

                /***************************************************************

                        Этот файл записываемый ли?

                ***************************************************************/

                export static бул записываем_ли (ткст имя)
                {
                        return (дайФлаги(имя) & ПФайл.ТолькоЧтение) is 0;
                }

                /***************************************************************

                        Является ли этот файл на самом деле папка/дир?

                ***************************************************************/

                export static бул папка_ли (ткст имя)
                {
                        return (дайФлаги(имя) & ПФайл.Папка) != 0;
                }

                /***************************************************************

                        Этот файл нормальный ли?

                ***************************************************************/

                export static бул файл_ли (ткст имя)
                {
                        return (дайФлаги(имя) & ПФайл.Папка) == 0;
                }

                /***************************************************************

                        Возвращает инфу о штампе времени.
                        Штампы времени возвращаются в формате, диктуемом 
                        файловой системой. Например, NTFS сохраняет UTC время, 
                        а штампы времени FAT  основаны на локальном времени.

                ***************************************************************/

                export static Штампы штампыВремени (ткст имя)
                {
                        static Время преобразуй (ФВРЕМЯ время)
                        {
                                return Время (ИнтервалВремени.Эпоха1601 + *cast(дол*) &время);
                        }

                        ФАЙЛ_АТР_ДАН_ВИН32 инфо =void;
                        Штампы                    время =void;

                        дайИнф (имя, инфо);
                        время.изменён = преобразуй (инфо.времяПоследнЗаписи);
                        время.использовался = преобразуй (инфо.времяПоследнДоступа);
                        время.создан  = преобразуй (инфо.времяСозд);
                        return время;
                }

                /***************************************************************

                        Установить для указанного файла штамп времени,
                        как он использовался, когда был изменён.

                ***************************************************************/

                export static проц штампыВремени (ткст имя, Время использовался, Время изменён)
                {
                        проц установи (ук h)
                        {
                                ФВРЕМЯ m1, a1;
                                auto m = изменён - Время.эпоха1601;
                                auto a = использовался - Время.эпоха1601;
                                *cast(дол*) &a1.датаВремяМладш = m.тики;
                                *cast(дол*) &m1.датаВремяМладш = m.тики;
                                if (УстановиФВремя (h, пусто, &a1, &m1) is 0)
                                    исключение (имя);
                        }
                                                
                        создайФайл (имя, &установи);
                }

                /***************************************************************

                        Перенести содержимое другого файла в этот. 
                        При несработке выводит ВВИскл.

                ***************************************************************/

                export static проц копируй (ткст ист, ткст приёмн)
                {
                        version (Win32SansUnicode)
                                {
                                if (! КопируйФайлА (ист, приёмн, нет))
                                      исключение (ист);
                                }
                             else
                                {

                                if (! КопируйФайл ( ист, приёмн, нет))
                                      исключение (ист);
                                }
                }

                /***************************************************************

                        Удалить файл/папку из файловой системы.
                        Возвращает да при успехе, нет в противном случае.

                ***************************************************************/

                export static бул удали (ткст имя)
                {
                        if (папка_ли(имя))
                           {
                           version (Win32SansUnicode)
                                    return УдалиПапкуА (имя) != 0;
                                else
                                   {
                                   return УдалиПапку (имя) != 0;
                                   }
                           }
                        else
                           version (Win32SansUnicode)
                                    return УдалиФайлА (имя) != 0;
                                else
                                   {
                                   return УдалиФайл (имя) != 0;
                                   }
                }

                /***************************************************************

                       Изменить имя или положение файла/папки.

                ***************************************************************/

                export static проц переименуй (ткст ист, ткст приёмн)
                {
                        const цел Typical = sys.WinConsts.ФПЕРЕМЕСТ_ЗАМЕНИ_СУЩ +
                                            sys.WinConsts.ФПЕРЕМЕСТ_КОПИР_РАЗРЕШЕНО +
                                            sys.WinConsts.ФПЕРЕМЕСТ_ПЕРЕПИШИ;

                        цел результат;
                        version (Win32SansUnicode)
                                 результат = ПереместиФайлДопА (ист, приёмн, Typical);
                             else
                                {
                                результат = ПереместиФайлДоп ( ист, приёмн, Typical);
                                }

                        if (! результат)
                              исключение (ист);
                }

                /***************************************************************

                        Создать новый файл.

                ***************************************************************/

                export static проц создайФайл (ткст имя)
                {
                        создайФайл (имя, пусто);
                }

                /***************************************************************

                        Создать новую папку.

                ***************************************************************/

                export static проц создайПапку (ткст имя)
                {
                        version (Win32SansUnicode)
                                {
                                if (! СоздайПапкуА (имя, пусто))
                                      исключение (имя);
                                }
                             else
                                {
                                if (! СоздайПапку ( имя, пусто))
                                      исключение (имя);
                                }
                }

                /***************************************************************

                        Даёт список набора файлов из заданной папки.
                        Каждый путь и имяф передаётся в предоставленный
                        делегат, с префиксом пути и тем, является ли
                        эта Запись папкой.

                        Примечание: размещает небольшой буфер памяти.

                ***************************************************************/

                export static цел список (ткст папка, цел delegate(ref ИнфОФайле) дг, бул все=нет)
                {
                        HANDLE                  h;
                        цел                     возвр;
                        ткст                  префикс;
                        сим[МАКС_ПУТЬ+1]        врем =void;
                        ПоискДанных               инфофайле =void;
                        
                        version (Win32SansUnicode)
                                 alias сим T;
                              else
                                 alias шим T;

                        цел следщ()
                        {
                                version (Win32SansUnicode)
                                         return НайдиСледующийФайлА(h, &инфофайле);
                                   else
                                      return НайдиСледующийФайл (h, &инфофайле);
                        }

                        static T[] псеп_в_конце (T[] s, T[] расш)
                        {
                                if (s.length && s[$-1] is '/')
                                    return s ~ расш;
                                return s ~ "/" ~ расш;
                        }

                        version (Win32SansUnicode)
                                 h = НайдиПервыйФайлА (cast(ткст) псеп_в_конце(папка[0..$-1], "*"), &инфофайле);
                             else
                                {
                                h = НайдиПервыйФайл (папка, &инфофайле);
                                }

                        if (h is НЕВЕРНХЭНДЛ)
                            return возвр; 

                        scope (exit)
                               НайдиЗакрой (h);

                        префикс = ФС.псеп_в_конце (папка[0..$-1]);
                        do {
                           version (Win32SansUnicode)
                                   {
                                   auto длин = strlen (инфофайле.имяФайла.ptr);
                                   auto ткт = инфофайле.имяФайла.ptr [0 .. длин];
                                   }
                                else
                                   {
                                   auto длин = wcslen (инфофайле.имяФайла.ptr);
                                   auto ткт = вТкст (врем, инфофайле.имяФайла [0 .. длин]);
                                   }

                           // пропусти скрытый/system файлы
                           if (все || (инфофайле.атрибутыФайла & (ПФайл.Системный | ПФайл.Скрытый)) is 0)
                              {
                              ИнфОФайле инфо =void;
                              инфо.имя   = ткт;
                              инфо.путь   = префикс;
                              инфо.байты  = (cast(бдол) инфофайле.размерФайлаВ << 32) + инфофайле.размерФайлаН;
                              инфо.папка = (инфофайле.атрибутыФайла & ПФайл.Папка) != 0;
                              инфо.скрытый = (инфофайле.атрибутыФайла & ПФайл.Скрытый) != 0;
                              инфо.системный = (инфофайле.атрибутыФайла & ПФайл.Системный) != 0;

                              // пропусти "..." names
                              if (ткт.length > 3 || ткт != "..."[0 .. ткт.length])
                                  if ((возвр = дг(инфо)) != 0)
                                       break;
                              }
                           } while (следщ);

                        return возвр;
                }

                /***************************************************************

                        Создать новый файл.

                ***************************************************************/

                private static проц создайФайл (ткст имя, проц delegate(ук) дг)
                {
                        ук h;

                        auto флаги = дг.ptr ? ПРежСоздФайла.ОткрытьСущ : ПРежСоздФайла.СоздатьВсегда;
                        version (Win32SansUnicode)
                                 h = СоздайФайлА (имя, ППраваДоступа.ГенернаяЗапись,
                                                  cast(ПСовмИспФайла) 0, пусто, флаги, ПФайл.Нормальный, 
                                                  cast(ук) 0);
                             else
                                {
                                 h = СоздайФайл (имя, ППраваДоступа.ГенернаяЗапись,
                                                 cast(ПСовмИспФайла) 0, пусто, флаги, ПФайл.Нормальный, 
                                                 cast(ук) 0);
                                }

                        if (h is НЕВЕРНХЭНДЛ)
                            исключение (имя);

                        if (дг.ptr)
                            дг(h);

                        if (! ЗакройДескр (h))
                              исключение (имя);
                }
        }

        /***********************************************************************

                Posix-specific код

        ***********************************************************************/

        version (Posix)
        {
                /***************************************************************

                        Get инфо about this путь

                ***************************************************************/

                private static бцел дайИнф (ткст имя, ref stat_t статс)
                {
                        if (posix.stat (имя.ptr, &статс))
                            исключение (имя);

                        return статс.st_mode;
                }

                /***************************************************************

                        Return whether the файл or путь есть_ли

                ***************************************************************/

                export static бул есть_ли (ткст имя)
                {
                        stat_t статс =void;
                        return posix.stat (имя.ptr, &статс) is 0;
                }

                /***************************************************************

                        Возвращает файл length (в байтах)

                ***************************************************************/

               export static бдол размерФайла (ткст имя)
                {
                        stat_t статс =void;

                        дайИнф (имя, статс);
                        return cast(бдол) статс.st_size;
                }

                /***************************************************************

                        Is this файл записываемый?

                ***************************************************************/

               export  static бул записываем_ли (ткст имя)
                {
                        stat_t статс =void;

                        return (дайИнф(имя, статс) & O_RDONLY) is 0;
                }

                /***************************************************************

                        Is this файл actually a папка/дир?

                ***************************************************************/

                export static бул папка_ли (ткст имя)
                {
                        stat_t статс =void;

                        return (дайИнф(имя, статс) & S_IFMT) is S_IFDIR;
                }

                /***************************************************************

                        Is this a нормаль файл?

                ***************************************************************/

               export static бул файл_ли (ткст имя)
                {
                        stat_t статс =void;

                        return (дайИнф(имя, статс) & S_IFMT) is S_IFREG;
                }

                /***************************************************************

                        Return timestamp information

                        Timestamps are returns in a форматируй dictated by the 
                        файл-system. For example NTFS keeps UTC время, 
                        while FAT timestamps are based on the local время

                ***************************************************************/

                export static Штампы штампыВремени (ткст имя)
                {
                        static Время преобразуй (typeof(stat_t.st_mtime) секунды)
                        {
                                return Время.epoch1970 +
                                       ИнтервалВремени.изСек(секунды);
                        }

                        stat_t статс =void;
                        Штампы время  =void;

                        дайИнф (имя, статс);

                        время.изменён = преобразуй (статс.st_mtime);
                        время.использовался = преобразуй (статс.st_atime);
                        время.создан  = преобразуй (статс.st_ctime);
                        return время;
                }

                /***************************************************************

                        Устанавливает использовался and изменён timestamps of the
                        specified файл

                ***************************************************************/

                export static проц штампыВремени (ткст имя, Время использовался, Время изменён)
                {
                        utimbuf время =void;
                        время.actime = (использовался - Время.epoch1970).сек;
                        время.modtime = (изменён - Время.epoch1970).сек;
                        if (utime (имя.ptr, &время) is -1)
                            исключение (имя);
                }

                /***********************************************************************

                        Transfer the контент of другой файл в_ this one. Возвращает
                        reference в_ this class on success, либо throws an ВВИскл
                        upon failure.

                        Note: allocates a память буфер

                ***********************************************************************/

                export static проц копируй (ткст исток, ткст приёмник)
                {
                        auto ист = posix.открой (исток.ptr, O_RDONLY, 0640);
                        scope (exit)
                               if (ист != -1)
                                   posix.закрой (ист);

                        auto приёмн = posix.открой (приёмник.ptr, O_CREAT | O_RDWR, 0660);
                        scope (exit)
                               if (приёмн != -1)
                                   posix.закрой (приёмн);

                        if (ист is -1 || приёмн is -1)
                            исключение (исток);

                        // копируй контент
                        ббайт[] буф = new ббайт [16 * 1024];
                        цел читай = posix.читай (ист, буф.ptr, буф.length);
                        while (читай > 0)
                              {
                              auto p = буф.ptr;
                              do {
                                 цел записано = posix.пиши (приёмн, p, читай);
                                 p += записано;
                                 читай -= записано;
                                 if (записано is -1)
                                     исключение (приёмник);
                                 } while (читай > 0);
                              читай = posix.читай (ист, буф.ptr, буф.length);
                              }
                        if (читай is -1)
                            исключение (исток);

                        // копируй timestamps
                        stat_t статс;
                        if (posix.stat (исток.ptr, &статс))
                            исключение (исток);

                        utimbuf utim;
                        utim.actime = статс.st_atime;
                        utim.modtime = статс.st_mtime;
                        if (utime (приёмник.ptr, &utim) is -1)
                            исключение (приёмник);
                }

                /***************************************************************

                        Удали the файл/дир из_ the файл-system. 
                        Возвращает да on success - нет иначе.

                ***************************************************************/

                export static бул удали (ткст имя)
                {
                        return rt.core.stdc.stdio.удали(имя.ptr) != -1;
                }

                /***************************************************************

                       change the имя or location of a файл/дир

                ***************************************************************/

                export static проц переименуй (ткст ист, ткст приёмн)
                {
                        if (rt.core.stdc.stdio.переименуй (ист.ptr, приёмн.ptr) is -1)
                            исключение (ист);
                }

                /***************************************************************

                        Create a new файл

                ***************************************************************/

                export static проц создайФайл (ткст имя)
                {
                        цел fd;

                        fd = posix.открой (имя.ptr, O_CREAT | O_WRONLY | O_TRUNC, 0660);
                        if (fd is -1)
                            исключение (имя);

                        if (posix.закрой(fd) is -1)
                            исключение (имя);
                }

                /***************************************************************

                        Create a new дир

                ***************************************************************/

                export static проц создайПапку (ткст имя)
                {
                        if (posix.mkdir (имя.ptr, 0777))
                            исключение (имя);
                }

                /***************************************************************

                        List the установи of filenames within this папка.

                        Each путь and имяф is passed в_ the предоставленный
                        delegate, along with the путь префикс and whether
                        the Запись is a папка or not.

                        Note: allocates and reuses a small память буфер

                ***************************************************************/

                export static цел список (ткст папка, цел delegate(ref ИнфОФайле) дг, бул все=нет)
                {
                        цел             возвр;
                        Пап*            пап;
                        dirent          Запись;
                        dirent*         pentry;
                        stat_t          sbuf;
                        ткст          префикс;
                        ткст          sfnbuf;

                        пап = rt.core.stdc.posix.dirent.opendir (папка.ptr);
                        if (! пап)
                              return возвр;

                        scope (exit)
                               rt.core.stdc.posix.dirent.closedir (пап);

                        // ensure a trailing '/' is present
                        префикс = ФС.псеп_в_конце (папка[0..$-1]);

                        // prepare our имяф буфер
                        sfnbuf = префикс.dup;
                        
                        while (да)
                              {
                              // pentry is пусто at конец of listing, либо on an ошибка 
                              reдобавьir_r (пап, &Запись, &pentry);
                              if (pentry is пусто)
                                  break;

                              auto длин = cidrus.strlen (Запись.d_name.ptr);
                              auto ткт = Запись.d_name.ptr [0 .. длин];
                              ++длин;  // include the пусто

                              // resize the буфер as necessary ...
                              if (sfnbuf.length < префикс.length + длин)
                                  sfnbuf.length = префикс.length + длин;

                              sfnbuf [префикс.length .. префикс.length + длин]
                                      = Запись.d_name.ptr [0 .. длин];

                              // пропусти "..." names
                              if (ткт.length > 3 || ткт != "..."[0 .. ткт.length])
                                 {
                                 ИнфОФайле инфо =void;
                                 инфо.байты  = 0;
                                 инфо.имя   = ткт;
                                 инфо.путь   = префикс;
                                 инфо.скрытый = ткт[0] is '.';
                                 инфо.папка = инфо.системный = нет;
                                 
                                 if (! stat (sfnbuf.ptr, &sbuf))
                                    {
                                    инфо.папка = (sbuf.st_mode & S_IFDIR) != 0;
                                    if (инфо.папка is нет)
                                        if ((sbuf.st_mode & S_IFREG) is 0)
                                             инфо.системный = да;
                                        else
                                           инфо.байты = cast(бдол) sbuf.st_size;
                                    }
                                 if (все || (инфо.скрытый | инфо.системный) is нет)
                                     if ((возвр = дг(инфо)) != 0)
                                          break;
                                 }
                              }
                        return возвр;
                }
        }
}


/*******************************************************************************

        Parse a файл путь

        Файл пути containing non-ansi characters should be UTF-8 кодирован.
        Supporting Unicode in this manner was deemed в_ be ещё suitable
        than provопрing a шим version of ПутеПарсер, and is Всё consistent
        & compatible with the approach taken with the Уир class.

        Note that образцы of adjacent '.' разделители are treated specially
        in that they will be assigned в_ the имя where there is no distinct
        суффикс. In добавьition, a '.' at the старт of a имя signifies it does 
        not belong в_ the суффикс т.е. ".файл" is a имя rather than a суффикс.
        Образцы of intermediate '.' characters will иначе be assigned
        в_ the суффикс, such that "файл....суффикс" включает the dots within
        the суффикс itself. See метод расш() for a суффикс without dots.

        Note also that normalization of путь-разделители does *not* occur by 
        default. This means that usage of '\' characters should be explicitly
        преобразованый передhand преобр_в '/' instead (an исключение is thrown in those
        cases where '\' is present). On-the-fly conversion is avoопрed because
        (a) the предоставленный путь is consопрered immutable*and (b) we avoопр taking
        a копируй of the original путь. Module ФПуть есть_ли at a higher уровень, 
        without such contraints.

*******************************************************************************/

export struct ПутеПарсер
{       
         ткст  fp;                     // фпуть with trailing
         цел     конец_,                   // перед any trailing 0
                        расш_,                   // после правейший '.'
                        имя_,                  // файл/Пап имя
                        том_,                // путь перед имя
                        суффикс_;                // включая левейший '.'

        /***********************************************************************

                Parse the путь spec

        ***********************************************************************/

        export ПутеПарсер разбор (ткст путь)
        {
                return разбор (путь, путь.length);
        }

        /***********************************************************************

                Duplicate this путь

                Note: allocates память for the путь контент

        ***********************************************************************/

        export ПутеПарсер dup ()
        {
                auto возвр = *this;
                возвр.fp = fp.dup;
                return возвр;
        }

        /***********************************************************************

                Возвращает complete текст of this фпуть

        ***********************************************************************/

        export ткст вТкст ()
        {
                return fp [0 .. конец_];
        }

        /***********************************************************************

                Возвращает корень of this путь. Roots are constructs such as
                "c:"

        ***********************************************************************/

        export ткст корень ()
        {
                return fp [0 .. том_];
        }

        /***********************************************************************

                Возвращает файл путь. Paths may старт and конец with a "/".
                The корень путь is "/" and an unspecified путь is returned as
                an пустой ткст. Directory пути may be разбей such that the
                дир имя is placed преобр_в the 'имя' member; дир
                пути are treated no differently than файл пути

        ***********************************************************************/

        export ткст папка ()
        {
                return fp [том_ .. имя_];
        }

        /***********************************************************************

                Возвращает путь representing the родитель of this one. This
                will typically return the current путь component, though
                with a special case where the имя component is пустой. In 
                such cases, the путь is scanned for a prior сегмент:
                ---
                нормаль:  /x/y/z => /x/y
                special: /x/y/  => /x
                нормаль:  /x     => /
                нормаль:  /      => [пустой]
                ---

                Note that this returns a путь suitable for splitting преобр_в
                путь and имя components (there's no trailing разделитель).

        ***********************************************************************/

        export ткст родитель ()
        {
                auto p = путь;
                if (имя.length is 0)
                    for (цел i=p.length-1; --i > 0;)
                         if (p[i] is ФайлКонст.СимПутьРазд)
                            {
                            p = p[0 .. i];
                            break;
                            }
                return ФС.очищенный (p);
        }

        /***********************************************************************

                Pop the правейший element off this путь, strИПping off a
                trailing '/' as appropriate:
                ---
                /x/y/z => /x/y
                /x/y/  => /x/y  (note trailing '/' in the original)
                /x/y   => /x
                /x     => /
                /      => [пустой]
                ---

                Note that this returns a путь suitable for splitting преобр_в
                путь and имя components (there's no trailing разделитель).

        ***********************************************************************/

        export ткст вынь ()
        {
                return ФС.очищенный (путь);
        }

        /***********************************************************************

                Возвращает имя of this файл, либо дир.

        ***********************************************************************/

        export ткст имя ()
        {
                return fp [имя_ .. суффикс_];
        }

        /***********************************************************************

                Ext is the хвост of the имяф, rightward of the правейший
                '.' разделитель e.g. путь "foo.bar" есть расш "bar". Note that
                образцы of adjacent разделители are treated specially - for
                example, ".." will wind up with no расш at все

        ***********************************************************************/

        export ткст расш ()
        {
                auto x = суффикс;
                if (x.length)
                   {
                   if (расш_ is 0)
                       foreach (c; x)
                                if (c is '.')
                                    ++расш_;
                                else
                                   break;
                   x = x [расш_ .. $];
                   }
                return x;
        }

        /***********************************************************************

                Suffix is like расш, but включает the разделитель e.g. путь
                "foo.bar" есть суффикс ".bar"

        ***********************************************************************/

        export ткст суффикс ()
        {
                return fp [суффикс_ .. конец_];
        }

        /***********************************************************************

                return the корень + папка combination

        ***********************************************************************/

        export ткст путь ()
        {
                return fp [0 .. имя_];
        }

        /***********************************************************************

                return the имя + суффикс combination

        ***********************************************************************/

        export ткст файл ()
        {
                return fp [имя_ .. конец_];
        }

        /***********************************************************************

                Возвращает да, если this путь is *not* relative в_ the
                current working дир

        ***********************************************************************/

        export бул абс_ли ()
        {
                return (том_ > 0) ||
                       (том_ < конец_ && fp[том_] is ФайлКонст.СимПутьРазд);
        }

        /***********************************************************************

                Возвращает да, если this ФПуть is пустой

        ***********************************************************************/

        export бул пуст_ли ()
        {
                return конец_ is 0;
        }

        /***********************************************************************

                Возвращает да, если this путь есть a родитель. Note that a
                родитель is defined by the presence of a путь-разделитель in
                the путь. This means 'foo' within "/foo" is consопрered a
                ветвь of the корень

        ***********************************************************************/

        export бул ветвь_ли ()
        {
                return папка.length > 0;
        }

        /***********************************************************************

                Does this путь equate в_ the given текст? We ignore trailing
                путь-разделители when testing equivalence

        ***********************************************************************/

        export цел opEquals (ткст s)
        {       
                return ФС.очищенный(s) == ФС.очищенный(вТкст);
        }

        /***********************************************************************

                Parse the путь spec with explicit конец точка. A '\' is 
                consопрered illegal in the путь and should be normalized
                out перед this is invoked (the контент managed here is
                consопрered immutable, and thus cannot be изменён by this
                function)

        ***********************************************************************/

        package ПутеПарсер разбор (ткст путь, т_мера конец)
        {
                конец_ = конец;
                fp = путь;
                том_ = 0;
                имя_ = суффикс_ = -1;

                for (цел i=конец_; --i >= 0;)
                     switch (fp[i])
                            {
                            case ФайлКонст.СимФайлРазд:
                                 if (имя_ < 0)
                                     if (суффикс_ < 0 && i && fp[i-1] != '.')
                                         суффикс_ = i;
                                 break;

                            case ФайлКонст.СимПутьРазд:
                                 if (имя_ < 0)
                                     имя_ = i + 1;
                                 break;

                            // Windows файл разделители are illegal. Use
                            // стандарт() or equivalent в_ преобразуй first
                            case '\\':
                                 ФС.исключение ("неожиданный '\\' символ в пути: ", путь[0..конец]);

                            version (Win32)
                            {
                            case ':':
                                 том_ = i + 1;
                                 break;
                            }

                            default:
                                 break;
                            }

                if (имя_ < 0)
                    имя_ = том_;

                if (суффикс_ < 0 || суффикс_ is имя_)
                    суффикс_ = конец_;

                return *this;
        }
}


/*******************************************************************************

        Does this путь currently есть_ли?

*******************************************************************************/

export бул есть_ли (ткст имя)
{
        сим[512] врем =void;
        return ФС.есть_ли (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Возвращает the время of the последний modification. Accurate
        в_ whatever the F/S supports, and in a форматируй dictated
        by the файл-system. For example NTFS keeps UTC время, 
        while FAT timestamps are based on the local время. 

*******************************************************************************/

export Время изменён (ткст имя)
{       
        return штампыВремени(имя).изменён;
}

/*******************************************************************************

        Возвращает the время of the последний access. Accurate в_
        whatever the F/S supports, and in a форматируй dictated
        by the файл-system. For example NTFS keeps UTC время, 
        while FAT timestamps are based on the local время.

*******************************************************************************/

export Время использовался (ткст имя)
{
        return штампыВремени(имя).использовался;
}

/*******************************************************************************

        Возвращает the время of файл creation. Accurate в_
        whatever the F/S supports, and in a форматируй dictated
        by the файл-system. For example NTFS keeps UTC время,  
        while FAT timestamps are based on the local время.

*******************************************************************************/

export Время создан (ткст имя)
{
        return штампыВремени(имя).создан;
}

/*******************************************************************************

        Возвращает файл length (в байтах)

*******************************************************************************/

export бдол размерФайла (ткст имя)
{
        сим[512] врем =void;
        return ФС.размерФайла (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Is this файл записываемый?

*******************************************************************************/

export бул записываем_ли (ткст имя)
{
        сим[512] врем =void;
        return ФС.записываем_ли (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Is this файл actually a папка/дир?

*******************************************************************************/

export бул папка_ли (ткст имя)
{
        сим[512] врем =void;
        return ФС.папка_ли (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Is this файл actually a нормаль файл?
        Not a дир or (on unix) a устройство файл or link.

*******************************************************************************/

export бул файл_ли (ткст имя)
{
        сим[512] врем =void;
        return ФС.файл_ли (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Return timestamp information

        Timestamps are returns in a форматируй dictated by the 
        файл-system. For example NTFS keeps UTC время, 
        while FAT timestamps are based on the local время

*******************************************************************************/

export ФС.Штампы штампыВремени (ткст имя)
{
        сим[512] врем =void;
        return ФС.штампыВремени (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Устанавливает использовался and изменён timestamps указанного файл

        Since 0.99.9

*******************************************************************************/

export проц штампыВремени (ткст имя, Время использовался, Время изменён)
{
        сим[512] врем =void;
        ФС.штампыВремени (ФС.ткт0(имя, врем), использовался, изменён);
}

/*******************************************************************************

        Удали the файл/дир из_ the файл-system. Возвращает да, если
        successful, нет иначе

*******************************************************************************/

export бул удали (ткст имя)
{      
        сим[512] врем =void;
        return ФС.удали (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Удали the файлы and папки listed in the предоставленный пути. Where
        папки are listed, they should be preceded by their contained
        файлы in order в_ be successfully removed. Возвращает установи of пути
        that неудачно в_ be removed (where .length is zero upon success).

        The коллируй() function can be used в_ предоставляет the ввод пути:
        ---
        удали (коллируй (".", "*.d", да));
        ---

        Use with great caution

        Note: may размести память

        Since: 0.99.9

*******************************************************************************/

export ткст[] удали (ткст[] пути)
{     
        ткст[] неудачно;
        foreach (путь; пути)
                 if (! удали (путь))
                       неудачно ~= путь;
        return неудачно;
}

/*******************************************************************************

        Create a new файл

*******************************************************************************/

export проц создайФайл (ткст имя)
{
        сим[512] врем =void;
        ФС.создайФайл (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Create a new дир

*******************************************************************************/

export проц создайПапку (ткст имя)
{
        сим[512] врем =void;
        ФС.создайПапку (ФС.ткт0(имя, врем));
}

/*******************************************************************************

        Create an entire путь consisting of this папка along with
        все родитель папки. The путь should not contain '.' or '..'
        segments, which can be removed via the нормализуй() function.

        Note that each сегмент is создан как папка, включая the
        trailing сегмент.

        Выводит исключение: ВВИскл upon system ошибки

        Выводит исключение: ИсклНелегальногоАргумента if a сегмент есть_ли but как 
        файл instead of a папка

*******************************************************************************/

export проц создайПуть (ткст путь)
{
        проц тест (ткст сегмент)
        {
                if (сегмент.length)
                    if (! есть_ли (сегмент))
                          создайПапку (сегмент);
                    else
                       if (! папка_ли (сегмент))
                             throw new ИсклНелегальногоАргумента ("Путь.создайПуть :: файл/папка конфликтуют: " ~ сегмент);
        }

        foreach (i, сим c; путь)
                 if (c is '/')
                     тест (путь [0 .. i]);
        тест (путь);
}

/*******************************************************************************

       change the имя or location of a файл/дир

*******************************************************************************/

export проц переименуй (ткст ист, ткст приёмн)
{
        сим[512] tmp1 =void;
        сим[512] tmp2 =void;
        ФС.переименуй (ФС.ткт0(ист, tmp1), ФС.ткт0(приёмн, tmp2));
}

/*******************************************************************************

        Transfer the контент of one файл в_ другой. Выводит исключение 
        an ВВИскл upon failure.

*******************************************************************************/

export проц копируй (ткст ист, ткст приёмн)
{
        сим[512] tmp1 =void;
        сим[512] tmp2 =void;
        ФС.копируй (ФС.ткт0(ист, tmp1), ФС.ткт0(приёмн, tmp2));
}

/*******************************************************************************

        Provопрes foreach support via a fruct, as in
        ---
        foreach (инфо; ветви("myfolder"))
                 ...
        ---

        Each путь and имяф is passed в_ the foreach
        delegate, along with the путь префикс and whether
        the Запись is a папка or not. The инфо construct
        exposes the following атрибуты:
        ---
        ткст  путь
        ткст  имя
        бдол   байты
        бул    папка
        ---

        Аргумент 'все' controls whether скрытый and system 
        файлы are included - these are ignored by default

*******************************************************************************/

export ФС.Листинг ветви (ткст путь, бул все=нет)
{
        return ФС.Листинг (путь, все);
}

/*******************************************************************************

        коллируй все файлы and папки из_ the given путь whose имя matches
        the given образец. Folders will be traversed where рекурсия is включен, 
        and набор of совпадают names is returned as filepaths (включая those 
        папки which match the образец)

        Note: allocates память for returned пути

        Since: 0.99.9

*******************************************************************************/

export ткст[] коллируй (ткст путь, ткст образец, бул рекурсия=нет)
{      
        ткст[] список;

        foreach (инфо; ветви (путь))
                {
                if (инфо.папка && рекурсия)
                    список ~= коллируй (объедини(инфо.путь, инфо.имя), образец, да);

                if (совпадение (инфо.имя, образец))
                    список ~= объедини (инфо.путь, инфо.имя);
                }
        return список;
}

/*******************************************************************************

        Join набор of путь specs together. A путь разделитель is
        potentially inserted between each of the segments.

        Note: may размести память

*******************************************************************************/

export ткст объедини (ткст[] пути...)
{
        return ФС.объедини (пути);
}

/*******************************************************************************

        Convert путь разделители в_ a стандарт форматируй, using '/' as
        the путь разделитель. This is compatible with Уир and все of 
        the contemporary O/S which Dinrus supports. Known exceptions
        include the Windows команда-строка процессор, which consопрers
        '/' characters в_ be switches instead. Use the исконный()
        метод в_ support that.

        Note: mutates the предоставленный путь.

*******************************************************************************/

export ткст стандарт (ткст путь)
{
        return замени (путь, '\\', '/');
}

/*******************************************************************************

        Convert в_ исконный O/S путь разделители where that is required,
        such as when dealing with the Windows команда-строка. 
        
        Note: mutates the предоставленный путь. Use this образец в_ obtain a 
        копируй instead: исконный(путь.dup);

*******************************************************************************/

export ткст исконный (ткст путь)
{
        version (Win32)
                 замени (путь, '/', '\\');
        return путь;
}

/*******************************************************************************

        Возвращает путь representing the родитель of this one, with a special 
        case concerning a trailing '/':
        ---
        нормаль:  /x/y/z => /x/y
        нормаль:  /x/y/  => /x/y
        special: /x/y/  => /x
        нормаль:  /x     => /
        нормаль:  /      => пустой
        ---

        The результат can be разбей via разбор()

*******************************************************************************/

export ткст родитель (ткст путь)
{
        return вынь (ФС.очищенный (путь));
}

/*******************************************************************************

        Возвращает путь representing the родитель of this one:
        ---
        нормаль:  /x/y/z => /x/y
        нормаль:  /x/y/  => /x/y
        нормаль:  /x     => /
        нормаль:  /      => пустой
        ---

        The результат can be разбей via разбор()

*******************************************************************************/

export ткст вынь (ткст путь)
{
        цел i = путь.length;
        while (i && путь[--i] != '/') {}
        return путь [0..i];
}

/*******************************************************************************

        Break a путь преобр_в "голова" and "хвост" components. For example: 
        ---
        "/a/b/c" -> "/a","b/c" 
        "a/b/c" -> "a","b/c" 
        ---

*******************************************************************************/

export ткст разбей (ткст путь, out ткст голова, out ткст хвост)
{
        голова = путь;
        if (путь.length > 1)
            foreach (i, сим c; путь[1..$])
                     if (c is '/')
                        {
                        голова = путь [0 .. i+1];
                        хвост = путь [i+2 .. $];
                        break;
                        }
        return путь;
}

/*******************************************************************************

        Замени все путь 'из_' instances with 'в_', in place (overwrites
        the предоставленный путь)

*******************************************************************************/

export ткст замени (ткст путь, сим из_, сим в_)
{
        foreach (ref сим c; путь)
                 if (c is из_)
                     c = в_;
        return путь;
}

/*******************************************************************************

        Parse a путь преобр_в its constituent components. 
        
        Note that the предоставленный путь is sliced, not duplicated

*******************************************************************************/

export ПутеПарсер разбор (ткст путь)
{
        ПутеПарсер p;
        
        p.разбор (путь);
        return p;
}

/*******************************************************************************

*******************************************************************************/

debug(UnitTest)
{
        unittest
        {
                auto p = разбор ("/foo/bar/файл.расш");
                assert (p == "/foo/bar/файл.расш");
                assert (p.папка == "/foo/bar/");
                assert (p.путь == "/foo/bar/");
                assert (p.файл == "файл.расш");
                assert (p.имя == "файл");
                assert (p.суффикс == ".расш");
                assert (p.расш == "расш");
                assert (p.ветвь_ли == да);
                assert (p.пуст_ли == нет);
                assert (p.абс_ли == да);
        }
}


/******************************************************************************

        Matches a образец against a имяф.

        Some characters of образец have special a meaning (they are
        <i>meta-characters</i>) and <b>can't</b> be эскапирован. These are:
        <p><table>
        <tr><td><b>*</b></td>
        <td>Matches 0 or ещё instances of any character.</td></tr>
        <tr><td><b>?</b></td>
        <td>Matches exactly one instances of any character.</td></tr>
        <tr><td><b>[</b><i>симвы</i><b>]</b></td>
        <td>Matches one экземпляр of any character that appears
        between the brackets.</td></tr>
        <tr><td><b>[!</b><i>симвы</i><b>]</b></td>
        <td>Matches one экземпляр of any character that does not appear
        between the brackets после the exclamation метка.</td></tr>
        </table><p>
        Internally indivопрual character comparisons are готово calling
        charMatch(), so its rules apply here too. Note that путь
        разделители and dots don't stop a meta-character из_ совпадают
        further portions of the имяф.

        Возвращает: да, если образец matches имяф, нет иначе.

        Выводит исключение: Nothing.
        -----
        version (Win32)
                {
                совпадение("foo.bar", "*") // => да
                совпадение(r"foo/foo\bar", "f*b*r") // => да
                совпадение("foo.bar", "f?bar") // => нет
                совпадение("Goo.bar", "[fg]???bar") // => да
                совпадение(r"d:\foo\bar", "d*foo?bar") // => да
                }
        version (Posix)
                {
                совпадение("Go*.bar", "[fg]???bar") // => нет
                совпадение("/foo*home/bar", "?foo*bar") // => да
                совпадение("fСПДar", "foo?bar") // => да
                }
        -----
    
******************************************************************************/

export бул совпадение (ткст имяф, ткст образец)
in
{
        // Verify that образец[] is valid
        бул inbracket = нет;
        for (auto i=0; i < образец.length; i++)
            {
            switch (образец[i])
                   {
                   case '[':
                        assert(!inbracket);
                        inbracket = да;
                        break;
                   case ']':
                        assert(inbracket);
                        inbracket = нет;
                        break;
                   default:
                        break;
                   }
            }
}
body
{
        цел пи;
        цел ni;
        сим pc;
        сим nc;
        цел j;
        цел not;
        цел anymatch;

        бул charMatch (сим c1, сим c2)
        {
        version (Win32)
                {
                if (c1 != c2)
				if(bool рез =((c1 >= 'a' && c1 <= 'z') ? c1 - ('a' - 'A') : c1) ==
                           ((c2 >= 'a' && c2 <= 'z') ? c2 - ('a' - 'A') : c2)) return рез;
						else return ((c1 >= 'а' && c1 <= 'я') ? c1 - ('а' - 'А') : c1) ==
                           ((c2 >= 'а' && c2 <= 'я') ? c2 - ('а' - 'А') : c2);
                return да;
                }
        version (Posix)
                 return c1 == c2;
        }

        ni = 0;
        for (пи = 0; пи < образец.length; пи++)
            {
            pc = образец [пи];
            switch (pc)
                   {
                   case '*':
                        if (пи + 1 == образец.length)
                            goto match;
                        for (j = ni; j < имяф.length; j++)
                            {
                            if (совпадение(имяф[j .. имяф.length],
                                образец[пи + 1 .. образец.length]))
                               goto match;
                            }
                        goto nomatch;

                   case '?':
                        if (ni == имяф.length)
                            goto nomatch;
                        ni++;
                        break;

                   case '[':
                        if (ni == имяф.length)
                            goto nomatch;
                        nc = имяф[ni];
                        ni++;
                        not = 0;
                        пи++;
                        if (образец[пи] == '!')
                           {
                           not = 1;
                           пи++;
                           }
                        anymatch = 0;
                        while (1)
                              {
                              pc = образец[пи];
                              if (pc == ']')
                                  break;
                              if (!anymatch && charMatch(nc, pc))
                                   anymatch = 1;
                              пи++;
                              }
                        if (!(anymatch ^ not))
                              goto nomatch;
                        break;

                   default:
                        if (ni == имяф.length)
                            goto nomatch;
                        nc = имяф[ni];
                        if (!charMatch(pc, nc))
                             goto nomatch;
                        ni++;
                        break;
                   }
            }
        if (ni < имяф.length)
            goto nomatch;

        match:
            return да;

        nomatch:
            return нет;
}

/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{
        unittest
        {
        version (Win32)
        assert(совпадение("foo", "Foo"));
        version (Posix)
        assert(!совпадение("foo", "Foo"));
        
        assert(совпадение("foo", "*"));
        assert(совпадение("foo.bar", "*"));
        assert(совпадение("foo.bar", "*.*"));
        assert(совпадение("foo.bar", "foo*"));
        assert(совпадение("foo.bar", "f*bar"));
        assert(совпадение("foo.bar", "f*b*r"));
        assert(совпадение("foo.bar", "f???bar"));
        assert(совпадение("foo.bar", "[fg]???bar"));
        assert(совпадение("foo.bar", "[!gh]*bar"));
        
        assert(!совпадение("foo", "bar"));
        assert(!совпадение("foo", "*.*"));
        assert(!совпадение("foo.bar", "f*baz"));
        assert(!совпадение("foo.bar", "f*b*x"));
        assert(!совпадение("foo.bar", "[gh]???bar"));
        assert(!совпадение("foo.bar", "[!fg]*bar"));
        assert(!совпадение("foo.bar", "[fg]???baz"));
        }
}


/*******************************************************************************

        Normalizes a путь component
        ---
        . segments are removed
        <сегмент>/.. are removed
        ---

        Несколько consecutive forward slashes are replaced with a single 
        forward слэш. On Windows, \ will be преобразованый в_ / prior в_ any
        normalization.

        Note that any число of .. segments at the front is ignored,
        unless it is an абсолютный путь, in which case they are removed.

        The ввод путь is copied преобр_в either the предоставленный буфер, либо a куча
        allocated Массив if no буфер was предоставленный. Normalization modifies
        this копируй перед returning the relevant срез.
        -----
        нормализуй("/home/foo/./bar/../../john/doe"); // => "/home/john/doe"
        -----

        Note: allocates память

*******************************************************************************/

export ткст нормализуй (ткст путь, ткст буф = пусто)
{
        т_мера  инд;            // Текущий позиция
        т_мера  moveTo;         // Position в_ перемести
        бул    абс_ли;     // Whether the путь is абсолютный
        enum    {NodeStackLength = 64}

        // Starting positions of regular путь segments are pushed 
        // on this stack в_ avoопр backward scanning when .. segments 
        // are encountered
        т_мера[NodeStackLength] nodeStack;
        т_мера nodeStackTop;

        // Moves the путь хвост starting at the current позиция в_ 
        // moveTo. Then sets the current позиция в_ moveTo.
        проц перемести ()
        {
                auto длин = путь.length - инд;
                memmove (путь.ptr + moveTo, путь.ptr + инд, длин);
                путь = путь[0..moveTo + длин];
                инд = moveTo;
        }

        // Checks if the character at the current позиция is a 
        // разделитель. If да, normalizes the разделитель в_ '/' on 
        // Windows and advances the current позиция в_ the следщ 
        // character.
        бул isSep (ref т_мера i)
        {
                сим c = путь[i];
                version (Windows)
                        {
                        if (c == '\\')
                                путь[i] = '/';
                        else if (c != '/')
                                return нет;
                        }
                     else
                        {
                        if (c != '/')
                                return нет;
                        }
                i++;
                return да;
        }

        if (буф is пусто)
            путь = путь.dup;
        else
           путь = буф[0..путь.length] = путь;

        version (Windows)
        {
                // SkИП Windows drive specifiers
                if (путь.length >= 2 && путь[1] == ':')
                   {
                   auto c = путь[0];

                   if (c >= 'a' && c <= 'z')
                      {
                      путь[0] = c - 32;
                      инд = 2;
                      }
                   else 
                      if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')
                          инд = 2;
                   }
        }

        if (инд == путь.length)
            return путь;

        moveTo = инд;
        if (isSep(инд))
           {
           moveTo++; // preserve корень разделитель.
           абс_ли = да;
           }

        while (инд < путь.length)
              {
              // SkИП duplicate разделители
              if (isSep(инд))
                  continue;

              if (путь[инд] == '.')
                 {
                 // покинь the current позиция at the старт of 
                 // the сегмент
                 auto i = инд + 1;
                 if (i < путь.length && путь[i] == '.')
                    {
                    i++;
                    if (i == путь.length || isSep(i))
                       {
                       // It is a '..' сегмент. If the stack is not 
                       // пустой, установи moveTo and the current позиция
                       // в_ the старт позиция of the последний найдено 
                       // regular сегмент
                       if (nodeStackTop > 0)
                           moveTo = nodeStack[--nodeStackTop];

                       // If no regular сегмент старт positions on the 
                       // stack, drop the .. сегмент if it is абсолютный 
                       // путь or, иначе, advance moveTo and the 
                       // current позиция в_ the character после the 
                       // '..' сегмент
                       else 
                          if (!абс_ли)
                             {
                             if (moveTo != инд)
                                {
                                i -= инд - moveTo;
                                перемести();
                                }
                             moveTo = i;
                             }
        
                       инд = i;
                       continue;
                       }
                    }
        
                 // If it is '.' сегмент, пропусти it.
                 if (i == путь.length || isSep(i))
                    {
                    инд = i;
                    continue;
                    }
                 }

              // Удали excessive '/', '.' and/or '..' preceeding the 
              // сегмент
              if (moveTo != инд)
                  перемести();

              // Push the старт позиция of the regular сегмент on the 
              // stack
              assert (nodeStackTop < NodeStackLength);
              nodeStack[nodeStackTop++] = инд;

              // SkИП the regular сегмент and установи moveTo в_ the позиция 
              // после the сегмент (включая the trailing '/' if present)
              for (; инд < путь.length && !isSep(инд); инд++) 
                  {}
              moveTo = инд;
              }

        if (moveTo != инд)
            перемести();
        return путь;
}

/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{
        unittest
        {
        assert (нормализуй ("") == "");
        assert (нормализуй ("/home/../john/../.DinrusTango.lib/.htaccess") == "/.DinrusTango.lib/.htaccess");
        assert (нормализуй ("/home/../john/../.DinrusTango.lib/foo.conf") == "/.DinrusTango.lib/foo.conf");
        assert (нормализуй ("/home/john/.DinrusTango.lib/foo.conf") == "/home/john/.DinrusTango.lib/foo.conf");
        assert (нормализуй ("/foo/bar/.htaccess") == "/foo/bar/.htaccess");
        assert (нормализуй ("foo/bar/././.") == "foo/bar/");
        assert (нормализуй ("././foo/././././bar") == "foo/bar");
        assert (нормализуй ("/foo/../john") == "/john");
        assert (нормализуй ("foo/../john") == "john");
        assert (нормализуй ("foo/bar/..") == "foo/");
        assert (нормализуй ("foo/bar/../john") == "foo/john");
        assert (нормализуй ("foo/bar/doe/../../john") == "foo/john");
        assert (нормализуй ("foo/bar/doe/../../john/../bar") == "foo/bar");
        assert (нормализуй ("./foo/bar/doe") == "foo/bar/doe");
        assert (нормализуй ("./foo/bar/doe/../../john/../bar") == "foo/bar");
        assert (нормализуй ("./foo/bar/../../john/../bar") == "bar");
        assert (нормализуй ("foo/bar/./doe/../../john") == "foo/john");
        assert (нормализуй ("../../foo/bar") == "../../foo/bar");
        assert (нормализуй ("../../../foo/bar") == "../../../foo/bar");
        assert (нормализуй ("d/") == "d/");
        assert (нормализуй ("/home/john/./foo/bar.txt") == "/home/john/foo/bar.txt");
        assert (нормализуй ("/home//john") == "/home/john");

        assert (нормализуй("/../../bar/") == "/bar/");
        assert (нормализуй("/../../bar/../baz/./") == "/baz/");
        assert (нормализуй("/../../bar/boo/../baz/.bar/.") == "/bar/baz/.bar/");
        assert (нормализуй("../..///.///bar/..//..//baz/.//boo/..") == "../../../baz/");
        assert (нормализуй("./bar/./..boo/./..bar././/") == "bar/..boo/..bar./");
        assert (нормализуй("/bar/..") == "/");
        assert (нормализуй("bar/") == "bar/");
        assert (нормализуй(".../") == ".../");
        assert (нормализуй("///../foo") == "/foo");
        assert (нормализуй("./foo") == "foo");
        auto буф = new сим[100];
        auto возвр = нормализуй("foo/bar/./baz", буф);
        assert (возвр.ptr == буф.ptr);
        assert (возвр == "foo/bar/baz");

        version (Windows) 
                {
                assert (нормализуй ("\\foo\\..\\john") == "/john");
                assert (нормализуй ("foo\\..\\john") == "john");
                assert (нормализуй ("foo\\bar\\..") == "foo/");
                assert (нормализуй ("foo\\bar\\..\\john") == "foo/john");
                assert (нормализуй ("foo\\bar\\doe\\..\\..\\john") == "foo/john");
                assert (нормализуй ("foo\\bar\\doe\\..\\..\\john\\..\\bar") == "foo/bar");
                assert (нормализуй (".\\foo\\bar\\doe") == "foo/bar/doe");
                assert (нормализуй (".\\foo\\bar\\doe\\..\\..\\john\\..\\bar") == "foo/bar");
                assert (нормализуй (".\\foo\\bar\\..\\..\\john\\..\\bar") == "bar");
                assert (нормализуй ("foo\\bar\\.\\doe\\..\\..\\john") == "foo/john");
                assert (нормализуй ("..\\..\\foo\\bar") == "../../foo/bar");
                assert (нормализуй ("..\\..\\..\\foo\\bar") == "../../../foo/bar");
                assert (нормализуй(r"C:") == "C:");
                assert (нормализуй(r"C") == "C");
                assert (нормализуй(r"c:\") == "C:/");
                assert (нормализуй(r"C:\..\.\..\..\") == "C:/");
                assert (нормализуй(r"c:..\.\boo\") == "C:../boo/");
                assert (нормализуй(r"C:..\..\boo\foo\..\.\..\..\bar") == "C:../../../bar");
                assert (нормализуй(r"C:boo\..") == "C:");
                }
        }
}


/*******************************************************************************

*******************************************************************************/

debug (Путь)
{
        import io.Stdout;

        проц main()
        { 
                foreach (файл; коллируй (".", "*.d", да))
                         Стдвыв (файл).нс;      
        }
}
