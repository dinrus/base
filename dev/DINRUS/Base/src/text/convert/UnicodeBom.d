module text.convert.UnicodeBom;

private import  stdrus;

private import  Utf = text.convert.Utf;


private extern (C) проц onUnicodeError (ткст сооб, т_мера индкс = 0);

/*******************************************************************************

        see http://icu.sourceforge.net/docs/papers/forms_of_unicode/#t2

*******************************************************************************/

enum Кодировка {
              Неизвестно,
              UTF_8N,
              UTF_8,
              UTF_16,
              UTF_16BE,
              UTF_16LE,
              UTF_32,
              UTF_32BE,
              UTF_32LE,
              };

/*******************************************************************************

        Преобразует контент unicode.

        Unicode - это кодировка текстового материала. Цель данного модуля -  
        предоставить интерфейс к внешней кодировке с программно-заданной внутренней
        кодировкой. Эта внутренняя кодировка декларируется через шаблонный аргумент 
        T, в то время как внешняя кодировка либо заданная, либо производная.

        Поддерживаются три внутренние кодировки: сим, шим и дим. Приводимые
        здесь методы оперируют с массивами этих типов. Таким образом, раскодируй()
        возвращает Массив этого типа, в то время как кодируй() ожидает Массив 
        стороннего типа.

        Поддерживаются следующие внешние кодировки:

                Кодировка.Неизвестно 
                Кодировка.UTF_8N
                Кодировка.UTF_8
                Кодировка.UTF_16
                Кодировка.UTF_16BE
                Кодировка.UTF_16LE 
                Кодировка.UTF_32 
                Кодировка.UTF_32BE
                Кодировка.UTF_32LE 

        Их можно разделить на неявные и явные:

                Кодировка.Неизвестно 
                Кодировка.UTF_8
                Кодировка.UTF_16
                Кодировка.UTF_32 


                Кодировка.UTF_8N
                Кодировка.UTF_16BE
                Кодировка.UTF_16LE 
                Кодировка.UTF_32BE
                Кодировка.UTF_32LE 
        
        Ранее указанная группа неявных кодировок может использоваться для 'обнаружения'
        неизвестной кодировки, путём исследования первых нескольких байтов контента
        на наличие сигнатуры. Эта сигнатура необязательна, но её часто записывают, и 
        контент становится самоописательным. Когда кодировка неизвестна, с помощью 
        одной из неявных кодировок можно заставить метод раскодируй() искать 
        сигнатуру и исправить саму кодировку. Символ ZWNBSP может быть спутан с
		этой сигнатурой; today's unicode контент is supposed в_ use the WORD-JOINER character instead.
       
        Группа явных кодировок используется, когда кодировка контента известна. 
        Их *следует* использовать при преобразовании во внутреннюю кодировку, 
        так как записанный контент должен быть в известном формате. Следует отметить, что 
        при операции раскодируй() наличие сигнатуры вызывает конфликт с 
        этими явными вариациями.


        See 
        $(LINK http://www.utf-8.com/)
        $(LINK http://www.hackcraft.net/xmlUnicode/)
        $(LINK http://www.unicode.org/faq/utf_bom.html/)
        $(LINK http://www.azillionmonkeys.com/qed/unicode.html/)
        $(LINK http://icu.sourceforge.net/docs/papers/forms_of_unicode/)

*******************************************************************************/

class ЮникодМПБ(T) : BomSniffer
{
        static if (!is (T == сим) && !is (T == шим) && !is (T == дим)) 
                    pragma (msg, "Типом шаблона должен быть сим, шим или дим");

        /***********************************************************************
        
                Конструирует экземпляр, используя заданную внешнюю кодировку ~ 
                один из типов Кодировка.xx 

        ***********************************************************************/
                                  
        this (Кодировка кодировка)
        {
                установи (кодировка);
        }
        
        /***********************************************************************

                Преобразует предоставленный контент. Этот контент исследуется на 
                наличие сигнатуры мпб, которая удаляется. Исключение выводится в том
                случае, если сигнатура присутствует, когда, согласно типу кодировки,
                её не должно быть. И наоборот, выводится исключение,
                если известной сигнатуры нет, когда для текущей кодировки ожидается
                её наличие.

                Когда предоставлена 'взято', эта переменная устанавливается в число 
                элементов, потреблённое из ввода и декодер оперирует в поточном 
                режиме, то есть: должен прилагаться 'приёмн', поскольку 
                он не был изменён в размере или расположен в памяти.

        ***********************************************************************/

        final T[] раскодируй (проц[] контент, T[] приёмн=пусто, бцел* взято=пусто)
        {
                // поиск мпб
                auto инфо = тест (контент);

                //ожидается мпб?
                if (отыщи[кодировка].тест)
                    if (инфо)
                       {
                       // yep ~ и we got one
                       установи (инфо.кодировка, да);

                       // откинь мпб из_ контент
                       контент = контент [инфо.мпб.length .. length];
                       }
                    else
                       // can this кодировка be defaulted?
                       if (настройки.откат)
                           установи (настройки.откат, нет);
                       else
                          onUnicodeError ("ЮникодМПБ.раскодируй :: неизвестно или отсутствует мпб");
                else
                   if (инфо)
                       // найдено a мпб when using an явный кодировка
                       onUnicodeError ("ЮникодМПБ.раскодируй :: явно кодировка не допускает мпб");   
                
                // преобразуй it в_ internal представление
                auto возвр = преобр_в (обменяйБайты(контент), настройки.тип, приёмн, взято);
                if (взято && инфо)
                    *взято += инфо.мпб.length;
                return возвр;
        }

        /***********************************************************************

                Выполняет кодировку контента. Заметьте, что кодировка должна 
                относиться к явной разновидности.

        ***********************************************************************/

        final проц[] кодируй (T[] контент, проц[] приёмн=пусто)
        {
                if (настройки.тест)
                    onUnicodeError ("ЮникодМПБ.кодируй :: не удаётся запись в неспецифичной кодировке");

                // преобразуй it в_ external представление, и пиши
		return обменяйБайты (из_ (контент, настройки.тип, приёмн));
        }

        /***********************************************************************

                Обменять байты, как требуется для этой кодировки.

        ***********************************************************************/

        private final проц[] обменяйБайты (проц[] контент)
        {
                бул эндиан = настройки.эндиан;
                бул обменяй   = настройки.бигЭндиан;

                version (БигЭндиан)
                         обменяй = !обменяй;

                if (эндиан && обменяй)
                   {
                   if (настройки.тип == Утф16)
                       ПерестановкаБайт.своп16 (контент.ptr, контент.length);
                   else
                       ПерестановкаБайт.своп32 (контент.ptr, контент.length);
                   }
                return контент;
        }
        
        /***********************************************************************
      
                Преобразует из 'тип' в заданный T.

                Когда предоставлена 'взято', эта переменная устанавливается в число 
                элементов, потреблённое из ввода и декодер оперирует в поточном 
                режиме, то есть: должен прилагаться 'приёмн', поскольку 
                он не был изменён в размере или расположен в памяти.

        ***********************************************************************/

        static T[] преобр_в (проц[] x, бцел тип, T[] приёмн=пусто, бцел* взято = пусто)
        {
                T[] возвр;
                
                static if (is (T == сим))
                          {
                          if (тип == Утф8)
                             {
                             if (взято)
                                 *взято = x.length;
                             возвр = cast(ткст) x;
                             }
                          else
                          if (тип == Утф16)
                              возвр = Utf.вТкст (cast(шим[]) x, приёмн, взято);
                          else
                          if (тип == Утф32)
                              возвр = Utf.вТкст (cast(дим[]) x, приёмн, взято);
                          }

                static if (is (T == шим))
                          {
                          if (тип == Утф16)
                             {
                             if (взято)
                                 *взято = x.length;
                             возвр = cast(шим[]) x;
                             }
                          else
                          if (тип == Утф8)
                              возвр = Utf.вТкст16 (cast(ткст) x, приёмн, взято);
                          else
                          if (тип == Утф32)
                              возвр = Utf.вТкст16 (cast(дим[]) x, приёмн, взято);
                          }

                static if (is (T == дим))
                          {
                          if (тип == Утф32)
                             {
                             if (взято)
                                 *взято = x.length;
                             возвр = cast(дим[]) x;
                             }
                          else
                          if (тип == Утф8)
                              возвр = Utf.вТкст32 (cast(ткст) x, приёмн, взято);
                          else
                          if (тип == Утф16)
                              возвр = Utf.вТкст32 (cast(шим[]) x, приёмн, взято);
                          }
                return возвр;
        }


        /***********************************************************************
      
                Преобразует из 'тип' в заданный T.

                Когда предоставлена 'взято', эта переменная устанавливается в число 
                элементов, потреблённое из ввода и декодер оперирует в поточном 
                режиме, то есть: должен прилагаться 'приёмн', поскольку 
                он не был изменён в размере или расположен в памяти.

        ***********************************************************************/

        static проц[] из_ (T[] x, бцел тип, проц[] приёмн=пусто, бцел* взято=пусто)
        {
                проц[] возвр;

                static if (is (T == сим))
                          {
                          if (тип == Утф8)
                             {
                             if (взято)
                                 *взято = x.length;
                             возвр = x;
                             }
                          else
                          if (тип == Утф16)
                              возвр = Utf.вТкст16 (x, cast(шим[]) приёмн, взято);
                          else
                          if (тип == Утф32)
                              возвр = Utf.вТкст32 (x, cast(дим[]) приёмн, взято);
                          }

                static if (is (T == шим))
                          {
                          if (тип == Утф16)
                             {
                             if (взято)
                                 *взято = x.length;
                             возвр = x;
                             }
                          else
                          if (тип == Утф8)
                              возвр = Utf.вТкст (x, cast(ткст) приёмн, взято);
                          else
                          if (тип == Утф32)
                              возвр = Utf.вТкст32 (x, cast(дим[]) приёмн, взято);
                          }

                static if (is (T == дим))
                          {
                          if (тип == Утф32)
                             {
                             if (взято)
                                 *взято = x.length;
                             возвр = x;
                             }
                          else
                          if (тип == Утф8)
                              возвр = Utf.вТкст (x, cast(ткст) приёмн, взято);
                          else
                          if (тип == Утф16)
                              возвр = Utf.вТкст16 (x, cast(шим[]) приёмн, взято);
                          }

                return возвр;
        }
}



/*******************************************************************************

        Определяет префиксы меток порядка байтов (МПБ).  

*******************************************************************************/

class BomSniffer 
{
        private бул     найдено;        // кодировка обнаружена?
        private Кодировка кодер;      // текущ кодировка 
        private Инфо*    настройки;     // ук на конфиг кодировки

        private struct  Инфо
                {
                цел      тип;          // тип элемента (сим/шим/дим)
                Кодировка кодировка;      // Кодировка.xx
                ткст   мпб;           // образец в_ сверь for сигнатура
                бул     тест,          // should we тест for this кодировка?
                         эндиан,        // this кодировка have эндиан concerns?
                         бигЭндиан;     // is this a big-эндиан кодировка?
                Кодировка откат;      // can this кодировка be defaulted?
                };

        private enum {Утф8, Утф16, Утф32};
        
        private const Инфо[] отыщи =
        [
        {Утф8,  Кодировка.Неизвестно,  пусто,        да,  нет, нет, Кодировка.UTF_8},
        {Утф8,  Кодировка.UTF_8N,   пусто,        да,  нет, нет, Кодировка.UTF_8},
        {Утф8,  Кодировка.UTF_8,    x"efbbbf",   нет},
        {Утф16, Кодировка.UTF_16,   пусто,        да,  нет, нет, Кодировка.UTF_16BE},
        {Утф16, Кодировка.UTF_16BE, x"feff",     нет, да, да},
        {Утф16, Кодировка.UTF_16LE, x"fffe",     нет, да},
        {Утф32, Кодировка.UTF_32,   пусто,        да,  нет, нет, Кодировка.UTF_32BE},
        {Утф32, Кодировка.UTF_32BE, x"0000feff", нет, да, да},
        {Утф32, Кодировка.UTF_32LE, x"fffe0000", нет, да},
        ];

        /***********************************************************************

                Возвращает текущую кодировку. Это либо изначально указанная
                кодировка, либо производная, полученная исследованием
                контента на мпб. Последнее выполняется как часть метода 
                раскодируй().

        ***********************************************************************/

        final Кодировка кодировка ()
        {
                return кодер;
        }
        
        /***********************************************************************

                Была ли кодировка расположена в этом тексте (конфигурируется посредством установи).

        ***********************************************************************/

        final бул кодирован ()
        {
                return найдено;
        }

        /***********************************************************************

                Возвращает сигнатуру (мпб) текущей кодировки.

        ***********************************************************************/

        final проц[] сигнатура ()
        {
                return настройки.мпб;
        }

        /***********************************************************************

                Конфигурирует this экземпляр с помощью конвертеров unicode.

        ***********************************************************************/

        final проц установи (Кодировка кодировка, бул найдено = нет)
        {
                this.настройки = &отыщи[кодировка];
                this.кодер = кодировка;
                this.найдено = найдено;
        }
        
        /***********************************************************************

                Сканирует сигнатуры мпб, в поиске совпадений. Сканирование происходит 
                в реверсном порядке, чтобы первым получить самый длинный случай.

        ***********************************************************************/

        static final Инфо* тест (проц[] контент)
        {
                for (Инфо* инфо=отыщи.ptr+отыщи.length; --инфо >= отыщи.ptr;)
                     if (инфо.мпб)
                        {
                        цел длин = инфо.мпб.length;
                        if (длин <= контент.length)
                            if (контент[0..длин] == инфо.мпб[0..длин])
                                return инфо;
                        }
                return пусто;
        }
}

/*******************************************************************************

*******************************************************************************/

debug (UnitTest)
{
        unittest
        {
                проц[] INPUT2 = "abc\xE3\x81\x82\xE3\x81\x84\xE3\x81\x86";
                проц[] INPUT = x"efbbbf" ~ INPUT2;
                auto мпб = new ЮникодМПБ!(сим)(Кодировка.Неизвестно);
                бцел взято;
                сим[256] буф;
                
                auto temp = мпб.раскодируй (INPUT, буф, &взято);
                assert (взято == INPUT.length);
                assert (мпб.кодировка == Кодировка.UTF_8);
                
                temp = мпб.раскодируй (INPUT2, буф, &взято);
                assert (взято == INPUT2.length);
                assert (мпб.кодировка == Кодировка.UTF_8);
        }
}

debug (ЮникодМПБ)
{
        import io.Stdout;

        проц main()
        {
                проц[] INPUT2 = "abc\xE3\x81\x82\xE3\x81\x84\xE3\x81\x86";
                проц[] INPUT = x"efbbbf" ~ INPUT2;
                auto мпб = new ЮникодМПБ!(сим)(Кодировка.Неизвестно);
                бцел взято;
                сим[256] буф;
                
                auto temp = мпб.раскодируй (INPUT, буф, &взято);
                assert (temp == INPUT2);
                assert (взято == INPUT.length);
                assert (мпб.кодировка == Кодировка.UTF_8);
                
                temp = мпб.раскодируй (INPUT2, буф, &взято);
                assert (temp == INPUT2);
                assert (взято == INPUT2.length);
                assert (мпб.кодировка == Кодировка.UTF_8);
        }
}
