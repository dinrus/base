module crypto.cipher.TEA;

private import crypto.cipher.Cipher;

/** Implementation of the ТЕА cipher designed by
    David Wheeler и Roger Needham. */
export class ТЕА : ШифрБлок
{
    private
    {
        static const бцел ROUNDS = 32,
        KEY_SIZE = 16,
        BLOCK_SIZE = 8,
        DELTA = 0x9e3779b9u,
        DECRYPT_SUM = 0xc6ef3720u;
        бцел sk0, sk1, sk2, sk3, sum;
    }

    export  override проц сбрось() {}

    export  override ткст имя()
    {
        return "ТЕА";
    }

    export  override бцел размерБлока()
    {
        return BLOCK_SIZE;
    }

    export  проц иниц(бул зашифруй, СимметричныйКлюч парамыКлюча)
    {
        _зашифровать = зашифруй;

        if (парамыКлюча.ключ.length != KEY_SIZE)
            не_годится(имя()~": Неверная длина ключа (требует 16 байт)");

        sk0 = БайтКонвертер.БигЭндиан.в_!(бцел)(парамыКлюча.ключ[0..4]);
        sk1 = БайтКонвертер.БигЭндиан.в_!(бцел)(парамыКлюча.ключ[4..8]);
        sk2 = БайтКонвертер.БигЭндиан.в_!(бцел)(парамыКлюча.ключ[8..12]);
        sk3 = БайтКонвертер.БигЭндиан.в_!(бцел)(парамыКлюча.ключ[12..16]);

        _инициализован = да;
    }

    export  override бцел обнови(проц[] ввод_, проц[] вывод_)
    {
        if (!_инициализован)
            не_годится(имя()~": Шифр не инициализован");

        ббайт[] ввод = cast(ббайт[]) ввод_,
        вывод = cast(ббайт[]) вывод_;

        if (ввод.length < BLOCK_SIZE)
            не_годится(имя()~": Буфер ввода слишком краток");

        if (вывод.length < BLOCK_SIZE)
            не_годится(имя()~": Буфер вывода слишком краток");

        бцел v0 = БайтКонвертер.БигЭндиан.в_!(бцел)(ввод[0..4]),
                 v1 = БайтКонвертер.БигЭндиан.в_!(бцел)(ввод[4..8]);

        sum = _зашифровать ? 0 : DECRYPT_SUM;
        for (цел i = 0; i < ROUNDS; i++)
        {
            if (_зашифровать)
            {
                sum += DELTA;
                v0 += ((v1 << 4) + sk0) ^ (v1 + sum) ^ ((v1 >> 5) + sk1);
                v1 += ((v0 << 4) + sk2) ^ (v0 + sum) ^ ((v0 >> 5) + sk3);
            }
            else
            {
                v1 -= ((v0 << 4) + sk2) ^ (v0 + sum) ^ ((v0 >> 5) + sk3);
                v0 -= ((v1 << 4) + sk0) ^ (v1 + sum) ^ ((v1 >> 5) + sk1);
                sum -= DELTA;
            }
        }

        вывод[0..4] = БайтКонвертер.БигЭндиан.из_!(бцел)(v0);
        вывод[4..8] = БайтКонвертер.БигЭндиан.из_!(бцел)(v1);

        return BLOCK_SIZE;
    }

    /** Some ТЕА тест vectors. */
    debug (UnitTest)
    {
        unittest
        {
            static ткст[] ключи_теста = [
                "00000000000000000000000000000000",
                "00000000000000000000000000000000",
                "0123456712345678234567893456789a",
                "0123456712345678234567893456789a"
            ];

            static ткст[] простыеТексты_теста = [
                "0000000000000000",
                "0102030405060708",
                "0000000000000000",
                "0102030405060708"
            ];

            static ткст[] тексты_тестаШифра = [
                "41ea3a0a94baa940",
                "6a2f9cf3fccf3c55",
                "34e943b0900f5dcb",
                "773dc179878a81c0"
            ];


            ТЕА t = new ТЕА();
            foreach (бцел i, ткст test_key; ключи_теста)
            {
                ббайт[] буфер = new ббайт[t.размерБлока];
                ткст результат;
                СимметричныйКлюч ключ = new СимметричныйКлюч(БайтКонвертер.раскодируйГекс(test_key));

                // Encryption
                t.иниц(да, ключ);
                t.обнови(БайтКонвертер.раскодируйГекс(простыеТексты_теста[i]), буфер);
                результат = БайтКонвертер.кодируйГекс(буфер);
                assert(результат == тексты_тестаШифра[i],
                t.имя~": ("~результат~") != ("~тексты_тестаШифра[i]~")");

                // Decryption
                t.иниц(нет, ключ);
                t.обнови(БайтКонвертер.раскодируйГекс(тексты_тестаШифра[i]), буфер);
                результат = БайтКонвертер.кодируйГекс(буфер);
                assert(результат == простыеТексты_теста[i],
                t.имя~": ("~результат~") != ("~простыеТексты_теста[i]~")");
            }
        }
    }
}
