module crypto.cipher.XTEA;

private import crypto.cipher.Cipher;

/** Implementation of the ХТЕА cipher designed by
    David Wheeler и Roger Needham. */
export class ХТЕА : ШифрБлок
{
    private
    {
        static const бцел ROUNDS = 32,
                          KEY_SIZE = 16,
                          BLOCK_SIZE = 8,
                          DELTA = 0x9e3779b9u;
        бцел[] subkeys,
               sum0,
               sum1;
    }
    
    export  override проц сбрось(){}
    
    export  override ткст имя()
    {
        return "ХТЕА";
    }
    
    export  override бцел размерБлока()
    {
        return BLOCK_SIZE;
    }
    
    export  проц иниц(бул зашифруй, СимметричныйКлюч парамыКлюча)
    {
        _зашифровать = зашифруй;
                    
        if (парамыКлюча.ключ.length != KEY_SIZE)
            не_годится(имя()~": Неверная длина ключа (требует 16 байт)");
        
        subkeys = new бцел[4];
        sum0 = new бцел[32];
        sum1 = new бцел[32];
        
        цел i, j;
        for (i = j = 0; i < 4; i++, j+=цел.sizeof)
            subkeys[i] = БайтКонвертер.БигЭндиан.в_!(бцел)(парамыКлюча.ключ[j..j+цел.sizeof]);
            
        // Precompute the значения of sum + ключ[] в_ скорость up encryption
        for (i = j = 0; i < ROUNDS; i++)
        {
            sum0[i] = (j + subkeys[j & 3]);
            j += DELTA;
            sum1[i] = (j + subkeys[j >> 11 & 3]);
        }
        
        _инициализован = да;
    }
    
    export  override бцел обнови(проц[] ввод_, проц[] вывод_)
    {
        if (!_инициализован)
            не_годится(имя()~": Шифр не инициализован");
            
        ббайт[] ввод = cast(ббайт[]) ввод_,
                вывод = cast(ббайт[]) вывод_;
                    
        if (ввод.length < BLOCK_SIZE)
            не_годится(имя()~": Буфер ввода слишком краток");
            
        if (вывод.length < BLOCK_SIZE)
            не_годится(имя()~": Буфер вывода слишком краток");
        
        бцел v0 = БайтКонвертер.БигЭндиан.в_!(бцел)(ввод[0..4]),
             v1 = БайтКонвертер.БигЭндиан.в_!(бцел)(ввод[4..8]);
             
        if (_зашифровать)
        {
            for (цел i = 0; i < ROUNDS; i++)
            {
                v0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ sum0[i];
                v1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ sum1[i];
            }
        }
        else
        {
            for (цел i = ROUNDS-1; i >= 0; i--)
            {
                v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ sum1[i];
                v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ sum0[i];
            }
        }
        
        вывод[0..4] = БайтКонвертер.БигЭндиан.из_!(бцел)(v0);
        вывод[4..8] = БайтКонвертер.БигЭндиан.из_!(бцел)(v1);
        
        return BLOCK_SIZE;
    }
    
    /** Some ХТЕА тест vectors. */
    debug (UnitTest)
    {
        unittest
        {
            static ткст[] ключи_теста = [
                "00000000000000000000000000000000",
                "00000000000000000000000000000000",
                "0123456712345678234567893456789a",
                "0123456712345678234567893456789a",
                "00000000000000000000000000000001",
                "01010101010101010101010101010101",
                "0123456789abcdef0123456789abcdef",
                "0123456789abcdef0123456789abcdef",
                "00000000000000000000000000000000",
                "00000000000000000000000000000000"
            ];
                 
            static ткст[] простыеТексты_теста = [
                "0000000000000000",
                "0102030405060708",
                "0000000000000000",
                "0102030405060708",
                "0000000000000001",
                "0101010101010101",
                "0123456789abcdef",
                "0000000000000000",
                "0123456789abcdef",
                "4141414141414141"
            ];
                
            static ткст[] тексты_тестаШифра = [
                "dee9d4d8f7131ed9",
                "065c1b8975c6a816",
                "1ff9a0261ac64264",
                "8c67155b2ef91ead",
                "9f25fa5b0f86b758",
                "c2eca7cec9b7f992",
                "27e795e076b2b537",
                "5c8eddc60a95b3e1",
                "7e66c71c88897221",
                "ed23375a821a8c2d"
            ];
                
            ХТЕА t = new ХТЕА();
            foreach (бцел i, ткст test_key; ключи_теста)
            {
                ббайт[] буфер = new ббайт[t.размерБлока];
                ткст результат;
                СимметричныйКлюч ключ = new СимметричныйКлюч(БайтКонвертер.раскодируйГекс(test_key));
                
                // Encryption
                t.иниц(да, ключ);
                t.обнови(БайтКонвертер.раскодируйГекс(простыеТексты_теста[i]), буфер);
                результат = БайтКонвертер.кодируйГекс(буфер);
                assert(результат == тексты_тестаШифра[i],
                        t.имя~": ("~результат~") != ("~тексты_тестаШифра[i]~")");
    
                // Decryption
                t.иниц(нет, ключ);
                t.обнови(БайтКонвертер.раскодируйГекс(тексты_тестаШифра[i]), буфер);
                результат = БайтКонвертер.кодируйГекс(буфер);
                assert(результат == простыеТексты_теста[i],
                        t.имя~": ("~результат~") != ("~простыеТексты_теста[i]~")");
            }
        }
    }
}

