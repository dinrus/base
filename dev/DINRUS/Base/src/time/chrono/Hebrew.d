/*******************************************************************************

        copyright:      Copyright (c) 2005 John Chapman. Все права защищены

        license:        BSD стиль: $(LICENSE)

        version:        Mопр 2005: Initial release
                        Apr 2007: reshaped                        

        author:         John Chapman, Kris, snoyberg

******************************************************************************/

module time.chrono.Hebrew;

private import exception;

private import time.chrono.Calendar;



/**
 * $(ANCHOR _Hebrew)
 * Представляет Hebrew Календарь.
 */
export class Еврейский : Календарь {

  private const бцел[14][7] ДниМесяца = [
    // месяц                                                    // год тип
    [ 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  ], 
    [ 0, 30, 29, 29, 29, 30, 29, 0,  30, 29, 30, 29, 30, 29 ],  // 1
    [ 0, 30, 29, 30, 29, 30, 29, 0,  30, 29, 30, 29, 30, 29 ],  // 2
    [ 0, 30, 30, 30, 29, 30, 29, 0,  30, 29, 30, 29, 30, 29 ],  // 3
    [ 0, 30, 29, 29, 29, 30, 30, 29, 30, 29, 30, 29, 30, 29 ],  // 4
    [ 0, 30, 29, 30, 29, 30, 30, 29, 30, 29, 30, 29, 30, 29 ],  // 5
    [ 0, 30, 30, 30, 29, 30, 30, 29, 30, 29, 30, 29, 30, 29 ]   // 6
  ];

  private const бцел YearOfOneAD = 3760;
  private const бцел DaysToOneAD = cast(цел)(YearOfOneAD * 365.2735);

  private const бцел PartsPerHour = 1080;
  private const бцел PartsPerDay = 24 * PartsPerHour;
  private const бцел DaysPerMonth = 29;
  private const бцел DaysPerMonthFraction = 12 * PartsPerHour + 793;
  private const бцел PartsPerMonth = DaysPerMonth * PartsPerDay + DaysPerMonthFraction;
  private const бцел FirstNewMoon = 11 * PartsPerHour + 204;

  private бцел minYear_ = YearOfOneAD + 1583;
  private бцел maxYear_ = YearOfOneAD + 2240;

  /**
   * Представляет текущ эра.
   */
  public const бцел ЕВРЕЙСКИЙ_ЭРА = 1;

  /**
   * Переписано. Возвращает Значение Времени, устновленное в заланную дата и время в указанном _era.
   * Параметры:
   *   год = Целое, представляющее _год.
   *   месяц = Целое, представляющее _месяц.
   *   день = Целое, представляющее _день.
   *   час = Целое, представляющее _час.
   *   минута = Целое, представляющее _минута.
   *   секунда = Целое, представляющее _секунда.
   *   миллисекунда = Целое, представляющее _миллисекунда.
   *   эра = Целое, представляющее _era.
   * Возвращает: Время, установленное в указанную дата и время.
   */
  export override Время воВремя(бцел год, бцел месяц, бцел день, бцел час, бцел минута, бцел секунда, бцел миллисекунда, бцел эра) {
    проверьГод(год, эра);
    return дайГрегорианскоеВремя(год, месяц, день, час, минута, секунда, миллисекунда);
  }

  /**
   * Переписано. Возвращает день недели в указанном Время.
   * Параметры: время = Значение Времени.
   * Возвращает: Значение ДняНедели, представляющее день недели времени.
   */
  export override ДеньНедели дайДеньНедели(Время время) {
    return cast(ДеньНедели) cast(бцел) ((время.тики / ИнтервалВремени.ТиковВДень + 1) % 7);
  }

  /**
   * Переписано. Возвращает день месяца в указанном Время.
   * Параметры: время = Значение Времени.
   * Возвращает: Целое, представляющее день месяца времени.
   */
  export override бцел дайДеньМесяца(Время время) {
    auto год = дайГод(время);
    auto yearType = дайТипГода(год);
    auto дни = дайНачалоГода(год) - DaysToOneAD;
    auto день = cast(цел)(время.тики / ИнтервалВремени.ТиковВДень) - дни;
    бцел n;
    while (n < 12 && день >= ДниМесяца[yearType][n + 1]) {
      день -= ДниМесяца[yearType][n + 1];
      n++;
    }
    return день + 1;
  }

  /**
   * Переписано. Возвращает день годв в указанном Время.
   * Параметры: время = Значение Времени.
   * Возвращает: Целое, представляющее день годв времени.
   */
  export override бцел дайДеньГода(Время время) {
    auto год = дайГод(время);
    auto дни = дайНачалоГода(год) - DaysToOneAD;
    return (cast(бцел)(время.тики / ИнтервалВремени.ТиковВДень) - дни) + 1;
  }

  /**
   * Переписано. Возвращает месяц в указанном Время.
   * Параметры: время = Значение Времени.
   * Возвращает: Целое, представляющее месяц во времени.
   */
  export override бцел дайМесяц(Время время) {
    auto год = дайГод(время);
    auto yearType = дайТипГода(год);
    auto дни = дайНачалоГода(год) - DaysToOneAD;
    auto день = cast(цел)(время.тики / ИнтервалВремени.ТиковВДень) - дни;
    бцел n;
    while (n < 12 && день >= ДниМесяца[yearType][n + 1]) {
      день -= ДниМесяца[yearType][n + 1];
      n++;
    }
    return n + 1;
  }

  /**
   * Переписано. Возвращает год в указанном Время.
   * Параметры: время = Значение Времени.
   * Возвращает: Целое, представляющее год во времени.
   */
  export override бцел дайГод(Время время) {
    auto день = cast(бцел)(время.тики / ИнтервалВремени.ТиковВДень) + DaysToOneAD;
    auto low = minYear_, high = maxYear_;
    // Perform a binary ищи.
    while (low <= high) {
      auto mопр = low + (high - low) / 2;
      auto startDay = дайНачалоГода(mопр);
      if (день < startDay)
        high = mопр - 1;
      else if (день >= startDay && день < дайНачалоГода(mопр + 1))
        return mопр;
      else
        low = mопр + 1;
    }
    return low;
  }

  /**
   * Переписано. Возвращает эра в указанном Время.
   * Параметры: время = Значение Времени.
   * Возвращает: Целое, представляющее эру во времени.
   */
  export override бцел дайЭру(Время время) {
    return ЕВРЕЙСКИЙ_ЭРА;
  }

  /**
   * Переписано. Возвращает число дней в указанном _год и _месяц указанного _era.
   * Параметры:
   *   год = Целое, представляющее _год.
   *   месяц = Целое, представляющее _месяц.
   *   эра = Целое, представляющее _era.
   * Возвращает: Число дней в указанном _год и _месяц указанного _era.
   */
  export override бцел дайДниМесяца(бцел год, бцел месяц, бцел эра) {
    проверьГод(год, эра);
    return ДниМесяца[дайТипГода(год)][месяц];
  }

  /**
   * Переписано. Возвращает число дней в указанном _год указанного _era.
   * Параметры:
   *   год = Целое, представляющее _год.
   *   эра = Целое, представляющее _era.
   * Возвращает: The число дней в указанном _год в указанном _era.
   */
  export override бцел дайДниГода(бцел год, бцел эра) {
    return дайНачалоГода(год + 1) - дайНачалоГода(год);
  }

  /**
   * Переписано. Возвращает число месяцев в указанном _год указанного _era.
   * Параметры:
   *   год = Целое, представляющее _год.
   *   эра = Целое, представляющее _era.
   * Возвращает: The число месяцев в указанном _год в указанном _era.
   */
  export override бцел дайМесяцыГода(бцел год, бцел эра) {
    return високосен_ли(год, эра) ? 13 : 12;
  }

  /**
   * Переписано. Показывает, является ли указанный _год в указанном _era високосным _год.
   * Параметры: год = Целое, представляющее _год.
   * Параметры: эра = Целое, представляющее _era.
   * Возвращает: да, указанный _год високосный _год; иначе, нет.
   */
  export override бул високосен_ли(бцел год, бцел эра) {
    проверьГод(год, эра);
    // да if год % 19 == 0, 3, 6, 8, 11, 14, 17
    return ((7 * год + 1) % 19) < 7;
  }

  /**
   * $(I Property.) Переписано. Получает список эр в текущ Календарь.
   * Возвращает: Массив целых чисел, представляющий эру в текущ Календарь.
   */
  export override бцел[] эры() {
        auto врем = [ЕВРЕЙСКИЙ_ЭРА];
        return врем.dup;
  }

  /**
   * $(I Property.) Переписано. Выводит определитель, связанный с текущ Календарь.
   * Возвращает: Целое, представляющее определитель текущ Календарь.
   */
  export override бцел опр() {
    return ЕВРЕЙСКИЙ;
  }

  private проц проверьГод(бцел год, бцел эра) {
    if ((эра != ТЕКУЩАЯ_ЭРА && эра != ЕВРЕЙСКИЙ_ЭРА) || (год > maxYear_ || год < minYear_))
      throw new ИсклНелегальногоАргумента("Значение вне диапазона.");
  }

  private бцел дайТипГода(бцел год) {
    цел yearLength = дайНачалоГода(год + 1) - дайНачалоГода(год);
    if (yearLength > 380)
      yearLength -= 30;
    switch (yearLength) {
      case 353:
        // "deficient"
        return 1;
      case 383:
        // "deficient" leap
        return 4;
      case 354:
        // "нормаль"
        return 2;
      case 384:
        // "нормаль" leap
        return 5;
      case 355:
        // "complete"
        return 3;
      case 385:
        // "complete" leap
        return 6;
      default:
        break;
    }
    // Satisfies -w
    throw new ИсклНелегальногоАргумента("Значение не действительно.");
  }

  private бцел дайНачалоГода(бцел год) {
    auto месяцы = (235 * год - 234) / 19;
    auto дво = месяцы * DaysPerMonthFraction + FirstNewMoon;
    auto день = месяцы * 29 + (дво / PartsPerDay);
    дво %= PartsPerDay;

    auto ДеньНедели = день % 7;
    if (ДеньНедели == 2 || ДеньНедели == 4 || ДеньНедели == 6) {
      день++;
      ДеньНедели = день % 7;
    }
    if (ДеньНедели == 1 && дво > 15 * PartsPerHour + 204 && !високосен_ли(год, ТЕКУЩАЯ_ЭРА))
      день += 2;
    else if (ДеньНедели == 0 && дво > 21 * PartsPerHour + 589 && високосен_ли(год, ТЕКУЩАЯ_ЭРА))
      день++;
    return день;
  }

  private Время дайГрегорианскоеВремя(бцел год, бцел месяц, бцел день, бцел час, бцел минута, бцел секунда, бцел миллисекунда) {
    auto yearType = дайТипГода(год);
    auto дни = дайНачалоГода(год) - DaysToOneAD + день - 1;
    for (цел i = 1; i <= месяц; i++)
      дни += ДниМесяца[yearType][i - 1];
    return Время((дни * ИнтервалВремени.ТиковВДень) + дайТикиВремени(час, минута, секунда)) + ИнтервалВремени.изМиллисек(миллисекунда);
  }

}

